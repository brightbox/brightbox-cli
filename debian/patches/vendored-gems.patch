diff --git a/lib/bbcloud/vendor/excon-0.3.7/Gemfile b/lib/bbcloud/vendor/excon-0.3.7/Gemfile
new file mode 100644
index 0000000..0caef14
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/Gemfile
@@ -0,0 +1,14 @@
+source "http://rubygems.org"
+
+gemspec
+
+group :benchmark do
+  gem 'em-http-request'
+  gem 'httparty'
+  gem 'rest-client'
+  gem 'tach', '0.0.8'
+  gem 'typhoeus'
+  gem 'sinatra'
+  gem 'streamly_ffi'
+  gem 'curb'
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/README.rdoc b/lib/bbcloud/vendor/excon-0.3.7/README.rdoc
new file mode 100644
index 0000000..d2e29c4
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/README.rdoc
@@ -0,0 +1,69 @@
+= excon
+
+Http(s) EXtended CONnections
+
+== Getting Started
+
+  sudo gem install excon
+
+Now you are ready to get started, easiest is to use one off requests to start. Windows users see the addendum at the end.
+
+  require 'rubygems'
+  require 'excon'
+  Excon.get('http://geemus.com')
+
+This will return a response object, which has body, headers and status attributes you can check out.
+
+This supports all the major http verbs: [connect, delete, get, head, options, post, put, trace]
+
+You can also create a connection to try and keep open across multiple requests (more performant!).
+
+  connection = Excon.new('http://geemus.com')
+  connection.request(:method => 'GET')
+
+You can also specify more complicated options to either style of call
+
+  Excon.get('http://geemus.com', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  # or
+  connection.request(:method => 'GET', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+
+If you need to do something special with a response you can also pass a block that will be called with each chunk.
+
+  Excon.get('http://geemus.com') {|chunk| p chunk }
+
+From there you should be able to make just about any request you might need.
+
+== Windows
+
+On windows the default ssl peer certificate verification won't work out for you.  You can opt after requiring excon like this:
+
+  require 'rubygems'
+  require 'excon'
+  Excon.ssl_verify_peer = false
+
+I'll provide a better solution when I can (and you should know that in the mean time this is succeptible to man in the middle attacks).
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/excon-0.3.7/Rakefile b/lib/bbcloud/vendor/excon-0.3.7/Rakefile
new file mode 100644
index 0000000..b293742
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'tests'
+  test.pattern = 'tests/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov tests/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_insert.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_insert.rb
new file mode 100644
index 0000000..237a973
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_insert.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(1_000_000) do
+  tach('concat') do
+    path = 'path'
+    path = '/' << path
+  end
+  tach('insert') do
+    path = 'path'
+    path.insert(0, '/')
+  end
+end
+
+# +--------+----------+
+# | tach   | total    |
+# +--------+----------+
+# | insert | 0.974036 |
+# +--------+----------+
+# | concat | 0.998904 |
+# +--------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_interpolate.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_interpolate.rb
new file mode 100644
index 0000000..bd2b7d9
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/concat_vs_interpolate.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+key = 'Content-Length'
+value = '100'
+Tach.meter(1_000) do
+  tach('concat') do
+    key << ': ' << value << "\r\n"
+  end
+  tach('interpolate') do
+    "#{key}: value\r\n"
+  end
+end
+
+# +-------------+----------+
+# | tach        | total    |
+# +-------------+----------+
+# | concat      | 0.000902 |
+# +-------------+----------+
+# | interpolate | 0.019667 |
+# +-------------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/cr_lf.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/cr_lf.rb
new file mode 100644
index 0000000..77adc33
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/cr_lf.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+CR_LF = "\r\n"
+
+Tach.meter(1_000_000) do
+  tach('constant') do
+    '' << CR_LF
+  end
+  tach('string') do
+    '' << "\r\n"
+  end
+end
+
+# +----------+----------+
+# | tach     | total    |
+# +----------+----------+
+# | constant | 0.819885 |
+# +----------+----------+
+# | string   | 0.893602 |
+# +----------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/excon_vs.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/excon_vs.rb
new file mode 100644
index 0000000..cd62228
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/excon_vs.rb
@@ -0,0 +1,159 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default)
+Bundler.require(:benchmark)
+
+require 'sinatra/base'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'em-http-request'
+require 'httparty'
+require 'net/http'
+require 'open-uri'
+require 'rest_client'
+require 'tach'
+require 'typhoeus'
+
+url = 'http://localhost:9292/data/1000'
+
+with_server do
+
+  Tach.meter(1000) do
+
+    tach('curb (persistent)') do |n|
+      curb = Curl::Easy.new
+
+      n.times do
+        curb.url = url
+        curb.http_get
+        curb.body_str
+      end
+    end
+
+    tach('em-http-request') do |n|
+      EventMachine.run {
+        count = 0
+
+        n.times do
+          http = EventMachine::HttpRequest.new(url).get
+
+          http.callback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+
+          http.errback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+        end
+      }
+    end
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+    excon = Excon.new(url)
+    tach('Excon (persistent)') do
+      excon.request(:method => 'get').body
+    end
+
+    tach('HTTParty') do
+      HTTParty.get(url).body
+    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', '/data/1000', 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get('/data/1000').body }
+    end
+
+    Net::HTTP.start('localhost', 9292) do |http|
+      tach('Net::HTTP (persistent)') do
+        http.get('/data/1000').body
+      end
+    end
+
+    tach('open-uri') do
+      open(url).read
+    end
+
+    tach('RestClient') do
+      RestClient.get(url)
+    end
+
+    streamly = StreamlyFFI::Connection.new
+    tach('StreamlyFFI (persistent)') do
+      streamly.get(url)
+    end
+
+    tach('Typhoeus') do
+      Typhoeus::Request.get(url).body
+    end
+
+  end
+end
+
+# +--------------------------+----------+
+# | tach                     | total    |
+# +--------------------------+----------+
+# | Excon (persistent)       | 1.521565 |
+# +--------------------------+----------+
+# | Excon                    | 1.624180 |
+# +--------------------------+----------+
+# | Typhoeus                 | 1.918563 |
+# +--------------------------+----------+
+# | StreamlyFFI (persistent) | 1.933218 |
+# +--------------------------+----------+
+# | Net::HTTP (persistent)   | 2.418454 |
+# +--------------------------+----------+
+# | Net::HTTP                | 2.439801 |
+# +--------------------------+----------+
+# | HTTParty                 | 2.609180 |
+# +--------------------------+----------+
+# | RestClient               | 2.905853 |
+# +--------------------------+----------+
+# | open-uri                 | 2.936382 |
+# +--------------------------+----------+
+# | em-http-request          | 3.933757 |
+# +--------------------------+----------+
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/headers_split_vs_match.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/headers_split_vs_match.rb
new file mode 100644
index 0000000..77f4b75
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/headers_split_vs_match.rb
@@ -0,0 +1,47 @@
+# require 'benchmark'
+
+# COUNT = 1_000_000
+# data = "Content-Length: 100"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('regex') do
+#     COUNT.times do
+#       header = data.match(/(.*):\s(.*)/)
+#     end
+#   end
+#   bench.report('split') do
+#     COUNT.times do
+#       header = data.split(': ')
+#     end
+#   end
+# end
+
+# Rehearsal ------------------------------------------------------------
+# regex                      4.270000   0.010000   4.280000 (  4.294186)
+# split                      3.870000   0.000000   3.870000 (  3.885645)
+# --------------------------------------------------- total: 8.150000sec
+# 
+#                                user     system      total        real
+# regex                      4.260000   0.010000   4.270000 (  4.284764)
+# split                      3.860000   0.010000   3.870000 (  3.882795)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100"
+Tach.meter(1_000_000) do
+  tach('regex') do
+    data.match(/(.*):\s(.*)/)
+    header = [$1, $2]
+  end
+  tach('split') do
+    header = data.split(': ')
+  end
+end
+
+# +-------+----------+----------+
+# | tach  | average  | total    |
+# +-------+----------+----------+
+# | regex | 4.680451 | 4.680451 |
+# +-------+----------+----------+
+# | split | 4.393218 | 4.393218 |
+# +-------+----------+----------+
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/merging.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/merging.rb
new file mode 100644
index 0000000..7674e3f
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/merging.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(10_000) do
+
+  tach('merge') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    override = default.merge(override)
+  end
+
+  tach('loop') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    for key, value in default
+      override[key] ||= default[key]
+    end
+    override
+  end
+
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/strip_newline.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/strip_newline.rb
new file mode 100644
index 0000000..88a964f
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/strip_newline.rb
@@ -0,0 +1,115 @@
+# require 'benchmark'
+# 
+# COUNT = 1_000_000
+# data = "Content-Length: 100\r\n"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('chomp') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp
+#     end
+#   end
+#   bench.report('chomp!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp!
+#     end
+#   end
+#   bench.report('chop') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop
+#     end
+#   end
+#   bench.report('chop!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop!
+#     end
+#   end
+#   bench.report('strip') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip
+#     end
+#   end
+#   bench.report('strip!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip!
+#     end
+#   end
+#   bench.report('index') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data[0..-3]
+#     end
+#   end
+# end
+
+
+
+# Rehearsal ------------------------------------------------------------
+# chomp                      0.640000   0.000000   0.640000 (  0.644043)
+# chomp!                     0.530000   0.000000   0.530000 (  0.531415)
+# chop                       0.620000   0.000000   0.620000 (  0.624321)
+# chop!                      0.500000   0.000000   0.500000 (  0.509146)
+# strip                      0.640000   0.000000   0.640000 (  0.638785)
+# strip!                     0.530000   0.000000   0.530000 (  0.532196)
+# index                      0.740000   0.000000   0.740000 (  0.745742)
+# --------------------------------------------------- total: 4.200000sec
+# 
+#                                user     system      total        real
+# chomp                      0.640000   0.010000   0.650000 (  0.647287)
+# chomp!                     0.530000   0.000000   0.530000 (  0.532868)
+# chop                       0.630000   0.000000   0.630000 (  0.628236)
+# chop!                      0.520000   0.000000   0.520000 (  0.522950)
+# strip                      0.640000   0.000000   0.640000 (  0.646328)
+# strip!                     0.520000   0.000000   0.520000 (  0.532715)
+# index                      0.740000   0.010000   0.750000 (  0.771277)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100\r\n"
+Tach.meter(1_000_000) do
+  tach('chomp') do
+    data.dup.chomp
+  end
+  tach('chomp!') do
+    data.dup.chomp!
+  end
+  tach('chop') do
+    data.dup.chop
+  end
+  tach('chop!') do
+    data.dup.chop!
+  end
+  tach('strip') do
+    data.dup.strip
+  end
+  tach('strip!') do
+    data.dup.strip!
+  end
+  tach('index') do
+    data.dup[0..-3]
+  end
+end
+
+# +--------+----------+----------+
+# | tach   | average  | total    |
+# +--------+----------+----------+
+# | chomp  | 1.444547 | 1.444547 |
+# +--------+----------+----------+
+# | chomp! | 1.276813 | 1.276813 |
+# +--------+----------+----------+
+# | chop   | 1.422744 | 1.422744 |
+# +--------+----------+----------+
+# | chop!  | 1.240941 | 1.240941 |
+# +--------+----------+----------+
+# | strip  | 1.444776 | 1.444776 |
+# +--------+----------+----------+
+# | strip! | 1.266459 | 1.266459 |
+# +--------+----------+----------+
+# | index  | 1.557975 | 1.557975 |
+# +--------+----------+----------+
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/excon-0.3.7/benchmarks/vs_stdlib.rb b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/vs_stdlib.rb
new file mode 100644
index 0000000..fca9a1e
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/benchmarks/vs_stdlib.rb
@@ -0,0 +1,82 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+
+require 'sinatra/base'
+require 'tach'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'net/http'
+require 'open-uri'
+
+url = 'http://localhost:9292/data/1000'
+
+with_server do
+
+  Tach.meter(100) do
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+#    tach('Excon (persistent)') do |times|
+#      excon = Excon.new(url)
+#      times.times do
+#        excon.request(:method => 'get').body
+#      end
+#    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', '/data/1000', 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get('/data/1000').body }
+    end
+
+#    tach('Net::HTTP (persistent)') do |times|
+#      Net::HTTP.start('localhost', 9292) do |http|
+#        times.times do
+#          http.get('/data/1000').body
+#        end
+#      end
+#    end
+
+#    tach('open-uri') do
+#      open(url).read
+#    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/excon.gemspec b/lib/bbcloud/vendor/excon-0.3.7/excon.gemspec
new file mode 100644
index 0000000..0ee2676
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/excon.gemspec
@@ -0,0 +1,90 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'excon'
+  s.version           = '0.3.7'
+  s.date              = '2011-01-05'
+  s.rubyforge_project = 'excon'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "speed, persistence, http(s)"
+  s.description = "EXtended http(s) CONnections"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+  s.add_development_dependency('open4')
+  s.add_development_dependency('shindo', '0.1.10')
+  s.add_development_dependency('sinatra')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    benchmarks/concat_vs_insert.rb
+    benchmarks/concat_vs_interpolate.rb
+    benchmarks/cr_lf.rb
+    benchmarks/excon_vs.rb
+    benchmarks/headers_split_vs_match.rb
+    benchmarks/merging.rb
+    benchmarks/strip_newline.rb
+    benchmarks/vs_stdlib.rb
+    excon.gemspec
+    lib/excon.rb
+    lib/excon/connection.rb
+    lib/excon/errors.rb
+    lib/excon/response.rb
+    tests/config.ru
+    tests/test_helper.rb
+    tests/threaded_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/lib/excon.rb b/lib/bbcloud/vendor/excon-0.3.7/lib/excon.rb
new file mode 100644
index 0000000..97aec48
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/lib/excon.rb
@@ -0,0 +1,52 @@
+$:.unshift(File.dirname(__FILE__)) unless
+  $:.include?(File.dirname(__FILE__)) || $:.include?(File.expand_path(File.dirname(__FILE__)))
+
+require 'cgi'
+require 'openssl'
+require 'socket'
+require 'uri'
+
+require 'excon/connection'
+require 'excon/errors'
+require 'excon/response'
+
+module Excon
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.3.7'
+  end
+
+  unless const_defined?(:CHUNK_SIZE)
+    CHUNK_SIZE = 1048576 # 1 megabyte
+  end
+
+  # Status of ssl peer verification
+  @ssl_verify_peer = true
+  def self.ssl_verify_peer
+    @ssl_verify_peer
+  end
+
+  # change the status of ssl peer verification
+  def self.ssl_verify_peer=(new_ssl_verify_peer)
+    @ssl_verify_peer = new_ssl_verify_peer
+  end
+
+  # @see Connection#initialize
+  #  Initializes a new keep-alive session for a given remote host
+  #
+  #   @param [String] url The destination URL
+  #   @param [Hash<Symbol, >] params One or more option params to set on the Connection instance
+  #   @return [Connection] A new Excon::Connection instance
+  def self.new(url, params = {})
+    Excon::Connection.new(url, params)
+  end
+
+  %w{connect delete get head options post put trace}.each do |method|
+    eval <<-DEF
+      def self.#{method}(url, params = {}, &block)
+        new(url).request(params.merge!(:method => :#{method}), &block)
+      end
+    DEF
+  end
+
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/lib/excon/connection.rb b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/connection.rb
new file mode 100644
index 0000000..71fc2db
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/connection.rb
@@ -0,0 +1,202 @@
+module Excon
+  class Connection
+
+    attr_reader :connection
+
+    CR_NL     = "\r\n"
+    HTTP_1_1  = " HTTP/1.1\r\n"
+
+    # Initializes a new Connection instance
+    #   @param [String] url The destination URL
+    #   @param [Hash<Symbol, >] params One or more optional params
+    #     @option params [String] :body Default text to be sent over a socket. Only used if :body absent in Connection#request params
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request. Only used if params[:headers] is not supplied to Connection#request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path Default path; appears after 'scheme://host:port/'. Only used if params[:path] is not supplied to Connection#request
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query Default query; appended to the 'scheme://host:port/path/' in the form of '?key=value'. Will only be used if params[:query] is not supplied to Connection#request
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    def initialize(url, params = {})
+      uri = URI.parse(url)
+      @connection = {
+        :headers  => {},
+        :host     => uri.host,
+        :path     => uri.path,
+        :port     => uri.port,
+        :query    => uri.query,
+        :scheme   => uri.scheme
+      }.merge!(params)
+      @socket_key = "#{@connection[:host]}:#{@connection[:port]}"
+      reset
+    end
+
+    # Sends the supplied request to the destination host.
+    #   @yield [chunk] @see Response#self.parse
+    #   @param [Hash<Symbol, >] params One or more optional params, override defaults set in Connection.new
+    #     @option params [String] :body text to be sent over a socket
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path appears after 'scheme://host:port/'
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query appended to the 'scheme://host:port/path/' in the form of '?key=value'
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    def request(params, &block)
+      begin
+        # connection has defaults, merge in new params to override
+        params = @connection.merge(params)
+        params[:headers] = @connection[:headers].merge(params[:headers] || {})
+        params[:headers]['Host'] ||= "#{params[:host]}:#{params[:port]}"
+
+        # if path is empty or doesn't start with '/', insert one
+        unless params[:path][0..0] == '/'
+          params[:path].insert(0, '/')
+        end
+
+        # start with "METHOD /path"
+        request = params[:method].to_s.upcase << ' ' << params[:path]
+
+        # add query to path, if there is one
+        case params[:query]
+        when String
+          request << '?' << params[:query]
+        when Hash
+          request << '?'
+          for key, values in params[:query]
+            for value in [*values]
+              value_string = value && ('=' << CGI.escape(value.to_s))
+              request << key.to_s << value_string.to_s << '&'
+            end
+          end
+          request.chop! # remove trailing '&'
+        end
+
+        # finish first line with "HTTP/1.1\r\n"
+        request << HTTP_1_1
+
+        # calculate content length and set to handle non-ascii
+        params[:headers]['Content-Length'] = case params[:body]
+        when File
+          params[:body].binmode
+          File.size(params[:body].path)
+        when String
+          if params[:body].respond_to?(:force_encoding)
+            params[:body].force_encoding('BINARY')
+          end
+          params[:body].length
+        else
+          0
+        end
+
+        # add headers to request
+        for key, values in params[:headers]
+          for value in [*values]
+            request << key.to_s << ': ' << value.to_s << CR_NL
+          end
+        end
+
+        # add additional "\r\n" to indicate end of headers
+        request << CR_NL
+
+        # write out the request, sans body
+        socket.write(request)
+
+        # write out the body
+        if params[:body]
+          if params[:body].is_a?(String)
+            socket.write(params[:body])
+          else
+            while chunk = params[:body].read(CHUNK_SIZE)
+              socket.write(chunk)
+            end
+          end
+        end
+
+        # read the response
+        response = Excon::Response.parse(socket, params, &block)
+        if response.headers['Connection'] == 'close'
+          reset
+        end
+        response
+      rescue => socket_error
+        reset
+        raise(Excon::Errors::SocketError.new(socket_error))
+      end
+
+      if params[:expects] && ![*params[:expects]].include?(response.status)
+        reset
+        raise(Excon::Errors.status_error(params, response))
+      else
+        response
+      end
+
+    rescue => request_error
+      if params[:idempotent] &&
+          (request_error.is_a?(Excon::Errors::SocketError) ||
+          (request_error.is_a?(Excon::Errors::HTTPStatusError) && response.status != 404))
+        retries_remaining ||= 4
+        retries_remaining -= 1
+        if retries_remaining > 0
+          retry
+        else
+          raise(request_error)
+        end
+      else
+        raise(request_error)
+      end
+    end
+
+    def reset
+      (old_socket = sockets.delete(@socket_key)) && old_socket.close
+    end
+
+    private
+
+    def connect
+      new_socket = TCPSocket.open(@connection[:host], @connection[:port])
+
+      if @connection[:scheme] == 'https'
+        # create ssl context
+        ssl_context = OpenSSL::SSL::SSLContext.new
+
+        if Excon.ssl_verify_peer
+          # turn verification on
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
+
+          # use default cert store
+          store = OpenSSL::X509::Store.new
+          store.set_default_paths
+          ssl_context.cert_store = store
+        else
+          # turn verification off
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        end
+
+        # open ssl socket
+        new_socket = OpenSSL::SSL::SSLSocket.new(new_socket, ssl_context)
+        new_socket.sync_close = true
+        new_socket.connect
+
+        # verify connection
+        new_socket.post_connection_check(@connection[:host])
+      end
+
+      new_socket
+    end
+
+    def closed?
+      sockets[@socket_key] && sockets[@socket_key].closed?
+    end
+
+    def socket
+      if closed?
+        reset
+      end
+      sockets[@socket_key] ||= connect
+    end
+
+    def sockets
+      Thread.current[:_excon_sockets] ||= {}
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/lib/excon/errors.rb b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/errors.rb
new file mode 100644
index 0000000..ef5deee
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/errors.rb
@@ -0,0 +1,116 @@
+module Excon
+  module Errors
+
+    class Error < StandardError; end
+
+    class SocketError < Error
+      attr_reader :socket_error
+
+      def initialize(socket_error=nil)
+        super(socket_error.message)
+        set_backtrace(socket_error.backtrace)
+        @socket_error = socket_error
+      end
+    end
+
+    class HTTPStatusError < Error
+      attr_reader :request, :response
+
+      def initialize(msg, request = nil, response = nil)
+        super(msg)
+        @request = request
+        @response = response
+      end
+    end
+
+    class Continue < HTTPStatusError; end                     # 100
+    class SwitchingProtocols < HTTPStatusError; end           # 101
+    class OK < HTTPStatusError; end                           # 200
+    class Created < HTTPStatusError; end                      # 201
+    class Accepted < HTTPStatusError; end                     # 202
+    class NonAuthoritativeInformation < HTTPStatusError; end  # 203
+    class NoContent < HTTPStatusError; end                    # 204
+    class ResetContent < HTTPStatusError; end                 # 205
+    class PartialContent < HTTPStatusError; end               # 206
+    class MultipleChoices < HTTPStatusError; end              # 300
+    class MovedPermanently < HTTPStatusError; end             # 301
+    class Found < HTTPStatusError; end                        # 302
+    class SeeOther < HTTPStatusError; end                     # 303
+    class NotModified < HTTPStatusError; end                  # 304
+    class UseProxy < HTTPStatusError; end                     # 305
+    class TemporaryRedirect < HTTPStatusError; end            # 307
+    class BadRequest < HTTPStatusError; end                   # 400
+    class Unauthorized < HTTPStatusError; end                 # 401
+    class PaymentRequired < HTTPStatusError; end              # 402
+    class Forbidden < HTTPStatusError; end                    # 403
+    class NotFound < HTTPStatusError; end                     # 404
+    class MethodNotAllowed < HTTPStatusError; end             # 405
+    class NotAcceptable < HTTPStatusError; end                # 406
+    class ProxyAuthenticationRequired < HTTPStatusError; end  # 407
+    class RequestTimeout < HTTPStatusError; end               # 408
+    class Conflict < HTTPStatusError; end                     # 409
+    class Gone < HTTPStatusError; end                         # 410
+    class LengthRequired < HTTPStatusError; end               # 411
+    class PreconditionFailed < HTTPStatusError; end           # 412
+    class RequestEntityTooLarge < HTTPStatusError; end        # 413
+    class RequestURITooLong < HTTPStatusError; end            # 414
+    class UnsupportedMediaType < HTTPStatusError; end         # 415
+    class RequestedRangeNotSatisfiable < HTTPStatusError; end # 416
+    class ExpectationFailed < HTTPStatusError; end            # 417
+    class UnprocessableEntity < HTTPStatusError; end          # 422
+    class InternalServerError < HTTPStatusError; end          # 500
+    class NotImplemented < HTTPStatusError; end               # 501
+    class BadGateway < HTTPStatusError; end                   # 502
+    class ServiceUnavailable < HTTPStatusError; end           # 503
+    class GatewayTimeout < HTTPStatusError; end               # 504
+
+    # Messages for nicer exceptions, from rfc2616
+    def self.status_error(request, response)
+      @errors ||= { 
+        100 => [Excon::Errors::Continue, 'Continue'],
+        101 => [Excon::Errors::SwitchingProtocols, 'Switching Protocols'],
+        200 => [Excon::Errors::OK, 'OK'],
+        201 => [Excon::Errors::Created, 'Created'],
+        202 => [Excon::Errors::Accepted, 'Accepted'],
+        203 => [Excon::Errors::NonAuthoritativeInformation, 'Non-Authoritative Information'],
+        204 => [Excon::Errors::NoContent, 'No Content'],
+        205 => [Excon::Errors::ResetContent, 'Reset Content'],
+        206 => [Excon::Errors::PartialContent, 'Partial Content'],
+        300 => [Excon::Errors::MultipleChoices, 'Multiple Choices'],
+        301 => [Excon::Errors::MovedPermanently, 'Moved Permanently'],
+        302 => [Excon::Errors::Found, 'Found'],
+        303 => [Excon::Errors::SeeOther, 'See Other'],
+        304 => [Excon::Errors::NotModified, 'Not Modified'],
+        305 => [Excon::Errors::UseProxy, 'Use Proxy'],
+        307 => [Excon::Errors::TemporaryRedirect, 'Temporary Redirect'],
+        400 => [Excon::Errors::BadRequest, 'Bad Request'],
+        401 => [Excon::Errors::Unauthorized, 'Unauthorized'],
+        402 => [Excon::Errors::PaymentRequired, 'Payment Required'],
+        403 => [Excon::Errors::Forbidden, 'Forbidden'],
+        404 => [Excon::Errors::NotFound, 'Not Found'],
+        405 => [Excon::Errors::MethodNotAllowed, 'Method Not Allowed'],
+        406 => [Excon::Errors::NotAcceptable, 'Not Acceptable'],
+        407 => [Excon::Errors::ProxyAuthenticationRequired, 'Proxy Authentication Required'],
+        408 => [Excon::Errors::RequestTimeout, 'Request Timeout'],
+        409 => [Excon::Errors::Conflict, 'Conflict'],
+        410 => [Excon::Errors::Gone, 'Gone'],
+        411 => [Excon::Errors::LengthRequired, 'Length Required'],
+        412 => [Excon::Errors::PreconditionFailed, 'Precondition Failed'],
+        413 => [Excon::Errors::RequestEntityTooLarge, 'Request Entity Too Large'],
+        414 => [Excon::Errors::RequestURITooLong, 'Request-URI Too Long'],
+        415 => [Excon::Errors::UnsupportedMediaType, 'Unsupported Media Type'],
+        416 => [Excon::Errors::RequestedRangeNotSatisfiable, 'Request Range Not Satisfiable'],
+        417 => [Excon::Errors::ExpectationFailed, 'Expectation Failed'],
+        422 => [Excon::Errors::UnprocessableEntity, 'Unprocessable Entity'],
+        500 => [Excon::Errors::InternalServerError, 'InternalServerError'],
+        501 => [Excon::Errors::NotImplemented, 'Not Implemented'],
+        502 => [Excon::Errors::BadGateway, 'Bad Gateway'],
+        503 => [Excon::Errors::ServiceUnavailable, 'Service Unavailable'],
+        504 => [Excon::Errors::GatewayTimeout, 'Gateway Timeout']
+      }
+      error, message = @errors[response.status] || [Excon::Errors::HTTPStatusError, 'Unknown']
+      error.new("Expected(#{request[:expects].inspect}) <=> Actual(#{response.status} #{message})\n  request => #{request.inspect}\n  response => #{response.inspect}", request, response)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/excon-0.3.7/lib/excon/response.rb b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/response.rb
new file mode 100644
index 0000000..bd1d6c4
--- /dev/null
+++ b/lib/bbcloud/vendor/excon-0.3.7/lib/excon/response.rb
@@ -0,0 +1,62 @@
+module Excon
+  class Response
+
+    def self.parse(socket, params = {}, &block)
+      if params[:block]
+        print "  \e[33m[WARN] params[:block] is deprecated, please pass the block to the request\e[0m"
+        block = params[:block]
+      end
+
+      response = new
+
+      response.status = socket.readline[9..11].to_i
+      while true
+        data = socket.readline.chop!
+        unless data.empty?
+          key, value = data.split(': ')
+          response.headers[key] = value
+        else
+          break
+        end
+      end
+
+      unless params[:method].to_s.upcase == 'HEAD'
+        if !block || (params[:expects] && ![*params[:expects]].include?(response.status))
+          response.body = ''
+          block = lambda { |chunk| response.body << chunk }
+        end
+
+        if response.headers['Transfer-Encoding'] && response.headers['Transfer-Encoding'].downcase == 'chunked'
+          while true
+            chunk_size = socket.readline.chop!.to_i(16)
+            chunk = socket.read(chunk_size + 2).chop! # 2 == "/r/n".length
+            if chunk_size > 0
+              block.call(chunk)
+            else
+              break
+            end
+          end
+        elsif response.headers['Connection'] && response.headers['Connection'].downcase == 'close'
+          block.call(socket.read)
+        elsif response.headers['Content-Length']
+          remaining = response.headers['Content-Length'].to_i
+          while remaining > 0
+            block.call(socket.read([CHUNK_SIZE, remaining].min))
+            remaining -= CHUNK_SIZE
+          end
+        end
+      end
+
+      response
+    end
+
+    attr_accessor :body, :headers, :status
+
+    def initialize(attributes = {})
+      @body    = attributes[:body] || ''
+      @headers = attributes[:headers] || {}
+      @status  = attributes[:status]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/.document b/lib/bbcloud/vendor/fog-0.4.0/.document
new file mode 100644
index 0000000..2a5f665
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/.document
@@ -0,0 +1,3 @@
+README.rdoc
+lib/**/*.rb
+bin/*
diff --git a/lib/bbcloud/vendor/fog-0.4.0/.gitignore b/lib/bbcloud/vendor/fog-0.4.0/.gitignore
new file mode 100644
index 0000000..3ebcd70
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/.gitignore
@@ -0,0 +1,11 @@
+*.gem
+*.rbc
+*.sw?
+.bundle
+.DS_Store
+_site/*
+coverage
+doc/*
+rdoc
+pkg
+spec/credentials.yml
diff --git a/lib/bbcloud/vendor/fog-0.4.0/Gemfile b/lib/bbcloud/vendor/fog-0.4.0/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/lib/bbcloud/vendor/fog-0.4.0/Gemfile.lock b/lib/bbcloud/vendor/fog-0.4.0/Gemfile.lock
new file mode 100644
index 0000000..249ef4f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/Gemfile.lock
@@ -0,0 +1,48 @@
+PATH
+  remote: .
+  specs:
+    fog (0.4.0)
+      builder
+      excon (>= 0.3.7)
+      formatador (>= 0.0.16)
+      json
+      mime-types
+      net-ssh (>= 2.0.23)
+      nokogiri (>= 1.4.4)
+      ruby-hmac
+
+GEM
+  remote: http://rubygems.org/
+  specs:
+    builder (3.0.0)
+    excon (0.3.7)
+    formatador (0.0.16)
+    gestalt (0.0.11)
+      formatador (>= 0.0.12)
+    json (1.4.6)
+    mime-types (1.16)
+    net-ssh (2.0.23)
+    nokogiri (1.4.4)
+    rake (0.8.7)
+    rspec (1.3.1)
+    ruby-hmac (0.4.0)
+    shindo (0.1.12)
+      formatador (>= 0.0.16)
+      gestalt (>= 0.0.11)
+
+PLATFORMS
+  ruby
+
+DEPENDENCIES
+  builder
+  excon (>= 0.3.7)
+  fog!
+  formatador (>= 0.0.16)
+  json
+  mime-types
+  net-ssh (>= 2.0.23)
+  nokogiri (>= 1.4.4)
+  rake
+  rspec (= 1.3.1)
+  ruby-hmac
+  shindo (= 0.1.12)
diff --git a/lib/bbcloud/vendor/fog-0.4.0/README.rdoc b/lib/bbcloud/vendor/fog-0.4.0/README.rdoc
new file mode 100644
index 0000000..93527cd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/README.rdoc
@@ -0,0 +1,176 @@
+http://geemus.s3.amazonaws.com/fog.png
+
+fog is the Ruby cloud computing library, top to bottom:
+
+* Collections provide a simplified interface, making clouds easier to work with and switch between.
+* Requests allow power users to get the most out of the features of each individual cloud.
+* Mocks make testing and integrating a breeze.
+
+== Getting Started
+
+  sudo gem install fog
+
+Now type 'fog' to try stuff, confident that fog will let you know what to do. Here is an example of wading through server creation for Amazon Elastic Compute Cloud:
+
+  >> server = AWS.servers.create
+  ArgumentError: image_id is required for this operation
+
+  >> server = AWS.servers.create(:image_id => 'ami-5ee70037')
+  <Fog::AWS::EC2::Server [...]>
+
+  >> server.destroy # cleanup after yourself or regret it, trust me
+  true
+
+== Collections
+
+A high level interface to each cloud is provided through collections, such as `images` and `servers`.
+You can see a list of available collections by calling `collections` on the connection object. You can try it out using the `fog` command:
+
+  >> AWS.collections
+  [:addresses, :directories, ..., :volumes, :zones]
+
+Some collections are available across multiple providers:
+
+* compute providers have +flavors+, +images+ and +servers+
+* dns providers have +zones+ and +records+
+* storage providers have +directories+ and +files+
+
+Collections share basic CRUD type operations, such as:
+* +all+ - fetch every object of that type from the provider.
+* +create+ - initialize a new record locally and a remote resource with the provider.
+* +get+ - fetch a single object by it's identity from the provider.
+* +new+ - initialize a new record locally, but do not create a remote resource with the provider.
+
+As an example, we'll try initializing and persisting a Rackspace Cloud server:
+
+  require 'fog'
+
+  compute = Fog::Compute.new(
+    :provider           => 'Rackspace',
+    :rackspace_api_key  => key,
+    :rackspace_username => username
+  )
+
+  # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
+  server = compute.servers.create(:flavor_id => 1, :image_id => 3, :name => 'my_server')
+  server.wait_for { ready? } # give server time to boot
+
+  # DO STUFF
+
+  server.destroy # cleanup after yourself or regret it, trust me
+
+== Models
+
+Many of the collection methods return individual objects, which also provide common methods:
+* +destroy+ - will destroy the persisted object from the provider
+* +save+ - persist the object to the provider
+* +wait_for+ - takes a block and waits for either the block to return true for the object or for a timeout (defaults to 10 minutes)
+
+== Mocks
+
+As you might imagine, testing code using Fog can be slow and expensive, constantly turning on and and shutting down instances.
+Mocking allows skipping this overhead by providing an in memory representation resources as you make requests.
+Enabling mocking easy to use, before you run other commands, simply run:
+
+  Fog.mock!
+
+Then proceed as usual, if you run into unimplemented mocks fog will raise an error and as always contributions are welcome!
+
+== Requests
+
+Requests allow you to dive deeper when the models just can't cut it.
+You can see a list of available requests by calling #requests on the connection object.
+
+For instance, ec2 provides methods related to reserved instances that don't have any models (yet). Here is how you can lookup your reserved instances:
+
+  $ fog
+  >> AWS[:ec2].describe_reserved_instances
+  #<Excon::Response [...]>
+
+It will return an {excon}[http://github.com/geemus/excon] response, which has `body`, `headers` and `status`. Both return nice hashes.
+
+== Go forth and conquer
+
+Play around and use the console to explore or check out the {getting started guide}[http://wiki.github.com/geemus/fog/getting-started-with-fog] for more details. Once you are reading to start scripting fog, here is a quick hint on how to make connections without the command line thing to help you.
+
+  # create a compute connection
+  compute = Fog::Compute.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+  # compute operations go here
+
+  # create a storage connection
+  storage = Fog::Storage.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+  # storage operations go here
+
+geemus says: "That should give you everything you need to get started, but let me know if there is anything I can do to help!"
+
+== Providers
+
+You should try out the (varying) support fog has for:
+* {AWS}[http://aws.amazon.com] [{Compute}[http://aws.amazon.com/ec2], {ELB}[http://aws.amazon.com/elasticloadbalancing], {Storage}[http://aws.amazon.com/s3], {SimpleDB}[http://aws.amazon.com/simpledb]]
+* <b><em>{Blue Box Group}[http://www.blueboxgrp.com]</em></b> [{Compute}[http://www.blueboxgrp.com/blocks]]
+* <b><em>{Brightbox}[http://www.brightbox.co.uk]</em></b> [{Compute}[http://beta.brightbox.com/]]
+* {Google}[http://www.google.com] [{Storage}[http://code.google.com/apis/storage]]
+* {Linode}[http://www.linode.com] [{DNS}[http://www.linode.com]]
+* Local [Storage]
+* {Rackspace}[http://www.rackspace.com] [{Compute}[http://www.rackspacecloud.com/cloud_hosting_products/servers], {Storage}[http://www.rackspacecloud.com/cloud_hosting_products/files]]
+* {Slicehost}[http://www.slicehost.com] [{Compute}[http://www.slicehost.com], {DNS}[http://www.slicehost.com]]
+* {Terremark}[http://www.terremark.com] [{vCloud Express}[http://vcloudexpress.terremark.com]]
+* {Zerigo}[http://www.zerigo.com] [{DNS}[http://www.zerigo.com/managed-dns]]
+
+There are also the basics of these providers (that could use your love):
+* <b><em>{GoGrid}[http://www.gogrid.com]</b></em> [{Compute}[http://www.gogrid.com]]
+* {Linode}[http://www.linode.com] [{Compute}[http://www.linode.com]]
+* {New Servers}[http://www.newservers.com] [{Compute}[http://www.newservers.com]]
+
+Special thanks to providers listed in <b><em>bold italics</em></b> for donating resources for fog tests!
+
+== Additional Resources
+
+Enjoy, and let me know what I can do to continue improving fog!
+
+* Follow {@fog}[http://twitter.com/fog] and/or {@geemus}[http://twitter.com/geemus] on Twitter
+* Discuss in irc on the {#ruby-fog}[irc://irc.freenode.net/ruby-fog] channel on Freenode
+* Discuss via email on the {mailing list}[http://groups.google.com/group/ruby-fog] (note: release notes appear on this list)
+* Report bugs or find stuff to work on in {issues}[http://github.com/geemus/fog/issues]
+* Learn about {contributing}[http://github.com/geemus/fog/wiki/contributor-guide] or find more info about the {Providers}[http://github.com/geemus/fog/wiki/Providers] (including some todo items)
+* See what already uses fog and add your own stuff to {the list}[http://wiki.github.com/geemus/fog/in-the-wild]
+* Check out blog posts and other mentions from elsewhere {press}[http://wiki.github.com/geemus/fog/press]
+
+== Sponsorship
+
+http://www.engineyard.com/images/logo.png
+
+All new work on fog is sponsored by {Engine Yard}[http://engineyard.com]
+
+== T-Shirts
+
+Wonder how you can get a shirt? Look no further!
+
+* Blue shirts go to people who have contributed indirectly, where contribution is a judgement call on geemus's part (but he is a pretty nice guy).
+* Grey shirts and a follow from @fog go to people who have made it on to the {contributors list}[https://github.com/geemus/fog/contributors] by submitting code.
+* Black shirts go to people who have made it on to the {collaborators list}[https://github.com/api/v2/json/repos/show/geemus/fog/collaborators] by coercing geemus into adding them (geemus is currently the only member of this list).
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/fog-0.4.0/Rakefile b/lib/bbcloud/vendor/fog-0.4.0/Rakefile
new file mode 100644
index 0000000..7749244
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/Rakefile
@@ -0,0 +1,132 @@
+require 'rubygems'
+require 'bundler/setup'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+task :examples do
+  sh("export FOG_MOCK=false && bundle exec shindont examples")
+  # some don't provide mocks so we'll leave this out for now
+  # sh("export FOG_MOCK=true  && bundle exec shindont examples")
+end
+
+task :test => :examples do
+  sh("export FOG_MOCK=true  && bundle exec spec spec") &&
+  sh("export FOG_MOCK=true  && bundle exec shindont tests") &&
+  sh("export FOG_MOCK=false && bundle exec spec spec") &&
+  sh("export FOG_MOCK=false && bundle exec shindont tests")
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+
+  # replace name version and date
+  replace_header(spec, :name)
+  replace_header(spec, :version)
+  replace_header(spec, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(spec, :rubyforge_project)
+
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/benchs/fog_vs.rb b/lib/bbcloud/vendor/fog-0.4.0/benchs/fog_vs.rb
new file mode 100644
index 0000000..464d8df
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/benchs/fog_vs.rb
@@ -0,0 +1,106 @@
+require 'rubygems'
+require 'aws/s3'
+require 'benchmark'
+require 'right_aws'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+
+data = File.open(File.expand_path('~/.fog')).read
+config = YAML.load(data)[:default]
+fog = Fog::AWS::S3.new(
+  :aws_access_key_id     => config[:aws_access_key_id],
+  :aws_secret_access_key => config[:aws_secret_access_key]
+)
+raws = RightAws::S3Interface.new(
+  config[:aws_access_key_id],
+  config[:aws_secret_access_key]
+)
+raws.logger.level = 3 # ERROR
+awss3 = AWS::S3::Base.establish_connection!(
+  :access_key_id     => config[:aws_access_key_id],
+  :secret_access_key => config[:aws_secret_access_key],
+  :persistent        => true
+)
+
+TIMES = 10
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('fog.put_bucket') do
+    TIMES.times do |x|
+      fog.put_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.create_bucket') do
+    TIMES.times do |x|
+      raws.create_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.create') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.create("awss3bench#{x}")
+    end
+  end
+
+  bench.report('fog.put_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        fog.put_object("fogbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('raws.put') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        raws.put("rawsbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('awss3::S3Object.create') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        AWS::S3::S3Object.create("lorem_#{y}", file, "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        fog.delete_object("fogbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('raws.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        raws.delete("rawsbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('awss3::S3Object.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        AWS::S3::S3Object.delete("lorem_#{y}", "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_bucket') do
+    TIMES.times do |x|
+      fog.delete_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.delete_bucket') do
+    TIMES.times do |x|
+      raws.delete_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.delete') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.delete("awss3bench#{x}")
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/benchs/params.rb b/lib/bbcloud/vendor/fog-0.4.0/benchs/params.rb
new file mode 100644
index 0000000..25674e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/benchs/params.rb
@@ -0,0 +1,43 @@
+require 'benchmark'
+
+def hash(options)
+  result = "#{options.delete(:name)}"
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+def optional(name, a = nil, b = nil, c = nil)
+  result = "#{name}"
+  options = { :a => a, :b => b, :c => c }
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+COUNT = 100_000
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('hash') do
+    COUNT.times do
+      hash({:name => 'name'})
+    end
+  end
+  bench.report('optional') do
+    COUNT.times do
+      optional('name')
+    end
+  end
+  bench.report('hash_with_option') do
+    COUNT.times do
+      hash({:name => 'name', :a => 'a', :b => 'b', :c => 'c'})
+    end
+  end
+  bench.report('optional_with_option') do
+    COUNT.times do
+      optional('name', :a => 'a', :b => 'b', :c => 'c')
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/benchs/parse_vs_push.rb b/lib/bbcloud/vendor/fog-0.4.0/benchs/parse_vs_push.rb
new file mode 100644
index 0000000..37d85e4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/benchs/parse_vs_push.rb
@@ -0,0 +1,60 @@
+require 'benchmark'
+require 'rubygems'
+require 'nokogiri'
+
+class Parser < Nokogiri::XML::SAX::Document
+
+  attr_reader :response
+
+  def initialize
+    reset
+  end
+
+  def reset
+    @item = {}
+    @response = { :items => [] }
+  end
+
+  def characters(string)
+    @value << string.strip
+  end
+
+  def start_element(name, attrs = [])
+    @value = nil
+  end
+
+  def end_element(name)
+    case name
+    when 'item'
+      @response[:items] << @item
+      @item = {}
+    when 'key'
+      @item[:key] = @value
+    end
+  end
+
+end
+
+data = <<-DATA
+<items>
+  <item>
+    <key>value</key>
+  </item>
+</items>
+DATA
+
+COUNT = 100
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('parse') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::Parser.new(parser).parse(data)
+    parser.response
+  end
+
+  bench.report('push') do
+    parser = Parser.new
+    Nokogiri::XML::SAX::PushParser.new(parser).write(data, true)
+    parser.response
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/bin/fog b/lib/bbcloud/vendor/fog-0.4.0/bin/fog
new file mode 100755
index 0000000..a1cc8a6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/bin/fog
@@ -0,0 +1,46 @@
+#!/usr/bin/env ruby
+require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib', 'fog'))
+require 'irb'
+require 'yaml'
+Fog.credential = ARGV.first ? ARGV.first.to_sym : nil
+Fog.mock! if ENV['FOG_MOCK']
+unless Fog.credentials
+  exit
+end
+
+require 'fog/core/bin'
+
+providers = Fog.providers.map{|provider| provider.to_s}
+providers = if providers.length > 1
+  providers[0...-1].join(', ') << ' and ' << providers[-1]
+else
+  providers.first
+end
+
+if ARGV.length > 1
+
+  puts(instance_eval(ARGV[1..-1].join(' ')).to_json)
+
+else
+
+  ARGV.clear # Avoid passing args to IRB
+  IRB.setup(nil)
+  @irb = IRB::Irb.new(nil)
+  IRB.conf[:MAIN_CONTEXT] = @irb.context
+  IRB.conf[:PROMPT][:FOG] = IRB.conf[:PROMPT][:SIMPLE].dup
+  IRB.conf[:PROMPT][:FOG][:RETURN] = "%s\n"
+  @irb.context.prompt_mode = :FOG
+  @irb.context.workspace = IRB::WorkSpace.new(binding)
+
+  Formatador.display_line('Welcome to fog interactive!')
+  Formatador.display_line(":#{Fog.credential} provides #{providers}")
+  providers = Fog.providers
+  Fog.modules.each do |_module_|
+    if _module_.respond_to?(:startup_notice)
+      _module_.send(:startup_notice)
+    end
+  end
+
+  catch(:IRB_EXIT) { @irb.eval_input }
+
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/examples/dns_tests.rb b/lib/bbcloud/vendor/fog-0.4.0/examples/dns_tests.rb
new file mode 100644
index 0000000..a938bc4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/examples/dns_tests.rb
@@ -0,0 +1,76 @@
+require 'rubygems'
+require 'shindo'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require File.join(File.dirname(__FILE__), '..', 'tests', 'helper')
+
+Shindo.tests('dns tests', 'dns') do
+
+  # iterate over all the providers
+  Fog.providers.each do |provider|
+
+    # skip if provider does not have storage
+    next unless provider.respond_to?(:services) && provider.services.include?(:dns)
+
+    tests(provider, provider.to_s.downcase) do
+
+      # use shortcuts to instantiate connection
+      @dns = Fog::DNS.new(:provider => provider.to_s)
+
+      # create a zone
+      #   domain should be the hostname
+      #   email is only required for linode, but included for consistency
+      tests('@zone = @dns.zones.create').succeeds do
+        @zone = @dns.zones.create(
+          :domain => 'fogdnsexamples.com',
+          :email => 'tests@fogdnsexamples.com'
+        )
+      end
+
+      # create a record in the zone
+      #   ip is the address to route to
+      #   name is the name for the record
+      #   type is the type of record to create
+      tests('@record = @zone.records.create').succeeds do
+        @record = @zone.records.create(
+          :ip => '1.2.3.4',
+          :name => 'www.fogdnsexamples.com',
+          :type => 'A'
+        )
+      end
+
+      # list zones
+      tests('@zones = @dns.zones').succeeds do
+        @zones = @dns.zones
+      end
+
+      # get a zone
+      tests('@dns.zones.get(@zone.identity)').succeeds do
+        @dns.zones.get(@zone.identity)
+      end
+
+      # list records
+      tests('@records = @zone.records').succeeds do
+        @records = @zone.records
+      end
+
+      # get a record
+      tests('@zone.records.get(@record.identity)').succeeds do
+        @zone.records.get(@record.identity)
+      end
+
+      # destroy the record
+      tests('@record.destroy').succeeds do
+        @record.destroy
+      end
+
+      # destroy the zone
+      tests('@zone.destroy').succeeds do
+        @zone.destroy
+      end
+
+    end
+
+  end
+
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/examples/storage_tests.rb b/lib/bbcloud/vendor/fog-0.4.0/examples/storage_tests.rb
new file mode 100755
index 0000000..0da5579
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/examples/storage_tests.rb
@@ -0,0 +1,103 @@
+require 'rubygems'
+require 'shindo'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require File.join(File.dirname(__FILE__), '..', 'tests', 'helper')
+
+Shindo.tests('storage tests', 'storage') do
+
+  # iterate over all the providers
+  Fog.providers.each do |provider|
+
+    # skip if provider does not have storage
+    next unless provider.respond_to?(:services) && provider.services.include?(:storage)
+
+    tests(provider, provider.to_s.downcase) do
+
+      # use shortcuts to instantiate connection
+      @storage = Fog::Storage.new(:provider => provider.to_s)
+
+      # for compatibility public is simply true or false
+      [false, true].each do |publicity|
+
+        tests(":public => #{publicity}") do
+
+          # create a directory
+          #   key should be a unique string
+          #   public should be a boolean
+          tests('@directory = @storage.directories.create').succeeds do
+            @directory = @storage.directories.create(
+              :key    => "fogstoragedirectory#{Time.now.to_i}",
+              :public => publicity
+            )
+          end
+
+          # list directories
+          tests('@directories = @storage.directories').succeeds do
+            @directories = @storage.directories
+          end
+
+          # get a directory
+          tests('@storage.directories.get(@directory.identity)').succeeds do
+            @storage.directories.get(@directory.identity)
+          end
+
+          # create a file in the directory
+          #   key can be any string
+          #   body can be a string or a file as File.open(path)
+          #   public should be a boolean and match the directory
+          tests('@file = @directory.files.create').succeeds do
+            @file = @directory.files.create(
+              :body   => 'fog_storage_object_body',
+              :key    => 'fogstorageobject',
+              :public => publicity
+            )
+          end
+
+          # list files
+          tests('@files = @directory.files').succeeds do
+            @files = @directory.files
+          end
+
+          # get a file
+          tests('@directory.files.get(@file.identity)').succeeds do
+            @directory.files.get(@file.identity)
+          end
+
+          # test the publicity of files
+          # Local is unable to inherently serve files, so we can skip it
+          unless provider == Local
+            # if the file is public it should have a url
+            test('!!@file.public_url == publicity') do
+              pending if Fog.mocking?
+              !!@file.public_url == publicity
+            end
+
+            # if it is public ensure that public url is usable
+            if publicity
+              tests('Excon.get(@file.public_url).body').returns('fog_storage_object_body') do
+                pending if Fog.mocking?
+                Excon.get(@file.public_url).body
+              end
+            end
+          end
+
+          # destroy the file
+          tests('@file.destroy').succeeds do
+            @file.destroy
+          end
+
+          # destroy the directory
+          tests('@directory.destroy').succeeds do
+            @directory.destroy
+          end
+
+        end
+
+      end
+
+    end
+
+  end
+
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/fog.gemspec b/lib/bbcloud/vendor/fog-0.4.0/fog.gemspec
new file mode 100644
index 0000000..78e6037
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/fog.gemspec
@@ -0,0 +1,62 @@
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'fog'
+  s.version           = '0.4.0'
+  s.date              = '2011-01-05'
+  s.rubyforge_project = 'fog'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "brings clouds to you"
+  s.description = "The Ruby cloud computing library."
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/fog'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  s.executables = ["fog"]
+  s.default_executable = 'fog'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  s.add_dependency('builder')
+  s.add_dependency('excon', '>=0.3.7')
+  s.add_dependency('formatador', '>=0.0.16')
+  s.add_dependency('json')
+  s.add_dependency('mime-types')
+  s.add_dependency('net-ssh', '>=2.0.23')
+  s.add_dependency('nokogiri', '>=1.4.4')
+  s.add_dependency('ruby-hmac')
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('rake')
+  s.add_development_dependency('rspec', '1.3.1')
+  s.add_development_dependency('shindo', '0.1.12')
+
+  s.files = `git ls-files`.split("\n")
+  s.test_files = `git ls-files -- {spec,tests}/*`.split("\n")
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog.rb
new file mode 100644
index 0000000..747f246
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog.rb
@@ -0,0 +1,24 @@
+require File.join(File.dirname(__FILE__), 'fog', 'core')
+
+module Fog
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.4.0'
+  end
+
+end
+
+require 'fog/aws'
+require 'fog/bluebox'
+require 'fog/brightbox'
+require 'fog/go_grid'
+require 'fog/google'
+require 'fog/linode'
+require 'fog/local'
+require 'fog/new_servers'
+require 'fog/rackspace'
+require 'fog/slicehost'
+require 'fog/terremark'
+require 'fog/vcloud'
+require 'fog/zerigo'
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws.rb
new file mode 100644
index 0000000..3492a5a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws.rb
@@ -0,0 +1,182 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+module Fog
+  module AWS
+
+    extend Fog::Provider
+
+    service_path 'fog/aws'
+    service 'cdn'
+    service 'compute'
+    service 'dns'
+    service 'ec2'
+    service 'elb'
+    service 'iam'
+    service 's3'
+    service 'simpledb'
+    service 'storage'
+
+    def self.indexed_param(key, values)
+      params = {}
+      unless key.include?('%d')
+        key << '.%d'
+      end
+      [*values].each_with_index do |value, index|
+        params[format(key, index + 1)] = value
+      end
+      params
+    end
+
+    def self.indexed_filters(filters)
+      params = {}
+      filters.keys.each_with_index do |key, key_index|
+        key_index += 1
+        params[format('Filter.%d.Name', key_index)] = key
+        [*filters[key]].each_with_index do |value, value_index|
+          value_index += 1
+          params[format('Filter.%d.Value.%d', key_index, value_index)] = value
+        end
+      end
+      params
+    end
+
+    def self.signed_params(params, options = {})
+      params.merge!({
+        'AWSAccessKeyId'    => options[:aws_access_key_id],
+        'SignatureMethod'   => 'HmacSHA256',
+        'SignatureVersion'  => '2',
+        'Timestamp'         => Time.now.utc.strftime("%Y-%m-%dT%H:%M:%SZ"),
+        'Version'           => options[:version]
+      })
+
+      body = ''
+      for key in params.keys.sort
+        unless (value = params[key]).nil?
+          body << "#{key}=#{CGI.escape(value.to_s).gsub(/\+/, '%20')}&"
+        end
+      end
+      string_to_sign = "POST\n#{options[:host]}:#{options[:port]}\n#{options[:path]}\n" << body.chop
+      signed_string = options[:hmac].sign(string_to_sign)
+      body << "Signature=#{CGI.escape(Base64.encode64(signed_string).chomp!).gsub(/\+/, '%20')}"
+
+      body
+    end
+
+    class Mock
+
+      def self.availability_zone
+        "us-east-1" << Fog::Mock.random_selection('abcd', 1)
+      end
+
+      def self.box_usage
+        sprintf("%0.10f", rand / 100).to_f
+      end
+
+      def self.dns_name_for(ip_address)
+        "ec2-#{ip_address.gsub('.','-')}.compute-1.amazonaws.com"
+      end
+
+      def self.private_dns_name_for(ip_address)
+        "ip-#{ip_address.gsub('.','-')}.ec2.internal"
+      end
+
+      def self.etag
+        Fog::Mock.random_hex(32)
+      end
+
+      def self.image
+        path = []
+        (rand(3) + 2).times do
+          path << Fog::Mock.random_letters(rand(9) + 8)
+        end
+        {
+          "imageOwnerId"   => Fog::Mock.random_letters(rand(5) + 4),
+          "blockDeviceMapping" => [],
+          "productCodes"   => [],
+          "kernelId"       => kernel_id,
+          "ramdiskId"      => ramdisk_id,
+          "imageState"     => "available",
+          "imageId"        => image_id,
+          "architecture"   => "i386",
+          "isPublic"       => true,
+          "imageLocation"  => path.join('/'),
+          "imageType"      => "machine",
+          "rootDeviceType" => ["ebs","instance-store"][rand(2)],
+          "rootDeviceName" => "/dev/sda1"
+        }
+      end
+
+      def self.image_id
+        "ami-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.key_fingerprint
+        fingerprint = []
+        20.times do
+          fingerprint << Fog::Mock.random_hex(2)
+        end
+        fingerprint.join(':')
+      end
+
+      def self.instance_id
+        "i-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.ip_address
+        ip = []
+        4.times do
+          ip << Fog::Mock.random_numbers(rand(3) + 1).to_i.to_s # remove leading 0
+        end
+        ip.join('.')
+      end
+
+      def self.kernel_id
+        "aki-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.key_material
+        key_material = ['-----BEGIN RSA PRIVATE KEY-----']
+        20.times do
+          key_material << Fog::Mock.random_base64(76)
+        end
+        key_material << Fog::Mock.random_base64(67) + '='
+        key_material << '-----END RSA PRIVATE KEY-----'
+        key_material.join("\n")
+      end
+
+      def self.owner_id
+        Fog::Mock.random_numbers(12)
+      end
+
+      def self.ramdisk_id
+        "ari-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.request_id
+        request_id = []
+        request_id << Fog::Mock.random_hex(8)
+        3.times do
+          request_id << Fog::Mock.random_hex(4)
+        end
+        request_id << Fog::Mock.random_hex(12)
+        request_id.join('-')
+      end
+
+      def self.reservation_id
+        "r-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.snapshot_id
+        "snap-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.volume_id
+        "vol-#{Fog::Mock.random_hex(8)}"
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/bin.rb
new file mode 100644
index 0000000..d93d499
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/bin.rb
@@ -0,0 +1,58 @@
+class AWS < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :cdn
+        Fog::AWS::CDN
+      when :compute, :ec2
+        Fog::AWS::Compute
+      when :dns
+        Fog::AWS::DNS
+      when :elb
+        Fog::AWS::ELB
+      when :iam
+        Fog::AWS::IAM
+      when :sdb
+        Fog::AWS::SimpleDB
+      when :eu_storage, :s3, :storage
+        Fog::AWS::Storage
+      else
+        # @todo Replace most instances of ArgumentError with NotImplementedError
+        # @todo For a list of widely supported Exceptions, see:
+        # => http://www.zenspider.com/Languages/Ruby/QuickRef.html#35
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        klazz = class_for(key)
+        hash[key] = case key 
+        when :ec2
+          location = caller.first
+          warning = "[yellow][WARN] AWS[:ec2] is deprecated, use AWS[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          klazz.new
+        when :eu_storage
+          klazz.new(:region => 'eu-west-1')
+        when :s3
+          location = caller.first
+          warning = "[yellow][WARN] AWS[:s3] is deprecated, use AWS[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          klazz.new
+        else
+          klazz.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:cdn, :compute, :dns, :elb, :iam, :sdb, :storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/cdn.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/cdn.rb
new file mode 100644
index 0000000..f07ce33
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/cdn.rb
@@ -0,0 +1,100 @@
+module Fog
+  module AWS
+    class CDN < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :version, :persistent
+
+      model_path 'fog/aws/models/cdn'
+
+      request_path 'fog/aws/requests/cdn'
+      request 'delete_distribution'
+      request 'get_distribution'
+      request 'get_distribution_list'
+      request 'post_distribution'
+      request 'post_invalidation'
+      request 'put_distribution_config'
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          require 'mime/types'
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[options[:region]][@aws_access_key_id]
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+      class Real
+
+        # Initialize connection to Cloudfront
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   cdn = Fog::AWS::CDN.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * cdn object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac     = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          @host     = options[:host]      || 'cloudfront.amazonaws.com'
+          @path     = options[:path]      || '/'
+          @port     = options[:port]      || 443
+          @scheme   = options[:scheme]    || 'https'
+          @version  = options[:version]  || '2010-11-01'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent] || true)
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers] ||= {}
+          params[:headers]['Date'] = Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000")
+          params[:headers]['Authorization'] = "AWS #{@aws_access_key_id}:#{signature(params)}"
+          params[:path] = "/#{@version}/#{params[:path]}" 
+          @connection.request(params, &block)
+        end
+
+        def signature(params)
+          string_to_sign = params[:headers]['Date']
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/compute.rb
new file mode 100644
index 0000000..5e0ee2b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/compute.rb
@@ -0,0 +1,242 @@
+module Fog
+  module AWS
+    class Compute < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :endpoint, :region, :host, :path, :port, :scheme, :persistent
+
+      model_path 'fog/aws/models/compute'
+      model       :address
+      collection  :addresses
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :key_pair
+      collection  :key_pairs
+      model       :security_group
+      collection  :security_groups
+      model       :server
+      collection  :servers
+      model       :snapshot
+      collection  :snapshots
+      model       :tag
+      collection  :tags
+      model       :volume
+      collection  :volumes
+
+      require 'fog/aws/parsers/compute/basic'
+
+      request_path 'fog/aws/requests/compute'
+      request :allocate_address
+      request :associate_address
+      request :attach_volume
+      request :authorize_security_group_ingress
+      request :create_image
+      request :create_key_pair
+      request :create_security_group
+      request :create_snapshot
+      request :create_tags
+      request :create_volume
+      request :delete_key_pair
+      request :delete_security_group
+      request :delete_snapshot
+      request :delete_tags
+      request :delete_volume
+      request :deregister_image
+      request :describe_addresses
+      request :describe_availability_zones
+      request :describe_images
+      request :describe_instances
+      request :describe_reserved_instances
+      request :describe_key_pairs
+      request :describe_regions
+      request :describe_security_groups
+      request :describe_snapshots
+      request :describe_tags
+      request :describe_volumes
+      request :detach_volume
+      request :disassociate_address
+      request :get_console_output
+      request :import_key_pair
+      request :modify_image_attributes
+      request :modify_snapshot_attribute
+      request :reboot_instances
+      request :release_address
+      request :register_image
+      request :revoke_security_group_ingress
+      request :run_instances
+      request :terminate_instances
+      request :start_instances
+      request :stop_instances
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            owner_id = Fog::AWS::Mock.owner_id
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :deleted_at => {},
+                :addresses  => {},
+                :images     => {},
+                :instances  => {},
+                :key_pairs  => {},
+                :limits     => { :addresses => 5 },
+                :owner_id   => owner_id,
+                :security_groups => {
+                  'default' => {
+                    'groupDescription'  => 'default group',
+                    'groupName'         => 'default',
+                    'ipPermissions'     => [
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => -1,
+                        'toPort'      => -1,
+                        'ipProtocol'  => 'icmp',
+                        'ipRanges'    => []
+                      },
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => 0,
+                        'toPort'      => 65535,
+                        'ipProtocol'  => 'tcp',
+                        'ipRanges'    => []
+                      },
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => 0,
+                        'toPort'      => 65535,
+                        'ipProtocol'  => 'udp',
+                        'ipRanges'    => []
+                      }
+                    ],
+                    'ownerId'           => owner_id
+                  }
+                },
+                :snapshots => {},
+                :volumes => {},
+                :tags => {}
+              }
+            end
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @region = options[:region] || 'us-east-1'
+          @data = self.class.data[@region][@aws_access_key_id]
+          @owner_id = @data[:owner_id]
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to EC2
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1']
+        #
+        # ==== Returns
+        # * EC2 object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          if @endpoint = options[:endpoint]
+            endpoint = URI.parse(@endpoint)
+            @host = endpoint.host
+            @path = endpoint.path
+            @port = endpoint.port
+            @scheme = endpoint.scheme
+          else
+            options[:region] ||= 'us-east-1'
+            @host = options[:host] || case options[:region]
+            when 'ap-southeast-1'
+              'ec2.ap-southeast-1.amazonaws.com'
+            when 'eu-west-1'
+              'ec2.eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              'ec2.us-east-1.amazonaws.com'
+            when 'us-west-1'
+              'ec2.us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+            @path   = options[:path]      || '/'
+            @port   = options[:port]      || 443
+            @scheme = options[:scheme]    || 'https'
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+        
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-08-31'
+            }
+          )
+
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :idempotent => idempotent,
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::HTTPStatusError => error
+            if match = error.message.match(/<Code>(.*)<\/Code><Message>(.*)<\/Message>/)
+              raise case match[1].split('.').last
+              when 'NotFound'
+                Fog::AWS::Compute::NotFound.slurp(error, match[2])
+              else
+                Fog::AWS::Compute::Error.slurp(error, "#{match[1]} => #{match[2]}")
+              end
+            else
+              raise error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/dns.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/dns.rb
new file mode 100644
index 0000000..09a9a55
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/dns.rb
@@ -0,0 +1,105 @@
+module Fog
+  module AWS
+    class DNS < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :version, :persistent
+
+      model_path 'fog/aws/models/dns'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/aws/requests/dns'
+      request :create_hosted_zone
+      request :get_hosted_zone
+      request :delete_hosted_zone
+      request :list_hosted_zones
+      request :change_resource_record_sets
+      request :list_resource_record_sets
+      request :get_change
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          require 'mime/types'
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[options[:region]][@aws_access_key_id]
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+      class Real
+
+        # Initialize connection to Route 53 DNS service
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   dns = Fog::AWS::DNS.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * dns object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac     = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          @host     = options[:host]      || 'route53.amazonaws.com'
+          @path     = options[:path]      || '/'
+          @port     = options[:port]      || 443
+          @scheme   = options[:scheme]    || 'https'
+          @version  = options[:version]  || '2010-10-01'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent] || true)
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers] ||= {}
+          params[:headers]['Date'] = Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000")
+          params[:headers]['X-Amzn-Authorization'] = "AWS3-HTTPS AWSAccessKeyId=#{@aws_access_key_id},Algorithm=HmacSHA1,Signature=#{signature(params)}"
+          params[:path] = "/#{@version}/#{params[:path]}" 
+          @connection.request(params, &block)
+        end
+
+        def signature(params)
+          string_to_sign = params[:headers]['Date']
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/ec2.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/ec2.rb
new file mode 100644
index 0000000..ba0f913
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/ec2.rb
@@ -0,0 +1,15 @@
+module Fog
+  module AWS
+    class EC2
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::AWS::EC2#new is deprecated, use Fog::AWS::Compute#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::AWS::Compute.new(attributes)
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/elb.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/elb.rb
new file mode 100644
index 0000000..1e29fbb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/elb.rb
@@ -0,0 +1,106 @@
+module Fog
+  module AWS
+    class ELB < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :region, :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/elb'
+      request :create_load_balancer
+      request :delete_load_balancer
+      request :deregister_instances_from_load_balancer
+      request :describe_instance_health
+      request :describe_load_balancers
+      request :disable_availability_zones_for_load_balancer
+      request :enable_availability_zones_for_load_balancer
+      request :register_instances_with_load_balancer
+
+      class Mock
+
+        def initialize(options={})
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to ELB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   elb = ELB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1'i, 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * ELB object with connection to AWS.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-southeast-1'
+            'elasticloadbalancing.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'elasticloadbalancing.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'elasticloadbalancing.us-east-1.amazonaws.com'
+          when 'us-west-1'
+            'elasticloadbalancing.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2009-11-25'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :idempotent => idempotent,
+            :host       => @host,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/iam.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/iam.rb
new file mode 100644
index 0000000..94033ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/iam.rb
@@ -0,0 +1,105 @@
+module Fog
+  module AWS
+    class IAM < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/iam'
+      request :add_user_to_group
+      request :create_access_key
+      request :create_group
+      request :create_user
+      request :delete_access_key
+      request :delete_group
+      request :delete_group_policy
+      request :delete_user
+      request :delete_user_policy
+      request :get_user
+      request :list_access_keys
+      request :list_groups
+      request :list_group_policies
+      request :list_user_policies
+      request :list_users
+      request :put_group_policy
+      request :put_user_policy
+      request :remove_user_from_group
+      request :update_access_key
+
+      class Mock
+
+        def initialize(options={})
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to IAM
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   iam = IAM.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * IAM object with connection to AWS.
+        def initialize(options={})
+          require 'json'
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @host       = options[:host]      || 'iam.amazonaws.com'
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-05-08'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :idempotent => idempotent,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :host       => @host,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/address.rb
new file mode 100644
index 0000000..b978d1b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/address.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Address < Fog::Model
+
+        identity  :public_ip, :aliases => 'publicIp'
+
+        attribute :server_id, :aliases => 'instanceId'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :public_ip
+
+          connection.release_address(public_ip)
+          true
+        end
+
+        def server=(new_server)
+          if new_server
+            associate(new_server)
+          else
+            disassociate
+          end
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          data = connection.allocate_address.body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        private
+
+        def associate(new_server)
+          if new_record?
+            @server = new_server
+          else
+            @server = nil
+            self.server_id = new_server.id
+            connection.associate_address(server_id, public_ip)
+          end
+        end
+
+        def disassociate
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.disassociate_address(public_ip)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/addresses.rb
new file mode 100644
index 0000000..e4414f5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/addresses.rb
@@ -0,0 +1,100 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/address'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Addresses < Fog::Collection
+
+        attribute :filters
+        attribute :server
+
+        model Fog::AWS::Compute::Address
+
+        # Used to create an IP address
+        #
+        # ==== Returns
+        #
+        #>> AWS.addresses.create
+        #  <Fog::AWS::Compute::Address
+        #    public_ip="4.88.524.95",
+        #    server_id=nil
+        #  >
+        #
+        # The IP address can be retreived by running AWS.addresses.get("test").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # AWS.addresses.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all IP addresses
+        #
+        #>> AWS.addresses.all
+        #  <Fog::AWS::Compute::Addresses
+        #    filters={},
+        #    server=nil
+        #    [
+        #      <Fog::AWS::Compute::Address
+        #        public_ip="76.7.46.54",
+        #        server_id=nil
+        #      >,
+        #      .......
+        #      <Fog::AWS::Compute::Address
+        #        public_ip="4.88.524.95",
+        #        server_id=nil
+        #      >
+        #    ]
+        #  >
+        #>>
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_addresses(filters).body
+          load(
+            data['addressesSet'].map do |address|
+              address.reject {|key, value| value.nil? || value.empty? }
+            end
+          )
+          if server
+            self.replace(self.select {|address| address.server_id == server.id})
+          end
+          self
+        end
+
+        # Used to retreive an IP address
+        #
+        # public_ip is required to get the associated IP information.
+        #
+        # You can run the following command to get the details:
+        # AWS.addresses.get("76.7.46.54")
+
+        def get(public_ip)
+          if public_ip
+            self.class.new(:connection => connection).all('public-ip' => public_ip).first
+          end
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super(attributes)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavor.rb
new file mode 100644
index 0000000..78ae6ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavor.rb
@@ -0,0 +1,21 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :bits
+        attribute :cores
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavors.rb
new file mode 100644
index 0000000..16c8828
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/flavors.rb
@@ -0,0 +1,166 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/flavor'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::AWS::Compute::Flavor
+
+        # Returns an array of all flavors that have been created
+        #
+        # AWS.flavors.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all available instance sizes
+        #
+        #>> AWS.flavors.all
+        #  <Fog::AWS::Compute::Flavors
+        #    [
+        #      <Fog::AWS::Compute::Flavor
+        #        id="t1.micro",
+        #        bits=0,
+        #        cores=2,
+        #        disk=0,
+        #        name="Micro Instance",
+        #        ram=613
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.small",
+        #        bits=32,
+        #        cores=1,
+        #        disk=160,
+        #        name="Small Instance",
+        #        ram=1740.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.large",
+        #        bits=64,
+        #        cores=4,
+        #        disk=850,
+        #        name="Large Instance",
+        #        ram=7680
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.xlarge",
+        #        bits=64,
+        #        cores=8,
+        #        disk=1690,
+        #        name="Extra Large Instance",
+        #        ram=15360
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="c1.medium",
+        #        bits=32,
+        #        cores=5,
+        #        disk=350,
+        #        name="High-CPU Medium",
+        #        ram=1740.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="c1.xlarge",
+        #        bits=64,
+        #        cores=20,
+        #        disk=1690,
+        #        name="High-CPU Extra Large",
+        #        ram=7168
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.xlarge",
+        #        bits=64,
+        #        cores=6.5,
+        #        disk=420,
+        #        name="High-Memory Extra Large",
+        #        ram=17510.4
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.2xlarge",
+        #        bits=64,
+        #        cores=13,
+        #        disk=850,
+        #        name="High Memory Double Extra Large",
+        #        ram=35020.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.4xlarge",
+        #        bits=64,
+        #        cores=26,
+        #        disk=1690,
+        #        name="High Memory Quadruple Extra Large",
+        #        ram=70041.6
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="cc1.4xlarge",
+        #        bits=64,
+        #        cores=33.5,
+        #        disk=1690,
+        #        name="Cluster Compute Quadruple Extra Large",
+        #        ram=23552
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="cg1.4xlarge",
+        #        bits=64,
+        #        cores=33.5,
+        #        disk=1690,
+        #        name="Cluster GPU Quadruple Extra Large",
+        #        ram=22528
+        #      >
+        #    ]
+        #  >
+        #
+
+        def all
+          data = [
+            { :bits => 0,  :cores =>   2,  :disk => 0,    :id =>  't1.micro',   :name => 'Micro Instance',       :ram => 613},
+
+            { :bits => 32, :cores =>   1,  :disk => 160,  :id =>  'm1.small',   :name => 'Small Instance',       :ram => 1740.8},
+            { :bits => 64, :cores =>   4,  :disk => 850,  :id =>  'm1.large',   :name => 'Large Instance',       :ram => 7680},
+            { :bits => 64, :cores =>   8,  :disk => 1690, :id =>  'm1.xlarge',  :name => 'Extra Large Instance', :ram => 15360},
+
+            { :bits => 32, :cores =>   5,  :disk => 350,  :id =>  'c1.medium',  :name => 'High-CPU Medium',      :ram => 1740.8},
+            { :bits => 64, :cores =>  20,  :disk => 1690, :id =>  'c1.xlarge',  :name => 'High-CPU Extra Large', :ram => 7168},
+
+            { :bits => 64, :cores =>  6.5, :disk => 420,  :id =>  'm2.xlarge',  :name => 'High-Memory Extra Large',           :ram => 17510.4},
+            { :bits => 64, :cores =>   13, :disk => 850,  :id =>  'm2.2xlarge', :name => 'High Memory Double Extra Large',    :ram => 35020.8},
+            { :bits => 64, :cores =>   26, :disk => 1690, :id =>  'm2.4xlarge', :name => 'High Memory Quadruple Extra Large', :ram => 70041.6},
+
+            { :bits => 64, :cores => 33.5, :disk => 1690, :id => 'cc1.4xlarge', :name => 'Cluster Compute Quadruple Extra Large', :ram => 23552},
+            { :bits => 64, :cores => 33.5, :disk => 1690, :id => 'cg1.4xlarge', :name => 'Cluster GPU Quadruple Extra Large',     :ram => 22528}
+          ]
+          load(data)
+          self
+        end
+
+        # Used to retreive a flavor
+        # flavor_id is required to get the associated flavor information.
+        # flavors available currently:
+        # 't1.micro', 'm1.small', 'm1.large', 'm1.xlarge', 'c1.medium', 'c1.xlarge', 'm2.xlarge', 'm2.2xlarge', 'm2.4xlarge', 'cc1.4xlarge', 'cg1.4xlarge'
+        #
+        # You can run the following command to get the details:
+        # AWS.flavors.get("t1.micro")
+        #
+        # ==== Returns
+        #
+        #>> AWS.flavors.get("t1.micro")
+        # <Fog::AWS::Compute::Flavor
+        #  id="t1.micro",
+        #  bits=0,
+        #  cores=2,
+        #  disk=0,
+        #  name="Micro Instance",
+        #  ram=613
+        #>
+        #
+
+        def get(flavor_id)
+          self.class.new(:connection => connection).all.detect {|flavor| flavor.id == flavor_id}
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/image.rb
new file mode 100644
index 0000000..abcf983
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/image.rb
@@ -0,0 +1,43 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id,                     :aliases => 'imageId'
+
+        attribute :architecture
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :description
+        attribute :location,              :aliases => 'imageLocation'
+        attribute :owner_id,              :aliases => 'imageOwnerId'
+        attribute :state,                 :aliases => 'imageState'
+        attribute :type,                  :aliases => 'imageType'
+        attribute :is_public,             :aliases => 'isPublic'
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :platform
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+        attribute :tags,                  :aliases => 'tagSet'
+        attribute :name
+
+        def deregister(delete_snapshot = false)
+          connection.deregister_image(id)
+
+          if(delete_snapshot && root_device_type == "ebs")
+            block_device = block_device_mapping.detect {|block_device| block_device['deviceName'] == root_device_name}
+            @connection.snapshots.new(:id => block_device['snapshotId']).destroy
+          else
+            true
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/images.rb
new file mode 100644
index 0000000..437ec27
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/images.rb
@@ -0,0 +1,62 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/image'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Images < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Image
+        
+        # Creates a new Amazon machine image
+        #
+        # AWS.images.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new image
+        #
+        #>> AWS.images.new
+        #  <Fog::AWS::Compute::Image
+        #    id=nil,
+        #    architecture=nil,
+        #    block_device_mapping=nil,
+        #    location=nil,
+        #    owner_id=nil,
+        #    state=nil,
+        #    type=nil,
+        #    is_public=nil,
+        #    kernel_id=nil,
+        #    platform=nil,
+        #    product_codes=nil,
+        #    ramdisk_id=nil,
+        #    root_device_type=nil,
+        #    root_device_name=nil,
+        #    tags=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_images(filters).body
+          load(data['imagesSet'])
+        end
+        
+        def get(image_id)
+          if image_id
+            self.class.new(:connection => connection).all('image-id' => image_id).first
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pair.rb
new file mode 100644
index 0000000..2512b5c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pair.rb
@@ -0,0 +1,44 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPair < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:material, :private_key)
+
+        identity  :name,        :aliases => 'keyName'
+
+        attribute :fingerprint, :aliases => 'keyFingerprint'
+        attribute :private_key, :aliases => 'keyMaterial'
+
+        attr_accessor :public_key
+
+        def destroy
+          requires :name
+
+          connection.delete_key_pair(name)
+          true
+        end
+
+        def save
+          requires :name
+
+          data = if public_key
+            connection.import_key_pair(name, public_key).body
+          else
+            connection.create_key_pair(name).body
+          end
+          new_attributes = data.reject {|key,value| !['keyFingerprint', 'keyMaterial', 'keyName'].include?(key)}
+          merge_attributes(new_attributes)
+          true
+        end
+
+        private
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pairs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pairs.rb
new file mode 100644
index 0000000..31657c2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/key_pairs.rb
@@ -0,0 +1,88 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/key_pair'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPairs < Fog::Collection
+
+        attribute :filters
+        attribute :key_name
+
+        model Fog::AWS::Compute::KeyPair
+
+        # Used to create a key pair.  There are 3 arguments and only name is required.  You can generate a new key_pair as follows:
+        # AWS.key_pairs.create(:name => "test", :fingerprint => "123", :private_key => '234234')
+        #
+        # ==== Returns
+        #
+        #<Fog::AWS::Compute::KeyPair
+        #  name="test",
+        #  fingerprint="3a:d3:e5:17:e5:e7:f7:de:fe:db:1b:c2:55:7d:94:0b:07:2e:05:aa",
+        #  private_key="-----BEGIN RSA PRIVATE KEY-----\nf/VtfXJ/ekTSlRS2GSItBSzMrEGoZ+EXeMOuiA7HFkDcgKt6aBiOX9Bysiyfc1rIrgWdFKqXBRJA\nrtvBPa3/32koMPV4FxG7RZrPuKLITmFoEV86M0DSLo+ErlOPuDChfrR9dk6eI17/o1VmSvYsIpDc\njvbgx+tt7ZEPvduoUag7YdnUI0f20fttsdXjMlyDg9pPOVF3/hqucqOb3t5y9lvVJJxdTnEDFSjb\nvodpaDT9+ssw4IsQsZEIvfL0hK+Lt4phbclUWfG7JVnYfdd2u4zU6Nqe0+3qoR0ZOH4/zaUko7z8\n7JMbJqs5bmdWfnQTrvbJ13545FRI/W48ZRJxqPcj0t2MzasbT4gMgtNJrSadq78RkRJjNTu4lZmK\nvJejkBZPicHvo5IRSEbDc90Rhdh0aZNifXn0d0DSV2N6Ywo2o1lwRAi3/l6XSjukyRpTPcMr14MP\ntGwS1Tvez41Oa7Y96VfsJB2xtKc6LGRFiPUg2ZAEHU15Q9bIISVzHXgdAcef1bsh8UN/fDBrTusm\nvJisQ+dLaPH7cZ03od+XTwJc+IyeL4RqWuASE0NNfEVJMS+qcpt0WeNzfG0C27SwIcfEKL0sC0kn\nCfX2WpZDg7T5xN+88ftKJaN9tymxTgvoJVS1/WKvWBAXVozKp4f6K8wKmwf7VdUt/FWbUi54LW02\nf1ONkaYEOVwDgWlGxVSx43MWqvVdT2MPFNEBL7OA1LPwCO2nyQQ9UM9gCE65S9Najf939Bq8xwqx\nGNFlLmaH6biZUyL8ewRJ8Y7rMQ5cXy/gHZywjkuoyLQ8vVpmVpb7r1FaM/AYSr5l6gJEWdqbJleN\ntnhjPeE6qXISzIUBvwKzzgFTyW8ZHQtgbP3bHEiPG2/OjKHnLUoOId/eetcE+ovIxWsBrTDbf2SV\nYUD91u+W9K35eX89ZaIiohLNg4z9+QHCs4rcWyOXEfprBKcP2QU5+Y9ysnXLAmZt6QhInaAsUpQZ\nyhImA24UqvqrK0yyGhf/quouK7q0QkVQR+f7nGClIaphJkxO/xylrnK/pYObr4s3B8kmksuHiYOu\n1yz6SeRkj8F9dxkRmzbBK/G0tLkxIElDbM7icI9gsEO7vvgaR/K8hSDi0RkFPG43I20tU8PqwHe7\nR4jFW+6sB2+9FDeLn+qkoDSaxzmAuIRW082z/r7rJVIpFEo14hNhQYkNXpH40+P/hA9RFgvhZe8M\nvK4rz/eu246Kij6kObieTfpZhgGHqvtU8x5cnqEZOz5Hc5m4B+gMaTA53kFSPOA0pn6gqgiuYEdI\nZUhO8P1PkNqkmLz7NJRnz3qpAo6RisAxPBVr2WdSg4bP0YpGS/0TE4OOJwGLldx6dCsX60++mn0q\n1fhNw8oyZiguYMAeEEDWP8x/bsRaFz5L8uQVnnnj8ei1oTmZ+Uw9/48snWYcurL2jsbuWhhE0NTt\nfe/cqov7ZaZHs+Tr20ZBEDEqUEWr/MMskj/ZSVxnza1G/hztFJMAThF9ZJoGQkHWHfXCGOLLGY+z\nqi0SC8EIeu8PUxjO2SRj9S9o/Dwg3iHyM3pj57kD7fDNnl3Ed6LMoCXoaQV8BdMX4xh=\n-----END RSA PRIVATE KEY-----"
+        #>
+        #
+        # The key_pair can be retreived by running AWS.key_pairs.get("test").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # Returns an array of all key pairs that have been created
+        #
+        # AWS.key_pairs.all
+        #
+        # ==== Returns
+        #
+        # <Fog::AWS::Compute::KeyPairs
+        #  key_name=nil
+        #  [
+        #    <Fog::AWS::Compute::KeyPair
+        #      name="test",
+        #      fingerprint="1f:26:3d:83:e7:4f:48:74:c3:1c:e6:b3:c7:f6:ec:d8:cb:09:b3:7f",
+        #      private_key=nil
+        #    >
+        #  ]
+        #>
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_key_pairs(filters).body
+          load(data['keySet'])
+        end
+
+        # Used to retreive a key pair that was created with the AWS.key_pairs.create method.
+        # The name is required to get the associated key_pair information.
+        #
+        # You can run the following command to get the details:
+        # AWS.key_pairs.get("test")
+        #
+        # ==== Returns
+        #
+        #>> AWS.key_pairs.get("test")
+        #  <Fog::AWS::Compute::KeyPair
+        #    name="test",
+        #    fingerprint="1f:26:3d:83:e7:4f:48:74:c3:1c:e6:b3:c7:f6:ec:d8:cb:09:b3:7f",
+        #    private_key=nil
+        #  >
+        #
+
+        def get(key_name)
+          if key_name
+            self.class.new(:connection => connection).all('key-name' => key_name).first
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_group.rb
new file mode 100644
index 0000000..0523fa8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_group.rb
@@ -0,0 +1,205 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroup < Fog::Model
+
+        identity  :name,            :aliases => 'groupName'
+
+        attribute :description,     :aliases => 'groupDescription'
+        attribute :ip_permissions,  :aliases => 'ipPermissions'
+        attribute :owner_id,        :aliases => 'ownerId'
+
+        # Authorize access by another security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.authorize_group_and_owner("some_group_name", "1234567890")
+        #
+        # == Parameters:
+        # group::
+        #   The name of the security group you're granting access to.
+        #
+        # owner::
+        #   The owner id for security group you're granting access to.
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def authorize_group_and_owner(group, owner)
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            'GroupName'                   => name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        # Authorize a new port range for a security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.authorize_port_range(20..21)
+        #
+        # == Parameters:
+        # range::
+        #   A Range object representing the port range you want to open up. E.g., 20..21
+        #
+        # options::
+        #   A hash that can contain any of the following keys:
+        #    :cidr_ip (defaults to "0.0.0.0/0")
+        #    :ip_protocol (defaults to "tcp")
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def authorize_port_range(range, options = {})
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'GroupName'   => name,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        # Removes an existing security group
+        #
+        # security_group.destroy
+        #
+        # ==== Returns
+        #
+        # True or false depending on the result
+        #
+
+        def destroy
+          requires :name
+
+          connection.delete_security_group(name)
+          true
+        end
+
+        # Revoke access by another security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.revoke_group_and_owner("some_group_name", "1234567890")
+        #
+        # == Parameters:
+        # group::
+        #   The name of the security group you're revoking access to.
+        #
+        # owner::
+        #   The owner id for security group you're revoking access access to.
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def revoke_group_and_owner(group, owner)
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            'GroupName'                   => name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        # Revoke an existing port range for a security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.revoke_port_range(20..21)
+        #
+        # == Parameters:
+        # range::
+        #   A Range object representing the port range you want to open up. E.g., 20..21
+        #
+        # options::
+        #   A hash that can contain any of the following keys:
+        #    :cidr_ip (defaults to "0.0.0.0/0")
+        #    :ip_protocol (defaults to "tcp")
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def revoke_port_range(range, options = {})
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'GroupName'   => name,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        # Create a security group
+        #
+        #  >> g = AWS.security_groups.new(:name => "some_name", :description => "something")
+        #  >> g.save
+        #
+        # == Returns:
+        #
+        # True or an exception depending on the result. Keep in mind that this *creates* a new security group.
+        # As such, it yields an InvalidGroup.Duplicate exception if you attempt to save an existing group.
+        #
+
+        def save
+          requires :description, :name
+
+          data = connection.create_security_group(name, description).body
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_groups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_groups.rb
new file mode 100644
index 0000000..176a7c5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/security_groups.rb
@@ -0,0 +1,95 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/security_group'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroups < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::SecurityGroup
+
+        # Creates a new security group
+        #
+        # AWS.security_groups.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new image
+        #
+        #>> AWS.security_groups.new
+        #  <Fog::AWS::Compute::SecurityGroup
+        #    name=nil,
+        #    description=nil,
+        #    ip_permissions=nil,
+        #    owner_id=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+        
+        # Returns an array of all security groups that have been created
+        #
+        # AWS.security_groups.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all security groups
+        #
+        #>> AWS.security_groups.all
+        #  <Fog::AWS::Compute::SecurityGroups
+        #    filters={}
+        #    [
+        #      <Fog::AWS::Compute::SecurityGroup
+        #        name="default",
+        #        description="default group",
+        #        ip_permissions=[{"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>-1, "toPort"=>-1, "ipRanges"=>[], "ipProtocol"=>"icmp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"tcp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"udp"}],
+        #        owner_id="312571045469"
+        #      >
+        #    ]
+        #  >
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_security_groups(filters).body
+          load(data['securityGroupInfo'])
+        end
+
+        # Used to retreive a security group
+        # group name is required to get the associated flavor information.
+        #
+        # You can run the following command to get the details:
+        # AWS.security_groups.get("default")
+        #
+        # ==== Returns
+        #
+        #>> AWS.security_groups.get("default")
+        #  <Fog::AWS::Compute::SecurityGroup
+        #    name="default",
+        #    description="default group",
+        #    ip_permissions=[{"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>-1, "toPort"=>-1, "ipRanges"=>[], "ipProtocol"=>"icmp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"tcp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"udp"}],
+        #    owner_id="312571045469"
+        #  > 
+        #
+        
+        def get(group_name)
+          if group_name
+            self.class.new(:connection => connection).all('group-name' => group_name).first
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/server.rb
new file mode 100644
index 0000000..39d3d8f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/server.rb
@@ -0,0 +1,209 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id,                    :aliases => 'instanceId'
+
+        attr_accessor :architecture
+        attribute :ami_launch_index,      :aliases => 'amiLaunchIndex'
+        attribute :availability_zone,     :aliases => ['availabilityZone', 'placement'], :squash => 'availabilityZone'
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :client_token,          :aliases => 'clientToken'
+        attribute :dns_name,              :aliases => 'dnsName'
+        attribute :groups
+        attribute :flavor_id,             :aliases => 'instanceType'
+        attribute :image_id,              :aliases => 'imageId'
+        attr_accessor :instance_initiated_shutdown_behavior
+        attribute :ip_address,            :aliases => 'ipAddress'
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :key_name,              :aliases => 'keyName'
+        attribute :created_at,            :aliases => 'launchTime'
+        attribute :monitoring,            :squash => 'state'
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :private_dns_name,      :aliases => 'privateDnsName'
+        attribute :private_ip_address,    :aliases => 'privateIpAddress'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :reason
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :state,                 :aliases => 'instanceState', :squash => 'name'
+        attribute :state_reason,          :aliases => 'stateReason'
+        attribute :subnet_id,             :aliases => 'subnetId'
+        attribute :tags,                  :aliases => 'tagSet'
+        attribute :user_data
+
+        attr_accessor :password
+        attr_writer   :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.groups ||= ["default"] unless attributes[:subnet_id]
+          self.flavor_id ||= 'm1.small'
+          super
+        end
+
+        def addresses
+          requires :id
+
+          connection.addresses(:server => self)
+        end
+
+        def console_output
+          requires :id
+
+          connection.get_console_output(id)
+        end
+
+        def destroy
+          requires :id
+
+          connection.terminate_instances(id)
+          true
+        end
+
+        remove_method :flavor_id
+        def flavor_id
+          @flavor && @flavor.id || attributes[:flavor_id]
+        end
+
+        def flavor=(new_flavor)
+          @flavor = new_flavor
+        end
+
+        def flavor
+          @flavor ||= connection.flavors.all.detect {|flavor| flavor.id == flavor_id}
+        end
+
+        def key_pair
+          requires :key_name
+
+          connection.keypairs.all(key_name).first
+        end
+
+        def key_pair=(new_keypair)
+          self.key_name = new_keypair && new_keypair.name
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          state == 'running'
+        end
+
+        def reboot
+          requires :id
+          connection.reboot_instances(id)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :image_id
+
+          options = {
+            'BlockDeviceMapping'          => block_device_mapping,
+            'ClientToken'                 => client_token,
+            'InstanceInitiatedShutdownBehavior' => instance_initiated_shutdown_behavior,
+            'InstanceType'                => flavor_id,
+            'KernelId'                    => kernel_id,
+            'KeyName'                     => key_name,
+            'Monitoring.Enabled'          => monitoring,
+            'Placement.AvailabilityZone'  => availability_zone,
+            'RamdiskId'                   => ramdisk_id,
+            'SecurityGroup'               => groups,
+            'SubnetId'                    => subnet_id,
+            'UserData'                    => user_data
+          }
+          options.delete_if {|key, value| value.nil?}
+
+          # If subnet is defined we are working on a virtual private cloud.
+          # subnet & security group cannot co-exist. I wish VPC just ignored
+          # the security group parameter instead, it would be much easier!
+          if subnet_id
+            options.delete('SecurityGroup')
+          else
+            options.delete('SubnetId')
+          end
+
+          data = connection.run_instances(image_id, 1, 1, options)
+          merge_attributes(data.body['instancesSet'].first)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :identity, :ip_address, :username
+          require 'json'
+
+          commands = [
+            %{mkdir .ssh},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ]
+          if public_key
+            commands << %{echo "#{public_key}" >> ~/.ssh/authorized_keys}
+          end
+          # allow some retries over the first 120 seconds because aws is weird
+          Timeout::timeout(120) do
+            begin
+              Timeout::timeout(4) do
+                Fog::SSH.new(ip_address, username, credentials).run(commands)
+              end
+            rescue Net::SSH::AuthenticationFailed, Timeout::Error
+              retry
+            end
+          end
+        rescue Errno::ECONNREFUSED => e
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :identity, :ip_address, :private_key, :username
+          Fog::SSH.new(ip_address, username, :key_data => [private_key]).run(commands)
+        end
+
+        def start
+          requires :id
+          connection.start_instances(id)
+          true
+        end
+
+        def stop
+          requires :id
+          connection.stop_instances(id)
+          true
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        def volumes
+          requires :id
+          connection.volumes(:server => self)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/servers.rb
new file mode 100644
index 0000000..173fbe5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/servers.rb
@@ -0,0 +1,158 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/server'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Servers < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Server
+
+        # Creates a new server
+        #
+        # AWS.servers.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new server
+        #
+        #>> AWS.servers.new
+        #  <Fog::AWS::Compute::Server
+        #    id=nil,
+        #    ami_launch_index=nil,
+        #    availability_zone=nil,
+        #    block_device_mapping=nil,
+        #    client_token=nil,
+        #    dns_name=nil,
+        #    groups=["default"],
+        #    flavor_id="m1.small",
+        #    image_id=nil,
+        #    ip_address=nil,
+        #    kernel_id=nil,
+        #    key_name=nil,
+        #    created_at=nil,
+        #    monitoring=nil,
+        #    product_codes=nil,
+        #    private_dns_name=nil,
+        #    private_ip_address=nil,
+        #    ramdisk_id=nil,
+        #    reason=nil,
+        #    root_device_name=nil,
+        #    root_device_type=nil,
+        #    state=nil,
+        #    state_reason=nil,
+        #    subnet_id=nil,
+        #    tags=nil,
+        #    user_data=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = self.filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_instances(filters).body
+          load(
+            data['reservationSet'].map do |reservation|
+              reservation['instancesSet'].map do |instance|
+                instance.merge(:groups => reservation['groupSet'])
+              end
+            end.flatten
+          )
+        end
+
+        def bootstrap(new_attributes = {})
+          server = connection.servers.new(new_attributes)
+
+          unless new_attributes[:key_name]
+            # first or create fog_#{credential} keypair
+            name = Fog.respond_to?(:credential) && Fog.credential || :default
+            unless server.key_pair = connection.key_pairs.get("fog_#{name}")
+              server.key_pair = connection.key_pairs.create(
+                :name => "fog_#{name}",
+                :public_key => server.public_key
+              )
+            end
+          end
+
+          # make sure port 22 is open in the first security group
+          security_group = connection.security_groups.get(server.groups.first)
+          authorized = security_group.ip_permissions.detect do |ip_permission|
+            ip_permission['ipRanges'].first && ip_permission['ipRanges'].first['cidrIp'] == '0.0.0.0/0' &&
+            ip_permission['fromPort'] == 22 &&
+            ip_permission['ipProtocol'] == 'tcp' &&
+            ip_permission['toPort'] == 22
+          end
+          unless authorized
+            security_group.authorize_port_range(22..22)
+          end
+
+          server.save
+          server.wait_for { ready? }
+          server.setup(:key_data => [server.private_key])
+          server
+        end
+
+        # Used to retreive a server
+        #
+        # server_id is required to get the associated server information.
+        #
+        # You can run the following command to get the details:
+        # AWS.servers.get("i-5c973972")
+        #
+        # ==== Returns
+        #
+        #>> AWS.servers.get("i-5c973972")
+        #  <Fog::AWS::Compute::Server
+        #    id="i-5c973972",
+        #    ami_launch_index=0,
+        #    availability_zone="us-east-1b",
+        #    block_device_mapping=[],
+        #    client_token=nil,
+        #    dns_name="ec2-25-2-474-44.compute-1.amazonaws.com",
+        #    groups=["default"],
+        #    flavor_id="m1.small",
+        #    image_id="test",
+        #    ip_address="25.2.474.44",
+        #    kernel_id="aki-4e1e1da7",
+        #    key_name=nil,
+        #    created_at=Mon Nov 29 18:09:34 -0500 2010,
+        #    monitoring=false,
+        #    product_codes=[],
+        #    private_dns_name="ip-19-76-384-60.ec2.internal",
+        #    private_ip_address="19.76.384.60",
+        #    ramdisk_id="ari-0b3fff5c",
+        #    reason=nil,
+        #    root_device_name=nil,
+        #    root_device_type="instance-store",
+        #    state="running",
+        #    state_reason={},
+        #    subnet_id=nil,
+        #    tags={},
+        #    user_data=nil
+        #  >
+        #
+        
+        def get(server_id)
+          if server_id
+            self.class.new(:connection => connection).all('instance-id' => server_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshot.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshot.rb
new file mode 100644
index 0000000..075a149
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshot.rb
@@ -0,0 +1,58 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshot < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:status, :state)
+
+        identity  :id,          :aliases => 'snapshotId'
+
+        attribute :description
+        attribute :progress
+        attribute :created_at,  :aliases => 'startTime'
+        attribute :owner_id,    :aliases => 'ownerId'
+        attribute :state,       :aliases => 'status'
+        attribute :tags,        :aliases => 'tagSet'
+        attribute :volume_id,   :aliases => 'volumeId'
+        attribute :volume_size, :aliases => 'volumeSize'
+
+        def destroy
+          requires :id
+
+          connection.delete_snapshot(id)
+          true
+        end
+
+        def ready?
+          state == 'completed'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :volume_id
+
+          data = connection.create_snapshot(volume_id, description).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          true
+        end
+
+        def volume
+          requires :id
+          connection.describe_volumes(volume_id)
+        end
+
+        private
+
+        def volume=(new_volume)
+          self.volume_id = new_volume.volume_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshots.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshots.rb
new file mode 100644
index 0000000..f532777
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/snapshots.rb
@@ -0,0 +1,52 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/snapshot'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshots < Fog::Collection
+
+        attribute :filters
+        attribute :volume
+
+        model Fog::AWS::Compute::Snapshot
+
+        def initialize(attributes)
+          self.filters ||= { 'RestorableBy' => 'self' }
+          super
+        end
+
+        def all(filters = filters, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_snapshots(filters.merge!(options)).body
+          load(data['snapshotSet'])
+          if volume
+            self.replace(self.select {|snapshot| snapshot.volume_id == volume.id})
+          end
+          self
+        end
+        
+        def get(snapshot_id)
+          if snapshot_id
+            self.class.new(:connection => connection).all('snapshot-id' => snapshot_id).first
+          end
+        end
+
+        def new(attributes = {})
+          if volume
+            super({ 'volumeId' => volume.id }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tag.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tag.rb
new file mode 100644
index 0000000..1d93183
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tag.rb
@@ -0,0 +1,36 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Tag < Fog::Model
+
+        identity  :key
+
+        attribute :value
+        attribute :resource_id,           :aliases => 'resourceId'
+        attribute :resource_type,         :aliases => 'resourceType'        
+
+        def initialize(attributes = {})
+          super
+        end
+
+        def destroy
+          requires :key, :resource_id
+          connection.delete_tags(resource_id, key)
+          true
+        end
+
+        def save
+          requires :key, :resource_id
+          connection.create_tags(resource_id, key => value)
+          true
+        end
+
+        private
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tags.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tags.rb
new file mode 100644
index 0000000..69fe22e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/tags.rb
@@ -0,0 +1,34 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/tag'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Tags < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Tag
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_tags(filters).body
+          load(data['tagSet'])
+        end
+        
+        def get(key)
+          if key
+            self.class.new(:connection => connection).all('key' => key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volume.rb
new file mode 100644
index 0000000..36c7972
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volume.rb
@@ -0,0 +1,109 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volume < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:status, :state)
+
+        identity  :id,                    :aliases => 'volumeId'
+
+        attribute :attached_at,           :aliases => 'attachTime'
+        attribute :availability_zone,     :aliases => 'availabilityZone'
+        attribute :created_at,            :aliases => 'createTime'
+        attribute :delete_on_termination, :aliases => 'deleteOnTermination'
+        attribute :device
+        attribute :server_id,             :aliases => 'instanceId'
+        attribute :size
+        attribute :snapshot_id,           :aliases => 'snapshotId'
+        attribute :state,                 :aliases => 'status'
+        attribute :tags,                  :aliases => 'tagSet'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_volume(id)
+          true
+        end
+
+        def ready?
+          state == 'available'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :availability_zone, :size
+
+          data = connection.create_volume(availability_zone, size, snapshot_id).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        def server=(new_server)
+          if new_server
+            attach(new_server)
+          else
+            detach
+          end
+        end
+
+        def snapshots
+          requires :id
+          connection.snapshots(:volume => self)
+        end
+
+        private
+
+        def attachmentSet=(new_attachment_set)
+          merge_attributes(new_attachment_set.first || {})
+        end
+
+        def attach(new_server)
+          if new_record?
+            @server = new_server
+            self.availability_zone = new_server.availability_zone
+          elsif new_server
+            requires :device
+            @server = nil
+            self.server_id = new_server.id
+            connection.attach_volume(server_id, id, device)
+            reload
+          end
+        end
+
+        def detach
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.detach_volume(id)
+            reload
+          end
+        end
+
+        def force_detach
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.detach_volume(id, 'Force' => true)
+            reload
+          end
+        end
+
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volumes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volumes.rb
new file mode 100644
index 0000000..9f2a024
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/compute/volumes.rb
@@ -0,0 +1,121 @@
+require 'fog/core/collection'
+require 'fog/aws/models/compute/volume'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volumes < Fog::Collection
+
+        attribute :filters
+        attribute :server
+
+        model Fog::AWS::Compute::Volume
+
+        # Used to create a volume.  There are 3 arguments and availability_zone and size are required.  You can generate a new key_pair as follows:
+        # AWS.volumes.create(:availability_zone => 'us-east-1a', :size => 't1.micro')
+        #
+        # ==== Returns
+        #
+        #<Fog::AWS::Compute::Volume
+        #  id="vol-1e2028b9",
+        #  attached_at=nil,
+        #  availability_zone="us-east-1a",
+        #  created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #  delete_on_termination=nil,
+        #  device=nil,
+        #  server_id=nil,
+        #  size="t1.micro",
+        #  snapshot_id=nil,
+        #  state="creating",
+        #  tags=nil
+        #>
+        #
+        # The volume can be retreived by running AWS.volumes.get("vol-1e2028b9").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # Used to return all volumes.
+        # AWS.volumes.all
+        #
+        # ==== Returns
+        #
+        #>>AWS.volumes.all
+        #<Fog::AWS::Compute::Volume
+        #  id="vol-1e2028b9",
+        #  attached_at=nil,
+        #  availability_zone="us-east-1a",
+        #  created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #  delete_on_termination=nil,
+        #  device=nil,
+        #  server_id=nil,
+        #  size="t1.micro",
+        #  snapshot_id=nil,
+        #  state="creating",
+        #  tags=nil
+        #>
+        #
+        # The volume can be retreived by running AWS.volumes.get("vol-1e2028b9").  See get method below.
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_volumes(filters).body
+          load(data['volumeSet'])
+          if server
+            self.replace(self.select {|volume| volume.server_id == server.id})
+          end
+          self
+        end
+
+        # Used to retreive a volume
+        # volume_id is required to get the associated volume information.
+        #
+        # You can run the following command to get the details:
+        # AWS.volumes.get("vol-1e2028b9")
+        #
+        # ==== Returns
+        #
+        #>> AWS.volumes.get("vol-1e2028b9")
+        # <Fog::AWS::Compute::Volume
+        #    id="vol-1e2028b9",
+        #    attached_at=nil,
+        #    availability_zone="us-east-1a",
+        #    created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #    delete_on_termination=nil,
+        #    device=nil,
+        #    server_id=nil,
+        #    size="t1.micro",
+        #    snapshot_id=nil,
+        #    state="available",
+        #    tags={}
+        #  >
+        #
+
+        def get(volume_id)
+          if volume_id
+            self.class.new(:connection => connection).all('volume-id' => volume_id).first
+          end
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/record.rb
new file mode 100644
index 0000000..dc746e3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/record.rb
@@ -0,0 +1,64 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id,           :aliases => ['Id']
+
+        attribute :ip,          :aliases => ['ResourceRecords']
+        attribute :name,        :aliases => ['Name']
+        attribute :ttl,         :aliases => ['TTL']
+        attribute :type,        :aliases => ['Type']
+        attribute :status,      :aliases => ['Status']
+        attribute :created_at,  :aliases => ['SubmittedAt']
+
+        def initialize(attributes={})
+          self.ttl    ||= 3600
+          super
+        end
+
+        def destroy
+          requires :ip, :name, :ttl, :type, :zone
+          options = {
+            :action           => 'DELETE',
+            :name             => name,
+            :resource_records => [*ip],
+            :ttl              => ttl,
+            :type             => type
+          }
+          connection.change_resource_record_sets(zone.id, [options])
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :ip, :name, :ttl, :type, :zone
+          options = {
+            :action           => 'CREATE',
+            :name             => name,
+            :resource_records => [*ip],
+            :ttl              => ttl,
+            :type             => type
+          }
+          data = connection.change_resource_record_sets(zone.id, [options]).body
+          merge_attributes(data)
+          true
+        end
+
+        private
+
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/records.rb
new file mode 100644
index 0000000..b32a4b9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/records.rb
@@ -0,0 +1,47 @@
+require 'fog/core/collection'
+require 'fog/aws/models/dns/record'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :is_truncated,      :aliases => ['IsTruncated']
+        attribute :max_items,         :aliases => ['MaxItems']
+        attribute :name
+        attribute :next_record_name,  :aliases => ['NextRecordName']
+        attribute :next_record_type,  :aliases => ['NextRecordType']
+        attribute :type
+
+        attribute :zone
+
+        model Fog::AWS::DNS::Record
+
+        def all(options = {})
+          requires :zone
+          options['MaxItems'] ||= max_items
+          options['Name']     ||= name
+          options['Type']     ||= type
+          data = connection.list_resource_record_sets(zone.id, options).body
+          merge_attributes(data.reject {|key, value| !['IsTruncated', 'MaxItems', 'NextRecordName', 'NextRecordType'].include?(key)})
+          load(data['ResourceRecordSets'])
+        end
+
+        def get(record_id)
+          data = connection.get_change(record_id).body
+          new(data)
+        rescue Excon::Errors::BadRequest
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zone.rb
new file mode 100644
index 0000000..56097f3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zone.rb
@@ -0,0 +1,53 @@
+require 'fog/core/model'
+# require 'fog/aws/models/dns/records'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id,                 :aliases => 'Id'
+
+        attribute :caller_reference,  :aliases => 'CallerReference'
+        attribute :change_info,       :aliases => 'ChangeInfo'
+        attribute :description,       :aliases => 'Comment'
+        attribute :domain,            :aliases => 'Name'
+        attribute :nameservers,       :aliases => 'NameServers'
+
+        def destroy
+          requires :identity
+          connection.delete_hosted_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::AWS::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def save
+          requires :domain
+          options = {}
+          options[:caller_ref]  = caller_reference if caller_reference
+          options[:comment]     = description if description
+          data = connection.create_hosted_zone(domain, options).body
+          merge_attributes(data)
+          true
+        end
+
+        private
+
+        define_method(:HostedZone=) do |new_hosted_zone|
+          merge_attributes(new_hosted_zone)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zones.rb
new file mode 100644
index 0000000..6de5128
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/dns/zones.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/aws/models/dns/zone'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Zones < Fog::Collection
+
+        attribute :marker,    :aliases => 'Marker'
+        attribute :max_items, :aliases => 'MaxItems'
+
+        model Fog::AWS::DNS::Zone
+
+        def all(options = {})
+          options['marker']   ||= marker
+          options['maxitems'] ||= max_items
+          data = connection.list_hosted_zones(options).body['HostedZones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_hosted_zone(zone_id).body
+          new(data)
+        rescue Excon::Errors::BadRequest
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directories.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directories.rb
new file mode 100644
index 0000000..a9e4fa9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directories.rb
@@ -0,0 +1,43 @@
+require 'fog/core/collection'
+require 'fog/aws/models/storage/directory'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::AWS::Storage::Directory
+
+        def all
+          data = connection.get_service.body['Buckets']
+          load(data)
+        end
+
+        def get(key, options = {})
+          remap_attributes(options, {
+            :delimiter  => 'delimiter',
+            :marker     => 'marker',
+            :max_keys   => 'max-keys',
+            :prefix     => 'prefix'
+          })
+          data = connection.get_bucket(key, options).body
+          directory = new(:key => data['Name'])
+          options = {}
+          for k, v in data
+            if ['CommonPrefixes', 'Delimiter', 'IsTruncated', 'Marker', 'MaxKeys', 'Prefix'].include?(k)
+              options[k] = v
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.load(data['Contents'])
+          directory
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directory.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directory.rb
new file mode 100644
index 0000000..e04b2f1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/directory.rb
@@ -0,0 +1,103 @@
+require 'fog/core/model'
+require 'fog/aws/models/storage/files'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key,           :aliases => ['Name', 'name']
+
+        attribute :creation_date, :aliases => 'CreationDate'
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def destroy
+          requires :key
+          connection.delete_bucket(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def location
+          requires :key
+          data = connection.get_bucket_location(key)
+          data.body['LocationConstraint']
+        end
+
+        def location=(new_location)
+          @location = new_location
+        end
+
+        def files
+          @files ||= begin
+            Fog::AWS::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def payer
+          requires :key
+          data = connection.get_request_payment(key)
+          data.body['Payer']
+        end
+
+        def payer=(new_payer)
+          requires :key
+          connection.put_request_payment(key, new_payer)
+          @payer = new_payer
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :key
+          if connection.get_bucket_acl(key).body['AccessControlList'].detect {|grant| grant['Grantee']['URI'] == 'http://acs.amazonaws.com/groups/global/AllUsers' && grant['Permission'] == 'READ'}
+            if key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{key}.s3.amazonaws.com"
+            else
+              "https://s3.amazonaws.com/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save
+          requires :key
+          options = {}
+          if @acl
+            options['x-amz-acl'] = @acl
+          end
+          if @location
+            options['LocationConstraint'] = @location
+          end
+          connection.put_bucket(key, options)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/file.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/file.rb
new file mode 100644
index 0000000..e3b58b9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/file.rb
@@ -0,0 +1,147 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Storage
+
+      class File < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:size, :content_length)
+        deprecate(:size=, :content_length=)
+
+        identity  :key,             :aliases => 'Key'
+
+        attr_writer :body
+        attribute :cache_control,       :aliases => 'Cache-Control'
+        attribute :content_disposition, :aliases => 'Content-Disposition'
+        attribute :content_encoding,    :aliases => 'Content-Encoding'
+        attribute :content_length,      :aliases => ['Content-Length', 'Size']
+        attribute :content_md5,         :aliases => 'Content-MD5'
+        attribute :content_type,        :aliases => 'Content-Type'
+        attribute :etag,                :aliases => ['Etag', 'ETag']
+        attribute :expires,             :aliases => 'Expires'
+        attribute :last_modified,       :aliases => ['Last-Modified', 'LastModified']
+        attribute :metadata
+        attribute :owner,               :aliases => 'Owner'
+        attribute :storage_class,       :aliases => ['x-amz-storage-class', 'StorageClass']
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def body
+          attributes[:body] ||= if last_modified && (file = collection.get(identity))
+            file.body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def copy(target_directory_key, target_file_key)
+          requires :directory, :key
+          connection.copy_object(directory.key, key, target_directory_key, target_file_key)
+          target_directory = connection.directories.new(:key => target_directory_key)
+          target_directory.files.get(target_file_key)
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.key, key)
+          true
+        end
+
+        remove_method :metadata
+        def metadata
+          attributes.reject {|key, value| !(key.to_s =~ /^x-amz-meta-/)}
+        end
+
+        remove_method :metadata=
+        def metadata=(new_metadata)
+          merge_attributes(new_metadata)
+        end
+
+        remove_method :owner=
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if connection.get_object_acl(directory.key, key).body['AccessControlList'].detect {|grant| grant['Grantee']['URI'] == 'http://acs.amazonaws.com/groups/global/AllUsers' && grant['Permission'] == 'READ'}
+            if directory.key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{directory.key}.s3.amazonaws.com/#{key}"
+            else
+              "https://s3.amazonaws.com/#{directory.key}/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          if options != {}
+            Formatador.display_line("[yellow][WARN] options param is deprecated, use acl= instead[/] [light_black](#{caller.first})[/]")
+          end
+          options['x-amz-acl'] ||= @acl if @acl
+          options['Cache-Control'] = cache_control if cache_control
+          options['Content-Disposition'] = content_disposition if content_disposition
+          options['Content-Encoding'] = content_encoding if content_encoding
+          options['Content-MD5'] = content_md5 if content_md5
+          options['Content-Type'] = content_type if content_type
+          options['Expires'] = expires if expires
+          options.merge(metadata)
+          options['x-amz-storage-class'] = storage_class if storage_class
+
+          data = connection.put_object(directory.key, key, body, options)
+          merge_attributes(data.headers)
+          if body.is_a?(String)
+            self.content_length = body.size
+          else
+            self.content_length = ::File.size(body.path)
+          end
+          true
+        end
+
+        def url(expires)
+          requires :key
+          collection.get_url(key, expires)
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/files.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/files.rb
new file mode 100644
index 0000000..fc94e10
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/models/storage/files.rb
@@ -0,0 +1,79 @@
+require 'fog/core/collection'
+require 'fog/aws/models/storage/file'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :common_prefixes, :aliases => 'CommonPrefixes'
+        attribute :delimiter,       :aliases => 'Delimiter'
+        attribute :directory
+        attribute :is_truncated,    :aliases => 'IsTruncated'
+        attribute :marker,          :aliases => 'Marker'
+        attribute :max_keys,        :aliases => ['MaxKeys', 'max-keys']
+        attribute :prefix,          :aliases => 'Prefix'
+
+        model Fog::AWS::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'delimiter'   => delimiter,
+            'marker'      => marker,
+            'max-keys'    => max_keys,
+            'prefix'      => prefix
+          }.merge!(options)
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            merge_attributes(parent.files.attributes)
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, options, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key, options)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/distribution.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/distribution.rb
new file mode 100644
index 0000000..0e8b74e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/distribution.rb
@@ -0,0 +1,59 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class Distribution < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DistributionConfig' => { 'CNAME' => [], 'Logging' => {}, 'TrustedSigners' => [] } }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CustomOrigin', 'S3Origin'
+              @origin = name
+              @response['DistributionConfig'][@origin] = {}
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'AwsAccountNumber'
+              @response['DistributionConfig']['TrustedSigners'] << @value
+            when 'Bucket', 'Prefix'
+              @response['DistributionConfig']['Logging'][name] = @value
+            when 'CNAME'
+              @response['DistributionConfig']['CNAME'] << @value
+            when 'DNSName', 'OriginAccessIdentity', 'OriginProtocolPolicy'
+              @response['DistributionConfig'][@origin][name] = @value
+            when 'DomainName', 'Id', 'Status'
+              @response[name] = @value
+            when 'CallerReference', 'Comment', 'DefaultRootObject', 'Origin', 'OriginAccessIdentity'
+              @response['DistributionConfig'][name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @response['DistributionConfig'][name] = true
+              else
+                @response['DistributionConfig'][name] = false
+              end
+            when 'HTTPPort', 'HTTPSPort'
+              @response['DistributionConfig'][@origin][name] = @value.to_i
+            when 'InProgressInvalidationBatches'
+              @response[name] = @value.to_i
+            when 'LastModifiedTime'
+              @response[name] = Time.parse(@value)
+            when 'Protocol'
+              @response['DistributionConfig']['RequireProtocols'] = @value
+            when 'Self'
+              @response['DistributionConfig']['TrustedSigners'] << 'Self'
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/get_distribution_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/get_distribution_list.rb
new file mode 100644
index 0000000..3e1a97a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/get_distribution_list.rb
@@ -0,0 +1,61 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class GetDistributionList < Fog::Parsers::Base
+
+          def reset
+            @distribution_summary = { 'CNAME' => [], 'TrustedSigners' => [] }
+            @response = { 'DistributionSummary' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CustomOrigin', 'S3Origin'
+              @origin = name
+              @distribution_summary[@origin] = {}
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DistributionSummary'
+              @response['DistributionSummary'] << @distribution_summary
+              @distribution_summary = { 'CNAME' => [], 'TrustedSigners' => [] }
+            when 'Comment', 'DomainName', 'Id', 'Origin', 'Status'
+              @distribution_summary[name] = @value
+            when 'CNAME'
+              @distribution_summary[name] << @value
+            when 'DNSName', 'OriginAccessIdentity', 'OriginProtocolPolicy'
+              @distribution_summary[@origin][name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @distribution_summary[name] = true
+              else
+                @distribution_summary[name] = false
+              end
+            when 'HTTPPort', 'HTTPSPort'
+              @distribution_summary[@origin][name] = @value.to_i
+            when 'LastModifiedTime'
+              @distribution_summary[name] = Time.parse(@value)
+            when 'IsTruncated'
+              if @value == 'true'
+                @response[name] = true
+              else
+                @response[name] = false
+              end
+            when 'Marker', 'NextMarker'
+              @response[name] = @value
+            when 'MaxItems'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/post_invalidation.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/post_invalidation.rb
new file mode 100644
index 0000000..653ad37
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/cdn/post_invalidation.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class PostInvalidation < Fog::Parsers::Base
+
+          def reset
+            @response = { 'InvalidationBatch' => { 'Path' => [] } }
+          end
+
+          def end_element(name)
+            case name
+            when 'CallerReference'
+              @response['InvalidationBatch'][name] = @value
+            when 'CreateTime', 'Id', 'Status'
+              @response[name] = @value
+            when 'Path'
+              @response['InvalidationBatch'][name] << @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/allocate_address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/allocate_address.rb
new file mode 100644
index 0000000..e655c90
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/allocate_address.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AllocateAddress < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'publicIp', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/attach_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/attach_volume.rb
new file mode 100644
index 0000000..4bb8150
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/attach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AttachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(@value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/basic.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/basic.rb
new file mode 100644
index 0000000..f591d96
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/basic.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class Basic < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId'
+              @response[name] = @value
+            when 'return'
+              if @value == 'true'
+                @response[name] = true
+              else
+                @response[name] = false
+              end
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_image.rb
new file mode 100644
index 0000000..57ee677
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId', 'name', 'description', 'noReboot', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_key_pair.rb
new file mode 100644
index 0000000..9fc8bd5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyMaterial', 'keyName', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_snapshot.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_snapshot.rb
new file mode 100644
index 0000000..e506a39
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_snapshot.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateSnapshot < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+              @response[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            when 'startTime'
+              @response[name] = Time.parse(@value)
+            when 'volumeSize'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_volume.rb
new file mode 100644
index 0000000..8b4263d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/create_volume.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'requestId', 'snapshotId', 'status', 'volumeId'
+              @response[name] = @value
+            when 'createTime'
+              @response[name] = Time.parse(@value)
+            when 'size'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/deregister_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/deregister_image.rb
new file mode 100644
index 0000000..697c124
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/deregister_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DeregisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'return', 'requestId', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_addresses.rb
new file mode 100644
index 0000000..51087f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_addresses.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAddresses < Fog::Parsers::Base
+
+          def reset
+            @address = {}
+            @response = { 'addressesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'publicIp'
+              @address[name] = @value
+            when 'item'
+              @response['addressesSet'] << @address
+              @address = {}
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_availability_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_availability_zones.rb
new file mode 100644
index 0000000..aef2364
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_availability_zones.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAvailabilityZones < Fog::Parsers::Base
+
+          def reset
+            @availability_zone = { 'messageSet' => [] }
+            @response = { 'availabilityZoneInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['availabilityZoneInfo'] << @availability_zone
+              @availability_zone = { 'messageSet' => [] }
+            when 'message'
+              @availability_zone['messageSet'] << @value
+            when 'regionName', 'zoneName', 'zoneState'
+              @availability_zone[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_images.rb
new file mode 100644
index 0000000..5863493
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_images.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeImages < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @image = { 'blockDeviceMapping' => [], 'productCodes' => [], 'tagSet' => {} }
+            @response = { 'imagesSet' => [] }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_tag_set
+              case name
+                when 'item'
+                  @image['tagSet'][@tag['key']] = @tag['value']
+                  @tag = {}
+                when 'key', 'value'
+                  @tag[name] = @value
+                when 'tagSet'
+                  @in_tag_set = false
+              end
+            elsif @in_block_device_mapping
+              case name
+                when 'blockDeviceMapping'
+                  @in_block_device_mapping = false
+                when 'deviceName', 'virtualName', 'snapshotId', 'deleteOnTermination'
+                  @block_device_mapping[name] = @value
+                when 'volumeSize'
+                  @block_device_mapping[name] = @value.to_i
+                when 'item'
+                  @image['blockDeviceMapping'] << @block_device_mapping
+                  @block_device_mapping = {}
+              end
+            else
+              case name
+              when 'architecture', 'description', 'imageId', 'imageLocation', 'imageOwnerId', 'imageState', 'imageType', 'kernelId', 'name', 'platform', 'ramdiskId', 'rootDeviceType','rootDeviceName','virtualizationType'
+                @image[name] = @value
+              when 'isPublic'
+                if @value == 'true'
+                  @image[name] = true
+                else
+                  @image[name] = false
+                end
+              when 'item'
+                @response['imagesSet'] << @image
+                @image = { 'blockDeviceMapping' => [], 'productCodes' => [], 'tagSet' => {} }
+              when 'productCode'
+                @image['productCodes'] << @value
+              when 'requestId'
+                @response[name] = @value
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_instances.rb
new file mode 100644
index 0000000..4844199
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_instances.rb
@@ -0,0 +1,119 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [], 'stateReason' => {}, 'tagSet' => {} }
+            @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+            @response = { 'reservationSet' => [] }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when'groupSet', 'productCodes'
+              @in_subset = true
+            when 'instancesSet'
+              @in_instances_set = true
+            when 'instanceState'
+              @in_instance_state = true
+            when 'stateReason'
+              @in_state_reason = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = @value.to_i
+            when 'availabilityZone'
+              @instance['placement'][name] = @value
+            when 'architecture', 'clientToken', 'dnsName', 'imageId',
+                  'instanceId', 'instanceType', 'ipAddress', 'kernelId',
+                  'keyName', 'privateDnsName', 'privateIpAddress', 'ramdiskId',
+                  'reason', 'rootDeviceType'
+              @instance[name] = @value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(@value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              if @in_instance_state
+                @instance['instanceState'][name] = @value.to_i
+              elsif @in_state_reason
+                @instance['stateReason'][name] = @value.to_i
+              end
+            when 'deleteOnTermination'
+              if @value == 'true'
+                @block_device_mapping[name] = true
+              else
+                @block_device_mapping[name] = false
+              end
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = @value
+            when 'groupId'
+              @reservation['groupSet'] << @value
+            when 'groupSet', 'productCodes'
+              @in_subset = false
+            when 'instancesSet'
+              @in_instances_set = false
+            when 'instanceState'
+              @in_instance_state = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif @in_tag_set
+                @instance['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              elsif @in_instances_set
+                @reservation['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [], 'stateReason' => {}, 'tagSet' => {} }
+              elsif !@in_subset
+                @response['reservationSet'] << @reservation
+                @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+              end
+            when 'key', 'value'
+              @tag[name] = @value
+            when 'launchTime'
+              @instance[name] = Time.parse(@value)
+            when 'name'
+              if @in_instance_state
+                @instance['instanceState'][name] = @value
+              elsif @in_state_reason
+                @instance['stateReason'][name] = @value
+              end
+            when 'ownerId', 'reservationId'
+              @reservation[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            when 'productCode'
+              @instance['productCodes'] << @value
+            when 'state'
+              if @value == 'true'
+                @instance['monitoring'][name] = true
+              else
+                @instance['monitoring'][name] = false
+              end
+            when 'stateReason'
+              @in_state_reason = false
+            when 'tagSet'
+              @in_tag_set = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_key_pairs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_key_pairs.rb
new file mode 100644
index 0000000..d62746b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_key_pairs.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeKeyPairs < Fog::Parsers::Base
+
+          def reset
+            @key = {}
+            @response = { 'keySet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['keySet'] << @key
+              @key = {}
+            when 'keyFingerprint', 'keyName'
+              @key[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_regions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_regions.rb
new file mode 100644
index 0000000..fe93ef4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_regions.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeRegions < Fog::Parsers::Base
+
+          def reset
+            @region = {}
+            @response = { 'regionInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['regionInfo'] << @region
+              @region = {}
+            when 'regionEndpoint', 'regionName'
+              @region[name] = @value
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_reserved_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_reserved_instances.rb
new file mode 100644
index 0000000..4452ebd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_reserved_instances.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeReservedInstances < Fog::Parsers::Base
+
+          def reset
+            @reserved_instance = {}
+            @response = { 'reservedInstancesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'instanceType', 'productDescription', 'reservedInstancesId', 'state'
+              @reserved_instance[name] = @value
+            when 'duration', 'instanceCount'
+              @reserved_instance[name] = @value.to_i
+            when 'fixedPrice', 'usagePrice'
+              @reserved_instance[name] = @value.to_f
+            when 'item'
+              @response['reservedInstancesSet'] << @reserved_instance
+              @reserved_instance = {}
+            when 'requestId'
+              @response[name] = @value
+            when 'start'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_security_groups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_security_groups.rb
new file mode 100644
index 0000000..225fed4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_security_groups.rb
@@ -0,0 +1,76 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSecurityGroups < Fog::Parsers::Base
+
+          def reset
+            @group = {}
+            @ip_permission = { 'groups' => [], 'ipRanges' => []}
+            @ip_range = {}
+            @security_group = { 'ipPermissions' => [] }
+            @response = { 'securityGroupInfo' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'groups'
+              @in_groups = true
+            when 'ipPermissions'
+              @in_ip_permissions = true
+            when 'ipRanges'
+              @in_ip_ranges = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'cidrIp'
+              @ip_range[name] = @value
+            when 'fromPort', 'toPort'
+              @ip_permission[name] = @value.to_i
+            when 'groups'
+              @in_groups = false
+            when 'groupDescription', 'ownerId'
+              @security_group[name] = @value
+            when 'groupName'
+              if @in_groups
+                @group[name] = @value
+              else
+                @security_group[name] = @value
+              end
+            when 'ipPermissions'
+              @in_ip_permissions = false
+            when 'ipProtocol'
+              @ip_permission[name] = @value
+            when 'ipRanges'
+              @in_ip_ranges = false
+            when 'item'
+              if @in_groups
+                @ip_permission['groups'] << @group
+                @group = {}
+              elsif @in_ip_ranges
+                @ip_permission['ipRanges'] << @ip_range
+                @ip_range = {}
+              elsif @in_ip_permissions
+                @security_group['ipPermissions'] << @ip_permission
+                @ip_permission = { 'groups' => [], 'ipRanges' => []}
+               else
+                @response['securityGroupInfo'] << @security_group
+                @security_group = { 'ipPermissions' => [] }
+              end
+            when 'requestId'
+              @response[name] = @value
+            when 'userId'
+              @group[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_snapshots.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_snapshots.rb
new file mode 100644
index 0000000..7e5b275
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_snapshots.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSnapshots < Fog::Parsers::Base
+
+          def reset
+            @response = { 'snapshotSet' => [] }
+            @snapshot = { 'tagSet' => {} }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_tag_set
+              case name
+              when 'item'
+                @snapshot['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              when 'key', 'value'
+                @tag[name] = @value
+              when 'tagSet'
+                @in_tag_set = false
+              end
+            else
+              case name
+              when 'item'
+                @response['snapshotSet'] << @snapshot
+                @snapshot = { 'tagSet' => {} }
+              when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+                @snapshot[name] ||= @value
+              when 'requestId'
+                @response[name] = @value
+              when 'startTime'
+                @snapshot[name] = Time.parse(@value)
+              when 'volumeSize'
+                @snapshot[name] = @value.to_i
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_tags.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_tags.rb
new file mode 100644
index 0000000..e52bcc1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_tags.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeTags < Fog::Parsers::Base
+
+          def reset
+            @tag = {}
+            @response = { 'tagSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'resourceId', 'resourceType', 'key', 'value'
+              @tag[name] = @value
+            when 'item'
+              @response['tagSet'] << @tag
+              @tag = {}
+            when 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_volumes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_volumes.rb
new file mode 100644
index 0000000..a0e8bb9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/describe_volumes.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeVolumes < Fog::Parsers::Base
+
+          def reset
+            @attachment = {}
+            @in_attachment_set = false
+            @response = { 'volumeSet' => [] }
+            @tag = {}
+            @volume = { 'attachmentSet' => [], 'tagSet' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'attachmentSet'
+              @in_attachment_set = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_attachment_set
+              case name
+              when 'attachmentSet'
+                @in_attachment_set = false
+              when 'attachTime'
+                @attachment[name] = Time.parse(@value)
+              when 'deleteOnTermination'
+                @attachment[name] = @value == 'true'
+              when 'device', 'instanceId', 'status', 'volumeId'
+                @attachment[name] = @value
+              when 'item'
+                @volume['attachmentSet'] << @attachment
+                @attachment = {}
+              end
+            elsif @in_tag_set
+              case name
+              when 'key', 'value'
+                @tag[name] = @value
+              when 'item'
+                @volume['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              when 'tagSet'
+                @in_tag_set = false
+              end
+            else
+              case name
+              when 'availabilityZone', 'snapshotId', 'status', 'volumeId'
+                @volume[name] = @value
+              when 'createTime'
+                @volume[name] = Time.parse(@value)
+              when 'item'
+                @response['volumeSet'] << @volume
+                @volume = { 'attachmentSet' => [], 'tagSet' => {} }
+              when 'requestId'
+                @response[name] = @value
+              when 'size'
+                @volume[name] = @value.to_i
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/detach_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/detach_volume.rb
new file mode 100644
index 0000000..54b3824
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/detach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DetachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(@value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/get_console_output.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/get_console_output.rb
new file mode 100644
index 0000000..1315735
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/get_console_output.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class GetConsoleOutput < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId'
+              @response[name] = @value
+            when 'output'
+              @response[name] = if @value
+                Base64.decode64(@value)
+              else
+                nil
+              end
+            when 'timestamp'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/import_key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/import_key_pair.rb
new file mode 100644
index 0000000..0aebc0b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/import_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class ImportKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyName', 'requestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/register_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/register_image.rb
new file mode 100644
index 0000000..8db68cf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/register_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RegisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId', 'imageId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/run_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/run_instances.rb
new file mode 100644
index 0000000..399a720
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/run_instances.rb
@@ -0,0 +1,89 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RunInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+            @response = { 'groupSet' => [], 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when 'groupSet'
+              @in_group_set = true
+            when 'productCodes'
+              @in_product_codes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = @value.to_i
+            when 'architecture', 'clientToken', 'dnsName', 'imageId',
+                  'instanceId', 'instanceType', 'ipAddress', 'kernelId',
+                  'keyName', 'privateDnsName', 'privateIpAddress', 'ramdiskId',
+                  'reason', 'rootDeviceType'
+              @instance[name] = @value
+            when 'availabilityZone'
+              @instance['placement'][name] = @value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(@value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              @instance['instanceState'][name] = @value.to_i
+            when 'deleteOnTermination'
+              if @value == 'true'
+                @block_device_mapping[name] = true
+              else
+                @block_device_mapping[name] = false
+              end
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = @value
+            when 'groupId'
+              @response['groupSet'] << @value
+            when 'groupSet'
+              @in_group_set = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif !@in_group_set && !@in_product_codes
+                @response['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+              end
+            when 'launchTime'
+              @instance[name] = Time.parse(@value)
+            when 'name'
+              @instance['instanceState'][name] = @value
+            when 'ownerId', 'requestId', 'reservationId'
+              @response[name] = @value
+            when 'product_code'
+              @instance['productCodes'] << @value
+            when 'productCodes'
+              @in_product_codes = false
+            when 'state'
+              if @value == 'true'
+                @instance['monitoring'][name] = true
+              else
+                @instance['monitoring'][name] = false
+              end
+            when 'subnetId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/start_stop_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/start_stop_instances.rb
new file mode 100644
index 0000000..f83bd5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/start_stop_instances.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class StartStopInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'currentState' => {}, 'previousState' => {} }
+            @response = { 'instancesSet' => [] }
+            @state = nil
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'currentState', 'previousState'
+              @state = name
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'code'
+              @instance[@state][name] = @value.to_s
+            when 'instanceId'
+              @instance[name] = @value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'currentState' => {}, 'previousState' => {} }
+            when 'name'
+              @instance[@state][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/terminate_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/terminate_instances.rb
new file mode 100644
index 0000000..6f9a466
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/compute/terminate_instances.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class TerminateInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'previousState' => {}, 'currentState' => {} }
+            @response = { 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'previousState'
+              @in_previous_state = true
+            elsif name == 'currentState'
+              @in_current_state = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId'
+              @instance[name] = @value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'previousState' => {}, 'currentState' => {} }
+            when 'code'
+              if @in_previous_state
+                @instance['previousState'][name] = @value.to_i
+              elsif @in_current_state
+                @instance['currentState'][name] = @value.to_i
+              end
+            when 'name'
+              if @in_previous_state
+                @instance['previousState'][name] = @value
+              elsif @in_current_state
+                @instance['currentState'][name] = @value
+              end
+            when 'previousState'
+              @in_previous_state = false
+            when 'requestId'
+              @response[name] = @value
+            when 'currentState'
+              @in_current_state = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/change_resource_record_sets.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/change_resource_record_sets.rb
new file mode 100644
index 0000000..dcb518d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/change_resource_record_sets.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ChangeResourceRecordSets < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+          
+          def end_element(name)
+            case name
+            when 'Id'  
+              @response[name] = @value.sub('/change/', '')
+            when 'Status', 'SubmittedAt'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/create_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/create_hosted_zone.rb
new file mode 100644
index 0000000..862599b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/create_hosted_zone.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class CreateHostedZone < Fog::Parsers::Base
+
+          def reset
+            @hosted_zone = {}
+            @change_info = {}
+            @name_servers = []
+            @response = {}
+            @section = :hosted_zone
+          end
+
+          def end_element(name)
+            if @section == :hosted_zone
+              case name
+              when 'Id'
+                @hosted_zone[name] = @value.sub('/hostedzone/', '')
+              when 'Name', 'CallerReference', 'Comment'
+                @hosted_zone[name]= @value
+              when 'HostedZone'
+                @response['HostedZone'] = @hosted_zone
+                @hosted_zone = {}
+                @section = :change_info
+              end
+            elsif @section == :change_info
+              case name
+              when 'Id'
+                @change_info[name]= @value.sub('/change/', '')
+              when 'Status', 'SubmittedAt'
+                @change_info[name] = @value
+              when 'ChangeInfo'
+                @response['ChangeInfo'] = @change_info
+                @change_info = {}
+                @section = :name_servers
+              end
+            elsif @section == :name_servers
+              case name
+              when 'NameServer'
+                @name_servers << @value
+              when 'NameServers'
+                @response['NameServers'] = @name_servers
+                @name_servers = {}
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/delete_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/delete_hosted_zone.rb
new file mode 100644
index 0000000..733b5e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/delete_hosted_zone.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class DeleteHostedZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+            @response['ChangeInfo'] = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Id', 'Status', 'SubmittedAt'
+              @response['ChangeInfo'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_change.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_change.rb
new file mode 100644
index 0000000..f88ee12
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_change.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class GetChange < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+          
+          def end_element(name)
+            case name
+            when 'Id'
+              @response[name] = @value.sub('/change/', '')
+            when 'Status', 'SubmittedAt'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_hosted_zone.rb
new file mode 100644
index 0000000..5eeef85
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/get_hosted_zone.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class GetHostedZone < Fog::Parsers::Base
+
+          def reset
+            @hosted_zone = {}
+            @name_servers = []
+            @response = {}
+            @section = :hosted_zone
+          end
+
+          def end_element(name)
+            if @section == :hosted_zone
+              case name
+              when 'Id'
+                @hosted_zone[name]= @value.sub('/hostedzone/', '')
+              when 'Name', 'CallerReference', 'Comment'
+                @hosted_zone[name]= @value
+              when 'HostedZone'
+                @response['HostedZone'] = @hosted_zone
+                @hosted_zone = {}
+                @section = :name_servers
+              end
+            elsif @section == :name_servers
+              case name
+              when 'NameServer'
+                @name_servers << @value
+              when 'NameServers'
+                @response['NameServers'] = @name_servers
+                @name_servers = {}
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_hosted_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_hosted_zones.rb
new file mode 100644
index 0000000..c95a8f0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_hosted_zones.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ListHostedZones < Fog::Parsers::Base
+
+          def reset
+            @hosted_zones = []
+            @zone = {}
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Id'
+              @zone[name] = @value.sub('/hostedzone/', '')
+            when 'Name', 'CallerReference', 'Comment'
+              @zone[name] = @value
+            when 'HostedZone'
+              @hosted_zones << @zone
+              @zone = {}
+            when 'HostedZones'
+              @response['HostedZones'] = @hosted_zones
+            when 'MaxItems'
+              @response[name] = @value.to_i
+            when 'IsTruncated', 'Marker', 'NextMarker'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_resource_record_sets.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_resource_record_sets.rb
new file mode 100644
index 0000000..cd9ce7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/dns/list_resource_record_sets.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ListResourceRecordSets < Fog::Parsers::Base
+
+          def reset
+            @resource_record = []
+            @resource_record_set = {}
+            @resource_record_set['ResourceRecords'] = []
+            @response = {}
+            @response['ResourceRecordSets'] = []
+            @section = :resource_record_set
+          end
+          
+          def end_element(name)
+            if @section == :resource_record_set
+              case name
+              when 'Name', 'Type', 'TTL'
+                @resource_record_set[name] = @value
+              when 'Value'
+                @resource_record_set['ResourceRecords'] << @value
+              when 'ResourceRecordSet'
+                @response['ResourceRecordSets'] << @resource_record_set
+                @resource_record_set = {}
+                @resource_record_set['ResourceRecords'] = []
+              when 'ResourceRecordSets'
+                @section = :main
+              end
+            elsif @section == :main
+                case name
+                when 'MaxItems'
+                  @response[name]= @value.to_i
+                when 'IsTruncated', 'NextRecordName', 'NextRecordType'
+                  @response[name]= @value
+                end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/create_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/create_load_balancer.rb
new file mode 100644
index 0000000..a69858c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/create_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class CreateLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CreateLoadBalancerResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DNSName'
+              @response['CreateLoadBalancerResult'][name] = @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/delete_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..cfb946e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/delete_load_balancer.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeleteLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeleteLoadBalancerResult' => nil, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..8436127
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeregisterInstancesFromLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeregisterInstancesFromLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['DeregisterInstancesFromLoadBalancerResult']['Instances'] << {name => @value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_instance_health.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_instance_health.rb
new file mode 100644
index 0000000..2c51dfd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_instance_health.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeInstanceHealth < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DescribeInstanceHealthResult' => { 'InstanceStates' => [] }, 'ResponseMetadata' => {} }
+            @instance_state = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'State', 'InstanceId', 'ReasonCode'
+              @instance_state[name] = @value
+            when 'member'
+              @response['DescribeInstanceHealthResult']['InstanceStates'] << @instance_state
+              @instance_state = {}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_load_balancers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..7778a6a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/describe_load_balancers.rb
@@ -0,0 +1,101 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeLoadBalancers < Fog::Parsers::Base
+
+          def reset
+            @load_balancer = { 'ListenerDescriptions' => [], 'Instances' => [], 'AvailabilityZones' => [], 'Policies' => {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => [] }, 'HealthCheck' => {} }
+            @listener_description = { 'PolicyNames' => [], 'Listener' => {} }
+            @results = { 'LoadBalancerDescriptions' => [] }
+            @response = { 'DescribeLoadBalancersResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'ListenerDescriptions'
+              @in_listeners = true
+            when 'Instances'
+              @in_instances = true
+            when 'AvailabilityZones'
+              @in_availability_zones = true
+            when 'PolicyNames'
+              @in_policy_names = true
+            when 'Policies'
+              @in_policies = true
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = true
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              if @in_policy_names
+                @listener_description['PolicyNames'] << @value
+              elsif @in_availability_zones
+                @load_balancer['AvailabilityZones'] << @value
+              elsif @in_listeners
+                @load_balancer['ListenerDescriptions'] << @listener_description
+                @listener_description = { 'PolicyNames' => [], 'Listener' => {} }
+              elsif @in_app_cookies
+                @load_balancer['Policies']['AppCookieStickinessPolicies'] << @value
+              elsif @in_lb_cookies
+                @load_balancer['Policies']['LBCookieStickinessPolicies'] << @value
+              elsif !@in_instances && !@in_policies
+                @results['LoadBalancerDescriptions'] << @load_balancer
+                @load_balancer = { 'ListenerDescriptions' => [], 'Instances' => [], 'AvailabilityZones' => [], 'Policies' => {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => [] }, 'HealthCheck' => {} }
+              end
+
+            when 'LoadBalancerName', 'DNSName'
+              @load_balancer[name] = @value
+            when 'CreatedTime'
+              @load_balancer[name] = Time.parse(@value)
+
+            when 'ListenerDescriptions'
+              @in_listeners = false
+            when 'PolicyNames'
+              @in_policy_names = false
+            when 'Protocol'
+              @listener_description['Listener'][name] = @value
+            when 'LoadBalancerPort', 'InstancePort'
+              @listener_description['Listener'][name] = @value.to_i
+
+            when 'Instances'
+              @in_instances = false
+            when 'InstanceId'
+              @load_balancer['Instances'] << @value
+
+            when 'AvailabilityZones'
+              @in_availability_zones = false
+
+            when 'Policies'
+              @in_policies = false
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = false
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = false
+
+            when 'Interval', 'HealthyThreshold', 'Timeout', 'UnhealthyThreshold'
+              @load_balancer['HealthCheck'][name] = @value.to_i
+            when 'Target'
+              @load_balancer['HealthCheck'][name] = @value
+
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+
+            when 'DescribeLoadBalancersResponse'
+              @response['DescribeLoadBalancersResult'] = @results
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..4abfb77
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DisableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DisableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['DisableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..cb96c38
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class EnableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'EnableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['EnableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << @value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..2b1cca3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class RegisterInstancesWithLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'RegisterInstancesWithLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['RegisterInstancesWithLoadBalancerResult']['Instances'] << {name => @value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/basic.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/basic.rb
new file mode 100644
index 0000000..10bf5da
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/basic.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class Basic < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_access_key.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_access_key.rb
new file mode 100644
index 0000000..f0559ef
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_access_key.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateAccessKey < Fog::Parsers::Base
+
+          def reset
+            @response = { 'AccessKey' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessKeyId', 'UserName', 'SecretAccessKey', 'Status'
+              @response['AccessKey'][name] = @value
+            when 'RequestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_group.rb
new file mode 100644
index 0000000..0e78c98
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_group.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateGroup < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Group' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'GroupId', 'GroupName', 'Path'
+              @response['Group'][name] = @value
+            when 'RequestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_user.rb
new file mode 100644
index 0000000..1fd2605
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/create_user.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateUser < Fog::Parsers::Base
+
+          def reset
+            @response = { 'User' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @response['User'][name] = @value
+            when 'RequestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/get_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/get_user.rb
new file mode 100644
index 0000000..27c58b7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/get_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class GetUser < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_GetUser.html
+
+          def reset
+            @response = { 'User' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @response['User'][name] = @value
+            when 'RequestId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_access_keys.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_access_keys.rb
new file mode 100644
index 0000000..2237d97
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_access_keys.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListAccessKeys < Fog::Parsers::Base
+
+          def reset
+            @access_key = {}
+            @response = { 'AccessKeys' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessKeyId', 'Status', 'Username'
+              @access_key[name] = @value
+            when 'member'
+              @response['AccessKeys'] << @access_key
+              @access_key = {}
+            when 'IsTruncated'
+              response[name] = (@value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_groups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_groups.rb
new file mode 100644
index 0000000..921c3b6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_groups.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListGroups < Fog::Parsers::Base
+
+          def reset
+            @group = {}
+            @response = { 'Groups' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'GroupId', 'GroupName', 'Path'
+              @group[name] = @value
+            when 'member'
+              @response['Groups'] << @group
+              @group = {}
+            when 'IsTruncated'
+              response[name] = (@value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_policies.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_policies.rb
new file mode 100644
index 0000000..3a6d1ab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_policies.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListPolicies < Fog::Parsers::Base
+
+          def reset
+            @response = { 'PolicyNames' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['PolicyNames'] << @value
+            when 'IsTruncated'
+              response[name] = (@value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_users.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_users.rb
new file mode 100644
index 0000000..7e83d6a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/iam/list_users.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListUsers < Fog::Parsers::Base
+
+          def reset
+            @user = {}
+            @response = { 'Users' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @user[name] = @value
+            when 'member'
+              @response['Users'] << @user
+              @user = {}
+            when 'IsTruncated'
+              response[name] = (@value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/basic.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/basic.rb
new file mode 100644
index 0000000..8a653e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/basic.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Basic < Fog::Parsers::Base
+
+          def initialize(nil_string)
+            @nil_string = nil_string
+            reset
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'RequestId'
+              response[name] = @value
+            end
+          end
+
+          def sdb_decode(value)
+            value.eql?(@nil_string) ? nil : value
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/domain_metadata.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..3d9df66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/domain_metadata.rb
@@ -0,0 +1,32 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class DomainMetadata < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'AttributeNameCount', 'AttributeNamesSizeBytes', 'AttributeValueCount', 'AttributeValuesSizeBytes', 'ItemCount', 'ItemNamesSizeBytes'
+              response[name] = @value.to_i
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'RequestId'
+              response[name] = @value
+            when 'Timestamp'
+              response[name] = Time.at(@value.to_i)
+            end
+          end
+
+        end
+        
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/get_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/get_attributes.rb
new file mode 100644
index 0000000..c1c9ee4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/get_attributes.rb
@@ -0,0 +1,36 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class GetAttributes < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @attribute = nil
+            @response = { 'Attributes' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Attribute'
+              @attribute = nil
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'Name'
+              @attribute = @value
+              response['Attributes'][@attribute] ||= []
+            when 'RequestId'
+              response[name] = @value
+            when 'Value'
+              response['Attributes'][@attribute] << sdb_decode(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/list_domains.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/list_domains.rb
new file mode 100644
index 0000000..8b1fa3e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/list_domains.rb
@@ -0,0 +1,30 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class ListDomains < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = { 'Domains' => [] }
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'DomainName'
+              response['Domains'] << @value
+            when 'NextToken', 'RequestId'
+              response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/select.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/select.rb
new file mode 100644
index 0000000..ce5e503
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/simpledb/select.rb
@@ -0,0 +1,41 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Select < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @item_name = @attribute_name = nil
+            @response = { 'Items' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'BoxUsage'
+              response[name] = @value.to_f
+            when 'Item'
+              @item_name = @attribute_name = nil
+            when 'Name'
+              if @item_name.nil? 
+                @item_name = @value
+                response['Items'][@item_name] = {}
+              else
+                @attribute_name = @value
+                response['Items'][@item_name][@attribute_name] ||= []
+              end
+            when 'NextToken', 'RequestId'
+              response[name] = @value
+            when 'Value'
+              response['Items'][@item_name][@attribute_name] << sdb_decode(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/access_control_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/access_control_list.rb
new file mode 100644
index 0000000..b0f1f70
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/access_control_list.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @in_access_control_list = false
+            @grant = { 'Grantee' => {} }
+            @response = { 'Owner' => {}, 'AccessControlList' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'AccessControlList'
+              @in_access_control_list = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessControlList'
+              @in_access_control_list = false
+            when 'Grant'
+              @response['AccessControlList'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Permission'
+              @grant[name] = @value
+            when 'URI'
+              @grant['Grantee'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/complete_multipart_upload.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/complete_multipart_upload.rb
new file mode 100644
index 0000000..272cce6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/complete_multipart_upload.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class CompleteMultipartUpload < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'ETag', 'Key', 'Location'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/copy_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/copy_object.rb
new file mode 100644
index 0000000..4e428bd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/copy_object.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class CopyObject < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'ETag'
+              @response[name] = @value.gsub('"', '')
+            when 'LastModified'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket.rb
new file mode 100644
index 0000000..0f69b7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucket < Fog::Parsers::Base
+
+          def reset
+            @object = { 'Owner' => {} }
+            @response = { 'Contents' => [], 'CommonPrefixes' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = false
+            when 'Contents'
+              @response['Contents'] << @object
+              @object = { 'Owner' => {} }
+            when 'DisplayName', 'ID'
+              @object['Owner'][name] = @value
+            when 'ETag'
+              @object[name] = @value.gsub('"', '')
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              @object['LastModified'] = Time.parse(@value)
+            when 'Marker', 'Name'
+              @response[name] = @value
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Prefix'
+              if @in_common_prefixes
+                @response['CommonPrefixes'] << @value
+              else
+                @response[name] = @value
+              end
+            when 'Size'
+              @object['Size'] = @value.to_i
+            when 'Delimiter', 'Key', 'StorageClass'
+              @object[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_location.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_location.rb
new file mode 100644
index 0000000..ba40bd0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_location.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketLocation < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'LocationConstraint'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_logging.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_logging.rb
new file mode 100644
index 0000000..fabbf85
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_logging.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketLogging < Fog::Parsers::Base
+
+          def reset
+            @grant = { 'Grantee' => {} }
+            @response = { 'BucketLoggingStatus' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Grant'
+              @response['BucketLoggingStatus']['LoggingEnabled']['TargetGrants'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'LoggingEnabled'
+              @response['BucketLoggingStatus']['LoggingEnabled'] = { 'TargetGrants' => [] }
+            when 'Permission'
+              @grant[name] = @value
+            when 'TargetBucket', 'TargetPrefix'
+              @response['BucketLoggingStatus'][name] = @value
+            when 'URI'
+              @grant['Grantee'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
new file mode 100644
index 0000000..70e6cc3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_object_versions.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketObjectVersions < Fog::Parsers::Base
+
+          def reset
+            @delete_marker = { 'Owner' => {} }
+            @version = { 'Owner' => {} }
+
+            @in_delete_marke = false
+            @in_version = false
+
+            @response = { 'Versions' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'DeleteMarker'
+              @in_delete_marker = true
+            when 'Version'
+              @in_version = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DeleteMarker'
+              @response['Versions'] << {'DeleteMarker' => @delete_marker }
+              @delete_marker = { 'Owner' => {} }
+              @in_delete_marker = false
+            when 'Version'
+              @response['Versions'] << {'Version' => @version }
+              @version = { 'Owner' => {} }
+              @in_version = false
+            when 'DisplayName', 'ID'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['Owner'][name] = @value
+            when 'ETag'
+              @version[name] = @value.gsub('"', '')
+            when 'IsLatest'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['IsLatest'] = if @value == 'true'
+                true
+              else
+                false
+              end
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['LastModified'] = Time.parse(@value)
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Size'
+              @version['Size'] = @value.to_i
+            when 'Key', 'KeyMarker', 'Name', 'Prefix', 'StorageClass', 'VersionId', 'VersionIdMarker'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              else
+                @response
+              end[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_versioning.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_versioning.rb
new file mode 100644
index 0000000..1a3f947
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_bucket_versioning.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketVersioning < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VersioningConfiguration' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Status'
+              @response['VersioningConfiguration'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_request_payment.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_request_payment.rb
new file mode 100644
index 0000000..2884f4b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_request_payment.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetRequestPayment < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'Payer'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_service.rb
new file mode 100644
index 0000000..d3ad8cc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/get_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetService < Fog::Parsers::Base
+
+          def reset
+            @bucket = {}
+            @response = { 'Owner' => {}, 'Buckets' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket'
+              @response['Buckets'] << @bucket
+              @bucket = {}
+            when 'CreationDate'
+              @bucket['CreationDate'] = Time.parse(@value)
+            when 'DisplayName', 'ID'
+              @response['Owner'][name] = @value
+            when 'Name'
+              @bucket[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/initiate_multipart_upload.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/initiate_multipart_upload.rb
new file mode 100644
index 0000000..2037d42
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/initiate_multipart_upload.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class InitiateMultipartUpload < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'Key', 'UploadId'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_multipart_uploads.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_multipart_uploads.rb
new file mode 100644
index 0000000..26f3cc9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_multipart_uploads.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class ListMultipartUploads < Fog::Parsers::Base
+
+          def reset
+            @upload = { 'Initiator' => {}, 'Owner' => {} }
+            @response = { 'Upload' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Initiator'
+              @in_initiator = true
+            when 'Owner'
+              @in_owner = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'KeyMarker', 'NextKeyMarker', 'NextUploadIdMarker', 'UploadIdMarker'
+              @response[name] = @value
+            when 'DisplayName', 'ID'
+              if @in_initiator
+                @upload['Initiator'][name] = @value
+              elsif @in_owner
+                @upload['Owner'][name] = @value
+              end
+            when 'Initiated'
+              @upload[name] = Time.parse(@value)
+            when 'Initiator'
+              @in_initiator = false
+            when 'IsTruncated'
+              @response[name] = @value == 'true'
+            when 'Key', 'StorageClass', 'UploadId'
+              @upload[name] = @value
+            when 'MaxUploads'
+              @response[name] = @value.to_i
+            when 'Owner'
+              @in_owner = false
+            when 'Upload'
+              @response['Upload'] << @upload
+              @upload = { 'Initiator' => {}, 'Owner' => {} }
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_parts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_parts.rb
new file mode 100644
index 0000000..41e6693
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/parsers/storage/list_parts.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class ListParts < Fog::Parsers::Base
+
+          def reset
+            @part = {}
+            @response = { 'Initiator' => {}, 'Part' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'Key', 'NextPartNumberMarker', 'PartNumberMarker', 'StorageClass', 'UploadId'
+              @response[name] = @value
+            when 'DisplayName', 'ID'
+              @response['Initiator'][name] = @value
+            when 'ETag'
+              @part[name] = @value
+            when 'IsTruncated'
+              @response[name] = @value == 'true'
+            when 'LastModified'
+              @part[name] = Time.parse(@value)
+            when 'MaxParts'
+              @response[name] = @value.to_i
+            when 'Part'
+              @response['Part'] << @part
+              @part = {}
+            when 'PartNumber', 'Size'
+              @part[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/delete_distribution.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/delete_distribution.rb
new file mode 100644
index 0000000..cfdda3a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/delete_distribution.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        # Delete a distribution from CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution to delete
+        # * etag<~String> - etag of that distribution from earlier get or put
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/DeleteDistribution.html
+
+        def delete_distribution(distribution_id, etag)
+          request({
+            :expects    => 204,
+            :headers    => { 'If-Match' => etag },
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => "/distribution/#{distribution_id}"
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def delete_distribution(distribution_id, etag)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution.rb
new file mode 100644
index 0000000..db5b64d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution.rb
@@ -0,0 +1,65 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/aws/parsers/cdn/distribution'
+
+        # Get information about a distribution from CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - id of distribution
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'S3Origin'<~Hash>:
+        #       * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #       * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #     or
+        #     * 'CustomOrigin'<~Hash>:
+        #       * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #       * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #       * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #       * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'InProgressInvalidationBatches'<~Integer> - number of invalidation batches in progress
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/GetDistribution.html
+
+        def get_distribution(distribution_id)
+          request({
+            :expects    => 200,
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution/#{distribution_id}"
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_distribution(distribution_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution_list.rb
new file mode 100644
index 0000000..1d5b641
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/get_distribution_list.rb
@@ -0,0 +1,67 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/aws/parsers/cdn/get_distribution_list'
+
+        # List information about distributions in CloudFront
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'Marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'MaxItems'<~Integer> - limits number of object keys returned
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxItems'<~Integer> - Maximum number of keys specified for query
+        #     * 'NextMarker'<~String> - Marker to specify for next page (id of last result of current page)
+        #     * 'DistributionSummary'<~Array>:
+        #       * 'S3Origin'<~Hash>:
+        #         * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #         * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #       or
+        #       * 'CustomOrigin'<~Hash>:
+        #         * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #         * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #         * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #       * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Id'<~String> - Id of distribution
+        #       * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'Status'<~String> - Status of distribution
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/ListDistributions.html
+
+        def get_distribution_list(options = {})
+          request({
+            :expects    => 200,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::CDN::GetDistributionList.new,
+            :path       => "/distribution",
+            :query      => options
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_distribution_list(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_distribution.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_distribution.rb
new file mode 100644
index 0000000..0d4452e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_distribution.rb
@@ -0,0 +1,99 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/aws/parsers/cdn/distribution'
+
+        # create a new distribution in CloudFront
+        #
+        # ==== Parameters
+        # * options<~Hash> - config for distribution.  Defaults to {}.
+        #   REQUIRED:
+        #   * 'S3Origin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #     * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #   or
+        #   * 'CustomOrigin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #     * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #     * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #     * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #   OPTIONAL:
+        #   * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #   * 'Comment'<~String> - Optional comment about distribution
+        #   * 'CNAME'<~Array> - Optional array of strings to set as CNAMEs
+        #   * 'DefaultRootObject'<~String> - Optional default object to return for '/'
+        #   * 'Enabled'<~Boolean> - Whether or not distribution should accept requests, defaults to true
+        #   * 'Logging'<~Hash>: Optional logging config
+        #     * 'Bucket'<~String> - Bucket to store logs in, ie 'mylogs.s3.amazonaws.com'
+        #     * 'Prefix'<~String> - Optional prefix for log filenames, ie 'myprefix/'
+        #   * 'OriginAccessIdentity'<~String> - Used for serving private content, in format 'origin-access-identity/cloudfront/ID'
+        #   * 'RequiredProtocols'<~String> - Optional, set to 'https' to force https connections
+        #   * 'TrustedSigners'<~Array> - Optional grant of rights to up to 5 aws accounts to generate signed URLs for private content, elements are either 'Self' for your own account or an AWS Account Number
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DomainName'<~String>: Domain name of distribution
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html
+
+        def post_distribution(options = {})
+          options['CallerReference'] = Time.now.to_i.to_s
+          data = '<?xml version="1.0" encoding="UTF-8"?>'
+          data << "<DistributionConfig xmlns=\"http://cloudfront.amazonaws.com/doc/#{@version}/\">"
+          for key, value in options
+            case value
+            when Array
+              for item in value
+                data << "<#{key}>#{item}</#{key}>"
+              end
+            when Hash
+              data << "<#{key}>"
+              for inner_key, inner_value in value
+                data << "<#{inner_key}>#{inner_value}</#{inner_key}>"
+              end
+              data << "</#{key}>"
+            else
+              data << "<#{key}>#{value}</#{key}>"
+            end
+          end
+          data << "</DistributionConfig>"
+          request({
+            :body       => data,
+            :expects    => 201,
+            :headers    => { 'Content-Type' => 'text/xml' },
+            :idempotent => true,
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution"
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def post_distribution(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_invalidation.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_invalidation.rb
new file mode 100644
index 0000000..c583ade
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/post_invalidation.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/aws/parsers/cdn/post_invalidation'
+
+        # List information about distributions in CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution for invalidations
+        # * paths<~Array> - Array of string paths to objects to invalidate
+        # * caller_reference<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Id'<~String> - Id of invalidation
+        #     * 'Status'<~String> - Status of invalidation
+        #     * 'CreateTime'<~Integer> - Time of invalidation creation
+        #     * 'InvalidationBatch'<~Array>:
+        #       * 'Path'<~Array> - Array of strings of objects to invalidate
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateInvalidation.html
+
+        def post_invalidation(distribution_id, paths, caller_reference = Time.now.to_i.to_s)
+          body = '<?xml version="1.0" encoding="UTF-8"?>'
+          body << "<InvalidationBatch>"
+          for path in [*paths]
+            body << "<Path>" << path << "</Path>"
+          end
+          body << "<CallerReference>" << caller_reference << "</CallerReference>"
+          body << "</InvalidationBatch>"
+          request({
+            :body       => body,
+            :expects    => 201,
+            :headers    => {'Content-Type' => 'text/xml'},
+            :idempotent => true,
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::CDN::PostInvalidation.new,
+            :path       => "/distribution/#{distribution_id}/invalidation"
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def post_invalidation(distribution_id, paths, caller_reference = Time.now.to_i.to_s)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/put_distribution_config.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/put_distribution_config.rb
new file mode 100644
index 0000000..fa935a8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/cdn/put_distribution_config.rb
@@ -0,0 +1,102 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/aws/parsers/cdn/distribution'
+
+        # update a distribution in CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution to update config for
+        # * options<~Hash> - config for distribution.  Defaults to {}.
+        #   REQUIRED:
+        #   * 'S3Origin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #     * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #   or
+        #   * 'CustomOrigin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #     * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #     * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #     * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #   OPTIONAL:
+        #   * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #   * 'Comment'<~String> - Optional comment about distribution
+        #   * 'CNAME'<~Array> - Optional array of strings to set as CNAMEs
+        #   * 'DefaultRootObject'<~String> - Optional default object to return for '/'
+        #   * 'Enabled'<~Boolean> - Whether or not distribution should accept requests, defaults to true
+        #   * 'Logging'<~Hash>: Optional logging config
+        #     * 'Bucket'<~String> - Bucket to store logs in, ie 'mylogs.s3.amazonaws.com'
+        #     * 'Prefix'<~String> - Optional prefix for log filenames, ie 'myprefix/'
+        #   * 'OriginAccessIdentity'<~String> - Used for serving private content, in format 'origin-access-identity/cloudfront/ID'
+        #   * 'RequiredProtocols'<~String> - Optional, set to 'https' to force https connections
+        #   * 'TrustedSigners'<~Array> - Optional grant of rights to up to 5 aws accounts to generate signed URLs for private content, elements are either 'Self' for your own account or an AWS Account Number
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DomainName'<~String>: Domain name of distribution
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html
+
+        def put_distribution_config(distribution_id, etag, options = {})
+          data = '<?xml version="1.0" encoding="UTF-8"?>'
+          data << "<DistributionConfig xmlns=\"http://cloudfront.amazonaws.com/doc/#{@version}/\">"
+          for key, value in options
+            case value
+            when Array
+              for item in value
+                data << "<#{key}>#{item}</#{key}>"
+              end
+            when Hash
+              data << "<#{key}>"
+              for inner_key, inner_value in value
+                data << "<#{inner_key}>#{inner_value}</#{inner_key}>"
+              end
+              data << "</#{key}>"
+            else
+              data << "<#{key}>#{value}</#{key}>"
+            end
+          end
+          data << "</DistributionConfig>"
+          request({
+            :body       => data,
+            :expects    => 200,
+            :headers    => {
+              'Content-Type'  => 'text/xml',
+              'If-Match'      => etag
+            },
+            :idempotent => true,
+            :method     => 'PUT',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution/#{distribution_id}/config"
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_distribution_config(distribution_id, etag, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/allocate_address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/allocate_address.rb
new file mode 100644
index 0000000..c6f5cec
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/allocate_address.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/allocate_address'
+
+        # Acquire an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'publicIp'<~String> - The acquired address
+        #     * 'requestId'<~String> - Id of the request
+        def allocate_address
+          request(
+            'Action'  => 'AllocateAddress',
+            :parser   => Fog::Parsers::AWS::Compute::AllocateAddress.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def allocate_address
+          response = Excon::Response.new
+          if describe_addresses.body['addressesSet'].size < @data[:limits][:addresses]
+            response.status = 200
+            public_ip = Fog::AWS::Mock.ip_address
+            data ={
+              'instanceId' => nil,
+              'publicIp'   => public_ip
+            }
+            @data[:addresses][public_ip] = data
+            response.body = {
+              'publicIp'  => public_ip,
+              'requestId' => Fog::AWS::Mock.request_id
+            }
+            response
+          else
+            response.status = 400
+            response.body = "<?xml version=\"1.0\"?><Response><Errors><Error><Code>AddressLimitExceeded</Code><Message>Too many addresses allocated</Message></Error></Errors><RequestID>#{Fog::AWS::Mock.request_id}</RequestID></Response>"
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/associate_address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/associate_address.rb
new file mode 100644
index 0000000..7080b41
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/associate_address.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Associate an elastic IP address with an instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate address with
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def associate_address(instance_id, public_ip)
+          request(
+            'Action'      => 'AssociateAddress',
+            'InstanceId'  => instance_id,
+            'PublicIp'    => public_ip,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def associate_address(instance_id, public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          instance = @data[:instances][instance_id]
+          address = @data[:addresses][public_ip]
+          if instance && address
+            address['instanceId'] = instance_id
+            instance['originalIpAddress'] = instance['ipAddress']
+            instance['ipAddress'] = public_ip
+            instance['dnsName'] = Fog::AWS::Mock.dns_name_for(public_ip)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          elsif !instance
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          elsif !address
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/attach_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/attach_volume.rb
new file mode 100644
index 0000000..d90505d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/attach_volume.rb
@@ -0,0 +1,81 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/attach_volume'
+
+        # Attach an Amazon EBS volume with a running instance, exposing as specified device
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate volume with
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * device<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def attach_volume(instance_id, volume_id, device)
+          request(
+            'Action'      => 'AttachVolume',
+            'VolumeId'    => volume_id,
+            'InstanceId'  => instance_id,
+            'Device'      => device,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::AttachVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def attach_volume(instance_id, volume_id, device)
+          response = Excon::Response.new
+          if instance_id && volume_id && device
+            response.status = 200
+            instance = @data[:instances][instance_id]
+            volume = @data[:volumes][volume_id]
+            if instance && volume
+              data = {
+                'attachTime'  => Time.now,
+                'device'      => device,
+                'instanceId'  => instance_id,
+                'status'      => 'attaching',
+                'volumeId'    => volume_id
+              }
+              volume['attachmentSet'] = [data]
+              volume['status'] = 'attaching'
+              response.status = 200
+              response.body = {
+                'requestId' => Fog::AWS::Mock.request_id
+              }.merge!(data)
+              response
+            elsif !instance
+              raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist.")
+            elsif !volume
+              raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+            end
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter instance_id'
+            elsif !volume_id
+              message << 'The request must contain the parameter volume_id'
+            else
+              message << 'The request must contain the parameter device'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
new file mode 100644
index 0000000..30cb6a3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/authorize_security_group_ingress.rb
@@ -0,0 +1,86 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Add permissions to a security group
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'GroupName'<~String> - Name of group
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'GroupName' - Name of group to modify
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def authorize_security_group_ingress(options = {})
+          request({
+            'Action'    => 'AuthorizeSecurityGroupIngress',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def authorize_security_group_ingress(options = {})
+          response = Excon::Response.new
+          group = @data[:security_groups][options['GroupName']]
+
+          if group
+            group['ipPermissions'] ||= []
+            if options['GroupName'] && options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              ['tcp', 'udp'].each do |protocol|
+                group['ipPermissions'] << {
+                  'groups'      => [{'groupName' => options['GroupName'], 'userId' => @owner_id}],
+                  'fromPort'    => 1,
+                  'ipRanges'    => [],
+                  'ipProtocol'  => protocol,
+                  'toPort'      => 65535
+                }
+              end
+              group['ipPermissions'] << {
+                'groups'      => [{'groupName' => options['GroupName'], 'userId' => @owner_id}],
+                'fromPort'    => -1,
+                'ipRanges'    => [],
+                'ipProtocol'  => 'icmp',
+                'toPort'      => -1
+              }
+            else
+              group['ipPermissions'] << {
+                'groups'      => [],
+                'fromPort'    => options['FromPort'],
+                'ipRanges'    => [],
+                'ipProtocol'  => options['IpProtocol'],
+                'toPort'      => options['ToPort']
+              }
+              if options['CidrIp']
+                group['ipPermissions'].last['ipRanges'] << { 'cidrIp' => options['CidrIp'] }
+              end
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{options['GroupName']}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_image.rb
new file mode 100644
index 0000000..c0492a3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_image.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_image'
+
+        # Create a bootable EBS volume AMI
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Instance used to create image.
+        # * name<~Name> - Name to give image.
+        # * description<~Name> - Description of image.
+        # * no_reboot<~Boolean> - Optional, whether or not to reboot the image when making the snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - The ID of the created AMI.
+        #     * 'requestId'<~String> - Id of request.
+        
+        def create_image(instance_id, name, description, no_reboot = false)
+          request(
+            'Action'            => 'CreateImage',
+            'InstanceId'        => instance_id,
+            'Name'              => name,
+            'Description'       => description,
+            'NoReboot'          => no_reboot.to_s,
+            :parser             => Fog::Parsers::AWS::Compute::CreateImage.new
+          )
+        end
+      end
+
+      class Mock
+        
+        # Usage
+        # 
+        # AWS[:compute].create_image("i-ac65ee8c", "test", "something")
+        #
+        
+        def create_image(instance_id, name, description, no_reboot = false)
+          response = Excon::Response.new
+          if instance_id && !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'InvalidParameterValue'
+            }
+            if name.empty?
+              response.body['Message'] = "Invalid value '' for name. Must be specified."
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_key_pair.rb
new file mode 100644
index 0000000..d96936c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_key_pair.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_key_pair'
+
+        # Create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyMaterial'<~String> - Unencrypted encoded PEM private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        def create_key_pair(key_name)
+          request(
+            'Action'  => 'CreateKeyPair',
+            'KeyName' => key_name,
+            :parser   => Fog::Parsers::AWS::Compute::CreateKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_key_pair(key_name)
+          response = Excon::Response.new
+          unless @data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyMaterial'     => Fog::AWS::Mock.key_material,
+              'keyName'         => key_name
+            }
+            @data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_security_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_security_group.rb
new file mode 100644
index 0000000..02cb8c1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_security_group.rb
@@ -0,0 +1,53 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Create a new security group
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        # * group_description<~String> - Description of group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def create_security_group(name, description)
+          request(
+            'Action'            => 'CreateSecurityGroup',
+            'GroupName'         => name,
+            'GroupDescription'  => CGI.escape(description),
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_security_group(name, description)
+          response = Excon::Response.new
+          unless @data[:security_groups][name]
+            data = {
+              'groupDescription'  => CGI.escape(description).gsub('%20', '+'),
+              'groupName'         => CGI.escape(name).gsub('%20', '+'),
+              'ipPermissions'     => [],
+              'ownerId'           => @owner_id
+            }
+            @data[:security_groups][name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidGroup.Duplicate => The security group '#{name}' already exists")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_snapshot.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_snapshot.rb
new file mode 100644
index 0000000..9240463
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_snapshot.rb
@@ -0,0 +1,71 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_snapshot'
+
+        # Create a snapshot of an EBS volume and store it in S3
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of EBS volume to snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'progress'<~String> - The percentage progress of the snapshot
+        #     * 'requestId'<~String> - id of request
+        #     * 'snapshotId'<~String> - id of snapshot
+        #     * 'startTime'<~Time> - timestamp when snapshot was initiated
+        #     * 'status'<~String> - state of snapshot
+        #     * 'volumeId'<~String> - id of volume snapshot targets
+        def create_snapshot(volume_id, description = nil)
+          request(
+            'Action'      => 'CreateSnapshot',
+            'Description' => description,
+            'VolumeId'    => volume_id,
+            :parser       => Fog::Parsers::AWS::Compute::CreateSnapshot.new
+          )
+        end
+
+      end
+
+      class Mock
+        
+        #
+        # Usage
+        #
+        # AWS[:compute].create_snapshot("vol-f7c23423", "latest snapshot")
+        #
+        
+        def create_snapshot(volume_id, description = nil)
+          response = Excon::Response.new
+          if volume = @data[:volumes][volume_id]
+            response.status = 200
+            snapshot_id = Fog::AWS::Mock.snapshot_id
+            data = {
+              'description' => description,
+              'ownerId'     => @owner_id,
+              'progress'    => nil,
+              'snapshotId'  => snapshot_id,
+              'startTime'   => Time.now,
+              'status'      => 'pending',
+              'volumeId'    => volume_id,
+              'volumeSize'  => volume['size']
+            }
+            @data[:snapshots][snapshot_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            @data[:snapshots][snapshot_id]['tagSet'] = {}
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_tags.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_tags.rb
new file mode 100644
index 0000000..ea5dc3f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_tags.rb
@@ -0,0 +1,78 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Adds tags to resources
+        #
+        # ==== Parameters
+        # * resources<~String> - One or more resources to tag
+        # * tags<~String> - hash of key value tag pairs to assign
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def create_tags(resources, tags)
+          resources = [*resources]
+          for key, value in tags
+            if value.nil?
+              tags[key] = ''
+            end
+          end
+          params = {}
+          params.merge!(AWS.indexed_param('ResourceId', resources))
+          params.merge!(AWS.indexed_param('Tag.%d.Key', tags.keys))
+          params.merge!(AWS.indexed_param('Tag.%d.Value', tags.values))
+          request({
+            'Action'            => 'CreateTags',
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def create_tags(resources, tags)
+          resources = [*resources]
+
+          tagged = resources.map do |resource_id|
+            type = case resource_id
+            when /^ami\-[a-z0-9]{8}$/i
+              'image'
+            when /^i\-[a-z0-9]{8}$/i
+              'instance'
+            when /^snap\-[a-z0-9]{8}$/i
+              'snapshot'
+            when /^vol\-[a-z0-9]{8}$/i
+              'volume'
+            end
+            if type && @data[:"#{type}s"][resource_id]
+              { 'resourceId' => resource_id, 'resourceType' => type }
+            else
+              raise(Fog::Service::NotFound.new("The #{type} ID '#{resource_id}' does not exist"))
+            end
+          end
+
+          tags.each do |key, value|
+            @data[:tags][key] ||= {}
+            @data[:tags][key][value] ||= []
+            @data[:tags][key][value] = @data[:tags][key][value] & tagged
+          end
+
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_volume.rb
new file mode 100644
index 0000000..8f5788a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/create_volume.rb
@@ -0,0 +1,74 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/create_volume'
+
+        # Create an EBS volume
+        #
+        # ==== Parameters
+        # * availability_zone<~String> - availability zone to create volume in
+        # * size<~Integer> - Size in GiBs for volume.  Must be between 1 and 1024.
+        # * snapshot_id<~String> - Optional, snapshot to create volume from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'availabilityZone'<~String> - Availability zone for volume
+        #     * 'createTime'<~Time> - Timestamp for creation
+        #     * 'size'<~Integer> - Size in GiBs for volume
+        #     * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #     * 'status's<~String> - State of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          request(
+            'Action'            => 'CreateVolume',
+            'AvailabilityZone'  => availability_zone,
+            'Size'              => size,
+            'SnapshotId'        => snapshot_id,
+            :parser             => Fog::Parsers::AWS::Compute::CreateVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          response = Excon::Response.new
+          if availability_zone && size
+            response.status = 200
+            volume_id = Fog::AWS::Mock.volume_id
+            data = {
+              'availabilityZone'  => availability_zone,
+              'attachmentSet'     => [],
+              'createTime'        => Time.now,
+              'size'              => size,
+              'snapshotId'        => snapshot_id,
+              'status'            => 'creating',
+              'tagSet'            => {},
+              'volumeId'          => volume_id
+            }
+            @data[:volumes][volume_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data.reject {|key,value| !['availabilityZone','createTime','size','snapshotId','status','volumeId'].include?(key) })
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'MissingParameter'
+            }
+            unless availability_zone
+              response.body['Message'] = 'The request must contain the parameter availability_zone'
+            else
+              response.body['Message'] = 'The request must contain the parameter size'
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_key_pair.rb
new file mode 100644
index 0000000..2efbf7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_key_pair.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a key pair that you own
+        #
+        # ==== Parameters
+        # * key_name<~String> - Name of the key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_key_pair(key_name)
+          request(
+            'Action'    => 'DeleteKeyPair',
+            'KeyName'   => key_name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_key_pair(key_name)
+          response = Excon::Response.new
+          @data[:key_pairs].delete(key_name)
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_security_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_security_group.rb
new file mode 100644
index 0000000..beea6e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_security_group.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a security group that you own
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_security_group(name)
+          request(
+            'Action'    => 'DeleteSecurityGroup',
+            'GroupName' => name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+        def delete_security_group(name)
+          response = Excon::Response.new
+          if @data[:security_groups][name]
+            @data[:security_groups].delete(name)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{name}' does not exist")
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_snapshot.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_snapshot.rb
new file mode 100644
index 0000000..966244a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_snapshot.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete a snapshot of an EBS volume that you own
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - ID of snapshot to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_snapshot(snapshot_id)
+          request(
+            'Action'      => 'DeleteSnapshot',
+            'SnapshotId'  => snapshot_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_snapshot(snapshot_id)
+          response = Excon::Response.new
+          if snapshot = @data[:snapshots].delete(snapshot_id)
+            response.status = true
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The snapshot '#{snapshot_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_tags.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_tags.rb
new file mode 100644
index 0000000..384098b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_tags.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Remove tags from resources
+        #
+        # ==== Parameters
+        # * resources<~String> - One or more resources to tag
+        # * tags<~String> - hash of key value tag pairs to assign
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_tags(resources, tags)
+          resources = [*resources]
+          for key, value in tags
+            if value.nil?
+              tags[key] = ''
+            end
+          end
+          params = {}
+          params.merge!(AWS.indexed_param('ResourceId', resources))
+          params.merge!(AWS.indexed_param('Tag.%d.Key', tags.keys))
+          params.merge!(AWS.indexed_param('Tag.%d.Value', tags.values))
+          request({
+            'Action'            => 'CreateTags',
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def delete_tags(resources, tags)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_volume.rb
new file mode 100644
index 0000000..85a254b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/delete_volume.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Delete an EBS volume
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of volume to delete.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def delete_volume(volume_id)
+          request(
+            'Action'    => 'DeleteVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_volume(volume_id)
+          response = Excon::Response.new
+          if volume = @data[:volumes][volume_id]
+            if volume["attachmentSet"].any?
+              attach = volume["attachmentSet"].first
+              raise Fog::AWS::Compute::Error.new("Client.VolumeInUse => Volume #{volume_id} is currently attached to #{attach["instanceId"]}")
+            end
+            @data[:deleted_at][volume_id] = Time.now
+            volume['status'] = 'deleting'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/deregister_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/deregister_image.rb
new file mode 100644
index 0000000..72442ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/deregister_image.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/deregister_image'
+
+        # deregister an image
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of image to deregister 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'return'<~Boolean> - Returns true if deregistration succeeded
+        #     * 'requestId'<~String> - Id of request
+        def deregister_image(image_id)
+          request(
+            'Action'      => 'DeregisterImage',
+            'ImageId'     => image_id,
+            :parser       => Fog::Parsers::AWS::Compute::DeregisterImage.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def deregister_image(image_id)
+          response = Excon::Response.new
+          if image_id 
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return' => "true"
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter image_id'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_addresses.rb
new file mode 100644
index 0000000..2ee51a8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_addresses.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_addresses'
+
+        # Describe all or specified IP addresses.
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'addressesSet'<~Array>:
+        #       * 'instanceId'<~String> - instance for ip address
+        #       * 'publicIp'<~String> - ip address for instance
+        def describe_addresses(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_addresses with #{filters.class} param is deprecated, use describe_addresses('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeAddresses',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAddresses.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_addresses(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_addresses with #{filters.class} param is deprecated, use describe_addresses('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          addresses_set = @data[:addresses].values
+
+          aliases = {'public-ip' => 'publicIp', 'instance-id' => 'instanceId'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            addresses_set = addresses_set.reject{|address| ![*filter_value].include?(address[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'     => Fog::AWS::Mock.request_id,
+            'addressesSet'  => addresses_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_availability_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_availability_zones.rb
new file mode 100644
index 0000000..80f3127
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_availability_zones.rb
@@ -0,0 +1,70 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_availability_zones'
+
+        # Describe all or specified availability zones
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'availabilityZoneInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'zoneName'<~String> - Name of zone
+        #       * 'zoneState'<~String> - State of zone
+        def describe_availability_zones(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_availability_zones with #{filters.class} param is deprecated, use describe_availability_zones('zone-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeAvailabilityZones',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAvailabilityZones.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_availability_zones(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_availability_zones with #{filters.class} param is deprecated, use describe_availability_zones('zone-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          availability_zone_info = [
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1b", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1c", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1d", "zoneState" => "available"},
+          ]
+
+          aliases = {'region-name' => 'regionName', 'zone-name' => 'zoneName', 'state' => 'zoneState'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            availability_zone_info = availability_zone_info.reject{|availability_zone| ![*filter_value].include?(availability_zone[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'availabilityZoneInfo'  => availability_zone_info,
+            'requestId'             => Fog::AWS::Mock.request_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_images.rb
new file mode 100644
index 0000000..fab6f69
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_images.rb
@@ -0,0 +1,65 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_images'
+
+        # Describe all or specified images.
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #   * filters and/or the following
+        #   * 'ExecutableBy'<~String> - Only return images that the executable_by
+        #     user has explicit permission to launch
+        #   * 'ImageId'<~Array> - Ids of images to describe
+        #   * 'Owner'<~String> - Only return images belonging to owner.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'imagesSet'<~Array>:
+        #       * 'architecture'<~String> - Architecture of the image
+        #       * 'blockDeviceMapping'<~Array> - An array of mapped block devices
+        #       * 'description'<~String> - Description of image
+        #       * 'imageId'<~String> - Id of the image
+        #       * 'imageLocation'<~String> - Location of the image
+        #       * 'imageOwnerId'<~String> - Id of the owner of the image
+        #       * 'imageState'<~String> - State of the image
+        #       * 'imageType'<~String> - Type of the image
+        #       * 'isPublic'<~Boolean> - Whether or not the image is public
+        #       * 'kernelId'<~String> - Kernel id associated with image, if any
+        #       * 'platform'<~String> - Operating platform of the image
+        #       * 'productCodes'<~Array> - Product codes for the image
+        #       * 'ramdiskId'<~String> - Ramdisk id associated with image, if any
+        #       * 'rootDeviceName'<~String> - Root device name, e.g. /dev/sda1
+        #       * 'rootDeviceType'<~String> - Root device type, ebs or instance-store
+        #       * 'virtualizationType'<~String> - Type of virtualization
+        def describe_images(filters = {})
+          options = {}
+          for key in ['ExecutableBy', 'ImageId', 'Owner']
+            if filters.is_a?(Hash) && filters.key?(key)
+              options[key] = filters.delete(key)
+            end
+          end
+          params = AWS.indexed_filters(filters).merge!(options)
+          request({
+            'Action'    => 'DescribeImages',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeImages.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_images(filters = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_instances.rb
new file mode 100644
index 0000000..fe181f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_instances.rb
@@ -0,0 +1,201 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_instances'
+
+        # Describe all or specified instances
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationSet'<~Array>:
+        #       * 'groupSet'<~Array> - Group names for reservation
+        #       * 'ownerId'<~String> - AWS Access Key ID of reservation owner
+        #       * 'reservationId'<~String> - Id of the reservation
+        #       * 'instancesSet'<~Array>:
+        #         * instance<~Hash>:
+        #           * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #           * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #           * 'blockDeviceMapping'<~Array>
+        #             * 'attachTime'<~Time> - time of volume attachment
+        #             * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #             * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #             * 'status'<~String> - status of attached volume
+        #             * 'volumeId'<~String> - Id of attached volume
+        #           * 'dnsName'<~String> - public dns name, blank until instance is running
+        #           * 'imageId'<~String> - image id of ami used to launch instance
+        #           * 'instanceId'<~String> - id of the instance
+        #           * 'instanceState'<~Hash>:
+        #             * 'code'<~Integer> - current status code
+        #             * 'name'<~String> - current status name
+        #           * 'instanceType'<~String> - type of instance
+        #           * 'ipAddress'<~String> - public ip address assigned to instance
+        #           * 'kernelId'<~String> - id of kernel used to launch instance
+        #           * 'keyName'<~String> - name of key used launch instances or blank
+        #           * 'launchTime'<~Time> - time instance was launched
+        #           * 'monitoring'<~Hash>:
+        #             * 'state'<~Boolean - state of monitoring
+        #           * 'placement'<~Hash>:
+        #             * 'availabilityZone'<~String> - Availability zone of the instance
+        #           * 'productCodes'<~Array> - Product codes for the instance
+        #           * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #           * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #           * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #           * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #           * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #           * 'reason'<~String> - reason for most recent state transition, or blank
+        def describe_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_instances with #{filters.class} param is deprecated, use describe_instances('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+
+          request({
+            'Action'    => 'DescribeInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_instances with #{filters.class} param is deprecated, use describe_instances('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+
+          if filters.keys.any? {|key| key =~ /^tag/}
+            Formatador.display_line("[yellow][WARN] describe_instances tag filters are not yet mocked[/] [light_black](#{caller.first})[/]")
+            Fog::Mock.not_implemented
+          end
+
+          response = Excon::Response.new
+
+          instance_set = @data[:instances].values
+
+          aliases = {
+            'architecture'      => 'architecture',
+            'availability-zone' => 'availabilityZone',
+            'client-token'      => 'clientToken',
+            'dns-token'         => 'dnsName',
+            'group-id'          => 'groupId',
+            'image-id'          => 'imageId',
+            'instance-id'       => 'instanceId',
+            'instance-lifecycle'  => 'instanceLifecycle',
+            'instance-type'     => 'instanceType',
+            'ip-address'        => 'ipAddress',
+            'kernel-id'         => 'kernelId',
+            'key-name'          => 'key-name',
+            'launch-index'      => 'launchIndex',
+            'launch-time'       => 'launchTime',
+            'monitoring-state'  => 'monitoringState',
+            'owner-id'          => 'ownerId',
+            'placement-group-name' => 'placementGroupName',
+            'platform'          => 'platform',
+            'private-dns-name'  => 'privateDnsName',
+            'private-ip-address'  => 'privateIpAddress',
+            'product-code'      => 'productCode',
+            'ramdisk-id'        => 'ramdiskId',
+            'reason'            => 'reason',
+            'requester-id'      => 'requesterId',
+            'reservation-id'    => 'reservationId',
+            'root-device-name'  => 'rootDeviceName',
+            'root-device-type'  => 'rootDeviceType',
+            'spot-instance-request-id' => 'spotInstanceRequestId',
+            'subnet-id'         => 'subnetId',
+            'virtualization-type' => 'virtualizationType',
+            'vpc-id'            => 'vpcId'
+          }
+          block_device_mapping_aliases = {
+            'attach-time'           => 'attachTime',
+            'delete-on-termination' => 'deleteOnTermination',
+            'device-name'           => 'deviceName',
+            'status'                => 'status',
+            'volume-id'             => 'volumeId',
+          }
+          instance_state_aliases = {
+            'code' => 'code',
+            'name' => 'name'
+          }
+          state_reason_aliases = {
+            'code'    => 'code',
+            'message' => 'message'
+          }
+          for filter_key, filter_value in filters
+            if block_device_mapping_key = filter_key.split('block-device-mapping.')[1]
+              aliased_key = block_device_mapping_aliases[block_device_mapping_key]
+              instance_set = instance_set.reject{|instance| !instance['blockDeviceMapping'].detect {|block_device_mapping| [*filter_value].include?(block_device_mapping[aliased_key])}}
+            elsif instance_state_key = filter_key.split('instance-state-')[1]
+              aliased_key = instance_state_aliases[instance_state_key]
+              instance_set = instance_set.reject{|instance| ![*filter_value].include?(instance['instanceState'][aliased_key])}
+            elsif state_reason_key = filter_key.split('state-reason-')[1]
+              aliased_key = state_reason_aliases[state_reason_key]
+              instance_set = instance_set.reject{|instance| ![*filter_value].include?(instance['stateReason'][aliased_key])}
+            else
+              aliased_key = aliases[filter_key]
+              instance_set = instance_set.reject {|instance| ![*filter_value].include?(instance[aliased_key])}
+            end
+          end
+
+          response.status = 200
+          reservation_set = {}
+
+          instance_set.each do |instance|
+            case instance['instanceState']['name']
+            when 'pending'
+              if Time.now - instance['launchTime'] > Fog::Mock.delay
+                instance['ipAddress']         = Fog::AWS::Mock.ip_address
+                instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+                instance['privateIpAddress']  = Fog::AWS::Mock.ip_address
+                instance['privateDnsName']    = Fog::AWS::Mock.private_dns_name_for(instance['privateIpAddress'])
+                instance['instanceState']     = { 'code' => 16, 'name' => 'running' }
+              end
+            when 'rebooting'
+              instance['instanceState'] = { 'code' => 16, 'name' => 'running' }
+            when 'shutting-down'
+              if Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay * 2
+                @data[:deleted_at].delete(instance['instanceId'])
+                @data[:instances].delete(instance['instanceId'])
+              elsif Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay
+                instance['instanceState'] = { 'code' => 48, 'name' => 'terminating' }
+              end
+            when 'terminating'
+              if Time.now - @data[:deleted_at][instance['instanceId']] > Fog::Mock.delay
+                @data[:deleted_at].delete(instance['instanceId'])
+                @data[:instances].delete(instance['instanceId'])
+              end
+            end
+
+            if @data[:instances][instance['instanceId']]
+
+              reservation_set[instance['reservationId']] ||= {
+                'groupSet'      => instance['groupSet'],
+                'instancesSet'  => [],
+                'ownerId'       => instance['ownerId'],
+                'reservationId' => instance['reservationId']
+              }
+              reservation_set[instance['reservationId']]['instancesSet'] << instance.reject{|key,value| !['amiLaunchIndex', 'architecture', 'blockDeviceMapping', 'clientToken', 'dnsName', 'imageId', 'instanceId', 'instanceState', 'instanceType', 'ipAddress', 'kernelId', 'keyName', 'launchTime', 'monitoring', 'placement', 'privateDnsName', 'privateIpAddress', 'productCodes', 'ramdiskId', 'reason', 'rootDeviceType', 'stateReason', 'tagSet'].include?(key)}
+            end
+          end
+
+          response.body = {
+            'requestId'       => Fog::AWS::Mock.request_id,
+            'reservationSet' => reservation_set.values
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_key_pairs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_key_pairs.rb
new file mode 100644
index 0000000..a462ca7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_key_pairs.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_key_pairs'
+
+        # Describe all or specified key pairs
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'keySet'<~Array>:
+        #       * 'keyName'<~String> - Name of key
+        #       * 'keyFingerprint'<~String> - Fingerprint of key
+        def describe_key_pairs(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_key_pairs with #{filters.class} param is deprecated, use describe_key_pairs('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeKeyPairs',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeKeyPairs.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_key_pairs(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_key_pairs with #{filters.class} param is deprecated, use describe_key_pairs('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          key_set = @data[:key_pairs].values
+
+          aliases = {'fingerprint' => 'keyFingerprint', 'key-name' => 'keyName'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            key_set = key_set.reject{|key_pair| ![*filter_value].include?(key_pair[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'keySet'    => key_set.map do |key_pair|
+              key_pair.reject {|key,value| !['keyFingerprint', 'keyName'].include?(key)}
+            end
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_regions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_regions.rb
new file mode 100644
index 0000000..b096313
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_regions.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_regions'
+
+        # Describe all or specified regions
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'regionInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'regionEndpoint'<~String> - Service endpoint for region
+        def describe_regions(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_regions with #{filters.class} param is deprecated, use describe_regions('region-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'region-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeRegions',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeRegions.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_regions(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_regions with #{filters.class} param is deprecated, use describe_regions('region-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'region-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+          region_info = [
+            {"regionName"=>"eu-west-1", "regionEndpoint"=>"eu-west-1.ec2.amazonaws.com"},
+            {"regionName"=>"us-east-1", "regionEndpoint"=>"us-east-1.ec2.amazonaws.com"}
+          ]
+
+          aliases = {'region-name' => 'regionName', 'endpoint' => 'regionEndpoint'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            region_info = region_info.reject{|region| ![*filter_value].include?(region[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'   => Fog::AWS::Mock.request_id,
+            'regionInfo'  => region_info
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_reserved_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_reserved_instances.rb
new file mode 100644
index 0000000..0fdd04a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_reserved_instances.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_reserved_instances'
+
+        # Describe all or specified reserved instances
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservedInstancesSet'<~Array>:
+        #       * 'availabilityZone'<~String> - availability zone of the instance
+        #       * 'duration'<~Integer> - duration of reservation, in seconds
+        #       * 'fixedPrice'<~Float> - purchase price of reserved instance
+        #       * 'instanceType'<~String> - type of instance
+        #       * 'instanceCount'<~Integer> - number of reserved instances
+        #       * 'productDescription'<~String> - reserved instance description
+        #       * 'reservedInstancesId'<~String> - id of the instance
+        #       * 'start'<~Time> - start time for reservation
+        #       * 'state'<~String> - state of reserved instance purchase, in .[pending-payment, active, payment-failed, retired]
+        #       * 'usagePrice"<~Float> - usage price of reserved instances, per hour
+        def describe_reserved_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_reserved_instances with #{filters.class} param is deprecated, use describe_reserved_instances('reserved-instances-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'reserved-instances-id' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeReservedInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeReservedInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_reserved_instances(filters = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_security_groups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_security_groups.rb
new file mode 100644
index 0000000..977951b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_security_groups.rb
@@ -0,0 +1,95 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_security_groups'
+
+        # Describe all or specified security groups
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'securityGroupInfo'<~Array>:
+        #       * 'groupDescription'<~String> - Description of security group
+        #       * 'groupName'<~String> - Name of security group
+        #       * 'ipPermissions'<~Array>:
+        #         * 'fromPort'<~Integer> - Start of port range (or -1 for ICMP wildcard)
+        #         * 'groups'<~Array>:
+        #           * 'groupName'<~String> - Name of security group
+        #           * 'userId'<~String> - AWS User Id of account
+        #         * 'ipProtocol'<~String> - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #         * 'ipRanges'<~Array>:
+        #           * 'cidrIp'<~String> - CIDR range
+        #         * 'toPort'<~Integer> - End of port range (or -1 for ICMP wildcard)
+        #       * 'ownerId'<~String> - AWS Access Key Id of the owner of the security group
+        def describe_security_groups(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_security_groups with #{filters.class} param is deprecated, use describe_security_groups('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeSecurityGroups',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSecurityGroups.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_security_groups(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_security_groups with #{filters.class} param is deprecated, use describe_security_groups('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          security_group_info = @data[:security_groups].values
+
+          aliases = {
+            'description' => 'groupDescription',
+            'group-name'  => 'groupName',
+            'owner-id'    => 'ownerId'
+          }
+          permission_aliases = {
+            'cidr'      => 'cidrIp',
+            'from-port' => 'fromPort',
+            'protocol'  => 'ipProtocol',
+            'to-port'   => 'toPort'
+          }
+          for filter_key, filter_value in filters
+            if permission_key = filter_key.split('ip-permission.')[1]
+              if permission_key == 'group-name'
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions']['groups'].detect {|group| [*filter_value].include?(group['groupName'])}}
+              elsif permission_key == 'user-id'
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions']['groups'].detect {|group| [*filter_value].include?(group['userId'])}}
+              else
+                aliased_key = permission_aliases[filter_key]
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions'].detect {|permission| [*filter_value].include?(permission[aliased_key])}}
+              end
+            else
+              aliased_key = aliases[filter_key]
+              security_group_info = security_group_info.reject{|security_group| ![*filter_value].include?(security_group[aliased_key])}
+            end
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'         => Fog::AWS::Mock.request_id,
+            'securityGroupInfo' => security_group_info
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_snapshots.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_snapshots.rb
new file mode 100644
index 0000000..37789b9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_snapshots.rb
@@ -0,0 +1,120 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_snapshots'
+
+        # Describe all or specified snapshots
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        # * options<~Hash>:
+        #   * 'Owner'<~String> - Owner of snapshot in ['self', 'amazon', account_id]
+        #   * 'RestorableBy'<~String> - Account id of user who can create volumes from this snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'snapshotSet'<~Array>:
+        #       * 'progress'<~String>: The percentage progress of the snapshot
+        #       * 'snapshotId'<~String>: Id of the snapshot
+        #       * 'startTime'<~Time>: Timestamp of when snapshot was initiated
+        #       * 'status'<~String>: Snapshot state, in ['pending', 'completed']
+        #       * 'volumeId'<~String>: Id of volume that snapshot contains
+        def describe_snapshots(filters = {}, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_snapshots with #{filters.class} param is deprecated, use describe_snapshots('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          unless options.empty?
+            Formatador.display_line("[yellow][WARN] describe_snapshots with a second param is deprecated, use describe_snapshots(options) instead[/] [light_black](#{caller.first})[/]")
+          end
+
+          for key in ['ExecutableBy', 'ImageId', 'Owner', 'RestorableBy']
+            if filters.has_key?(key)
+              options[key] = filters.delete(key)
+            end
+          end
+          options['RestorableBy'] ||= 'self'
+          params = AWS.indexed_filters(filters).merge!(options)
+          request({
+            'Action'    => 'DescribeSnapshots',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSnapshots.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_snapshots(filters = {}, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_snapshots with #{filters.class} param is deprecated, use describe_snapshots('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          unless options.empty?
+            Formatador.display_line("[yellow][WARN] describe_snapshots with a second param is deprecated, use describe_snapshots(options) instead[/] [light_black](#{caller.first})[/]")
+          end
+
+          if filters.keys.any? {|key| key =~ /^tag/}
+            Formatador.display_line("[yellow][WARN] describe_snapshots tag filters are not yet mocked[/] [light_black](#{caller.first})[/]")
+            Fog::Mock.not_implemented
+          end
+
+          response = Excon::Response.new
+
+          snapshot_set = @data[:snapshots].values
+
+          if filters.delete('owner-alias')
+            Formatador.display_line("[yellow][WARN] describe_snapshots with owner-alias is not mocked[/] [light_black](#{caller.first})[/]")
+          end
+          if filters.delete('RestorableBy')
+            Formatador.display_line("[yellow][WARN] describe_snapshots with RestorableBy is not mocked[/] [light_black](#{caller.first})[/]")
+          end
+
+          aliases = {
+            'description' => 'description',
+            'owner-id'    => 'ownerId',
+            'progress'    => 'progress',
+            'snapshot-id' => 'snapshotId',
+            'start-time'  => 'startTime',
+            'status'      => 'status',
+            'volume-id'   => 'volumeId',
+            'volume-size' => 'volumeSize'
+          }
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            snapshot_set = snapshot_set.reject{|snapshot| ![*filter_value].include?(snapshot[aliased_key])}
+          end
+
+          snapshot_set.each do |snapshot|
+            case snapshot['status']
+            when 'in progress', 'pending'
+              if Time.now - snapshot['startTime'] > Fog::Mock.delay * 2
+                snapshot['progress']  = '100%'
+                snapshot['status']    = 'completed'
+              elsif Time.now - snapshot['startTime'] > Fog::Mock.delay
+                snapshot['progress']  = '50%'
+                snapshot['status']    = 'in progress'
+              else
+                snapshot['progress']  = '0%'
+                snapshot['status']    = 'in progress'
+              end
+            end
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'snapshotSet' => snapshot_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_tags.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_tags.rb
new file mode 100644
index 0000000..cd41374
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_tags.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_tags'
+
+        # Describe all or specified tags
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'tagSet'<~Array>:
+        #       * 'resourceId'<~String> - id of resource tag belongs to
+        #       * 'resourceType'<~String> - type of resource tag belongs to
+        #       * 'key'<~String> - Tag's key
+        #       * 'value'<~String> - Tag's value
+        def describe_tags(filters = {})
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeTags',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeTags.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_tags(filters = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_volumes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_volumes.rb
new file mode 100644
index 0000000..a4b1639
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/describe_volumes.rb
@@ -0,0 +1,118 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/describe_volumes'
+
+        # Describe all or specified volumes.
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'volumeSet'<~Array>:
+        #       * 'availabilityZone'<~String> - Availability zone for volume
+        #       * 'createTime'<~Time> - Timestamp for creation
+        #       * 'size'<~Integer> - Size in GiBs for volume
+        #       * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #       * 'status'<~String> - State of volume
+        #       * 'volumeId'<~String> - Reference to volume
+        #       * 'attachmentSet'<~Array>:
+        #         * 'attachmentTime'<~Time> - Timestamp for attachment
+        #         * 'deleteOnTermination'<~Boolean> - Whether or not to delete volume on instance termination
+        #         * 'device'<~String> - How value is exposed to instance
+        #         * 'instanceId'<~String> - Reference to attached instance
+        #         * 'status'<~String> - Attachment state
+        #         * 'volumeId'<~String> - Reference to volume
+        def describe_volumes(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_volumes with #{filters.class} param is deprecated, use describe_volumes('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeVolumes',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeVolumes.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_volumes(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_volumes with #{filters.class} param is deprecated, use describe_volumes('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+
+          if filters.keys.any? {|key| key =~ /^tag/}
+            Formatador.display_line("[yellow][WARN] describe_volumes tag filters are not yet mocked[/] [light_black](#{caller.first})[/]")
+            Fog::Mock.not_implemented
+          end
+
+          response = Excon::Response.new
+
+          volume_set = @data[:volumes].values
+
+          aliases = {
+            'availability-zone' => 'availabilityZone',
+            'create-time' => 'createTime',
+            'size' => 'size',
+            'snapshot-id' => 'snapshotId',
+            'status' => 'status',
+            'volume-id' => 'volumeId'
+          }
+          attachment_aliases = {
+            'attach-time' => 'attachTime',
+            'delete-on-termination' => 'deleteOnTermination',
+            'device'      => 'device',
+            'instance-id' => 'instanceId',
+            'status'      => 'status'
+          }
+          for filter_key, filter_value in filters
+            if attachment_key = filter_key.split('attachment.')[1]
+              aliased_key = permission_aliases[filter_key]
+              volume_set = volume_set.reject{|volume| !volume['attachmentSet'].detect {|attachment| [*filter_value].include?(attachment[aliased_key])}}
+            else
+              aliased_key = aliases[filter_key]
+              volume_set = volume_set.reject{|volume| ![*filter_value].include?(volume[aliased_key])}
+            end
+          end
+
+          volume_set.each do |volume|
+            case volume['status']
+            when 'attaching'
+              if Time.now - volume['attachmentSet'].first['attachTime'] > Fog::Mock.delay
+                volume['attachmentSet'].first['status'] = 'in-use'
+                volume['status'] = 'in-use'
+              end
+            when 'creating'
+              if Time.now - volume['createTime'] > Fog::Mock.delay
+                volume['status'] = 'available'
+              end
+            when 'deleting'
+              if Time.now - @data[:deleted_at][volume['volumeId']] > Fog::Mock.delay
+                @data[:deleted_at].delete(volume['volumeId'])
+                @data[:volumes].delete(volume['volumeId'])
+              end
+            end
+          end
+          volume_set = volume_set.reject {|volume| !@data[:volumes][volume['volumeId']]}
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'volumeSet' => volume_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/detach_volume.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/detach_volume.rb
new file mode 100644
index 0000000..7f572da
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/detach_volume.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/detach_volume'
+
+        # Detach an Amazon EBS volume from a running instance
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * options<~Hash>:
+        #   * 'Device'<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #   * 'Force'<~Boolean> - If true forces detach, can cause data loss/corruption
+        #   * 'InstanceId'<~String> - Id of instance to associate volume with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        def detach_volume(volume_id, options = {})
+          request({
+            'Action'    => 'DetachVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DetachVolume.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def detach_volume(volume_id, options = {})
+          response = Excon::Response.new
+          response.status = 200
+          if (volume = @data[:volumes][volume_id]) && !volume['attachmentSet'].empty?
+            data = volume['attachmentSet'].pop
+            volume['status'] = 'available'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/disassociate_address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/disassociate_address.rb
new file mode 100644
index 0000000..db013b7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/disassociate_address.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Disassociate an elastic IP address from its instance (if any)
+        #
+        # ==== Parameters
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def disassociate_address(public_ip)
+          request(
+            'Action'    => 'DisassociateAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def disassociate_address(public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          if address = @data[:addresses][public_ip]
+            instance_id = address['instanceId']
+            instance = @data[:instances][instance_id]
+            instance['ipAddress']         = instance['originalIpAddress']
+            instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+            address['instanceId'] = nil
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/get_console_output.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/get_console_output.rb
new file mode 100644
index 0000000..f47fa7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/get_console_output.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/get_console_output'
+
+        # Retrieve console output for specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to get console output from
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'instanceId'<~String> - Id of instance
+        #     * 'output'<~String> - Console output
+        #     * 'requestId'<~String> - Id of request
+        #     * 'timestamp'<~Time> - Timestamp of last update to output
+        def get_console_output(instance_id)
+          request(
+            'Action'      => 'GetConsoleOutput',
+            'InstanceId'  => instance_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::GetConsoleOutput.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_console_output(instance_id)
+          response = Excon::Response.new
+          if instance = @data[:instances][instance_id]
+            response.status = 200
+            response.body = {
+              'instanceId'    => instance_id,
+              'output'        => nil,
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'timestamp'     => Time.now
+            }
+            response
+          else;
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/import_key_pair.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/import_key_pair.rb
new file mode 100644
index 0000000..1210a47
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/import_key_pair.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/import_key_pair'
+
+        # Import an existing public key to create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        # * public_key_material<~String> - RSA public key
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        def import_key_pair(key_name, public_key_material)
+          request(
+            'Action'  => 'ImportKeyPair',
+            'KeyName' => key_name,
+            'PublicKeyMaterial' => Base64::encode64(public_key_material),
+            :parser   => Fog::Parsers::AWS::Compute::ImportKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def import_key_pair(key_name, public_key_material)
+          response = Excon::Response.new
+          unless @data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyName'         => key_name
+            }
+            @data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_image_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_image_attributes.rb
new file mode 100644
index 0000000..97cf25d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_image_attributes.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Modify image attributes
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to modify
+        # * attribute<~String> - Attribute to modify, in ['launchPermission', 'productCodes']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        def modify_image_attributes(image_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          params.merge!(AWS.indexed_param('ProductCode', options['ProductCode']))
+          request({
+            'Action'        => 'ModifyImageAttribute',
+            'Attribute'     => attribute,
+            'ImageId'       => image_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def modify_image_attributes(image_id, attribute, operation_type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
new file mode 100644
index 0000000..24ac163
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/modify_snapshot_attribute.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Modify snapshot attributes
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - Id of snapshot to modify
+        # * attribute<~String> - Attribute to modify, in ['createVolumePermission']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        def modify_snapshot_attribute(snapshot_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          request({
+            'Action'        => 'ModifySnapshotAttribute',
+            'Attribute'     => attribute,
+            'SnapshotId'    => snapshot_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def modify_snapshot_attribute(snapshot_id, attribute, operation_type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/reboot_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/reboot_instances.rb
new file mode 100644
index 0000000..7c3f59a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/reboot_instances.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Reboot specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to reboot
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def reboot_instances(instance_id = [])
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'RebootInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def reboot_instances(instance_id = [])
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (@data[:instances].keys & instance_id).length == instance_id.length
+            for instance_id in instance_id
+              @data[:instances][instance_id]['status'] = 'rebooting'
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID #{instance_id.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/register_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/register_image.rb
new file mode 100644
index 0000000..4299680
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/register_image.rb
@@ -0,0 +1,89 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/register_image'
+
+        # register an image
+        #
+        # ==== Parameters
+        # * Name<~String> - Name of the AMI to be registered
+        # * Description<~String> - AMI description
+        # * Location<~String> - S3 manifest location (for S3 backed AMIs)
+        # or
+        # * RootDeviceName<~String> - Name of Root Device (for EBS snapshot backed AMIs)
+        # * BlockDevices<~Array>:
+        #   * BlockDeviceOptions<~Hash>:
+        #     * DeviceName<~String> - Name of the Block Device
+        #     * VirtualName<~String> - Name of the Virtual Device
+        #     * SnapshotId<~String> - id of the EBS Snapshot
+        #     * VolumeSize<~Integer> - Size of the snapshot (optional)
+        #     * NoDevice<~Boolean> - Do not use an ebs device (def: true)
+        #     * DeleteOnTermation<~Boolean> - Delete EBS volume on instance term (def: true)
+        # * Options<~Hash>:
+        #   * Architecture<~String> - i386 or x86_64
+        #   * KernelId<~String> - kernelId
+        #   * RamdiskId<~String> - ramdiskId
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - Id of newly created AMI
+
+        def register_image(name, description, location, block_devices=[], options={})
+          common_options = {
+            'Action'      => 'RegisterImage',
+            'Name'        => name,
+            'Description' => description,
+            :parser       => Fog::Parsers::AWS::Compute::RegisterImage.new
+          }
+
+          # This determines if we are doing a snapshot or a S3 backed AMI.
+          if(location =~ /^\/dev\/sd[a-p]\d{0,2}$/)
+            common_options['RootDeviceName'] = location
+          else
+            common_options['ImageLocation'] = location
+          end
+
+          bdi = 0
+          block_devices.each do |bd|
+            bdi += 1
+            ["DeviceName","VirtualName"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+            ["SnapshotId","VolumeSize","NoDevice","DeleteOnTermination"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.Ebs.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+
+          end
+
+          request(common_options.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def register_image(name, description, location, block_devices=[], options={})
+          response = Excon::Response.new
+          if !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if name.empty?
+              message << 'The request must contain the parameter name'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/release_address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/release_address.rb
new file mode 100644
index 0000000..38dc3de
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/release_address.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Release an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def release_address(public_ip)
+          request(
+            'Action'    => 'ReleaseAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def release_address(public_ip)
+          response = Excon::Response.new
+          if (address = @data[:addresses].delete(public_ip))
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
new file mode 100644
index 0000000..505c734
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/revoke_security_group_ingress.rb
@@ -0,0 +1,74 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        # Remove permissions from a security group
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'GroupName'<~String> - Name of group
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'GroupName' - Name of group to modify
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        def revoke_security_group_ingress(options = {})
+          request({
+            'Action'    => 'RevokeSecurityGroupIngress',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def revoke_security_group_ingress(options = {})
+          response = Excon::Response.new
+          group = @data[:security_groups][options['GroupName']]
+          if group
+            if options['GroupName'] && options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              group['ipPermissions'].delete_if {|permission|
+                permission['groups'].first['groupName'] == options['GroupName']
+              }
+            else
+              ingress = group['ipPermissions'].select {|permission|
+                permission['fromPort']    == options['FromPort'] &&
+                permission['ipProtocol']  == options['IpProtocol'] &&
+                permission['toPort']      == options['ToPort'] &&
+                (
+                  permission['ipRanges'].empty? ||
+                  (
+                    permission['ipRanges'].first &&
+                    permission['ipRanges'].first['cidrIp'] == options['CidrIp']
+                  )
+                )
+              }.first
+              group['ipPermissions'].delete(ingress)
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{options['GroupName']}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/run_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/run_instances.rb
new file mode 100644
index 0000000..e253cc8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/run_instances.rb
@@ -0,0 +1,167 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/run_instances'
+
+        # Launch specified instances
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to load on instances
+        # * min_count<~Integer> - Minimum number of instances to launch. If this
+        #   exceeds the count of available instances, no instances will be
+        #   launched.  Must be between 1 and maximum allowed for your account
+        #   (by default the maximum for an account is 20)
+        # * max_count<~Integer> - Maximum number of instances to launch. If this
+        #   exceeds the number of available instances, the largest possible
+        #   number of instances above min_count will be launched instead. Must
+        #   be between 1 and maximum allowed for you account
+        #   (by default the maximum for an account is 20)
+        # * options<~Hash>:
+        #   * 'Placement.AvailabilityZone'<~String> - Placement constraint for instances
+        #   * 'BlockDeviceMapping'<~Array>: array of hashes
+        #     * 'DeviceName'<~String> - where the volume will be exposed to instance
+        #     * 'VirtualName'<~String> - volume virtual device name
+        #     * 'Ebs.SnapshotId'<~String> - id of snapshot to boot volume from
+        #     * 'Ebs.VolumeSize'<~String> - size of volume in GiBs required unless snapshot is specified
+        #     * 'Ebs.DeleteOnTermination'<~String> - specifies whether or not to delete the volume on instance termination
+        #   * 'ClientToken'<~String> - unique case-sensitive token for ensuring idempotency
+        #   * 'SecurityGroup'<~Array> or <~String> - Name of security group(s) for instances (you must omit this parameter if using Virtual Private Clouds)
+        #   * 'InstanceInitiatedShutdownBehaviour'<~String> - specifies whether volumes are stopped or terminated when instance is shutdown, in [stop, terminate]
+        #   * 'InstanceType'<~String> - Type of instance to boot. Valid options
+        #     in ['m1.small', 'm1.large', 'm1.xlarge', 'c1.medium', 'c1.xlarge', 'm2.2xlarge', 'm2.4xlarge']
+        #     default is 'm1.small'
+        #   * 'KernelId'<~String> - Id of kernel with which to launch
+        #   * 'KeyName'<~String> - Name of a keypair to add to booting instances
+        #   * 'Monitoring.Enabled'<~Boolean> - Enables monitoring, defaults to
+        #     disabled
+        #   * 'RamdiskId'<~String> - Id of ramdisk with which to launch
+        #   * 'UserData'<~String> -  Additional data to provide to booting instances
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'groupSet'<~Array>: groups the instances are members in
+        #       * 'groupName'<~String> - Name of group
+        #     * 'instancesSet'<~Array>: returned instances
+        #       * instance<~Hash>:
+        #         * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #         * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #         * 'blockDeviceMapping'<~Array>
+        #           * 'attachTime'<~Time> - time of volume attachment
+        #           * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #           * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #           * 'status'<~String> - status of attached volume
+        #           * 'volumeId'<~String> - Id of attached volume
+        #         * 'dnsName'<~String> - public dns name, blank until instance is running
+        #         * 'imageId'<~String> - image id of ami used to launch instance
+        #         * 'instanceId'<~String> - id of the instance
+        #         * 'instanceState'<~Hash>:
+        #           * 'code'<~Integer> - current status code
+        #           * 'name'<~String> - current status name
+        #         * 'instanceType'<~String> - type of instance
+        #         * 'ipAddress'<~String> - public ip address assigned to instance
+        #         * 'kernelId'<~String> - Id of kernel used to launch instance
+        #         * 'keyName'<~String> - name of key used launch instances or blank
+        #         * 'launchTime'<~Time> - time instance was launched
+        #         * 'monitoring'<~Hash>:
+        #           * 'state'<~Boolean - state of monitoring
+        #         * 'placement'<~Hash>:
+        #           * 'availabilityZone'<~String> - Availability zone of the instance
+        #         * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #         * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #         * 'productCodes'<~Array> - Product codes for the instance
+        #         * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #         * 'reason'<~String> - reason for most recent state transition, or blank
+        #         * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #         * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #     * 'ownerId'<~String> - Id of owner
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationId'<~String> - Id of reservation
+        def run_instances(image_id, min_count, max_count, options = {})
+          if block_device_mapping = options.delete('BlockDeviceMapping')
+            block_device_mapping.each_with_index do |mapping, index|
+              for key, value in mapping
+                options.merge!({ format("BlockDeviceMapping.%d.#{key}", index) => value })
+              end
+            end
+          end
+          if security_groups = options.delete('SecurityGroup')
+            options.merge!(AWS.indexed_param('SecurityGroup', [*security_groups]))
+          end
+          if options['UserData']
+            options['UserData'] = Base64.encode64(options['UserData'])
+          end
+
+          idempotent = !(options['ClientToken'].nil? || options['ClientToken'].empty?)
+
+          request({
+            'Action'    => 'RunInstances',
+            'ImageId'   => image_id,
+            'MinCount'  => min_count,
+            'MaxCount'  => max_count,
+            :idempotent => idempotent,
+            :parser     => Fog::Parsers::AWS::Compute::RunInstances.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def run_instances(image_id, min_count, max_count, options = {})
+          response = Excon::Response.new
+          response.status = 200
+
+          group_set = [ (options['GroupId'] || 'default') ]
+          instances_set = []
+          reservation_id = Fog::AWS::Mock.reservation_id
+
+          min_count.times do |i|
+            instance_id = Fog::AWS::Mock.instance_id
+            instance = {
+              'amiLaunchIndex'      => i,
+              'blockDeviceMapping'  => [],
+              'clientToken'         => options['clientToken'],
+              'dnsName'             => nil,
+              'imageId'             => image_id,
+              'instanceId'          => instance_id,
+              'instanceState'       => { 'code' => 0, 'name' => 'pending' },
+              'instanceType'        => options['InstanceType'] || 'm1.small',
+              'kernelId'            => options['KernelId'] || Fog::AWS::Mock.kernel_id,
+              # 'keyName'             => options['KeyName'],
+              'launchTime'          => Time.now,
+              'monitoring'          => { 'state' => options['Monitoring.Enabled'] || false },
+              'placement'           => { 'availabilityZone' => options['Placement.AvailabilityZone'] || Fog::AWS::Mock.availability_zone },
+              'privateDnsName'      => nil,
+              'productCodes'        => [],
+              'ramdiskId'           => options['RamdiskId'] || Fog::AWS::Mock.ramdisk_id,
+              'reason'              => nil,
+              'rootDeviceType'      => 'instance-store'
+            }
+            instances_set << instance
+            @data[:instances][instance_id] = instance.merge({
+              'architecture'        => 'i386',
+              'groupSet'            => group_set,
+              'ownerId'             => @owner_id,
+              'privateIpAddress'    => nil,
+              'reservationId'       => reservation_id,
+              'stateReason'         => {},
+              'tagSet'              => {}
+            })
+          end
+          response.body = {
+            'groupSet'      => group_set,
+            'instancesSet'  => instances_set,
+            'ownerId'       => @owner_id,
+            'requestId'     => Fog::AWS::Mock.request_id,
+            'reservationId' => reservation_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/start_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/start_instances.rb
new file mode 100644
index 0000000..f6f21e9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/start_instances.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/start_stop_instances'
+
+        # Start specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        def start_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StartInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def start_instances(instance_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/stop_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/stop_instances.rb
new file mode 100644
index 0000000..eca2d05
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/stop_instances.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/start_stop_instances'
+
+        # Stop specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        def stop_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StopInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def stop_instances(instance_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/terminate_instances.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/terminate_instances.rb
new file mode 100644
index 0000000..7d4afab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/compute/terminate_instances.rb
@@ -0,0 +1,94 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/aws/parsers/compute/terminate_instances'
+
+        # Terminate specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to terminates
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'instancesSet'<~Array>:
+        #       * 'instanceId'<~String> - id of the terminated instance
+        #       * 'previousState'<~Hash>: previous state of instance
+        #         * 'code'<~Integer> - previous status code
+        #         * 'name'<~String> - name of previous state
+        #       * 'shutdownState'<~Hash>: shutdown state of instance
+        #         * 'code'<~Integer> - current status code
+        #         * 'name'<~String> - name of current state
+        def terminate_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'TerminateInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::TerminateInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def terminate_instances(instance_id)
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (@data[:instances].keys & instance_id).length == instance_id.length
+            response.body = {
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'instancesSet'  => []
+            }
+            response.status = 200
+            for id in instance_id
+              instance = @data[:instances][id]
+              @data[:deleted_at][id] = Time.now
+              code = case instance['instanceState']['name']
+              when 'pending'
+                0
+              when 'running'
+                16
+              when 'shutting-down'
+                32
+              when 'terminated'
+                48
+              when 'stopping'
+                64
+              when 'stopped'
+                80
+              end
+              state = { 'name' => 'shutting-down', 'code' => 32}
+              response.body['instancesSet'] << {
+                'instanceId'    => id,
+                'previousState' => instance['instanceState'],
+                'currentState'  => state
+              }
+              instance['instanceState'] = state
+            end
+
+            describe_addresses.body['addressesSet'].each do |address|
+              if instance_id.include?(address['instanceId'])
+                disassociate_address(address['publicIp'])
+              end
+            end
+
+            describe_volumes.body['volumeSet'].each do |volume|
+              if volume['attachmentSet'].first && instance_id.include?(volume['attachmentSet'].first['instanceId'])
+                detach_volume(volume['volumeId'])
+              end
+            end
+
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/change_resource_record_sets.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/change_resource_record_sets.rb
new file mode 100644
index 0000000..e812b68
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/change_resource_record_sets.rb
@@ -0,0 +1,90 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/change_resource_record_sets'
+
+        # Use this action to create or change your authoritative DNS information for a zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - ID of the zone these changes apply to
+        # * options<~Hash>
+        #   * comment<~String> - Any comments you want to include about the change.
+        #   * change_batch<~Array> - The information for a change request
+        #     * changes<~Hash> -
+        #       * action<~String> -  'CREATE' or 'DELETE'
+        #       * name<~String> - This must be a fully-specified name, ending with a final period
+        #       * type<~String> - A | AAAA | CNAME | MX | NS | PTR | SOA | SPF | SRV | TXT 
+        #       * ttl<~Integer> - 
+        #       * resource_record<~String>
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ChangeInfo'<~Hash>
+        #       * 'Id'<~String> - The ID of the request
+        #       * 'Status'<~String> - status of the request - PENDING | INSYNC
+        #       * 'SubmittedAt'<~String> - The date and time the change was made
+        #   * status<~Integer> - 201 when successful
+        def change_resource_record_sets(zone_id, change_batch, options = {})
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          optional_tags = ''
+          options.each { |option, value|
+            case option
+            when :comment
+              optional_tags+= "<Comment>#{value}</Comment>"
+            end
+          }
+          
+          #build XML
+          if change_batch.count > 0
+            
+            changes= "<ChangeBatch>#{optional_tags}<Changes>"
+            
+            change_batch.each { |change_item|
+              action_tag = %Q{<Action>#{change_item[:action]}</Action>}
+              name_tag = %Q{<Name>#{change_item[:name]}</Name>}
+              type_tag = %Q{<Type>#{change_item[:type]}</Type>}
+              ttl_tag = %Q{<TTL>#{change_item[:ttl]}</TTL>}
+              resource_records= change_item[:resource_records]
+              resource_record_tags = ''
+              resource_records.each { |record|
+                resource_record_tags+= %Q{<ResourceRecord><Value>#{record}</Value></ResourceRecord>}
+              }
+              resource_tag=  %Q{<ResourceRecords>#{resource_record_tags}</ResourceRecords>}
+              
+              change_tags = %Q{<Change>#{action_tag}<ResourceRecordSet>#{name_tag}#{type_tag}#{ttl_tag}#{resource_tag}</ResourceRecordSet></Change>}
+              changes+= change_tags
+            }          
+            
+            changes+= '</Changes></ChangeBatch>'
+          end
+
+          body =   %Q{<?xml version="1.0" encoding="UTF-8"?><ChangeResourceRecordSetsRequest xmlns="https://route53.amazonaws.com/doc/2010-10-01/">#{changes}</ChangeResourceRecordSetsRequest>}
+          request({
+            :body       => body,
+            :parser     => Fog::Parsers::AWS::DNS::ChangeResourceRecordSets.new,
+            :expects    => 200,
+            :method     => 'POST',
+            :path       => "hostedzone/#{zone_id}/rrset"
+          })
+
+        end
+
+      end
+
+      class Mock
+
+        def change_resource_record_sets(zone_id, change_batch, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/create_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/create_hosted_zone.rb
new file mode 100644
index 0000000..70ce950
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/create_hosted_zone.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/create_hosted_zone'
+
+        # Creates a new hosted zone
+        #
+        # ==== Parameters
+        # * name<~String> - The name of the domain. Must be a fully-specified domain that ends with a period
+        # * options<~Hash>
+        #   * caller_ref<~String> - unique string that identifies the request & allows failed 
+        #                           calls to be retried without the risk of executing the operation twice
+        #   * comment<~Integer> - 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZone'<~Hash>:
+        #       * 'Id'<~String> - 
+        #       * 'Name'<~String> - 
+        #       * 'CallerReference'<~String>
+        #       * 'Comment'<~String> - 
+        #     * 'ChangeInfo'<~Hash> -
+        #       * 'Id'<~String>
+        #       * 'Status'<~String>
+        #       * 'SubmittedAt'<~String>
+        #     * 'NameServers'<~Array>
+        #       * 'NameServer'<~String>
+        #   * status<~Integer> - 201 when successful
+        def create_hosted_zone(name, options = {})
+
+          optional_tags = ''
+          if options[:caller_ref]
+              optional_tags+= "<CallerReference>#{options[:call_ref]}</CallerReference>"
+          else
+            #make sure we have a unique call reference
+            caller_ref = "ref-#{rand(1000000).to_s}"
+            optional_tags+= "<CallerReference>#{caller_ref}</CallerReference>"            
+          end
+          if options[:comment]
+              optional_tags+= "<HostedZoneConfig><Comment>#{options[:comment]}</Comment></HostedZoneConfig>"
+          end
+            
+          request({
+            :body       => %Q{<?xml version="1.0" encoding="UTF-8"?><CreateHostedZoneRequest xmlns="https://route53.amazonaws.com/doc/2010-10-01/"><Name>#{name}</Name>#{optional_tags}</CreateHostedZoneRequest>},
+            :parser     => Fog::Parsers::AWS::DNS::CreateHostedZone.new,
+            :expects    => 201,
+            :method     => 'POST',
+            :path       => "hostedzone"
+          })
+
+        end
+
+      end
+
+      class Mock
+
+        def create_hosted_zone(name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/delete_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/delete_hosted_zone.rb
new file mode 100644
index 0000000..69b0431
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/delete_hosted_zone.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/delete_hosted_zone'
+
+        # Delete a hosted zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ChangeInfo'<~Hash> -
+        #       * 'Id'<~String> The ID of the request
+        #       * 'Status'<~String> The current state of the hosted zone
+        #       * 'SubmittedAt'<~String> The date and time the change was made
+        #   * status<~Integer> - 200 when successful
+        def delete_hosted_zone(zone_id)
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+          
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::DeleteHostedZone.new,
+            :method     => 'DELETE',
+            :path       => "hostedzone/#{zone_id}"
+          })
+
+        end
+
+      end
+
+
+      class Mock
+
+        def delete_hosted_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_change.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_change.rb
new file mode 100644
index 0000000..3da2b15
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_change.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/get_change'
+
+        # returns the current state of a change request
+        #
+        # ==== Parameters
+        # * change_id<~String>
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Id'<~String>
+        #     * 'Status'<~String>
+        #     * 'SubmittedAt'<~String>
+        #   * status<~Integer> - 200 when successful
+        def get_change(change_id)
+
+          # AWS methods return change_ids that looks like '/change/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          change_id = change_id.sub('/change/', '')
+
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::GetChange.new,
+            :method     => 'GET',
+            :path       => "change/#{change_id}"
+          })
+
+        end
+
+      end
+
+
+      class Mock
+
+        def get_change(change_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_hosted_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_hosted_zone.rb
new file mode 100644
index 0000000..0703327
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/get_hosted_zone.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/get_hosted_zone'
+
+        # retrieve information about a hosted zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - The ID of the hosted zone
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZone'<~Hash>:
+        #       * 'Id'<~String> - 
+        #       * 'Name'<~String> - 
+        #       * 'CallerReference'<~String>
+        #       * 'Comment'<~String> - 
+        #     * 'NameServers'<~Array>
+        #       * 'NameServer'<~String>
+        #   * status<~Integer> - 201 when successful
+        def get_hosted_zone(zone_id)
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::GetHostedZone.new,
+            :method     => 'GET',
+            :path       => "hostedzone/#{zone_id}"
+          })
+
+        end
+
+      end
+
+      class Mock
+
+        def get_hosted_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_hosted_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_hosted_zones.rb
new file mode 100644
index 0000000..06760bf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_hosted_zones.rb
@@ -0,0 +1,63 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/list_hosted_zones'
+
+        # Describe all or specified instances
+        #
+        # ==== Parameters
+        # * options<~Hash>
+        #   * marker<~String> - Indicates where to begin in your list of hosted zones. 
+        #   * max_items<~Integer> - The maximum number of hosted zones to be included in the response body
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZones'<~Array>:
+        #       * 'HostedZone'<~Hash>:
+        #         * 'Id'<~String> - 
+        #         * 'Name'<~String> - 
+        #         * 'CallerReference'<~String>
+        #         * 'Comment'<~String> - 
+        #     * 'Marker'<~String> - 
+        #     * 'MaxItems'<~Integer> - 
+        #     * 'IsTruncated'<~String> - 
+        #     * 'NextMarket'<~String>
+        #   * status<~Integer> - 200 when successful
+        def list_hosted_zones(options = {})
+
+          parameters = {}
+          options.each { |option, value|
+            case option
+            when :marker
+              parameters[option] = value
+            when :max_items
+              parameters[:maxitems] = value
+            end
+          }
+          
+          request({
+            :query      => parameters,
+            :parser     => Fog::Parsers::AWS::DNS::ListHostedZones.new,
+            :expects    => 200,
+            :method     => 'GET',
+            :path       => "hostedzone"
+          })
+
+        end
+
+      end
+
+
+      class Mock
+
+        def list_hosted_zones(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_resource_record_sets.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_resource_record_sets.rb
new file mode 100644
index 0000000..9f795f1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/dns/list_resource_record_sets.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/aws/parsers/dns/list_resource_record_sets'
+
+        # list your resource record sets
+        #
+        # ==== Parameters
+        # * zone_id<~String> - 
+        # * options<~Hash>
+        #   * type<~String> - 
+        #   * name<~String> -
+        #   * max_items<~Integer> - 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResourceRecordSet'<~Array>:
+        #       * 'Name'<~String> - 
+        #       * 'Type'<~String> - 
+        #       * 'TTL'<~Integer> - 
+        #       * 'ResourceRecords'<~Array>
+        #         * 'Value'<~String> - 
+        #     * 'IsTruncated'<~String> - 
+        #     * 'MaxItems'<~String> - 
+        #     * 'NextRecordName'<~String>
+        #     * 'NexRecordType'<~String>
+        #   * status<~Integer> - 201 when successful
+        def list_resource_record_sets(zone_id, options = {})
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          parameters = {}
+          options.each { |option, value|
+            case option
+            when :type, :name
+              parameters[option]= "#{value}"
+            when :max_items
+              parameters['maxitems']= "#{value}"
+            end
+          }
+          
+          request({
+            :query => parameters,
+            :parser     => Fog::Parsers::AWS::DNS::ListResourceRecordSets.new,
+            :expects    => 200,
+            :method     => 'GET',
+            :path       => "hostedzone/#{zone_id}/rrset"
+          })
+
+        end
+
+      end
+
+      class Mock
+
+        def list_resource_record_sets(zone_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/create_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/create_load_balancer.rb
new file mode 100644
index 0000000..6b80113
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/create_load_balancer.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/create_load_balancer'
+
+        # Create a new Elastic Load Balancer
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones for the ELB
+        # * lb_name<~String> - Name for the new ELB -- must be unique
+        # * listeners<~Array> - Array of Hashes describing ELB listeners to assign to the ELB
+        #   * 'Protocol'<~String> - Protocol to use. Either HTTP or TCP.
+        #   * 'LoadBalancerPort'<~Integer> - The port that the ELB will listen to for outside traffic
+        #   * 'InstancePort'<~Integer> - The port on the instance that the ELB will forward traffic to
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'CreateLoadBalancerResult'<~Hash>:
+        #       * 'DNSName'<~String> - DNS name for the newly created ELB
+        def create_load_balancer(availability_zones, lb_name, listeners)
+          params = ELB.indexed_param('AvailabilityZones.member', [*availability_zones])
+
+          listener_protocol = []
+          listener_lb_port = []
+          listener_instance_port = []
+          listeners.each do |listener|
+            listener_protocol.push(listener['Protocol'])
+            listener_lb_port.push(listener['LoadBalancerPort'])
+            listener_instance_port.push(listener['InstancePort'])
+          end
+
+          params.merge!(AWS.indexed_param('Listeners.member.%d.Protocol', listener_protocol))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.LoadBalancerPort', listener_lb_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.InstancePort', listener_instance_port))
+
+          request({
+            'Action'           => 'CreateLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::CreateLoadBalancer.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def create_load_balancer(availability_zones, lb_name, listeners)
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/delete_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..b4ca1f7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/delete_load_balancer.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/delete_load_balancer'
+
+        # Delete an existing Elastic Load Balancer
+        #
+        # Note that this API call, as defined by Amazon, is idempotent.
+        # That is, it will not return an error if you try to delete an
+        # ELB that does not exist.
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB to be deleted
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DeleteLoadBalancerResponse'<~nil>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_load_balancer(lb_name)
+          request({
+            'Action'           => 'DeleteLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeleteLoadBalancer.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_load_balancer(lb_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..56f08b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/deregister_instances_from_load_balancer'
+
+        # Deregister an instance from an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to remove from ELB
+        # * lb_name<~String> - Load balancer to remove instances from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DeregisterInstancesFromLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DeregisterInstancesFromLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeregisterInstancesFromLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+      class Mock
+
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_instance_health.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_instance_health.rb
new file mode 100644
index 0000000..01dbf0b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_instance_health.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_instance_health'
+
+        # Get health status for one or more instances on an existing ELB
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Load balancer to check instances health on
+        # * instance_ids<~Array> - Optional list of instance IDs to check
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeInstanceHealthResult'<~Hash>:
+        #       * 'InstanceStates'<~Array> - array of hashes describing instance health
+        #         * 'Description'<~String>
+        #         * 'State'<~String>
+        #         * 'InstanceId'<~String>
+        #         * 'ReasonCode'<~String>
+        def describe_instance_health(lb_name, instance_ids = [])
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DescribeInstanceHealth',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DescribeInstanceHealth.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_instance_health(lb_name, instance_ids = [])
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_load_balancers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..1524926
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/describe_load_balancers.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_load_balancers'
+
+        # Describe all or specified load balancers
+        #
+        # ==== Parameters
+        # * lb_name<~Array> - List of load balancer names to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeLoadBalancersResult'<~Hash>:
+        #       * 'LoadBalancerDescriptions'<~Array>
+        #         * 'LoadBalancerName'<~String> - name of load balancer
+        #         * 'DNSName'<~String> - external DNS name of load balancer
+        #         * 'CreatedTime'<~Time> - time load balancer was created
+        #         * 'ListenerDescriptions'<~Array>
+        #           * 'PolicyNames'<~Array> - list of policies enabled
+        #           * 'Listener'<~Hash>:
+        #             * 'InstancePort'<~Integer> - port on instance that requests are sent to
+        #             * 'Protocol'<~String> - transport protocol used for routing in [TCP, HTTP]
+        #             * 'LoadBalancerPort'<~Integer> - port that load balancer listens on for requests
+        #         * 'HealthCheck'<~Hash>:
+        #           * 'HealthyThreshold'<~Integer> - number of consecutive health probe successes required before moving the instance to the Healthy state
+        #           * 'Timeout'<~Integer> - number of seconds after which no response means a failed health probe
+        #           * 'Interval'<~Integer> - interval (in seconds) between health checks of an individual instance
+        #           * 'UnhealthyThreshold'<~Integer> - number of consecutive health probe failures that move the instance to the unhealthy state
+        #           * 'Target'<~String> - string describing protocol type, port and URL to check
+        #         * 'Policies'<~Hash>:
+        #           * 'LBCookieStickinessPolicies'<~Array> - list of Load Balancer Generated Cookie Stickiness policies for the LoadBalancer
+        #           * 'AppCookieStickinessPolicies'<~Array> - list of Application Generated Cookie Stickiness policies for the LoadBalancer
+        #         * 'AvailabilityZones'<~Array> - list of availability zones covered by this load balancer
+        #         * 'Instances'<~Array> - list of instances that the load balancer balances between
+        def describe_load_balancers(lb_name = [])
+          params = AWS.indexed_param('LoadBalancerNames.member', [*lb_name])
+          request({
+            'Action'  => 'DescribeLoadBalancers',
+            :parser   => Fog::Parsers::AWS::ELB::DescribeLoadBalancers.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_load_balancers(lb_name = [])
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..ab1e872
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/disable_availability_zones_for_load_balancer'
+
+        # Disable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to disable on ELB
+        # * lb_name<~String> - Load balancer to disable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DisableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones])
+          request({
+            'Action'           => 'DisableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DisableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..5711d03
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/enable_availability_zones_for_load_balancer'
+
+        # Enable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to enable on ELB
+        # * lb_name<~String> - Load balancer to enable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'EnableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones])
+          request({
+            'Action'           => 'EnableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::EnableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..9d4445d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/register_instances_with_load_balancer'
+
+        # Register an instance with an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to associate with ELB
+        # * lb_name<~String> - Load balancer to assign instances to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'RegisterInstancesWithLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'RegisterInstancesWithLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::RegisterInstancesWithLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+      class Mock
+
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/add_user_to_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/add_user_to_group.rb
new file mode 100644
index 0000000..7214ec2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/add_user_to_group.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add a user to a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * user_name<~String>: name of user to add
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_AddUserToGroup.html
+        #
+        def add_user_to_group(group_name, user_name)
+          request(
+            'Action'    => 'AddUserToGroup',
+            'GroupName' => group_name,
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def add_user_to_group(group_name, user_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_access_key.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_access_key.rb
new file mode 100644
index 0000000..cc4ad30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_access_key.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_access_key'
+
+        # Create a access keys for user (by default detects user from access credentials)
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessKey'<~Hash>:
+        #       * 'AccessKeyId'<~String> -
+        #       * 'Username'<~String> -
+        #       * 'SecretAccessKey'<~String> -
+        #       * 'Status'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateAccessKey.html
+        #
+        def create_access_key(options = {})
+          request({
+            'Action'    => 'CreateAccessKey',
+            :parser     => Fog::Parsers::AWS::IAM::CreateAccessKey.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def create_access_key(user_name = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_group.rb
new file mode 100644
index 0000000..e1cb28b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_group.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_group'
+
+        # Create a new group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group to create (do not include path)
+        # * path<~String>: optional path to group, defaults to '/'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Group'<~Hash>:
+        #       * Arn<~String> -
+        #       * GroupId<~String> -
+        #       * GroupName<~String> -
+        #       * Path<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateGroup.html
+        #
+        def create_group(group_name, path = '/')
+          request(
+            'Action'    => 'CreateGroup',
+            'GroupName' => group_name,
+            'Path'      => path,
+            :parser     => Fog::Parsers::AWS::IAM::CreateGroup.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_group(group_name, path = '/')
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_user.rb
new file mode 100644
index 0000000..099171c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/create_user.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_user'
+
+        # Create a new user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user to create (do not include path)
+        # * path<~String>: optional path to group, defaults to '/'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'User'<~Hash>:
+        #       * 'Arn'<~String> -
+        #       * 'Path'<~String> -
+        #       * 'UserId'<~String> -
+        #       * 'UserName'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateUser.html
+        #
+        def create_user(user_name, path = '/')
+          request(
+            'Action'    => 'CreateUser',
+            'UserName'  => user_name,
+            'Path'      => path,
+            :parser     => Fog::Parsers::AWS::IAM::CreateUser.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_user(user_name, path = '/')
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_access_key.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_access_key.rb
new file mode 100644
index 0000000..f7e7a2d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_access_key.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete an access key
+        # 
+        # ==== Parameters
+        # * access_key_id<~String> - Access key id to delete
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteAccessKey.html
+        #
+        def delete_access_key(access_key_id, options = {})
+          request({
+            'AccessKeyId' => access_key_id,
+            'Action'      => 'DeleteAccessKey',
+            :parser       => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def delete_access_key(access_key_id, user_name = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group.rb
new file mode 100644
index 0000000..71608b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteGroup.html
+        #
+        def delete_group(group_name)
+          request(
+            'Action'    => 'DeleteGroup',
+            'GroupName' => group_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_group(group_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group_policy.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group_policy.rb
new file mode 100644
index 0000000..ef5f534
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_group_policy.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a policy from a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * policy_name<~String>: name of policy document
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteGroupPolicy.html
+        #
+        def delete_group_policy(group_name, policy_name)
+          request(
+            'Action'          => 'DeleteGroupPolicy',
+            'GroupName'       => group_name,
+            'PolicyName'      => policy_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_group_policy(group_name, policy_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user.rb
new file mode 100644
index 0000000..57e1ef6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteUser.html
+        #
+        def delete_user(user_name)
+          request(
+            'Action'    => 'DeleteUser',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_user(user_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user_policy.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user_policy.rb
new file mode 100644
index 0000000..eb447b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/delete_user_policy.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a policy from a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user
+        # * policy_name<~String>: name of policy document
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteUserPolicy.html
+        #
+        def delete_user_policy(user_name, policy_name)
+          request(
+            'Action'          => 'DeleteUserPolicy',
+            'PolicyName'      => policy_name,
+            'UserName'        => user_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_user_policy(user_name, policy_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/get_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/get_user.rb
new file mode 100644
index 0000000..06a2df0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/get_user.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/get_user'
+
+        # Get User
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String>: Name of the User. Defaults to current user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'User'<~Hash> - User
+        #       * Arn<~String> -
+        #       * UserId<~String> -
+        #       * UserName<~String> -
+        #       * Path<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_Getuser.html
+        #
+        def get_user(options = {})
+          request({
+            'Action'  => 'GetUser',
+            :parser   => Fog::Parsers::AWS::IAM::GetUser.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def get_user(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_access_keys.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_access_keys.rb
new file mode 100644
index 0000000..ccf8fb0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_access_keys.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_access_keys'
+
+        # List access_keys
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String> - used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer> - limit results to this number per page
+        #   * 'UserName'<~String> - optional: username to lookup access keys for, defaults to current user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessKeys'<~Array> - Matching access keys
+        #       * access_key<~Hash>:
+        #         * AccessKeyId<~String> -
+        #         * Status<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListAccessKeys.html
+        #
+        def list_access_keys(options = {})
+          request({
+            'Action'  => 'ListAccessKeys',
+            :parser   => Fog::Parsers::AWS::IAM::ListAccessKeys.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_access_keys(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_group_policies.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_group_policies.rb
new file mode 100644
index 0000000..cd06643
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_group_policies.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_policies'
+
+        # List policies for a group
+        # 
+        # ==== Parameters
+        # * group_name<~String> - Name of group to list policies for
+        # * options<~Hash>: Optional
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PolicyNames'<~Array> - Matching policy names
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListGroupPolicies.html
+        #
+        def list_group_policies(group_name, options = {})
+          request({
+            'Action'    => 'ListGroupPolicies',
+            'GroupName' => group_name,
+            :parser     => Fog::Parsers::AWS::IAM::ListPolicies.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_group_policies(group_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_groups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_groups.rb
new file mode 100644
index 0000000..1500ce3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_groups.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_groups'
+
+        # List groups
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Groups'<~Array> - Matching groups
+        #       * group<~Hash>:
+        #         * Arn<~String> -
+        #         * GroupId<~String> -
+        #         * GroupName<~String> -
+        #         * Path<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListGroups.html
+        #
+        def list_groups(options = {})
+          request({
+            'Action'  => 'ListGroups',
+            :parser   => Fog::Parsers::AWS::IAM::ListGroups.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_groups(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_user_policies.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_user_policies.rb
new file mode 100644
index 0000000..e0b7528
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_user_policies.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_policies'
+
+        # List policies for a user
+        # 
+        # ==== Parameters
+        # * user_name<~String> - Name of user to list policies for
+        # * options<~Hash>: Optional
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PolicyNames'<~Array> - Matching policy names
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListUserPolicies.html
+        #
+        def list_user_policies(user_name, options = {})
+          request({
+            'Action'    => 'ListUserPolicies',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::ListPolicies.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_user_policies(user_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_users.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_users.rb
new file mode 100644
index 0000000..24dd7ea
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/list_users.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_users'
+
+        # List users
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Users'<~Array> - Matching groups
+        #       * user<~Hash>:
+        #         * Arn<~String> -
+        #         * Path<~String> -
+        #         * UserId<~String> -
+        #         * UserName<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListUsers.html
+        #
+        def list_users(options = {})
+          request({
+            'Action'  => 'ListUsers',
+            :parser   => Fog::Parsers::AWS::IAM::ListUsers.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_users(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_group_policy.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_group_policy.rb
new file mode 100644
index 0000000..c2abdd4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_group_policy.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add or update a policy for a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * policy_name<~String>: name of policy document
+        # * policy_document<~Hash>: policy document, see: http://docs.amazonwebservices.com/IAM/latest/UserGuide/PoliciesOverview.html
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_PutGroupPolicy.html
+        #
+        def put_group_policy(group_name, policy_name, policy_document)
+          request(
+            'Action'          => 'PutGroupPolicy',
+            'GroupName'       => group_name,
+            'PolicyName'      => policy_name,
+            'PolicyDocument'  => policy_document.to_json,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def put_group_policy(group_name, policy_name, policy_document)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_user_policy.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_user_policy.rb
new file mode 100644
index 0000000..c2d6ee3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/put_user_policy.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add or update a policy for a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user
+        # * policy_name<~String>: name of policy document
+        # * policy_document<~Hash>: policy document, see: http://docs.amazonwebservices.com/IAM/latest/UserGuide/PoliciesOverview.html
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_PutUserPolicy.html
+        #
+        def put_user_policy(user_name, policy_name, policy_document)
+          request(
+            'Action'          => 'PutUserPolicy',
+            'PolicyName'      => policy_name,
+            'PolicyDocument'  => policy_document.to_json,
+            'UserName'        => user_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def put_user_policy(user_name, policy_name, policy_document)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/remove_user_from_group.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/remove_user_from_group.rb
new file mode 100644
index 0000000..289db7e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/remove_user_from_group.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a user from a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * user_name<~String>: name of user to remove
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_RemoveUserFromGroup.html
+        #
+        def remove_user_from_group(group_name, user_name)
+          request(
+            'Action'    => 'RemoveUserFromGroup',
+            'GroupName' => group_name,
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def remove_user_from_group(group_name, user_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/update_access_key.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/update_access_key.rb
new file mode 100644
index 0000000..5e2d79d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/iam/update_access_key.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Update an access key for a user
+        # 
+        # ==== Parameters
+        # * access_key_id<~String> - Access key id to delete
+        # * status<~String> - status of keys in ['Active', 'Inactive']
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_UpdateAccessKey.html
+        #
+        def update_access_key(access_key_id, status, options = {})
+          request({
+            'AccessKeyId' => access_key_id,
+            'Action'      => 'UpdateAccessKey',
+            'Status'      => status,
+            :parser       => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def update_access_key(access_key_id, status, user_name = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/batch_put_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
new file mode 100644
index 0000000..ec4ebaa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put items attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * items<~Hash> - Keys are the items names and may use any UTF-8
+        #   characters valid in xml.  Control characters and sequences not allowed
+        #   in xml are not valid.  Can be up to 1024 bytes long.  Values are the
+        #   attributes to add to the given item and may use any UTF-8 characters
+        #   valid in xml. Control characters and sequences not allowed in xml are
+        #   not valid.  Each name and value can be up to 1024 bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          request({
+            'Action'      => 'BatchPutAttributes',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_batch_attributes(items, replace_attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            for item_name, attributes in items do
+              for key, value in attributes do
+                @data[:domains][domain_name][item_name] ||= {}
+                if replace_attributes[item_name] && replace_attributes[item_name].include?(key)
+                  @data[:domains][domain_name][item_name][key.to_s] = []
+                else
+                  @data[:domains][domain_name][item_name][key.to_s] ||= []
+                end
+                @data[:domains][domain_name][item_name][key.to_s] << value.to_s
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/create_domain.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/create_domain.rb
new file mode 100644
index 0000000..c4a2a2a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/create_domain.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Create a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def create_domain(domain_name)
+          request(
+            'Action'      => 'CreateDomain',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_domain(domain_name)
+          response = Excon::Response.new
+          @data[:domains][domain_name] = {}
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_attributes.rb
new file mode 100644
index 0000000..7fefed8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_attributes.rb
@@ -0,0 +1,63 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to remove from the item.  Defaults to
+        #   nil, which will delete the entire item. Attribute names and values may
+        #   use any UTF-8 characters valid in xml. Control characters and sequences
+        #   not allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          request({
+            'Action'      => 'DeleteAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_attributes(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            if attributes
+              for key, value in attributes
+                if @data[:domains][domain_name][key]
+                  @data[:domains][domain_name][key].delete('value')
+                end
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_domain.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_domain.rb
new file mode 100644
index 0000000..30df4d3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/delete_domain.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Delete a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_domain(domain_name)
+          request(
+            'Action'      => 'DeleteDomain',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_domain(domain_name)
+          response = Excon::Response.new
+          if @data[:domains].delete(domain_name)
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/domain_metadata.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..515f3a7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/domain_metadata.rb
@@ -0,0 +1,76 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/domain_metadata'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AttributeNameCount' - number of unique attribute names in domain
+        #     * 'AttributeNamesSizeBytes' - total size of unique attribute names, in bytes
+        #     * 'AttributeValueCount' - number of all name/value pairs in domain
+        #     * 'AttributeValuesSizeBytes' - total size of attributes, in bytes
+        #     * 'BoxUsage'
+        #     * 'ItemCount' - number of items in domain
+        #     * 'ItemNameSizeBytes' - total size of item names in domain, in bytes
+        #     * 'RequestId'
+        #     * 'Timestamp' - last update time for metadata.
+        def domain_metadata(domain_name)
+          request(
+            'Action'      => 'DomainMetadata',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::DomainMetadata.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_metadata(domain_name)
+          response = Excon::Response.new
+          if domain = @data[:domains][domain_name]
+            response.status = 200
+          
+            attribute_names = []
+            attribute_values = []
+            for item in domain.values
+              for key, values in item
+                attribute_names << key
+                for value in values
+                  attribute_values << value
+                end
+              end
+            end
+          
+            response.body = {
+              'AttributeNameCount'        => attribute_names.length,
+              'AttributeNamesSizeBytes'   => attribute_names.join('').length,
+              'AttributeValueCount'       => attribute_values.length,
+              'AttributeValuesSizeBytes'  => attribute_values.join('').length,
+              'BoxUsage'                  => Fog::AWS::Mock.box_usage,
+              'ItemCount'                 => domain.keys.length,
+              'ItemNamesSizeBytes'        => domain.keys.join('').length,
+              'RequestId'                 => Fog::AWS::Mock.request_id,
+              'Timestamp'                 => Time.now
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/get_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/get_attributes.rb
new file mode 100644
index 0000000..0ba081b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/get_attributes.rb
@@ -0,0 +1,72 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/get_attributes'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Array> - Attributes to return from the item.  Defaults to
+        #   {}, which will return all attributes. Attribute names and values may use
+        #   any UTF-8 characters valid in xml. Control characters and sequences not 
+        #   allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Attributes' - list of attribute name/values for the item
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def get_attributes(domain_name, item_name, attributes = {})
+          
+          request({
+            'Action'      => 'GetAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::GetAttributes.new(@nil_string)
+          }.merge!(encode_attribute_names(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def get_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            object = {}
+            if attributes
+              for attribute in attributes
+                if @data[:domains][domain_name][item_name] && @data[:domains][domain_name][item_name]
+                  object[attribute] = @data[:domains][domain_name][item_name][attribute]
+                end
+              end
+            elsif @data[:domains][domain_name][item_name]
+              object = @data[:domains][domain_name][item_name]
+            end
+            response.status = 200
+            response.body = {
+              'Attributes'  => object,
+              'BoxUsage'    => Fog::AWS::Mock.box_usage,
+              'RequestId'   => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/list_domains.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/list_domains.rb
new file mode 100644
index 0000000..0742b4c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/list_domains.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/list_domains'
+
+        # List SimpleDB domains
+        #
+        # ==== Parameters
+        # * options<~Hash> - options, defaults to {}
+        #   * 'MaxNumberOfDomains'<~Integer> - number of domains to return
+        #     between 1 and 100, defaults to 100
+        #   * 'NextToken'<~String> - Offset token to start listing, defaults to nil
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'Domains' - array of domain names.
+        #     * 'NextToken' - offset to start with if there are are more domains to list
+        #     * 'RequestId'
+        def list_domains(options = {})
+          request({
+            'Action'    => 'ListDomains',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::SimpleDB::ListDomains.new(@nil_string)
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_domains(options = {})
+          response = Excon::Response.new
+          keys = @data[:domains].keys
+          max = options['MaxNumberOfDomains'] || keys.size
+          offset = options['NextToken'] || 0
+          domains = []
+          for key, value in @data[:domains].keys[offset...max]
+            domains << key
+          end
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'Domains'   => domains,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          if max < keys.size
+            response.body['NextToken'] = max + 1
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/put_attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/put_attributes.rb
new file mode 100644
index 0000000..deeca82
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/put_attributes.rb
@@ -0,0 +1,78 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put item attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to add to the item.  Attribute names
+        #   and values may use any UTF-8 characters valid in xml. Control characters
+        #   and sequences not allowed in xml are not valid.  Each name and value can
+        #   be up to 1024 bytes long.
+        # * options<~Hash> - Accepts the following keys.
+        #   :replace => [Array of keys to replace]
+        #   :expect => {name/value pairs for performing conditional put}
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          request({
+            'Action'      => 'PutAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_attributes(attributes, options[:replace], options[:expect])))
+        end
+
+      end
+
+      class Mock
+
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          response = Excon::Response.new
+          if @data[:domains][domain_name]
+            options[:expect].each do |ck, cv|
+              if @data[:domains][domain_name][item_name][ck] != [cv]
+                response.status = 409
+                raise(Excon::Errors.status_error({:expects => 200}, response))
+              end
+            end
+            attributes.each do |key, value|
+              @data[:domains][domain_name][item_name] ||= {}
+              @data[:domains][domain_name][item_name][key.to_s] = [] unless @data[:domains][domain_name][item_name][key.to_s]
+              if options[:replace].include?(key.to_s)
+                @data[:domains][domain_name][item_name][key.to_s] = [*value].map {|x| x.to_s}
+              else
+                @data[:domains][domain_name][item_name][key.to_s] += [*value].map {|x| x.to_s}
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/select.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/select.rb
new file mode 100644
index 0000000..70132e3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/simpledb/select.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/select'
+
+        # Select item data from SimpleDB
+        #
+        # ==== Parameters
+        # * select_expression<~String> - Expression to query domain with.
+        # * next_token<~String> - Offset token to start list, defaults to nil.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'<~Float>
+        #     * 'RequestId'<~String>
+        #     * 'Items'<~Hash> - list of attribute name/values for the items formatted as 
+        #       { 'item_name' => { 'attribute_name' => ['attribute_value'] }}
+        #     * 'NextToken'<~String> - offset to start with if there are are more domains to list
+        def select(select_expression, next_token = nil)
+          request(
+            'Action'            => 'Select',
+            'NextToken'         => next_token,
+            'SelectExpression'  => select_expression,
+            :idempotent         => true,
+            :parser             => Fog::Parsers::AWS::SimpleDB::Select.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def select(select_expression, next_token = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/abort_multipart_upload.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/abort_multipart_upload.rb
new file mode 100644
index 0000000..312647a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/abort_multipart_upload.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Abort a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to abort multipart upload on
+        # * object_name<~String> - Name of object to abort multipart upload on
+        # * upload_id<~String> - Id of upload to add part to
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadAbort.html
+        #
+        def abort_multipart_upload(bucket_name, object_name, upload_id)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id}
+          })
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def abort_multipart_upload(bucket_name, object_name, upload_id)
+          Fog::Mock.not_implemented
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/complete_multipart_upload.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/complete_multipart_upload.rb
new file mode 100644
index 0000000..4ccc19d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/complete_multipart_upload.rb
@@ -0,0 +1,60 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/complete_multipart_upload'
+
+        # Complete a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to complete multipart upload for
+        # * object_name<~String> - Name of object to complete multipart upload for
+        # * upload_id<~String> - Id of upload to add part to
+        # * parts<~Array>: Array of etags for parts
+        #   * :etag<~String> - Etag for this part
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'Bucket'<~String> - bucket of new object
+        #     * 'ETag'<~String> - etag of new object (will be needed to complete upload)
+        #     * 'Key'<~String> - key of new object
+        #     * 'Location'<~String> - location of new object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadComplete.html
+        #
+        def complete_multipart_upload(bucket_name, object_name, upload_id, parts)
+          data = "<CompleteMultipartUpload>"
+          parts.each_with_index do |part, index|
+            data << "<Part>"
+            data << "<PartNumber>#{index + 1}</PartNumber>"
+            data << "<ETag>#{part}</ETag>"
+            data << "</Part>"
+          end
+          data << "</CompleteMultipartUpload>"
+          request({
+            :body       => data,
+            :expects    => 200,
+            :headers    => { 'Content-Length' => data.length },
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::Storage::CompleteMultipartUpload.new,
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id}
+          })
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def complete_multipart_upload(bucket_name, object_name, upload_id, parts)
+          Fog::Mock.not_implemented
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/copy_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/copy_object.rb
new file mode 100644
index 0000000..51d2a76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/copy_object.rb
@@ -0,0 +1,75 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/copy_object'
+
+        # Copy an object from one S3 bucket to another
+        #
+        # ==== Parameters
+        # * source_bucket_name<~String> - Name of source bucket
+        # * source_object_name<~String> - Name of source object
+        # * target_bucket_name<~String> - Name of bucket to create copy in
+        # * target_object_name<~String> - Name for new copy of object
+        # * options<~Hash>:
+        #   * 'x-amz-metadata-directive'<~String> - Specifies whether to copy metadata from source or replace with data in request.  Must be in ['COPY', 'REPLACE']
+        #   * 'x-amz-copy_source-if-match'<~String> - Copies object if its etag matches this value
+        #   * 'x-amz-copy_source-if-modified_since'<~Time> - Copies object it it has been modified since this time
+        #   * 'x-amz-copy_source-if-none-match'<~String> - Copies object if its etag does not match this value
+        #   * 'x-amz-copy_source-if-unmodified-since'<~Time> - Copies object it it has not been modified since this time
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #     * 'LastModified'<~Time> - date object was last modified
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectCOPY.html
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          headers = { 'x-amz-copy-source' => "/#{source_bucket_name}/#{source_object_name}" }.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{target_bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::AWS::Storage::CopyObject.new,
+            :path     => CGI.escape(target_object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          response = Excon::Response.new
+          source_bucket = @data[:buckets][source_bucket_name]
+          source_object = source_bucket && source_bucket[:objects][source_object_name]
+          target_bucket = @data[:buckets][target_bucket_name]
+
+          if source_object && target_bucket
+            response.status = 200
+            target_object = source_object.dup
+            target_object.merge!({
+              'Name' => target_object_name
+            })
+            target_bucket[:objects][target_object_name] = target_object
+            response.body = {
+              'ETag'          => target_object['ETag'],
+              'LastModified'  => Time.parse(target_object['LastModified'])
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_bucket.rb
new file mode 100644
index 0000000..769212e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_bucket.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketDELETE.html
+
+        def delete_bucket(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE'
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def delete_bucket(bucket_name)
+          response = Excon::Response.new
+          if @data[:buckets][bucket_name].nil?
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          elsif @data[:buckets][bucket_name] && !@data[:buckets][bucket_name][:objects].empty?
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          else
+            @data[:buckets].delete(bucket_name)
+            response.status = 204
+          end
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_object.rb
new file mode 100644
index 0000000..b4e7d72
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/delete_object.rb
@@ -0,0 +1,49 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object to delete
+        # * object_name<~String> - Name of object to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectDELETE.html
+
+        def delete_object(bucket_name, object_name)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def delete_object(bucket_name, object_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 204
+            bucket[:objects].delete(object_name)
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket.rb
new file mode 100644
index 0000000..72bc6af
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket.rb
@@ -0,0 +1,111 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket'
+
+        # List information about objects in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'CommonPrefixes'<~Array> - Array of strings for common prefixes
+        #     * 'Contents'<~Array>:
+        #       * 'ETag'<~String>: Etag of object
+        #       * 'Key'<~String>: Name of object
+        #       * 'LastModified'<~String>: Timestamp of last modification of object
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'Size'<~Integer> - Size of object
+        #       * 'StorageClass'<~String> - Storage class of object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGET.html
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucket.new,
+            :query    => options
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          if options['delimiter']
+            Fog::Mock.not_implemented
+          end
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            contents = bucket[:objects].values.sort {|x,y| x['Key'] <=> y['Key']}.reject do |object|
+                (options['prefix'] && object['Key'][0...options['prefix'].length] != options['prefix']) ||
+                (options['marker'] && object['Key'] <= options['marker'])
+              end.map do |object|
+                data = object.reject {|key, value| !['ETag', 'Key', 'LastModified', 'Size', 'StorageClass'].include?(key)}
+                data.merge!({
+                  'LastModified' => Time.parse(data['LastModified']),
+                  'Owner'        => bucket['Owner'],
+                  'Size'         => data['Size'].to_i
+                })
+              data
+            end
+            max_keys = options['max-keys'] || 1000
+            size = [max_keys, 1000].min
+            truncated_contents = contents[0...size]
+
+            response.status = 200
+            response.body = {
+              'CommonPrefixes'  => [],
+              'Contents'        => truncated_contents,
+              'IsTruncated'     => truncated_contents.size != contents.size,
+              'Marker'          => options['marker'],
+              'MaxKeys'         => max_keys,
+              'Name'            => bucket['Name'],
+              'Prefix'          => options['prefix']
+            }
+            if options['max-keys'] && options['max-keys'] < response.body['Contents'].length
+                response.body['IsTruncated'] = true
+                response.body['Contents'] = response.body['Contents'][0...options['max-keys']]
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_acl.rb
new file mode 100644
index 0000000..92128aa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_acl.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/access_control_list'
+
+        # Get access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get access control list for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETacl.html
+
+        def get_bucket_acl(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :query      => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_acl(bucket_name)
+          response = Excon::Response.new
+          if acl = @data[:acls][:bucket][bucket_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_location.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_location.rb
new file mode 100644
index 0000000..774c1ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_location.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_location'
+
+        # Get location constraint for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get location constraint for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'LocationConstraint'<~String> - Location constraint of the bucket
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETlocation.html
+
+        def get_bucket_location(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketLocation.new,
+            :query    => {'location' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_location(bucket_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            response.body = {'LocationConstraint' => bucket['LocationConstraint'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_logging.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_logging.rb
new file mode 100644
index 0000000..f516a8a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_logging.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_logging'
+
+        # Get logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get logging status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BucketLoggingStatus'<~Hash>: (will be empty if logging is disabled)
+        #       * 'LoggingEnabled'<~Hash>:
+        #         * 'TargetBucket'<~String> - bucket where logs are stored
+        #         * 'TargetPrefix'<~String> - prefix logs are stored with
+        #         * 'TargetGrants'<~Array>:
+        #           * 'Grant'<~Hash>:
+        #             * 'Grantee'<~Hash>:
+        #                 * 'DisplayName'<~String> - Display name of grantee
+        #                 * 'ID'<~String> - Id of grantee
+        #               or
+        #                 * 'URI'<~String> - URI of group to grant access for
+        #             * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETlogging.html
+
+        def get_bucket_logging(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketLogging.new,
+            :query      => {'logging' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_logging(bucket_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_object_versions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_object_versions.rb
new file mode 100644
index 0000000..9b1ac43
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_object_versions.rb
@@ -0,0 +1,83 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_object_versions'
+
+        # List information about object versions in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'key-marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #   * 'version-id-marker'<~String> - limits object versions to only those that
+        #     appear lexicographically after its value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'KeyMarker'<~String> - Key marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'VersionIdMarker'<~String> - Version id marker specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not this is the totality of the bucket
+        #     * 'Versions'<~Array>:
+        #         * 'DeleteMarker'<~Hash>:
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'VersionId'<~String> - The id of this version
+        #       or
+        #         * 'Version'<~Hash>:
+        #           * 'ETag'<~String>: Etag of object
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'Size'<~Integer> - Size of object
+        #           * 'StorageClass'<~String> - Storage class of object
+        #           * 'VersionId'<~String> - The id of this version
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETVersion.html
+
+        def get_bucket_object_versions(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketObjectVersions.new,
+            :query    => {'versions' => nil}.merge!(options)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_object_versions(bucket_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_versioning.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_versioning.rb
new file mode 100644
index 0000000..a436506
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_bucket_versioning.rb
@@ -0,0 +1,48 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_bucket_versioning'
+
+        # Get versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get versioning status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'VersioningConfiguration'<~Hash>
+        #         * Status<~String>: Versioning status in ['Enabled', 'Suspended', nil]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETversioningStatus.html
+
+        def get_bucket_versioning(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketVersioning.new,
+            :query      => {'versioning' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_versioning(bucket_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object.rb
new file mode 100644
index 0000000..440d8d3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object.rb
@@ -0,0 +1,107 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGET.html
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          }, &block)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name]) && (object = bucket[:objects][object_name])
+            if options['If-Match'] && options['If-Match'] != object['ETag']
+              response.status = 412
+            elsif options['If-Modified-Since'] && options['If-Modified-Since'] > Time.parse(object['LastModified'])
+              response.status = 304
+            elsif options['If-None-Match'] && options['If-None-Match'] == object['ETag']
+              response.status = 304
+            elsif options['If-Unmodified-Since'] && options['If-Unmodified-Since'] < Time.parse(object['LastModified'])
+              response.status = 412
+            else
+              response.status = 200
+              response.headers = {
+                'Content-Length'  => object['Size'],
+                'Content-Type'    => object['Content-Type'],
+                'ETag'            => object['ETag'],
+                'Last-Modified'   => object['LastModified']
+              }
+              unless block_given?
+                response.body = object[:body]
+              else
+                data = StringIO.new(object[:body])
+                remaining = data.length
+                while remaining > 0
+                  chunk = data.read([remaining, Excon::CHUNK_SIZE].min)
+                  block.call(chunk)
+                  remaining -= Excon::CHUNK_SIZE
+                end
+              end
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_acl.rb
new file mode 100644
index 0000000..7e50965
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_acl.rb
@@ -0,0 +1,77 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/access_control_list'
+
+        # Get access control list for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get access control list for
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGETacl.html
+
+        def get_object_acl(bucket_name, object_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :path       => CGI.escape(object_name),
+            :query      => query
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object_acl(bucket_name, object_name)
+          response = Excon::Response.new
+          if acl = @data[:acls][:object][bucket_name] && @data[:acls][:object][bucket_name][object_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_torrent.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_torrent.rb
new file mode 100644
index 0000000..b90a0ca
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_torrent.rb
@@ -0,0 +1,58 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get torrent for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get torrent for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of grantee
+        #             * 'ID'<~String> - Id of grantee
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGETtorrent.html
+
+        def get_object_torrent(bucket_name, object_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :path       => CGI.escape(object_name),
+            :query      => {'torrent' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object_object(bucket_name, object_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_url.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_url.rb
new file mode 100644
index 0000000..3b1f223
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_object_url.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/S3_QSAuth.html
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_request_payment.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_request_payment.rb
new file mode 100644
index 0000000..d555800
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_request_payment.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_request_payment'
+
+        # Get configured payer for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get payer for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Payer'<~String> - Specifies who pays for download and requests
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTrequestPaymentGET.html
+
+        def get_request_payment(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetRequestPayment.new,
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_request_payment(bucket_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            response.body = { 'Payer' => bucket['Payer'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_service.rb
new file mode 100644
index 0000000..5465ef1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/get_service.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/get_service'
+
+        # List information about S3 buckets for authorized user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Buckets'<~Hash>:
+        #       * 'Name'<~String> - Name of bucket
+        #       * 'CreationTime'<~Time> - Timestamp of bucket creation
+        #     * 'Owner'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of bucket owner
+        #       * 'ID'<~String> - Id of bucket owner
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTServiceGET.html
+        #
+        def get_service
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => @host,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetService.new,
+            :url      => @host
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_service
+          response = Excon::Response.new
+          response.headers['Status'] = 200
+          buckets = @data[:buckets].values.map do |bucket|
+            bucket.reject do |key, value|
+              !['CreationDate', 'Name'].include?(key)
+            end
+          end
+          response.body = {
+            'Buckets' => buckets,
+            'Owner'   => { 'DisplayName' => 'owner', 'ID' => 'some_id'}
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/head_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/head_object.rb
new file mode 100644
index 0000000..5451a80
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/head_object.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get headers for an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectHEAD.html
+
+        def head_object(bucket_name, object_name, options={})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'HEAD',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def head_object(bucket_name, object_name, options = {})
+          response = get_object(bucket_name, object_name, options)
+          response.body = nil
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/initiate_multipart_upload.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/initiate_multipart_upload.rb
new file mode 100644
index 0000000..060a762
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/initiate_multipart_upload.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/initiate_multipart_upload'
+
+        # Initiate a multipart upload to an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message (defaults to Base64 encoded MD5 of object.read)
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-amz-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~String> - Bucket where upload was initiated
+        #     * 'Key'<~String> - Object key where the upload was initiated
+        #     * 'UploadId'<~String> - Id for initiated multipart upload
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadInitiate.html
+        #
+        def initiate_multipart_upload(bucket_name, object_name, options = {})
+          request({
+            :expects    => 200,
+            :headers    => options,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::Storage::InitiateMultipartUpload.new,
+            :path       => CGI.escape(object_name),
+            :query      => {'uploads' => nil}
+          })
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def initiate_multipart_upload(bucket_name, object_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_multipart_uploads.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_multipart_uploads.rb
new file mode 100644
index 0000000..9cbbb42
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_multipart_uploads.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/list_multipart_uploads'
+
+        # List multipart uploads for a bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to list multipart uploads for
+        # * upload_id<~String> - upload id to list objects for
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'key-marker'<~String> - limits parts to only those that appear
+        #     lexicographically after this key.
+        #   * 'max-uploads'<~Integer> - limits number of uploads returned
+        #   * 'upload-id-marker'<~String> - limits uploads to only those that appear
+        #     lexicographically after this upload id.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~string> - Bucket where the multipart upload was initiated
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'KeyMarker'<~String> - first key in list, only upload ids after this lexographically will appear
+        #     * 'MaxUploads'<~Integer> - Maximum results to return
+        #     * 'NextKeyMarker'<~String> - last key in list, for further pagination
+        #     * 'NextUploadIdMarker'<~String> - last key in list, for further pagination
+        #     * 'Upload'<~Hash>:
+        #       * 'Initiated'<~Time> - Time when upload was initiated
+        #       * 'Initiator'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of upload initiator
+        #         * 'ID'<~String> - Id of upload initiator
+        #       * 'Key'<~String> - Key where multipart upload was initiated
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of upload owner
+        #         * 'ID'<~String> - Id of upload owner
+        #       * 'StorageClass'<~String> - Storage class of object
+        #       * 'UploadId'<~String> - upload id of upload containing part
+        #     * 'UploadIdMarker'<String> - first key in list, only upload ids after this lexographically will appear
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadListMPUpload.html
+        #
+        def list_multipart_uploads(bucket_name, options = {})
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::ListMultipartUploads.new,
+            :query    => options.merge!({'uploads' => nil})
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def list_multipart_uploads(bucket_name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_parts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_parts.rb
new file mode 100644
index 0000000..c2333d1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/list_parts.rb
@@ -0,0 +1,67 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/aws/parsers/storage/list_parts'
+
+        # List parts for a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to list parts for
+        # * object_name<~String> - Name of object to list parts for
+        # * upload_id<~String> - upload id to list objects for
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'max-parts'<~Integer> - limits number of parts returned
+        #   * 'part-number-marker'<~String> - limits parts to only those that appear
+        #     lexicographically after this part number.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~string> - Bucket where the multipart upload was initiated
+        #     * 'Initiator'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of upload initiator
+        #       * 'ID'<~String> - Id of upload initiator
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Key'<~String> - Key where multipart upload was initiated
+        #     * 'MaxParts'<~String> - maximum number of replies alllowed in response
+        #     * 'NextPartNumberMarker'<~String> - last item in list, for further pagination
+        #     * 'Part'<~Array>:
+        #       * 'ETag'<~String> - ETag of part
+        #       * 'LastModified'<~Timestamp> - Last modified for part
+        #       * 'PartNumber'<~String> - Part number for part
+        #       * 'Size'<~Integer> - Size of part
+        #     * 'PartNumberMarker'<~String> - Part number after which listing begins
+        #     * 'StorageClass'<~String> - Storage class of object
+        #     * 'UploadId'<~String> - upload id of upload containing part
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadListParts.html
+        #
+        def list_parts(bucket_name, object_name, upload_id, options = {})
+          options['uploadId'] = upload_id
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::ListParts.new,
+            :path     => CGI.escape(object_name),
+            :query    => options.merge!({'uploadId' => upload_id})
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def list_parts(bucket_name, object_name, upload_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/post_object_hidden_fields.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/post_object_hidden_fields.rb
new file mode 100644
index 0000000..bbd3717
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/post_object_hidden_fields.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get a hash of hidden fields for form uploading to S3, in the form {:field_name => :field_value}
+        # Form should look like: <form action="http://#{bucket_name}.s3.amazonaws.com/" method="post" enctype="multipart/form-data">
+        # These hidden fields should then appear, followed by a field named 'file' which is either a textarea or file input.
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * acl<~String> - access control list, in ['private', 'public-read', 'public-read-write', 'authenticated-read', 'bucket-owner-read', 'bucket-owner-full-control']
+        #   * Cache-Control - same as REST header
+        #   * Content-Type - same as REST header
+        #   * Content-Disposition - same as REST header
+        #   * Content-Encoding - same as REST header
+        #   * Expires - same as REST header
+        #   * key - key for object, set to '${filename}' to use filename provided by user
+        #   * policy - security policy for upload
+        #   * success_action_redirect - url to redirct to upon success
+        #   * success_action_status - status code to return on success, in [200, 201, 204]
+        #   * x-amz-security-token - devpay security token
+        #   * x-amz-meta-... - meta data tags
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/HTTPPOSTForms.html
+
+        def post_object_hidden_fields(options = {})
+          if options['policy']
+            options['policy'] = options['policy'].to_json
+            options['AWSAccessKeyId'] = @aws_access_key_id
+            string_to_sign = Base64.encode64(options['policy']).chomp!
+            signed_string = @hmac.sign(string_to_sign)
+            options['Signature'] = Base64.encode64(signed_string).chomp!
+          end
+          options
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def post_object_hidden_fields(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket.rb
new file mode 100644
index 0000000..604ab4a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket.rb
@@ -0,0 +1,77 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to create
+        # * options<~Hash> - config arguments for bucket.  Defaults to {}.
+        #   * 'LocationConstraint'<~Symbol> - sets the location for the bucket
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 200
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUT.html
+
+        def put_bucket(bucket_name, options = {})
+          if location_constraint = options.delete('LocationConstraint')
+            data =
+<<-DATA
+  <CreateBucketConfiguration>
+    <LocationConstraint>#{location_constraint}</LocationConstraint>
+  </CreateBucketConfiguration>
+DATA
+          else
+            data = nil
+          end
+          request({
+            :expects    => 200,
+            :body       => data,
+            :headers    => options,
+            :idempotent => true,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT'
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_bucket(bucket_name, options = {})
+          if options['x-amz-acl']
+            unless ['private', 'public-read', 'public-read-write', 'authenticated-read']
+              raise Excon::Errors::BadRequest.new('invalid x-amz-acl')
+            else
+              @data[:acls][:bucket][bucket_name] = self.class.acls(options['x-amz-acl'])
+            end
+          end
+          response = Excon::Response.new
+          response.status = 200
+          bucket = {
+            :objects        => {},
+            'Name'          => bucket_name,
+            'CreationDate'  => Time.now,
+            'Owner'         => { 'DisplayName' => 'owner', 'ID' => 'some_id'},
+            'Payer'         => 'BucketOwner'
+          }
+          if options['LocationConstraint']
+            bucket['LocationConstraint'] = options['LocationConstraint']
+          else
+            bucket['LocationConstraint'] = nil
+          end
+          unless @data[:buckets][bucket_name]
+            @data[:buckets][bucket_name] = bucket
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_acl.rb
new file mode 100644
index 0000000..9072f95
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_acl.rb
@@ -0,0 +1,84 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTacl.html
+
+        def put_bucket_acl(bucket_name, acl)
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_bucket_acl(bucket_name, acl)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_logging.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_logging.rb
new file mode 100644
index 0000000..61cbacf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_logging.rb
@@ -0,0 +1,91 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * logging_status<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTlogging.html
+
+        def put_bucket_logging(bucket_name, logging_status)
+          if logging_status['LoggingEnabled'].empty?
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01" />
+DATA
+          else
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01">
+  <LoggingEnabled>
+    <TargetBucket>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetBucket>
+    <TargetPrefix>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetPrefix>
+    <TargetGrants>
+DATA
+
+            acl['AccessControlList'].each do |grant|
+              data << "      <Grant>"
+              type = case grant['Grantee'].keys.sort
+              when ['DisplayName', 'ID']
+                'CanonicalUser'
+              when ['EmailAddress']
+                'AmazonCustomerByEmail'
+              when ['URI']
+                'Group'
+              end
+              data << "        <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+              for key, value in grant['Grantee']
+                data << "          <#{key}>#{value}</#{key}>"
+              end
+              data << "        </Grantee>"
+              data << "        <Permission>#{grant['Permission']}</Permission>"
+              data << "      </Grant>"
+            end
+
+            data <<
+<<-DATA
+    </TargetGrants>
+  </LoggingEnabled>
+</BucketLoggingStatus>
+DATA
+          end
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'logging' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_bucket_logging(bucket_name, logging_status)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_versioning.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_versioning.rb
new file mode 100644
index 0000000..8bc08f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_bucket_versioning.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * status<~String> - Status to change to in ['Enabled', 'Suspended']
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html
+
+        def put_bucket_versioning(bucket_name, status)
+          data =
+<<-DATA
+<VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Status>#{status}</Status>
+</VersioningConfiguration>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'versioning' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_bucket_versioning(bucket_name, status)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object.rb
new file mode 100644
index 0000000..f96d96a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object.rb
@@ -0,0 +1,91 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an object in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * data<~File||String> - File or String to create object from
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-Length'<~String> - Size of object in bytes (defaults to object.read.length)
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'Expires'<~String> - Cache expiry
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-amz-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectPUT.html
+        #
+        def put_object(bucket_name, object_name, data, options = {})
+          data = parse_data(data)
+          headers = data[:headers].merge!(options)
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_object(bucket_name, object_name, data, options = {})
+          if options['x-amz-acl']
+            unless ['private', 'public-read', 'public-read-write', 'authenticated-read']
+              raise Excon::Errors::BadRequest.new('invalid x-amz-acl')
+            else
+              @data[:acls][:object][bucket_name] ||= {}
+              @data[:acls][:object][bucket_name][object_name] = self.class.acls(options['x-amz-acl'])
+            end
+          end
+          data = parse_data(data)
+          unless data[:body].is_a?(String)
+            data[:body] = data[:body].read
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name])
+            response.status = 200
+            object = {
+              :body           => data[:body],
+              'Content-Type'  => data[:headers]['Content-Type'],
+              'ETag'          => Fog::AWS::Mock.etag,
+              'Key'           => object_name,
+              'LastModified'  => Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000"),
+              'Size'          => data[:headers]['Content-Length'],
+              'StorageClass'  => 'STANDARD'
+            }
+            bucket[:objects][object_name] = object
+            response.headers = {
+              'Content-Length'  => object['Size'],
+              'Content-Type'    => object['Content-Type'],
+              'ETag'            => object['ETag'],
+              'Last-Modified'   => object['LastModified']
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_acl.rb
new file mode 100644
index 0000000..4fd1f04
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_acl.rb
@@ -0,0 +1,93 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change access control list for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * object_name<~String> - name of object to get access control list for
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectPUTacl.html
+
+        def put_object_acl(bucket_name, object_name, acl, options = {})
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :path       => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_object_acl(bucket_name, object_name, options, acl)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_url.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_url.rb
new file mode 100644
index 0000000..3a28946
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_object_url.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3 for putting an object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/S3_QSAuth.html
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_request_payment.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_request_payment.rb
new file mode 100644
index 0000000..aba9cf7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/put_request_payment.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change who pays for requests to an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * payer<~String> - valid values are BucketOwner or Requester
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTrequestPaymentPUT.html
+
+        def put_request_payment(bucket_name, payer)
+          data =
+<<-DATA
+<RequestPaymentConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Payer>#{payer}</Payer>
+</RequestPaymentConfiguration>
+DATA
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_request_payment(bucket_name, payer)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            response.status = 200
+            bucket['Payer'] = payer
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/sync_clock.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/sync_clock.rb
new file mode 100644
index 0000000..986af7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/sync_clock.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Sync clock against S3 to avoid skew errors
+        #
+        def sync_clock
+          response = begin
+            get_service
+          rescue => error
+            error.response
+          end
+          Fog::Time.now = Time.parse(response.headers['Date'])
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def sync_clock
+          true
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/upload_part.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/upload_part.rb
new file mode 100644
index 0000000..e38a8fa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/requests/storage/upload_part.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Upload a part for a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to add part to
+        # * object_name<~String> - Name of object to add part to
+        # * upload_id<~String> - Id of upload to add part to
+        # * part_number<~String> - Index of part in upload
+        # * data<~File||String> - Content for part
+        # * options<~Hash>:
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object (will be needed to complete upload)
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadUploadPart.html
+        #
+        def upload_part(bucket_name, object_name, upload_id, part_number, data, options = {})
+          data = parse_data(data)
+          headers = options
+          headers['Content-Length'] = data[:headers]['Content-Length']
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id, 'partNumber' => part_number}
+          })
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def upload_part(bucket_name, object_name, upload_id, part_number, data, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/s3.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/s3.rb
new file mode 100644
index 0000000..a1e1991
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/s3.rb
@@ -0,0 +1,15 @@
+module Fog
+  module AWS
+    class S3
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::AWS::S3#new is deprecated, use Fog::AWS::Storage#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::AWS::Storage.new(attributes)
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/simpledb.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/simpledb.rb
new file mode 100644
index 0000000..d76975d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/simpledb.rb
@@ -0,0 +1,172 @@
+module Fog
+  module AWS
+    class SimpleDB < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :nil_string, :path, :port, :scheme, :persistent
+      
+      request_path 'fog/aws/requests/simpledb'
+      request :batch_put_attributes
+      request :create_domain
+      request :delete_attributes
+      request :delete_domain
+      request :domain_metadata
+      request :get_attributes
+      request :list_domains
+      request :put_attributes
+      request :select
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :domains => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+          @data = self.class.data[@aws_access_key_id]
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to SimpleDB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * SimpleDB object with connection to aws.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @host       = options[:host]      || 'sdb.amazonaws.com'
+          @nil_string = options[:nil_string]|| 'nil'
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        private
+
+        def encode_attributes(attributes, replace_attributes = [], expected_attributes = {})
+          encoded_attributes = {}
+          if attributes
+
+            expected_attributes.keys.each_with_index do |exkey, index|
+              for value in Array(expected_attributes[exkey])
+                encoded_attributes["Expected.#{index}.Name"] = exkey.to_s
+                encoded_attributes["Expected.#{index}.Value"] = sdb_encode(value)
+              end
+            end
+
+            index = 0
+            for key in attributes.keys
+              for value in Array(attributes[key])
+                encoded_attributes["Attribute.#{index}.Name"] = key.to_s
+                if replace_attributes.include?(key)
+                  encoded_attributes["Attribute.#{index}.Replace"] = 'true'
+                end
+                encoded_attributes["Attribute.#{index}.Value"] = sdb_encode(value)
+                index += 1
+              end
+            end
+          end
+          encoded_attributes
+        end
+
+        def encode_attribute_names(attributes)
+          AWS.indexed_param('AttributeName', attributes.map {|attribute| attributes.to_s})
+        end
+
+        def encode_batch_attributes(items, replace_attributes = Hash.new([]))
+          encoded_attributes = {}
+          if items
+            item_index = 0
+            for item_key in items.keys
+              encoded_attributes["Item.#{item_index}.ItemName"] = item_key.to_s
+              for attribute_key in items[item_key].keys
+                attribute_index = 0
+                for value in Array(items[item_key][attribute_key])
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Name"] = attribute_key.to_s
+                  if replace_attributes[item_key].include?(attribute_key)
+                    encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Replace"] = 'true'
+                  end
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Value"] = sdb_encode(value)
+                  attribute_index += 1
+                end
+                item_index += 1
+              end
+            end
+          end
+          encoded_attributes
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          idempotent = params.delete(:idempotent)
+          parser = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2009-04-15'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :host       => @host,
+            :idempotent => idempotent,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+        def sdb_encode(value)
+          if value.nil?
+            @nil_string
+          else
+            value.to_s
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/storage.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/storage.rb
new file mode 100644
index 0000000..e5c2af8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/aws/storage.rb
@@ -0,0 +1,313 @@
+module Fog
+  module AWS
+    class Storage < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :endpoint, :region, :host, :path, :port, :scheme, :persistent
+      
+      model_path 'fog/aws/models/storage'
+      collection  :directories
+      model       :directory
+      collection  :files
+      model       :file
+
+      request_path 'fog/aws/requests/storage'
+      request :abort_multipart_upload
+      request :complete_multipart_upload
+      request :copy_object
+      request :delete_bucket
+      request :delete_object
+      request :get_bucket
+      request :get_bucket_acl
+      request :get_bucket_location
+      request :get_bucket_logging
+      request :get_bucket_object_versions
+      request :get_bucket_versioning
+      request :get_object
+      request :get_object_acl
+      request :get_object_torrent
+      request :get_object_url
+      request :get_request_payment
+      request :get_service
+      request :head_object
+      request :initiate_multipart_upload
+      request :list_multipart_uploads
+      request :list_parts
+      request :post_object_hidden_fields
+      request :put_bucket
+      request :put_bucket_acl
+      request :put_bucket_logging
+      request :put_bucket_versioning
+      request :put_object
+      request :put_object_acl
+      request :put_object_url
+      request :put_request_payment
+      request :sync_clock
+      request :upload_part
+
+      module Utils
+
+        def cdn
+          @cdn ||= Fog::AWS::CDN.new(
+            :aws_access_key_id => @aws_access_key_id,
+            :aws_secret_access_key => @aws_secret_access_key
+          )
+        end
+
+        def parse_data(data)
+          metadata = {
+            :body => nil,
+            :headers => {}
+          }
+
+          if data.is_a?(String)
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = metadata[:body].size.to_s
+          else
+            filename = ::File.basename(data.path)
+            unless (mime_types = MIME::Types.of(filename)).empty?
+              metadata[:headers]['Content-Type'] = mime_types.first.content_type
+            end
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = ::File.size(data.path).to_s
+          end
+          # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+          metadata
+        end
+
+        def url(params, expires)
+          params[:headers]['Date'] = expires.to_i
+          query = [params[:query]].compact
+          query << "AWSAccessKeyId=#{@aws_access_key_id}"
+          query << "Signature=#{CGI.escape(signature(params))}"
+          query << "Expires=#{params[:headers]['Date']}"
+          bucket = params[:host].split('.').first
+          path = CGI.escape(params[:path]).gsub('%2F', '/')
+          "https://#{@host}/#{path}?#{query.join('&')}"
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.acls(type)
+          case type
+          when 'private'
+            @private ||= {
+              "AccessControlList" => [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Grantee" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+                }
+              ],
+              "Owner" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read'
+            @public_read ||= begin
+              public_read = self.acls('private').dup
+              public_read['AccessControlList'] << {
+                "Permission" => "READ",
+                "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AllUsers"}
+              }
+              public_read
+            end
+          when 'public-read-write'
+            @public_read_write ||= begin
+              public_read_write = self.acls('public-read').dup
+              public_read_write['AccessControlList'] << {
+                "Permission" => "WRITE",
+                "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AllUsers"}
+              }
+              public_read_write
+            end
+          when 'authenticated-read'
+            @authenticated_read ||= begin
+              authenticated_read = self.acls('private').dup
+              authenticated_read['AccessControlList'] << {
+                "Permission" => "READ",
+                "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"}
+              }
+              authenticated_read
+            end
+          end
+        end
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :acls => {
+                  :bucket => {},
+                  :object => {}
+                },
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          require 'mime/types'
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'eu-west-1'
+            's3-eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            's3.amazonaws.com'
+          when 'ap-southeast-1'
+            's3-ap-southeast-1.amazonaws.com'
+          when 'us-west-1'
+            's3-us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @data = self.class.data[options[:region]][@aws_access_key_id]
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+      
+      class Real
+        include Utils
+        extend Fog::Deprecation
+        deprecate(:reset, :reload)
+
+        # Initialize connection to S3
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   s3 = S3.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * S3 object with connection to aws.
+        def initialize(options={})
+          require 'mime/types'
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          if @endpoint = options[:endpoint]
+            endpoint = URI.parse(@endpoint)
+            @host = endpoint.host
+            @path = endpoint.path
+            @port = endpoint.port
+            @scheme = endpoint.scheme
+          else
+            options[:region] ||= 'us-east-1'
+            @host = options[:host] || case options[:region]
+            when 'eu-west-1'
+              's3-eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              's3.amazonaws.com'
+            when 'ap-southeast-1'
+              's3-ap-southeast-1.amazonaws.com'
+            when 'us-west-1'
+              's3-us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+            @path   = options[:path]      || '/'
+            @port   = options[:port]      || 443
+            @scheme = options[:scheme]    || 'https'
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent] || true)
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers]['Date'] = Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000")
+          params[:headers]['Authorization'] = "AWS #{@aws_access_key_id}:#{signature(params)}"
+          params[:expects] = [307, *params[:expects]].flatten
+          # FIXME: ToHashParser should make this not needed
+          original_params = params.dup
+
+          response = @connection.request(params, &block)
+
+          if response.status == 307
+            uri = URI.parse(response.headers['Location'])
+            Formatador.display_line("[yellow][WARN] fog: followed redirect to #{uri.host}, connecting to the matching region will be more performant[/]")
+            response = Fog::Connection.new("#{@scheme}://#{uri.host}:#{@port}", false).request(original_params, &block)
+          end
+
+          response
+        end
+
+        def signature(params)
+          string_to_sign =
+<<-DATA
+#{params[:method]}
+#{params[:headers]['Content-MD5']}
+#{params[:headers]['Content-Type']}
+#{params[:headers]['Date']}
+DATA
+
+          amz_headers, canonical_amz_headers = {}, ''
+          for key, value in params[:headers]
+            if key[0..5] == 'x-amz-'
+              amz_headers[key] = value
+            end
+          end
+          amz_headers = amz_headers.sort {|x, y| x[0] <=> y[0]}
+          for key, value in amz_headers
+            canonical_amz_headers << "#{key}:#{value}\n"
+          end
+          string_to_sign << canonical_amz_headers
+
+          subdomain = params[:host].split(".#{@host}").first
+          unless subdomain =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+            Formatador.display_line("[yellow][WARN] fog: the specified s3 bucket name(#{subdomain}) is not a valid dns name, which will negatively impact performance.  For details see: http://docs.amazonwebservices.com/AmazonS3/latest/dev/BucketRestrictions.html[/]")
+            params[:host] = params[:host].split("#{subdomain}.")[-1]
+            if params[:path]
+              params[:path] = "#{subdomain}/#{params[:path]}"
+            else
+              params[:path] = subdomain
+            end
+            subdomain = nil
+          end
+
+          canonical_resource  = @path.dup
+          unless subdomain.nil? || subdomain == @host
+            canonical_resource << "#{CGI.escape(subdomain).downcase}/"
+          end
+          canonical_resource << params[:path].to_s
+          canonical_resource << '?'
+          for key in (params[:query] || {}).keys
+            if %w{acl location logging notification partNumber policy requestPayment torrent uploadId uploads versionId versioning versions}.include?(key)
+              canonical_resource << "#{key}#{"=#{params[:query][key]}" unless params[:query][key].nil?}&"
+            end
+          end
+          canonical_resource.chop!
+          string_to_sign << canonical_resource
+
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox.rb
new file mode 100644
index 0000000..19d6c49
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox.rb
@@ -0,0 +1,20 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module Bluebox
+
+    extend Fog::Provider
+
+    service_path 'fog/bluebox'
+    service :compute
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Bluebox#new is deprecated, use Fog::Bluebox::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Bluebox::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/bin.rb
new file mode 100644
index 0000000..30e33dd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/bin.rb
@@ -0,0 +1,31 @@
+class Bluebox < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :blocks, :compute
+        Fog::Bluebox::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :blocks
+          location = caller.first
+          warning = "[yellow][WARN] Bluebox[:blocks] is deprecated, use Bluebox[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/compute.rb
new file mode 100644
index 0000000..d543e9f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/compute.rb
@@ -0,0 +1,89 @@
+module Fog
+  module Bluebox
+    class Compute < Fog::Service
+
+      requires :bluebox_api_key, :bluebox_customer_id
+      recognizes :bluebox_host, :bluebox_port, :bluebox_scheme, :persistent
+
+      model_path 'fog/bluebox/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/bluebox/requests/compute'
+      request :create_block
+      request :destroy_block
+      request :get_block
+      request :get_blocks
+      request :get_product
+      request :get_products
+      request :get_template
+      request :get_templates
+      request :reboot_block
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @bluebox_api_key = options[:bluebox_api_key]
+          @data = self.class.data[@bluebox_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          @bluebox_api_key      = options[:bluebox_api_key]
+          @bluebox_customer_id  = options[:bluebox_customer_id]
+          @host   = options[:bluebox_host]    || "boxpanel.blueboxgrp.com"
+          @port   = options[:bluebox_port]    || 443
+          @scheme = options[:bluebox_scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64([@bluebox_customer_id, @bluebox_api_key].join(':')).delete("\r\n")}"
+          })
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Bluebox::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavor.rb
new file mode 100644
index 0000000..5b17396
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :cost
+        attribute :description
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavors.rb
new file mode 100644
index 0000000..a22719c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/bluebox/models/compute/flavor'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Bluebox::Compute::Flavor
+
+        def all
+          data = connection.get_products.body
+          load(data)
+        end
+
+        def get(product_id)
+          response = connection.get_product(product_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/image.rb
new file mode 100644
index 0000000..6347f55
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/image.rb
@@ -0,0 +1,19 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :description
+        attribute :public
+        attribute :created_at, :aliases => 'created'
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/images.rb
new file mode 100644
index 0000000..8472df7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/images.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/bluebox/models/compute/image'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Bluebox::Compute::Image
+
+        def all
+          data = connection.get_templates.body
+          load(data)
+        end
+
+        def get(template_id)
+          response = connection.get_template(template_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/server.rb
new file mode 100644
index 0000000..126926f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/server.rb
@@ -0,0 +1,123 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class BlockInstantiationError < StandardError; end
+
+      class Server < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:ssh_key, :public_key)
+        deprecate(:ssh_key=, :public_key=)
+        deprecate(:user, :username)
+        deprecate(:user=, :username=)
+
+        identity :id
+
+        attribute :cpu
+        attribute :description
+        attribute :flavor_id,   :aliases => :product, :squash => 'id'
+        attribute :hostname
+        attribute :image_id
+        attribute :ips
+        attribute :memory
+        attribute :status
+        attribute :storage
+        attribute :template
+
+        attr_accessor :password
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id ||= '94fd37a7-2606-47f7-84d5-9000deda52ae'
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.destroy_block(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          status == 'running'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_block(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id
+          options = if !password && !public_key
+            raise(ArgumentError, "password or public_key is required for this operation")
+          elsif public_key
+            {'ssh_public_key' => public_key}
+          elsif @password
+            {'password' => password}
+          end
+          options['username'] = username
+          data = connection.create_block(flavor_id, image_id, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :identity, :ips, :public_key, :username
+          Fog::SSH.new(ips.first['address'], username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :identity, :ips, :private_key, :username
+          Fog::SSH.new(ips.first['address'], username, :key_data => [private_key]).run(commands)
+        end
+
+        def username
+          @username ||= 'deploy'
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/servers.rb
new file mode 100644
index 0000000..1a4c321
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/models/compute/servers.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/bluebox/models/compute/server'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Bluebox::Compute::Server
+
+        def all
+          data = connection.get_blocks.body
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:key_data => [server.private_key])
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_block(server_id).body
+            new(server)
+          end
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/create_block.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/create_block.rb
new file mode 100644
index 0000000..71f278a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/create_block.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Create a new block
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of product to create block with
+        # * template_id<~Integer> - Id of template to create block with
+        # * options<~Hash>:
+        #     * password<~String> - Password for block
+        #   or
+        #     * ssh_key<~String> - ssh public key
+        #   * username<~String> - optional, defaults to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def create_block(product_id, template_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'POST',
+            :path     => '/api/blocks.json',
+            :query    => {'product' => product_id, 'template' => template_id}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_block(product_id, template_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/destroy_block.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/destroy_block.rb
new file mode 100644
index 0000000..ba1d12f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/destroy_block.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Destroy a block
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to destroy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def destroy_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_block(block_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_block.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_block.rb
new file mode 100644
index 0000000..ca33c79
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_block.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a block.
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def get_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_block(block_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_blocks.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_blocks.rb
new file mode 100644
index 0000000..1de0f15
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_blocks.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of blocks
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'ips'<~Array> - Ip addresses for the block
+        #     * 'id'<~String> - Id of the block
+        #     * 'storage'<~Integer> - Disk space quota for the block
+        #     * 'memory'<~Integer> - RAM quota for the block
+        #     * 'cpu'<~Float> - The fractional CPU quota for this block
+        #     * 'hostname'<~String> - The hostname for the block
+        def get_blocks
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/blocks.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_blocks
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_product.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_product.rb
new file mode 100644
index 0000000..d3cb34a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_product.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a product
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_product(product_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_products/#{product_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_product(product_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_products.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_products.rb
new file mode 100644
index 0000000..191ca36
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_products.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of products
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the product
+        #     * 'description'<~String> - Description of the product
+        #     * 'cost'<~Decimal> - Hourly cost of the product
+        def get_products
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_products.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_products
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_template.rb
new file mode 100644
index 0000000..024f654
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_template.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a template
+        #
+        # ==== Parameters
+        # * template_id<~Integer> - Id of template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_template(template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_templates/#{template_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_template(template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_templates.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_templates.rb
new file mode 100644
index 0000000..88ecc30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/get_templates.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of OS templates
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the image
+        #     * 'description'<~String> - Description of the image
+        #     * 'public'<~Boolean> - Public / Private image
+        #     * 'created'<~Datetime> - Timestamp of when the image was created
+        def get_templates
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_templates.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_templates
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/reboot_block.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/reboot_block.rb
new file mode 100644
index 0000000..e935d74
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/bluebox/requests/compute/reboot_block.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Reboot block
+        #
+        # ==== Parameters
+        # * block_id<~String> - Id of block to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def reboot_block(block_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "api/blocks/#{block_id}/#{'soft_' if type == 'SOFT'}reboot.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_block(block_id, type = 'SOFT')
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox.rb
new file mode 100644
index 0000000..90eb63c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox.rb
@@ -0,0 +1,9 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module Brightbox
+    extend Fog::Provider
+    service_path 'fog/brightbox'
+    service 'compute'
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/bin.rb
new file mode 100644
index 0000000..9f0cc14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/bin.rb
@@ -0,0 +1,29 @@
+class Brightbox < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Brightbox::Compute
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+    def account
+      @@connections[:compute].account
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/compute.rb
new file mode 100644
index 0000000..d5b81ee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/compute.rb
@@ -0,0 +1,144 @@
+module Fog
+  module Brightbox
+    class Compute < Fog::Service
+
+      API_URL = "https://api.gb1.brightbox.com/"
+
+      requires :brightbox_client_id, :brightbox_secret
+      recognizes :brightbox_auth_url, :brightbox_api_url
+
+      model_path 'fog/brightbox/models/compute'
+      model :account # Singular resource, no collection
+      collection :servers
+      model :server
+      collection :flavors
+      model :flavor
+      collection :images
+      model :image
+      collection :load_balancers
+      model :load_balancer
+      collection :zones
+      model :zone
+      collection :cloud_ips
+      model :cloud_ip
+      collection :users
+      model :user
+
+      request_path 'fog/brightbox/requests/compute'
+      request :add_nodes_load_balancer
+      request :create_api_client
+      request :create_cloud_ip
+      request :create_image
+      request :create_load_balancer
+      request :create_server
+      request :destroy_api_client
+      request :destroy_cloud_ip
+      request :destroy_image
+      request :destroy_load_balancer
+      request :destroy_server
+      request :get_account
+      request :get_api_client
+      request :get_cloud_ip
+      request :get_image
+      request :get_interface
+      request :get_load_balancer
+      request :get_server
+      request :get_server_type
+      request :get_user
+      request :get_zone
+      request :list_api_clients
+      request :list_cloud_ips
+      request :list_images
+      request :list_load_balancers
+      request :list_server_types
+      request :list_servers
+      request :list_users
+      request :list_zones
+      request :map_cloud_ip
+      request :remove_nodes_load_balancer
+      request :reset_ftp_password_account
+      request :resize_server
+      request :shutdown_server
+      request :snapshot_server
+      request :start_server
+      request :stop_server
+      request :unmap_cloud_ip
+      request :update_account
+      request :update_api_client
+      request :update_image
+      request :update_load_balancer
+      request :update_server
+      request :update_user
+
+      class Mock
+
+        def initialize(options)
+          @brightbox_client_id = options[:brightbox_client_id] || Fog.credentials[:brightbox_client_id]
+          @brightbox_secret = options[:brightbox_secret] || Fog.credentials[:brightbox_secret]
+        end
+
+        def request(options)
+          raise "Not implemented"
+        end
+      end
+
+      class Real
+
+        def initialize(options)
+          require "json"
+          # Currently authentication and api endpoints are the same but may change
+          @auth_url = options[:brightbox_auth_url] || Fog.credentials[:brightbox_auth_url] || API_URL
+          @api_url = options[:brightbox_api_url] || Fog.credentials[:brightbox_api_url] || API_URL
+          @brightbox_client_id = options[:brightbox_client_id] || Fog.credentials[:brightbox_client_id]
+          @brightbox_secret = options[:brightbox_secret] || Fog.credentials[:brightbox_secret]
+          @connection = Fog::Connection.new(@api_url)
+        end
+
+        def request(params)
+          begin
+            get_oauth_token if @oauth_token.nil?
+            response = authenticated_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            get_oauth_token
+            response = authenticated_request(params)
+          end
+          unless response.body.empty?
+            response = JSON.parse(response.body)
+          end
+        end
+
+        def account
+          Fog::Brightbox::Compute::Account.new(get_account)
+        end
+
+      private
+        def get_oauth_token(options = {})
+          auth_url = options[:brightbox_auth_url] || @auth_url
+
+          connection = Fog::Connection.new(auth_url)
+          @authentication_body = {'client_id' => @brightbox_client_id, 'grant_type' => 'none'}.to_json
+
+          response = connection.request({
+            :path => "/token",
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic " + Base64.encode64("#{@brightbox_client_id}:#{@brightbox_secret}").chomp,
+              'Content-Type' => 'application/json'
+            },
+            :method   => 'POST',
+            :body     => @authentication_body
+          })
+          @oauth_token = JSON.parse(response.body)["access_token"]
+          return @oauth_token
+        end
+
+        def authenticated_request(options)
+          headers = options[:headers] || {}
+          headers.merge!("Authorization" => "OAuth #{@oauth_token}")
+          options[:headers] = headers
+          @connection.request(options)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/account.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/account.rb
new file mode 100644
index 0000000..a24ca77
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/account.rb
@@ -0,0 +1,51 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Account < Fog::Model
+
+        identity :id
+        attribute :resource_type
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :address_1
+        attribute :address_2
+        attribute :city
+        attribute :county
+        attribute :postcode
+        attribute :country_code
+        attribute :country_name
+        attribute :vat_registration_number
+        attribute :telephone_number
+        attribute :telephone_verified
+        attribute :ram_limit
+        attribute :ram_used
+        attribute :limits_cloudips
+        attribute :library_ftp_host
+        attribute :library_ftp_user
+        # This is always returned as null/nil unless performing a reset_ftp_password request
+        attribute :library_ftp_password
+        attribute :created_at, :type => :time
+
+
+
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :clients
+        attribute :images
+        attribute :servers
+        attribute :users
+        attribute :zones
+
+        def reset_ftp_password
+          requires :identity
+          connection.reset_ftp_password_account(identity)["library_ftp_password"]
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ip.rb
new file mode 100644
index 0000000..56b6fab
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ip.rb
@@ -0,0 +1,47 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIp < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+        attribute :reverse_dns
+        attribute :public_ip
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :interface_id, :aliases => "interface", :squash => "id"
+        attribute :server_id, :aliases => "server", :squash => "id"
+
+        def map(interface_to_map)
+          requires :identity
+          connection.map_cloud_ip(identity, :interface => interface_to_map)
+        end
+
+        def mapped?
+          status == "mapped"
+        end
+
+        def unmap
+          requires :identity
+          connection.unmap_cloud_ip(identity)
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_cloud_ip(identity)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ips.rb
new file mode 100644
index 0000000..2a93e95
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/cloud_ips.rb
@@ -0,0 +1,34 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/cloud_ip'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIps < Fog::Collection
+
+        model Fog::Brightbox::Compute::CloudIp
+
+        def all
+          data = connection.list_cloud_ips
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_cloud_ip(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def allocate
+          data = connection.create_cloud_ip
+          new(data)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavor.rb
new file mode 100644
index 0000000..805b79b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavor.rb
@@ -0,0 +1,33 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+
+        attribute :handle
+
+        attribute :bits
+        attribute :cores
+        attribute :disk, :aliases => "disk_size"
+        attribute :ram
+
+        attribute :resource_type
+        attribute :description
+
+        def bits
+          0 # This is actually based on the Image type used. 32bit or 64bit Images are supported
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavors.rb
new file mode 100644
index 0000000..50c4b42
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/flavor'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Brightbox::Compute::Flavor
+
+        def all
+          data = connection.list_server_types
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_server_type(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/image.rb
new file mode 100644
index 0000000..4313eec
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/image.rb
@@ -0,0 +1,56 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :source
+        attribute :source_type
+
+        attribute :ancestor_id, :aliases => "ancestor", :squash => "id"
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :arch
+
+        attribute :resource_type
+        attribute :description
+        attribute :public
+        attribute :official
+        attribute :virtual_size
+        attribute :disk_size
+        attribute :created_at
+
+        def ready?
+          status == "available"
+        end
+
+        def save
+          requires :source, :arch
+          options = {
+            :source => source,
+            :arch => arch,
+            :name => name,
+            :description => description
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_image(options)
+          merge_attributes(data)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_image(identity)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/images.rb
new file mode 100644
index 0000000..55e7436
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/images.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/image'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Brightbox::Compute::Image
+
+        def all
+          data = connection.list_images
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_image(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancer.rb
new file mode 100644
index 0000000..55b184d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancer.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class LoadBalancer < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+
+        attribute :nodes
+        attribute :policy
+        attribute :healthcheck
+        attribute :listeners
+        attribute :account
+
+        def ready?
+          status == 'active'
+        end
+
+        def save
+          requires :nodes, :listeners, :healthcheck
+          options = {
+            :nodes => nodes,
+            :listeners => listeners,
+            :healthcheck => healthcheck,
+            :policy => policy,
+            :name => name
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_load_balancer(options)
+          merge_attributes(data)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_load_balancer(identity)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancers.rb
new file mode 100644
index 0000000..b71b450
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/load_balancers.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/load_balancer'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class LoadBalancers < Fog::Collection
+
+        model Fog::Brightbox::Compute::LoadBalancer
+
+        def all
+          data = connection.list_load_balancers
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_load_balancer(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/server.rb
new file mode 100644
index 0000000..4380bee
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/server.rb
@@ -0,0 +1,94 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :hostname
+        attribute :created_at, :type => :time
+        attribute :deleted_at, :type => :time
+        attribute :started_at, :type => :time
+        attribute :user_data
+
+        attribute :resource_type
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :image_id, :aliases => "image", :squash => "id"
+        attribute :flavor_id, :aliases => "server_type", :squash => "id"
+        attribute :zone_id, :aliases => "zone", :squash => "id"
+
+        attribute :snapshots
+        attribute :cloud_ips
+        attribute :interfaces
+
+        def snapshot
+          requires :identity
+          connection.snapshot_server(identity)
+        end
+
+        def reboot
+          false
+        end
+
+        def start
+          requires :identity
+          connection.start_server(identity)
+          true
+        end
+
+        def stop
+          requires :identity
+          connection.stop_server(identity)
+          true
+        end
+
+        def shutdown
+          requires :identity
+          connection.shutdown_server(identity)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_server(identity)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def ready?
+          status == 'active'
+        end
+
+        def save
+          requires :image_id
+          options = {
+            :image => image_id,
+            :server_type => flavor_id,
+            :name => name,
+            :zone => zone_id,
+            :user_data => user_data
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_server(options)
+          merge_attributes(data)
+          true
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/servers.rb
new file mode 100644
index 0000000..cbe2494
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/servers.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/server'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Brightbox::Compute::Server
+
+        def all
+          data = connection.list_servers
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_server(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/user.rb
new file mode 100644
index 0000000..8432b7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/user.rb
@@ -0,0 +1,39 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class User < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :resource_type
+        attribute :name
+        attribute :email_address
+        attribute :email_verified
+        attribute :ssh_key
+
+        attribute :account_id, :aliases => "default_account", :squash => "id"
+        attribute :accounts
+
+        def save
+          requires :identity
+
+          options = {
+            :email_address => email_address,
+            :ssh_key => ssh_key,
+            :name => name
+          }
+
+          data = connection.update_user(identity, options)
+          merge_attributes(data)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/users.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/users.rb
new file mode 100644
index 0000000..25fa39c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/users.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/user'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Users < Fog::Collection
+
+        model Fog::Brightbox::Compute::User
+
+        def all
+          data = connection.list_users
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_user(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zone.rb
new file mode 100644
index 0000000..e041561
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zone.rb
@@ -0,0 +1,21 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :handle
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zones.rb
new file mode 100644
index 0000000..529b6be
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/models/compute/zones.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/brightbox/models/compute/zone'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zones < Fog::Collection
+
+        model Fog::Brightbox::Compute::Zone
+
+        def all
+          data = connection.list_zones
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_zone(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/add_nodes_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/add_nodes_load_balancer.rb
new file mode 100644
index 0000000..5e4de85
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/add_nodes_load_balancer.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def add_nodes_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/add_nodes",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def add_nodes_load_balancer(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_api_client.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_api_client.rb
new file mode 100644
index 0000000..70ca4e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_api_client.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_api_client(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_api_client(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
new file mode 100644
index 0000000..e71f105
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_cloud_ip.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_cloud_ip(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_cloud_ip(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_image.rb
new file mode 100644
index 0000000..d020b76
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_image.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_image(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_load_balancer.rb
new file mode 100644
index 0000000..d58922b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_load_balancer.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_load_balancer(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_load_balancer(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_server.rb
new file mode 100644
index 0000000..fc70bc7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/create_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_server(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_api_client.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_api_client.rb
new file mode 100644
index 0000000..d2b2ade
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_api_client.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
new file mode 100644
index 0000000..d7b6e04
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_cloud_ip.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_image.rb
new file mode 100644
index 0000000..cb20d75
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_image.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_load_balancer.rb
new file mode 100644
index 0000000..e0ba81d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_load_balancer.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_load_balancer(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_server.rb
new file mode 100644
index 0000000..1b74d86
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/destroy_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def destroy_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_account.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_account.rb
new file mode 100644
index 0000000..0d21a24
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_account(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/account",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_account(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_api_client.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_api_client.rb
new file mode 100644
index 0000000..2a1ad8b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_api_client.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
new file mode 100644
index 0000000..e6688a9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_cloud_ip.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_image.rb
new file mode 100644
index 0000000..c855ff7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_image.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_interface.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_interface.rb
new file mode 100644
index 0000000..5e8c388
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_interface.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_interface(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/interfaces/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_interface(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_load_balancer.rb
new file mode 100644
index 0000000..48e0e46
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_load_balancer.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_load_balancer(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server.rb
new file mode 100644
index 0000000..cc8ed5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server_type.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server_type.rb
new file mode 100644
index 0000000..e710ece
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_server_type.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server_type(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_type(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_user.rb
new file mode 100644
index 0000000..d3e1401
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_user.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_user(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_zone.rb
new file mode 100644
index 0000000..8ff2334
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/get_zone.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_zone(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_api_clients.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_api_clients.rb
new file mode 100644
index 0000000..c7bf4f7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_api_clients.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_api_clients(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_api_clients(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_cloud_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
new file mode 100644
index 0000000..e2a8388
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_cloud_ips.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_cloud_ips(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_cloud_ips(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_images.rb
new file mode 100644
index 0000000..900d058
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_images.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_images(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_load_balancers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_load_balancers.rb
new file mode 100644
index 0000000..d95cc7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_load_balancers.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_load_balancers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/load_balancers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_load_balancers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_server_types.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_server_types.rb
new file mode 100644
index 0000000..728c797
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_server_types.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_server_types(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_server_types(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_servers.rb
new file mode 100644
index 0000000..1806b5d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_servers.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_servers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_users.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_users.rb
new file mode 100644
index 0000000..bcd933c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_users.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_users(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_users(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_zones.rb
new file mode 100644
index 0000000..a9e8738
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/list_zones.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_zones(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_zones(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/map_cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
new file mode 100644
index 0000000..401c4ea
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/map_cloud_ip.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def map_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/map",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def map_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/remove_nodes_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/remove_nodes_load_balancer.rb
new file mode 100644
index 0000000..c768f00
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/remove_nodes_load_balancer.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def remove_nodes_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/remove_nodes",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def remove_nodes_load_balancer(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
new file mode 100644
index 0000000..007abcf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/reset_ftp_password_account.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def reset_ftp_password_account(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'POST',
+            :path     => "/1.0/account/reset_ftp_password",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reset_ftp_password_account(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/resize_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/resize_server.rb
new file mode 100644
index 0000000..b22f36a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/resize_server.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def resize_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/resize",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def resize_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/shutdown_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/shutdown_server.rb
new file mode 100644
index 0000000..c25eee8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/shutdown_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def shutdown_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/shutdown",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def shutdown_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/snapshot_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/snapshot_server.rb
new file mode 100644
index 0000000..6a83aba
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/snapshot_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def snapshot_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/snapshot",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def snapshot_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/start_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/start_server.rb
new file mode 100644
index 0000000..6b7e132
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/start_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def start_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/start",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def start_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/stop_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/stop_server.rb
new file mode 100644
index 0000000..d5a78c9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/stop_server.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def stop_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/stop",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def stop_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
new file mode 100644
index 0000000..a7d4659
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/unmap_cloud_ip.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def unmap_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/unmap",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def unmap_cloud_ip(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_account.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_account.rb
new file mode 100644
index 0000000..f2158d1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_account.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_account(options = {})
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/account",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_account(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_api_client.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_api_client.rb
new file mode 100644
index 0000000..5cf001a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_api_client.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_api_client(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_image.rb
new file mode 100644
index 0000000..23d745e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_image.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_image(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_load_balancer.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_load_balancer.rb
new file mode 100644
index 0000000..6c67801
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_load_balancer.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [202],
+            :method   => 'PUT',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_load_balancer(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_server.rb
new file mode 100644
index 0000000..6b8d3b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_server.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_user.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_user.rb
new file mode 100644
index 0000000..5074f4f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/brightbox/requests/compute/update_user.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_user(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_user(identifier, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core.rb
new file mode 100644
index 0000000..dfa61c3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core.rb
@@ -0,0 +1,34 @@
+__LIB_DIR__ = File.expand_path(File.join(File.dirname(__FILE__), '..'))
+
+$LOAD_PATH.unshift __LIB_DIR__ unless
+  $LOAD_PATH.include?(__LIB_DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__LIB_DIR__))
+
+# external core dependencies
+require 'rubygems'
+require 'base64'
+require 'cgi'
+require 'excon'
+require 'formatador'
+require 'time'
+require 'timeout'
+
+# internal core dependencies
+require 'fog/core/attributes'
+require 'fog/core/collection'
+require 'fog/core/compute'
+require 'fog/core/connection'
+require 'fog/core/credentials'
+require 'fog/core/deprecation'
+require 'fog/core/dns'
+require 'fog/core/errors'
+require 'fog/core/hmac'
+require 'fog/core/model'
+require 'fog/core/mock'
+# require 'fog/core/parser'
+require 'fog/core/provider'
+require 'fog/core/service'
+require 'fog/core/ssh'
+require 'fog/core/storage'
+require 'fog/core/time'
+require 'fog/core/wait_for'
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/attributes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/attributes.rb
new file mode 100644
index 0000000..eaa145a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/attributes.rb
@@ -0,0 +1,178 @@
+module Fog
+  module Attributes
+    module ClassMethods
+
+      def _load(marshalled)
+        new(Marshal.load(marshalled))
+      end
+
+      def aliases
+        @aliases ||= {}
+      end
+
+      def attributes
+        @attributes ||= []
+      end
+
+      def attribute(name, options = {})
+        class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}
+            attributes[:#{name}]
+          end
+        EOS
+        case options[:type]
+        when :boolean
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = case new_#{name}
+              when 'true'
+                true
+              when 'false'
+                false
+              end
+            end
+          EOS
+        when :float
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_f
+            end
+          EOS
+        when :integer
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_i
+            end
+          EOS
+        when :string
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_s
+            end
+          EOS
+        when :time
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = if new_#{name}.nil? || new_#{name} == "" || new_#{name}.is_a?(Time)
+                new_#{name}
+              else
+                Time.parse(new_#{name})
+              end
+            end
+          EOS
+        when :array
+          class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}=(new_#{name})
+            attributes[:#{name}] = [*new_#{name}]
+          end
+          EOS
+        else
+          if squash = options[:squash]
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_data)
+                if new_data.is_a?(Hash)
+                  if new_data[:#{squash}] || new_data["#{squash}"]
+                    attributes[:#{name}] = new_data[:#{squash}] || new_data["#{squash}"]
+                  else
+                    attributes[:#{name}] = [ new_data ]
+                  end
+                else
+                  attributes[:#{name}] = new_data
+                end
+              end
+            EOS
+          else
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_#{name})
+                attributes[:#{name}] = new_#{name}
+              end
+            EOS
+          end
+        end
+        @attributes ||= []
+        @attributes |= [name]
+        for new_alias in [*options[:aliases]]
+          aliases[new_alias] = name
+        end
+      end
+
+      def identity(name, options = {})
+        @identity = name
+        self.attribute(name, options)
+      end
+
+      def ignore_attributes(*args)
+        @ignored_attributes = args
+      end
+
+      def ignored_attributes
+        @ignored_attributes ||= []
+      end
+
+    end
+
+    module InstanceMethods
+
+      def _dump
+        Marshal.dump(attributes)
+      end
+
+      def attributes
+        @attributes ||= {}
+      end
+
+      def identity
+        send(self.class.instance_variable_get('@identity'))
+      end
+
+      def identity=(new_identity)
+        send("#{self.class.instance_variable_get('@identity')}=", new_identity)
+      end
+
+      def merge_attributes(new_attributes = {})
+        for key, value in new_attributes
+          unless self.class.ignored_attributes.include?(key)
+            if aliased_key = self.class.aliases[key]
+              send("#{aliased_key}=", value)
+            elsif (public_methods | private_methods).detect {|method| ["#{key}=", :"#{key}="].include?(method)}
+              send("#{key}=", value)
+            else
+              attributes[key] = value
+            end
+          end
+        end
+        self
+      end
+
+      def new_record?
+        !identity
+      end
+
+      # check that the attributes specified in args exist and is not nil
+      def requires(*args)
+        missing = []
+        for arg in [:connection] | args
+          missing << arg unless send("#{arg}")
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, "#{missing.first} is required for this operation")
+          else
+            raise(ArgumentError, "#{missing[0...-1].join(", ")} and #{missing[-1]} are required for this operation")
+          end
+        end
+      end
+
+      private
+
+      def remap_attributes(attributes, mapping)
+        for key, value in mapping
+          if attributes.key?(key)
+            attributes[value] = attributes.delete(key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/bin.rb
new file mode 100644
index 0000000..a3d150e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/bin.rb
@@ -0,0 +1,87 @@
+require 'fog/core/credentials'
+
+module Fog
+  class << self
+
+    def providers
+      [
+        ::AWS,
+        ::Bluebox,
+        ::Brightbox,
+        ::GoGrid,
+        ::Google,
+        ::Linode,
+        ::Local,
+        ::NewServers,
+        ::Rackspace,
+        ::Slicehost,
+        ::Terremark,
+        ::Zerigo
+      ].select {|provider| provider.available?}
+    end
+
+    def modules
+      [
+        ::Vcloud
+      ].select {|_module_| _module_.initialized?}
+    end
+
+  end
+
+  class Bin
+    class << self
+
+      def available?
+        availability = true
+        for service in services
+          begin
+            service = self.class_for(service)
+            availability &&= service.requirements.all? { |requirement| Fog.credentials.include?(requirement) }
+          rescue ArgumentError => e
+            warning = "[yellow][WARN] #{e.message}[/]"
+            Formatador.display_line(warning)
+            availability = false
+          rescue => e
+            availability = false
+          end
+        end
+
+        if availability
+          for service in services
+            for collection in self.class_for(service).collections
+              unless self.respond_to?(collection)
+                self.class_eval <<-EOS, __FILE__, __LINE__
+                  def self.#{collection}
+                    self[:#{service}].#{collection}
+                  end
+                EOS
+              end
+            end
+          end
+        end
+
+        availability
+      end
+
+      def collections
+        services.map {|service| self[service].collections}.flatten.sort_by {|service| service.to_s}
+      end
+
+    end
+  end
+
+end
+
+require 'fog/aws/bin'
+require 'fog/bluebox/bin'
+require 'fog/brightbox/bin'
+require 'fog/go_grid/bin'
+require 'fog/google/bin'
+require 'fog/linode/bin'
+require 'fog/local/bin'
+require 'fog/new_servers/bin'
+require 'fog/rackspace/bin'
+require 'fog/slicehost/bin'
+require 'fog/terremark/bin'
+require 'fog/vcloud/bin'
+require 'fog/zerigo/bin'
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/collection.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/collection.rb
new file mode 100644
index 0000000..9f3658c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/collection.rb
@@ -0,0 +1,126 @@
+module Fog
+  class Collection < Array
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    Array.public_instance_methods(false).each do |method|
+      unless [:reject, :select].include?(method.to_sym)
+        class_eval <<-RUBY
+          def #{method}(*args)
+            unless @loaded
+              lazy_load
+            end
+            super
+          end
+        RUBY
+      end
+    end
+
+    %w[reject select].each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          data = super
+          result = self.clone.clear.concat(data)
+        end
+      RUBY
+    end
+
+    def self.model(new_model=nil)
+      if new_model == nil
+        @model
+      else
+        @model = new_model
+      end
+    end
+
+    attr_accessor :connection
+
+    remove_method :clear
+    def clear
+      @loaded = true
+      super
+    end
+
+    def create(attributes = {})
+      object = new(attributes)
+      object.save
+      object
+    end
+
+    def initialize(attributes = {})
+      @loaded = false
+      merge_attributes(attributes)
+    end
+
+    remove_method :inspect
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}\n"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+          data << "\n"
+        end
+        data << "#{Thread.current[:formatador].indentation}["
+        unless self.empty?
+          data << "\n"
+          Thread.current[:formatador].indent do
+            data << self.map {|member| member.inspect}.join(",\n")
+            data << "\n"
+          end
+          data << Thread.current[:formatador].indentation
+        end
+        data << "]\n"
+      end
+      data << "#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def load(objects)
+      clear
+      for object in objects
+        self << new(object)
+      end
+      self
+    end
+
+    def model
+      self.class.instance_variable_get('@model')
+    end
+
+    def new(attributes = {})
+      model.new(
+        attributes.merge(
+          :collection => self,
+          :connection => connection
+        )
+      )
+    end
+
+    def reload
+      clear
+      lazy_load
+      self
+    end
+
+    def table(attributes = nil)
+      Formatador.display_table(self.map {|instance| instance.attributes}, attributes)
+    end
+
+    def to_json
+      self.map {|member| member.attributes}.to_json
+    end
+
+    private
+
+    def lazy_load
+      self.all
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/compute.rb
new file mode 100644
index 0000000..116c977
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/compute.rb
@@ -0,0 +1,37 @@
+module Fog
+  class Compute
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/aws'
+        Fog::AWS::Compute.new(attributes)
+      when 'Bluebox'
+        require 'fog/bluebox'
+        Fog::Bluebox::Compute.new(attributes)
+      when 'Brightbox'
+        require 'fog/brightbox'
+        Fog::Brightbox::Compute.new(attributes)
+      when 'GoGrid'
+        require 'fog/go_grid'
+        Fog::GoGrid::Compute.new(attributes)
+      when 'Linode'
+        require 'fog/linode'
+        Fog::Linode::Compute.new(attributes)
+      when 'NewServers'
+        require 'fog/new_servers'
+        Fog::NewServers::Compute.new(attributes)
+      when 'Rackspace'
+        require 'fog/rackspace'
+        Fog::Rackspace::Compute.new(attributes)
+      when 'Slicehost'
+        require 'fog/slicehost'
+        Fog::Slicehost::Compute.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized compute provider")
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/connection.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/connection.rb
new file mode 100644
index 0000000..9a4d819
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/connection.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Connection
+
+    def initialize(url, persistent=false)
+      @excon = Excon.new(url)
+      @persistent = persistent
+    end
+
+    def request(params, &block)
+      unless @persistent
+        reset
+      end
+      unless block_given?
+        if (parser = params.delete(:parser))
+          body = Nokogiri::XML::SAX::PushParser.new(parser)
+          block = lambda { |chunk| body << chunk }
+        end
+      end
+
+      response = @excon.request(params, &block)
+
+      if parser
+        body.finish
+        response.body = parser.response
+      end
+
+      response
+    end
+
+    def reset
+      @excon.reset
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/credentials.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/credentials.rb
new file mode 100644
index 0000000..46dad80
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/credentials.rb
@@ -0,0 +1,87 @@
+require 'yaml'
+
+module Fog
+  require 'fog/core/deprecation'
+  extend Fog::Deprecation
+  self_deprecate(:config_path, :credentials_path)
+
+  # Assign a new credential to use from configuration file
+  #   @param [String, Symbol] new_credential name of new credential to use
+  #   @ return [String, Symbol] name of the new credential
+  def self.credential=(new_credential)
+    @credential = new_credential
+  end
+
+  # @return [String, Symbol] The credential to use in Fog
+  def self.credential
+    @credential ||= :default
+  end
+
+  # @return [String] The path for configuration_file
+  def self.credentials_path
+    @credential_path ||= File.expand_path(ENV["FOG_RC"] || '~/.fog')
+  end
+
+  # @return [String] The new path for credentials file
+  def self.credentials_path=(new_credentials_path)
+    @credential_path = new_credentials_path
+  end
+
+  # @return [Hash] The credentials pulled from the configuration file
+  # @raise [LoadError] Configuration unavailable in configuration file
+  def self.credentials
+    @credentials  ||= begin
+      if File.exists?(credentials_path)
+        credentials = YAML.load_file(credentials_path)
+        (credentials && credentials[credential]) or raise LoadError.new missing_credentials
+      else
+        {}
+      end
+    end
+  end
+
+private
+
+  # @return [String] The error message that will be raised, if credentials cannot be found
+  def self.missing_credentials
+    <<-YML
+Missing Credentials
+
+To run as '#{credential}', add the following to your resource config file: #{config_path}
+An alternate file may be used by placing its path in the FOG_RC environment variable
+
+#######################################################
+# Fog Credentials File
+#
+# Key-value pairs should look like:
+# :aws_access_key_id:                 022QF06E7MXBSAMPLE
+:#{credential}:
+  :aws_access_key_id:
+  :aws_secret_access_key:
+  :bluebox_api_key:
+  :bluebox_customer_id:
+  :brightbox_client_id:
+  :brightbox_secret:
+  :go_grid_api_key:
+  :go_grid_shared_secret:
+  :google_storage_access_key_id:
+  :google_storage_secret_access_key:
+  :local_root:
+  :new_servers_password:
+  :new_servers_username:
+  :public_key_path:
+  :private_key_path:
+  :rackspace_api_key:
+  :rackspace_username:
+  :slicehost_password:
+  :terremark_username:
+  :terremark_password:
+  :zerigo_email:
+  :zerigo_token:
+#
+# End of Fog Credentials File
+#######################################################
+
+YML
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/deprecation.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/deprecation.rb
new file mode 100644
index 0000000..6a156a1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/deprecation.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Deprecation
+
+    def deprecate(older, newer)
+      module_eval <<-EOS, __FILE__, __LINE__
+        def #{older}(*args)
+          Formatador.display_line("[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/] [light_black](#{caller.first})[/]")
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+    def self_deprecate(older, newer)
+      module_eval <<-EOS, __FILE__, __LINE__
+        def self.#{older}(*args)
+          Formatador.display_line("[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/] [light_black](#{caller.first})[/]")
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/dns.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/dns.rb
new file mode 100644
index 0000000..4130619
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/dns.rb
@@ -0,0 +1,25 @@
+module Fog
+  class DNS
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/aws'
+        Fog::AWS::DNS.new(attributes)
+      when 'Linode'
+        require 'fog/linode'
+        Fog::Linode::DNS.new(attributes)
+      when 'Slicehost'
+        require 'fog/slicehost'
+        Fog::Slicehost::DNS.new(attributes)
+      when 'Zerigo'
+        require 'fog/zerigo'
+        Fog::Zerigo::DNS.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized storage provider")
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/errors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/errors.rb
new file mode 100644
index 0000000..e42d9a0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/errors.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Errors
+
+    class Error < StandardError
+      attr_accessor :verbose
+
+      def self.slurp(error, message = nil)
+        new_error = new(message)
+        new_error.set_backtrace(error.backtrace)
+        new_error.verbose = error.message
+        new_error
+      end
+    end
+
+    class MockNotImplemented < Fog::Errors::Error; end
+
+    class NotFound < Fog::Errors::Error; end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/hmac.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/hmac.rb
new file mode 100644
index 0000000..8051947
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/hmac.rb
@@ -0,0 +1,48 @@
+module Fog
+  class HMAC
+
+    def initialize(type, key)
+      @key = key
+      case type
+      when 'sha1'
+        setup_sha1
+      when 'sha256'
+        setup_sha256
+      end
+    end
+
+    def sign(data)
+      @signer.call(data)
+    end
+
+    private
+
+    def setup_sha1
+      @digest = OpenSSL::Digest::Digest.new('sha1')
+      @signer = lambda do |data|
+        OpenSSL::HMAC.digest(@digest, @key, data)
+      end
+    end
+
+    def setup_sha256
+      begin
+        @digest = OpenSSL::Digest::Digest.new('sha256')
+        @signer = lambda do |data|
+          OpenSSL::HMAC.digest(@digest, @key, data)
+        end
+      rescue RuntimeError => error
+        unless error.message == 'Unsupported digest algorithm (sha256).'
+          raise error
+        else
+          require 'hmac-sha2'
+          @hmac = ::HMAC::SHA256.new(@key)
+          @signer = lambda do |data|
+            @hmac.update(data)
+            @hmac.digest
+          end
+        end
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/mock.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/mock.rb
new file mode 100644
index 0000000..fee1692
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/mock.rb
@@ -0,0 +1,68 @@
+module Fog
+
+  @mocking = false
+
+  def self.mock!
+    @mocking = true
+  end
+
+  def self.mock?
+    @mocking
+  end
+
+  def self.mocking?
+    @mocking
+  end
+
+  module Mock
+
+    @delay = 1
+    def self.delay
+      @delay
+    end
+
+    def self.delay=(new_delay)
+      raise ArgumentError, "delay must be non-negative" unless new_delay >= 0
+      @delay = new_delay
+    end
+
+    def self.not_implemented
+      raise Fog::Errors::MockNotImplemented.new("Contributions welcome!")
+    end
+
+    def self.random_base64(length)
+      random_selection(
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
+        length
+      )
+    end
+
+    def self.random_hex(length)
+      max = ('f' * length).to_i(16)
+      rand(max).to_s(16).rjust(length, '0')
+    end
+
+    def self.random_letters(length)
+      random_selection(
+        'abcdefghijklmnopqrstuvwxyz',
+        length
+      )
+    end
+
+    def self.random_numbers(length)
+      max = ('9' * length).to_i
+      rand(max).to_s
+    end
+
+    def self.random_selection(characters, length)
+      selection = ''
+      length.times do
+        position = rand(characters.length)
+        selection << characters[position..position]
+      end
+      selection
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/model.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/model.rb
new file mode 100644
index 0000000..bc3213d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/model.rb
@@ -0,0 +1,56 @@
+module Fog
+  class Model
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    attr_accessor :collection, :connection
+
+    def initialize(new_attributes = {})
+      merge_attributes(new_attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "\n#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+        end
+      end
+      data << "\n#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def reload
+      requires :identity
+      if data = collection.get(identity)
+        new_attributes = data.attributes
+        merge_attributes(new_attributes)
+        self
+      end
+    end
+
+    def to_json
+      attributes.to_json
+    end
+
+    def wait_for(timeout=600, interval=1, &block)
+      reload
+      Fog.wait_for(timeout, interval) do
+        retries = 3
+        if reload
+          retries = 3
+        elsif retries > 0
+          retries -= 1
+          sleep(1)
+        elsif retries == 0
+          raise Fog::Errors::Error.new("Reload failed, #{self.class} #{self.identity} went away.")
+        end
+        instance_eval(&block)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/parser.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/parser.rb
new file mode 100644
index 0000000..2cb7df3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/parser.rb
@@ -0,0 +1,93 @@
+module Fog
+  module Parsers
+    class Base < Nokogiri::XML::SAX::Document
+
+      attr_reader :response
+
+      def initialize
+        reset
+      end
+
+      def reset
+        @response = {}
+      end
+
+      def characters(string)
+        @value ||= ''
+        @value << string.strip
+      end
+
+      def start_element(name, attrs = [])
+        @value = nil
+      end
+
+    end
+  end
+end
+
+module Fog
+  class ToHashDocument < Nokogiri::XML::SAX::Document
+
+    def initialize
+      @stack = []
+    end
+
+    def characters(string)
+      @value ||= ''
+      @value << string.strip
+    end
+
+    def end_element(name)
+      last = @stack.pop
+      if last.empty? && @value.empty?
+        @stack.last[name.to_sym] = ''
+      elsif last == {:i_nil=>"true"}
+        @stack.last[name.to_sym] = nil
+      elsif !@value.empty?
+        @stack.last[name.to_sym] = @value
+      end
+      @value = ''
+    end
+
+    def body
+      @stack.first
+    end
+
+    def response
+      body
+    end
+
+    def start_element(name, attributes = [])
+      @value = ''
+      parsed_attributes = {}
+      until attributes.empty?
+        if attributes.first.is_a?(Array)
+          key, value = attributes.shift
+        else
+          key, value = attributes.shift, attributes.shift
+        end
+        parsed_attributes[key.gsub(':','_').to_sym] = value
+      end
+      if @stack.last.is_a?(Array)
+        @stack.last << {name.to_sym => parsed_attributes}
+      else
+        data = if @stack.empty?
+          @stack.push(parsed_attributes)
+          parsed_attributes
+        elsif @stack.last[name.to_sym]
+          unless @stack.last[name.to_sym].is_a?(Array)
+            @stack.last[name.to_sym] = [@stack.last[name.to_sym]]
+          end
+          @stack.last[name.to_sym] << parsed_attributes
+          @stack.last[name.to_sym].last
+        else
+          @stack.last[name.to_sym] = {}
+          @stack.last[name.to_sym].merge!(parsed_attributes)
+          @stack.last[name.to_sym]
+        end
+        @stack.push(data)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/provider.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/provider.rb
new file mode 100644
index 0000000..484a804
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/provider.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Provider
+
+    def service_path(new_path)
+      @service_path = new_path
+    end
+
+    def service(new_service)
+      services << new_service
+      require File.join(@service_path, new_service.to_s)
+    end
+
+    def services
+      @services ||= []
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/service.rb
new file mode 100644
index 0000000..ad1e8d1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/service.rb
@@ -0,0 +1,158 @@
+module Fog
+  class Service
+
+    class Error < Fog::Errors::Error; end
+    class NotFound < Fog::Errors::NotFound; end
+
+    module Collections
+
+      def collections
+        service.collections
+      end
+
+      def requests
+        service.requests
+      end
+
+    end
+
+    class << self
+
+      def inherited(child)
+        child.class_eval <<-EOS, __FILE__, __LINE__
+          module Collections
+            include Fog::Service::Collections
+
+            def service
+              #{child}
+            end
+          end
+
+          def self.service
+            #{child}
+          end
+        EOS
+      end
+
+      def new(options={})
+        # attempt to load credentials from config file
+        begin
+          default_credentials = Fog.credentials.reject {|key, value| !(recognized | requirements).include?(key)}
+          options = default_credentials.merge(options)
+        rescue LoadError
+          # if there are no configured credentials, do nothing
+        end
+
+        validate_options(options)
+        setup_requirements
+
+        if Fog.mocking?
+          service::Mock.send(:include, service::Collections)
+          service::Mock.new(options)
+        else
+          service::Real.send(:include, service::Collections)
+          service::Real.new(options)
+        end
+      end
+
+      def setup_requirements
+        if superclass.respond_to?(:setup_requirements)
+          superclass.setup_requirements
+        end
+
+        @required ||= false
+        unless @required
+          for collection in collections
+            require [@model_path, collection].join('/')
+            constant = collection.to_s.split('_').map {|characters| characters[0...1].upcase << characters[1..-1]}.join('')
+            service::Collections.module_eval <<-EOS, __FILE__, __LINE__
+              def #{collection}(attributes = {})
+                #{service}::#{constant}.new({:connection => self}.merge(attributes))
+              end
+            EOS
+          end
+          for model in models
+            require [@model_path, model].join('/')
+          end
+          for request in requests
+            require [@request_path, request].join('/')
+          end
+          @required = true
+        end
+      end
+
+      def model_path(new_path)
+        @model_path = new_path
+      end
+
+      def collection(new_collection)
+        collections << new_collection
+      end
+
+      def collections
+        @collections ||= []
+      end
+
+      def model(new_model)
+        models << new_model
+      end
+
+      def models
+        @models ||= []
+      end
+
+      def request_path(new_path)
+        @request_path = new_path
+      end
+
+      def request(new_request)
+        requests << new_request
+      end
+
+      def requests
+        @requests ||= []
+      end
+
+      def requires(*args)
+        requirements.concat(args)
+      end
+
+      def requirements
+        @requirements ||= []
+      end
+
+      def recognizes(*args)
+        recognized.concat(args)
+      end
+
+      def recognized
+        @recognized ||= []
+      end
+
+      def reset_data(keys=Mock.data.keys)
+        Mock.reset_data(keys)
+      end
+
+      def reset_data(keys=Mock.data.keys)
+        Mock.reset_data(keys)
+      end
+
+      def validate_options(options)
+        missing = requirements - options.keys
+        unless missing.empty?
+          raise ArgumentError, "Missing required arguments: #{missing.join(', ')}"
+        end
+
+        unless recognizes.empty?
+          unrecognized = options.keys - requirements - recognized
+          unless unrecognized.empty?
+            raise ArgumentError, "Unrecognized arguments: #{unrecognized.join(', ')}"
+          end
+        end
+      end
+
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/ssh.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/ssh.rb
new file mode 100644
index 0000000..0e24863
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/ssh.rb
@@ -0,0 +1,116 @@
+module Fog
+  module SSH
+
+    def self.new(address, username, options = {})
+      unless options[:key_data] || options[:keys] || options[:password]
+        raise ArgumentError.new(':key_data, :keys or :password are required to initialize SSH')
+      end
+      if Fog.mocking?
+        Fog::SSH::Mock.new(address, username, options)
+      else
+        Fog::SSH::Real.new(address, username, options)
+      end
+    end
+
+    def self.reset_data(keys=Mock.data.keys)
+      Mock.reset_data(keys)
+    end
+
+    class Mock
+
+      def self.data
+        @data ||= Hash.new do |hash, key|
+          hash[key] = {}
+        end
+      end
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options
+      end
+
+      def run(commands)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+    class Real
+
+      def initialize(address, username, options)
+        require 'net/ssh'
+        @address  = address
+        @username = username
+        @options  = { :paranoid => false }.merge(options)
+      end
+
+      def run(commands)
+        commands = [*commands]
+        results  = []
+        begin
+          Net::SSH.start(@address, @username, @options) do |ssh|
+            commands.each do |command|
+              escaped_command = command.sub(/'/, %{'"'"'})
+              result = Result.new(escaped_command)
+              ssh.open_channel do |ssh_channel|
+                ssh_channel.request_pty
+                ssh_channel.exec(%{bash -lc '#{escaped_command}'}) do |channel, success|
+                  unless success
+                    raise "Could not execute command: #{command.inspect}"
+                  end
+
+                  channel.on_data do |ch, data|
+                    result.stdout << data
+                  end
+
+                  channel.on_extended_data do |ch, type, data|
+                    next unless type == 1
+                    result.stderr << data
+                  end
+
+                  channel.on_request('exit-status') do |ch, data|
+                    result.status = data.read_long
+                  end
+
+                  channel.on_request('exit-signal') do |ch, data|
+                    result.status = 255
+                  end
+                end
+              end
+              ssh.loop
+              results << result
+            end
+          end
+        rescue Net::SSH::HostKeyMismatch => exception
+          exception.remember_host!
+          sleep 0.2
+          retry
+        end
+        results
+      end
+
+    end
+
+    class Result
+
+      attr_accessor :command, :stderr, :stdout, :status
+
+      def display_stdout
+        Formatador.display_line(stdout.split("\r\n"))
+      end
+
+      def display_stderr
+        Formatador.display_line(stderr.split("\r\n"))
+      end
+
+      def initialize(command)
+        @command = command
+        @stderr = ''
+        @stdout = ''
+      end
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/storage.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/storage.rb
new file mode 100644
index 0000000..c3d8724
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/storage.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Storage
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/aws'
+        Fog::AWS::Storage.new(attributes)
+      when 'Google'
+        require 'fog/google'
+        Fog::Google::Storage.new(attributes)
+      when 'Local'
+        require 'fog/local'
+        Fog::Local::Storage.new(attributes)
+      when 'Rackspace'
+        require 'fog/rackspace'
+        Fog::Rackspace::Storage.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized storage provider")
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/time.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/time.rb
new file mode 100644
index 0000000..23c81a0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/time.rb
@@ -0,0 +1,21 @@
+module Fog
+  class Time < ::Time
+    class << self
+
+      def now
+        ::Time.now - offset
+      end
+
+      def now=(new_now)
+        old_now = ::Time.now
+        @offset = old_now - new_now
+        new_now
+      end
+
+      def offset
+        @offset ||= 0
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/wait_for.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/wait_for.rb
new file mode 100644
index 0000000..3a9133b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/core/wait_for.rb
@@ -0,0 +1,17 @@
+module Fog
+
+  def self.wait_for(timeout=600, interval=1, &block)
+    duration = 0
+    start = Time.now
+    until yield || duration > timeout
+      sleep(interval)
+      duration = Time.now - start
+    end
+    if duration > timeout
+      false
+    else
+      { :duration => duration }
+    end
+  end
+  
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid.rb
new file mode 100644
index 0000000..7a1e63f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid.rb
@@ -0,0 +1,20 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module GoGrid
+
+    extend Fog::Provider
+
+    service_path 'fog/go_grid'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::GoGrid#new is deprecated, use Fog::GoGrid::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::GoGrid::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/bin.rb
new file mode 100644
index 0000000..8d07481
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/bin.rb
@@ -0,0 +1,31 @@
+class GoGrid < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute, :servers
+        Fog::GoGrid::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :servers
+          location = caller.first
+          warning = "[yellow][WARN] GoGrid[:servers] is deprecated, use GoGrid[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/compute.rb
new file mode 100644
index 0000000..f71b85b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/compute.rb
@@ -0,0 +1,103 @@
+module Fog
+  module GoGrid
+    class Compute < Fog::Service
+
+      requires :go_grid_api_key, :go_grid_shared_secret
+      recognizes :host, :path, :port, :scheme, :persistent
+
+      model_path 'fog/go_grid/models/compute'
+      model         :image
+      collection    :images
+      model         :server
+      collection    :servers
+
+      request_path 'fog/go_grid/requests/compute'
+      request :common_lookup_list
+      request :grid_image_get
+      request :grid_image_list
+      request :grid_ip_list
+      request :grid_loadbalancer_list
+      request :grid_server_add
+      request :grid_server_delete
+      request :grid_server_get
+      request :grid_server_list
+      request :grid_server_power
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+          @data = self.class.data[@go_grid_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'digest/md5'
+          require 'json'
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+          @host   = options[:host]    || "api.gogrid.com"
+          @path   = options[:path]    || "/api"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params = {
+            :expects  => 200,
+            :method   => 'GET'
+          }.merge!(params)
+
+          params[:query] ||= {}
+          params[:query].merge!({
+            'api_key' => @go_grid_api_key,
+            'format'  => 'json',
+            'sig'     => Digest::MD5.hexdigest("#{@go_grid_api_key}#{@go_grid_shared_secret}#{Time.now.to_i}"),
+            'v'       => '1.5'
+          })
+
+          begin
+            response = @connection.request(
+              params.merge!(:path => "#{@path}/#{params[:path]}")
+            )
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::GoGrid::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/image.rb
new file mode 100644
index 0000000..d93fe19
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/image.rb
@@ -0,0 +1,60 @@
+require 'fog/core/model'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :description
+        attribute :friendly_name, :aliases => 'friendlyName'
+        attribute :created_at,    :aliases => 'createdTime'
+        attribute :updated_at,    :aliases => 'updatedTime'
+        attribute :server_id,     :aliases => 'id'
+        attribute :state
+        attribute :price
+        attribute :location
+        attribute :billingtokens
+        attribute :os
+        attribute :architecture
+        attribute :type
+        attribute :active,        :aliases => 'isActive'
+        attribute :public,        :aliases => 'isPublic'
+        attribute :object_type,   :aliases => 'object'
+        attribute :owner
+
+
+        def server=(new_server)
+          requires :id
+
+          @server_id = new_server.id
+        end
+
+        def destroy
+          requires :id
+
+          connection.grid_server_delete(id)
+          true
+        end
+
+        def ready?
+          status == 'Available'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :server_id
+
+          data = connection.grid_server_add(server_id, 'name' => name)
+          merge_attributes(data.body['image'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/images.rb
new file mode 100644
index 0000000..6693386
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/images.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/go_grid/models/compute/image'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::GoGrid::Compute::Image
+
+        attribute :server
+
+        def all
+          data = connection.grid_image_list.body['list']
+          load(data)
+          if server
+            self.replace(self.select {|image| image.server_id == server.id})
+          end
+        end
+
+        def get(image_id)
+          response = connection.grid_image_get.body['list'][image_id]
+          new(data)
+        rescue Fog::GoGrid::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/server.rb
new file mode 100644
index 0000000..e80659a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/server.rb
@@ -0,0 +1,56 @@
+require 'fog/core/model'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class BlockInstantiationError < StandardError; end
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :image_id        # id or name
+        attribute :ip
+        attribute :memory       # server.ram
+        attribute :state
+        attribute :description  # Optional
+        attribute :sandbox      # Optional. Default: False
+
+        def initialize(attributes={})
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.grid_server_destroy(id)
+          true
+        end
+
+        def image
+          requires :image_id
+          connection.grid_image_get(image_id)
+        end
+
+        def ready?
+          @state == 'On'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :name, :image_id, :ip, :memory
+          options['isSandbox'] = sandbox if sandbox
+          options['server.ram'] = memory
+          options['image'] = image_id
+          data = connection.grid_server_add(name, image, ip, options)
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/servers.rb
new file mode 100644
index 0000000..fcc1d38
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/models/compute/servers.rb
@@ -0,0 +1,35 @@
+require 'fog/core/collection'
+require 'fog/go_grid/models/compute/server'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::GoGrid::Compute::Server
+
+        def all
+          data = connection.grid_server_list.body['list']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.grid_server_get(server_id).body['list']
+            new(server)
+          end
+        rescue Fog::GoGrid::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/common_lookup_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/common_lookup_list.rb
new file mode 100644
index 0000000..227461d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/common_lookup_list.rb
@@ -0,0 +1,36 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List options and lookups
+        #
+        # ==== Parameters
+        # * 'lookup'<~String> - the lookup to be listed
+        # * options<~Hash>:
+        #   * 'sort'<~String> - column to sort result by in ['description', 'id', 'name']
+        #   * 'asc'<~String>  - order to sort in ['true','false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def common_lookup_list(lookup, options={})
+          request(
+            :path     => 'common/lookup/list',
+            :query    => {'lookup' => lookup}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def common_lookup_list(lookup, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_get.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_get.rb
new file mode 100644
index 0000000..38a011d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_get.rb
@@ -0,0 +1,41 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'id'<~String>         - ID of the image
+        #   * 'name'<~String>       - Name of the image
+        #   * 'image'<~String>      - ID(s) or Name(s) of the images to retrive. Can be speicifed multiple times
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_image_get(options={})
+          request(
+            :path     => 'grid/image/get',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_image_get(options={})
+          #response = Excon::Response.new
+
+          #images = @data[:list].values
+          #for image in images
+          #  case image['state']
+          #  when 'Available'
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_list.rb
new file mode 100644
index 0000000..360a573
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_image_list.rb
@@ -0,0 +1,44 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isPublic'<~String>   - If true only returns public images, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #   * 'state'<~String>      - state to limit results to, in ['Saving', 'Available']
+        #   * 'type'<~String>       - image type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_image_list(options={})
+          request(
+            :path     => 'grid/image/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_image_list(options={})
+          #response = Excon::Response.new
+
+          #images = @data[:list].values
+          #for image in images
+          #  case image['state']
+          #  when 'Available'
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_ip_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_ip_list.rb
new file mode 100644
index 0000000..907c6e5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_ip_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List ips
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'ip.state'<~String>      - state to limit results to in ip.state
+        #   * 'ip.type'<~String>       - type to limit results to in ip.type
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_ip_list(options={})
+          request(
+            :path     => 'grid/ip/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_ip_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
new file mode 100644
index 0000000..7fecf61
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_loadbalancer_list.rb
@@ -0,0 +1,36 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List load balancers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_loadbalancer_list(options={})
+          request(
+            :path     => 'grid/loadbalancer/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_loadbalancer_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_add.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_add.rb
new file mode 100644
index 0000000..3870df8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_add.rb
@@ -0,0 +1,44 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * 'image'<~String>  - image to use, in grid_image_list
+        # * 'ip'<~String> - initial public ip for this server
+        # * 'name'<~String>   - name of the server, 20 or fewer characters
+        # * 'server_ram'<~String> - flavor to use, in common_lookup_list('server.ram')
+        # * 'options'<~Hash>:
+        #   * 'description'<~String>  - description of this server
+        #   * 'isSandbox'<~String>    - treat this server as image sandbox? in ['true', 'false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_add(image, ip, name, server_ram, options={})
+          request(
+            :path     => 'grid/server/add',
+            :query    => {
+              'image'       => image,
+              'ip'          => ip,
+              'name'        => name,
+              'server.ram'  => server_ram
+            }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_add(image, ip, name, server_ram, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_delete.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_delete.rb
new file mode 100644
index 0000000..a1fc331
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_delete.rb
@@ -0,0 +1,33 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Delete a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_delete(server)
+          request(
+            :path     => 'grid/server/delete',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_delete(server)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_get.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_get.rb
new file mode 100644
index 0000000..abee279
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_get.rb
@@ -0,0 +1,33 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Get one or more servers by name
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server(s) to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_get(servers)
+          request(
+            :path     => 'grid/server/get',
+            :query    => {'server' => [*servers]}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_get(servers)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_list.rb
new file mode 100644
index 0000000..5319b5c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isSandbox'<~String> - If true only  returns Image Sandbox servers, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #   * 'server.type'<~String> - server type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_list(options={})
+          request(
+            :path     => 'grid/server/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_power.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_power.rb
new file mode 100644
index 0000000..acbda1b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/go_grid/requests/compute/grid_server_power.rb
@@ -0,0 +1,34 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Start, Stop or Restart a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to power
+        # * 'power'<~String>  - power operation, in ['restart', 'start', 'stop']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_power(server, power)
+          request(
+            :path     => 'grid/server/power',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_server_power(server)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google.rb
new file mode 100644
index 0000000..2593ca6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google.rb
@@ -0,0 +1,27 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+module Fog
+  module Google
+
+    extend Fog::Provider
+
+    service_path 'fog/google'
+    service 'storage'
+
+    class Mock
+
+      def self.etag
+        hex(32)
+      end
+
+      def self.hex(length)
+        max = ('f' * length).to_i(16)
+        rand(max).to_s(16)
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/bin.rb
new file mode 100644
index 0000000..37c77db
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/bin.rb
@@ -0,0 +1,25 @@
+class Google < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :storage
+        Fog::Google::Storage
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directories.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directories.rb
new file mode 100644
index 0000000..cb31df0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directories.rb
@@ -0,0 +1,43 @@
+require 'fog/core/collection'
+require 'fog/google/models/storage/directory'
+
+module Fog
+  module Google
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Google::Storage::Directory
+
+        def all
+         data = connection.get_service.body['Buckets']
+         load(data)
+        end
+
+        def get(key, options = {})
+          remap_attributes(options, {
+            :delimiter  => 'delimiter',
+            :marker     => 'marker',
+            :max_keys   => 'max-keys',
+            :prefix     => 'prefix'
+          })
+          data = connection.get_bucket(key, options).body
+          directory = new(:key => data['Name'])
+          options = {}
+          for k, v in data
+            if ['CommonPrefixes', 'Delimiter', 'IsTruncated', 'Marker', 'MaxKeys', 'Prefix'].include?(k)
+              options[k] = v
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.load(data['Contents'])
+          directory
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directory.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directory.rb
new file mode 100644
index 0000000..d4ce67d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/directory.rb
@@ -0,0 +1,81 @@
+require 'fog/core/model'
+require 'fog/google/models/storage/files'
+
+module Fog
+  module Google
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key,           :aliases => ['Name', 'name']
+
+        attribute :creation_date, :aliases => 'CreationDate'
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def destroy
+          requires :key
+          connection.delete_bucket(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def files
+          @files ||= begin
+            Fog::Google::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :key
+          if connection.get_bucket_acl(key).body['AccessControlList'].detect {|entry| entry['Scope']['type'] == 'AllUsers' && entry['Permission'] == 'READ'}
+            if key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{key}.commondatastorage.googleapis.com"
+            else
+              "https://commondatastorage.googleapis.com/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save
+          requires :key
+          options = {}
+          if @acl
+            options['x-goog-acl'] = @acl
+          end
+          if @location
+            options['LocationConstraint'] = @location
+          end
+          connection.put_bucket(key, options)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/file.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/file.rb
new file mode 100644
index 0000000..4c16409
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/file.rb
@@ -0,0 +1,148 @@
+require 'fog/core/model'
+
+module Fog
+  module Google
+    class Storage
+
+      class File < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:size, :content_length)
+        deprecate(:size=, :content_length=)
+
+        identity  :key,             :aliases => 'Key'
+
+        attribute :cache_control,       :aliases => 'Cache-Control'
+        attribute :content_disposition, :aliases => 'Content-Disposition'
+        attribute :content_encoding,    :aliases => 'Content-Encoding'
+        attribute :content_length,      :aliases => ['Content-Length', 'Size']
+        attribute :content_md5,         :aliases => 'Content-MD5'
+        attribute :content_type,        :aliases => 'Content-Type'
+        attribute :etag,                :aliases => ['Etag', 'ETag']
+        attribute :expires,             :aliases => 'Expires'
+        attribute :last_modified,       :aliases => ['Last-Modified', 'LastModified']
+        attribute :metadata
+        attribute :owner,               :aliases => 'Owner'
+        attribute :storage_class,       :aliases => ['x-goog-storage-class', 'StorageClass']
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def body
+          attributes[:body] ||= if last_modified && (file = collection.get(identity))
+            file.body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def copy(target_directory_key, target_file_key)
+          requires :directory, :key
+          connection.copy_object(directory.key, key, target_directory_key, target_file_key)
+          target_directory = connection.directories.new(:key => target_directory_key)
+          target_directory.files.get(target_file_key)
+        end
+
+        def destroy
+          requires :directory, :key
+          begin
+            connection.delete_object(directory.key, key)
+          rescue Excon::Errors::NotFound
+          end
+          true
+        end
+
+        remove_method :metadata
+        def metadata
+          attributes.reject {|key, value| !(key.to_s =~ /^x-goog-meta-/)}
+        end
+
+        remove_method :metadata=
+        def metadata=(new_metadata)
+          merge_attributes(new_metadata)
+        end
+
+        remove_method :owner=
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if connection.get_object_acl(directory.key, key).body['AccessControlList'].detect {|entry| entry['Scope']['type'] == 'AllUsers' && entry['Permission'] == 'READ'}
+            if directory.key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{directory.key}.commondatastorage.googleapis.com/#{key}"
+            else
+              "https://commondatastorage.googleapis.com/#{directory.key}/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          if options != {}
+            Formatador.display_line("[yellow][WARN] options param is deprecated, use acl= instead[/] [light_black](#{caller.first})[/]")
+          end
+          options['x-goog-acl'] ||= @acl if @acl
+          options['Cache-Control'] = cache_control if cache_control
+          options['Content-Disposition'] = content_disposition if content_disposition
+          options['Content-Encoding'] = content_encoding if content_encoding
+          options['Content-MD5'] = content_md5 if content_md5
+          options['Content-Type'] = content_type if content_type
+          options['Expires'] = expires if expires
+          options.merge(metadata)
+
+          data = connection.put_object(directory.key, key, body, options)
+          merge_attributes(data.headers)
+          if body.is_a?(String)
+            self.content_length = body.size
+          else
+            self.content_length = ::File.size(body.path)
+          end
+          true
+        end
+
+        def url(expires)
+          requires :key
+          collection.get_url(key, expires)
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/files.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/files.rb
new file mode 100644
index 0000000..0eaaec6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/models/storage/files.rb
@@ -0,0 +1,79 @@
+require 'fog/core/collection'
+require 'fog/google/models/storage/file'
+
+module Fog
+  module Google
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :common_prefixes, :aliases => 'CommonPrefixes'
+        attribute :delimiter,       :aliases => 'Delimiter'
+        attribute :directory
+        attribute :is_truncated,    :aliases => 'IsTruncated'
+        attribute :marker,          :aliases => 'Marker'
+        attribute :max_keys,        :aliases => ['MaxKeys', 'max-keys']
+        attribute :prefix,          :aliases => 'Prefix'
+
+        model Fog::Google::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'delimiter'   => delimiter,
+            'marker'      => marker,
+            'max-keys'    => max_keys,
+            'prefix'      => prefix
+          }.merge!(options)
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            merge_attributes(parent.files.attributes)
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, options, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key, options)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/access_control_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/access_control_list.rb
new file mode 100644
index 0000000..06e603e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/access_control_list.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @in_entries = false
+            @entry = { 'Scope' => {} }
+            @response = { 'Owner' => {}, 'AccessControlList' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Entries'
+              @in_entries = true
+            when 'Scope'
+              key, value = attrs.first
+              @entry['Scope'][key] = value
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Entries'
+              @in_entries = false
+            when 'Entry'
+              @response['AccessControlList'] << @entry
+              @entry = { 'Scope' => {} }
+            when 'DisplayName', 'ID'
+              if @in_entries
+                @entry['Scope'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Permission'
+              @entry[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/copy_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/copy_object.rb
new file mode 100644
index 0000000..843ef79
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/copy_object.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class CopyObject < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'ETag'
+              @response[name] = @value.gsub('"', '')
+            when 'LastModified'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket.rb
new file mode 100644
index 0000000..d70d910
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucket < Fog::Parsers::Base
+
+          def reset
+            @object = { 'Owner' => {} }
+            @response = { 'Contents' => [], 'CommonPrefixes' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = false
+            when 'Contents'
+              @response['Contents'] << @object
+              @object = { 'Owner' => {} }
+            when 'DisplayName', 'ID'
+              @object['Owner'][name] = @value
+            when 'ETag'
+              @object[name] = @value.gsub('"', '')
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              @object['LastModified'] = Time.parse(@value)
+            when 'Marker', 'Name'
+              @response[name] = @value
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Prefix'
+              if @in_common_prefixes
+                @response['CommonPrefixes'] << @value
+              else
+                @response[name] = @value
+              end
+            when 'Size'
+              @object['Size'] = @value.to_i
+            when 'Delimiter', 'Key', 'StorageClass'
+              @object[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_logging.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_logging.rb
new file mode 100644
index 0000000..9d4672a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_logging.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @grant = { 'Grantee' => {} }
+            @response = { 'BucketLoggingStatus' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = @value
+              else
+                @response['Owner'][name] = @value
+              end
+            when 'Grant'
+              @response['BucketLoggingStatus']['LoggingEnabled']['TargetGrants'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'LoggingEnabled'
+              @response['BucketLoggingStatus']['LoggingEnabled'] = { 'TargetGrants' => [] }
+            when 'Permission'
+              @grant[name] = @value
+            when 'TargetBucket', 'TargetPrefix'
+              @response['BucketLoggingStatus'][name] = @value
+            when 'URI'
+              @grant['Grantee'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_object_versions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_object_versions.rb
new file mode 100644
index 0000000..4d522eb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_object_versions.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucketObjectVersions < Fog::Parsers::Base
+
+          def reset
+            @delete_marker = { 'Owner' => {} }
+            @version = { 'Owner' => {} }
+
+            @in_delete_marke = false
+            @in_version = false
+
+            @response = { 'Versions' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'DeleteMarker'
+              @in_delete_marker = true
+            when 'Version'
+              @in_version = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DeleteMarker'
+              @response['Versions'] << {'DeleteMarker' => @delete_marker }
+              @delete_marker = { 'Owner' => {} }
+              @in_delete_marker = false
+            when 'Version'
+              @response['Versions'] << {'Version' => @version }
+              @version = { 'Owner' => {} }
+              @in_version = false
+            when 'DisplayName', 'ID'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['Owner'][name] = @value
+            when 'ETag'
+              @version[name] = @value.gsub('"', '')
+            when 'IsLatest'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['IsLatest'] = if @value == 'true'
+                true
+              else
+                false
+              end
+            when 'IsTruncated'
+              if @value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['LastModified'] = Time.parse(@value)
+            when 'KeyMarker', 'Name', 'Prefix', 'VersionIdMarker'
+              @response[name] = @value
+            when 'MaxKeys'
+              @response['MaxKeys'] = @value.to_i
+            when 'Size'
+              @version['Size'] = @value.to_i
+            when 'Key', 'Name', 'StorageClass', 'VersionId'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_versioning.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_versioning.rb
new file mode 100644
index 0000000..607bfbf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_bucket_versioning.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucketVersioning < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VersioningConfiguration' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Status'
+              @response['VersioningConfiguration'][name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_request_payment.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_request_payment.rb
new file mode 100644
index 0000000..c633114
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_request_payment.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetRequestPayment < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'Payer'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_service.rb
new file mode 100644
index 0000000..29a4e6d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/parsers/storage/get_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetService < Fog::Parsers::Base
+
+          def reset
+            @bucket = {}
+            @response = { 'Owner' => {}, 'Buckets' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket'
+              @response['Buckets'] << @bucket
+              @bucket = {}
+            when 'CreationDate'
+              @bucket['CreationDate'] = Time.parse(@value)
+            when 'DisplayName', 'ID'
+              @response['Owner'][name] = @value
+            when 'Name'
+              @bucket[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/copy_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/copy_object.rb
new file mode 100644
index 0000000..fbc3f03
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/copy_object.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/google/parsers/storage/copy_object'
+
+        # Copy an object from one Google Storage bucket to another
+        #
+        # ==== Parameters
+        # * source_bucket_name<~String> - Name of source bucket
+        # * source_object_name<~String> - Name of source object
+        # * target_bucket_name<~String> - Name of bucket to create copy in
+        # * target_object_name<~String> - Name for new copy of object
+        # * options<~Hash>:
+        #   * 'x-goog-metadata-directive'<~String> - Specifies whether to copy metadata from source or replace with data in request.  Must be in ['COPY', 'REPLACE']
+        #   * 'x-goog-copy_source-if-match'<~String> - Copies object if its etag matches this value
+        #   * 'x-goog-copy_source-if-modified_since'<~Time> - Copies object it it has been modified since this time
+        #   * 'x-goog-copy_source-if-none-match'<~String> - Copies object if its etag does not match this value
+        #   * 'x-goog-copy_source-if-unmodified-since'<~Time> - Copies object it it has not been modified since this time
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #     * 'LastModified'<~Time> - date object was last modified
+        #
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          headers = { 'x-goog-copy-source' => "/#{source_bucket_name}/#{source_object_name}" }.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{target_bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::Google::Storage::CopyObject.new,
+            :path     => CGI.escape(target_object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          response = Excon::Response.new
+          source_bucket = @data[:buckets][source_bucket_name]
+          source_object = source_bucket && source_bucket[:objects][source_object_name]
+          target_bucket = @data[:buckets][target_bucket_name]
+
+          if source_object && target_bucket
+            response.status = 200
+            target_object = source_object.dup
+            target_object.merge!({
+              'Name' => target_object_name
+            })
+            target_bucket[:objects][target_object_name] = target_object
+            response.body = {
+              'ETag'          => target_object['ETag'],
+              'LastModified'  => Time.parse(target_object['LastModified'])
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_bucket.rb
new file mode 100644
index 0000000..73177aa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_bucket.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Delete an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_bucket(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_bucket(bucket_name)
+          response = Excon::Response.new
+          if @data[:buckets][bucket_name].nil?
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          elsif @data[:buckets][bucket_name] && !@data[:buckets][bucket_name][:objects].empty?
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          else
+            @data[:buckets].delete(bucket_name)
+            response.status = 204
+          end
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_object.rb
new file mode 100644
index 0000000..919ee5e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/delete_object.rb
@@ -0,0 +1,50 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Delete an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object to delete
+        # * object_name<~String> - Name of object to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_object(bucket_name, object_name)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_object(bucket_name, object_name)
+          response = Excon::Response.new
+          if bucket = @data[:buckets][bucket_name]
+            if object = bucket[:objects][object_name]
+              response.status = 204
+              bucket[:objects].delete(object_name)
+            else
+              response.status = 404
+              raise(Excon::Errors.status_error({:expects => 204}, response))
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket.rb
new file mode 100644
index 0000000..81c1bac
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket.rb
@@ -0,0 +1,111 @@
+require 'pp'
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/google/parsers/storage/get_bucket'
+
+        # List information about objects in an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'CommonPrefixes'<~Array> - Array of strings for common prefixes
+        #     * 'Contents'<~Array>:
+        #       * 'ETag'<~String>: Etag of object
+        #       * 'Key'<~String>: Name of object
+        #       * 'LastModified'<~String>: Timestamp of last modification of object
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'Size'<~Integer> - Size of object
+        #       * 'StorageClass'<~String> - Storage class of object
+        #
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Google::Storage::GetBucket.new,
+            :query    => options
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          response = Excon::Response.new
+          name = /(\w+\.?)*/.match(bucket_name)
+          if bucket_name == name.to_s
+            if bucket = @data[:buckets][bucket_name]
+              contents = bucket[:objects].values.sort {|x,y| x['Key'] <=> y['Key']}.reject do |object|
+                  (options['prefix'] && object['Key'][0...options['prefix'].length] != options['prefix']) ||
+                  (options['marker'] && object['Key'] <= options['marker'])
+                end.map do |object|
+                  data = object.reject {|key, value| !['ETag', 'Key', 'LastModified', 'Size', 'StorageClass'].include?(key)}
+                  data.merge!({
+                    'LastModified' => Time.parse(data['LastModified']),
+                    'Owner'        => bucket['Owner'],
+                    'Size'         => data['Size'].to_i
+                  })
+                data
+              end
+              max_keys = options['max-keys'] || 1000
+              size = [max_keys, 1000].min
+              truncated_contents = contents[0...size]
+
+              response.status = 200
+              response.body = {
+                'CommonPrefixes'  => [],
+                'Contents'        => truncated_contents,
+                'IsTruncated'     => truncated_contents.size != contents.size,
+                'Marker'          => options['marker'],
+                'Name'            => bucket['Name'],
+                'Prefix'          => options['prefix']
+              }
+              if options['max-keys'] && options['max-keys'] < response.body['Contents'].length
+                  response.body['IsTruncated'] = true
+                  response.body['Contents'] = response.body['Contents'][0...options['max-keys']]
+              end
+            else
+              response.status = 404
+              raise(Excon::Errors.status_error({:expects => 200}, response))
+            end
+          else
+              response.status = 400
+              raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket_acl.rb
new file mode 100644
index 0000000..b6e9e62
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_bucket_acl.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/google/parsers/storage/access_control_list'
+
+        # Get access control list for an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get access control list for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_bucket_acl(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::Google::Storage::AccessControlList.new,
+            :query      => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_acl(bucket_name)
+          response = Excon::Response.new
+          if acl = @data[:acls][:bucket][bucket_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object.rb
new file mode 100644
index 0000000..6fd879b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object.rb
@@ -0,0 +1,104 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          }, &block)
+        end
+
+      end
+
+      class Mock
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name]) && (object = bucket[:objects][object_name])
+            if options['If-Match'] && options['If-Match'] != object['ETag']
+              response.status = 412
+            elsif options['If-Modified-Since'] && options['If-Modified-Since'] > Time.parse(object['LastModified'])
+              response.status = 304
+            elsif options['If-None-Match'] && options['If-None-Match'] == object['ETag']
+              response.status = 304
+            elsif options['If-Unmodified-Since'] && options['If-Unmodified-Since'] < Time.parse(object['LastModified'])
+              response.status = 412
+            else
+              response.status = 200
+              response.headers = {
+                'Content-Length'  => object['Size'],
+                'Content-Type'    => object['Content-Type'],
+                'ETag'            => object['ETag'],
+                'Last-Modified'   => object['LastModified']
+              }
+              unless block_given?
+                response.body = object[:body]
+              else
+                data = StringIO.new(object[:body])
+                remaining = data.length
+                while remaining > 0
+                  chunk = data.read([remaining, Excon::CHUNK_SIZE].min)
+                  block.call(chunk)
+                  remaining -= Excon::CHUNK_SIZE
+                end
+              end
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_acl.rb
new file mode 100644
index 0000000..6f3f0dd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_acl.rb
@@ -0,0 +1,74 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/google/parsers/storage/access_control_list'
+
+        # Get access control list for an Google Storage object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get access control list for
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_acl(bucket_name, object_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::Google::Storage::AccessControlList.new,
+            :path       => CGI.escape(object_name),
+            :query      => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_object_acl(bucket_name, object_name)
+          response = Excon::Response.new
+          if acl = @data[:acls][:object][bucket_name] && @data[:acls][:object][bucket_name][object_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_torrent.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_torrent.rb
new file mode 100644
index 0000000..83b28cb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_torrent.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get torrent for an Google Storage object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get torrent for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of grantee
+        #             * 'ID'<~String> - Id of grantee
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_torrent(bucket_name, object_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :path       => CGI.escape(object_name),
+            :query      => {'torrent' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_object_object(bucket_name, object_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_url.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_url.rb
new file mode 100644
index 0000000..e755bea
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an expiring object url from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_service.rb
new file mode 100644
index 0000000..5b31c13
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/get_service.rb
@@ -0,0 +1,53 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/google/parsers/storage/get_service'
+
+        # List information about Google Storage buckets for authorized user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Buckets'<~Hash>:
+        #       * 'Name'<~String> - Name of bucket
+        #       * 'CreationTime'<~Time> - Timestamp of bucket creation
+        #     * 'Owner'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of bucket owner
+        #       * 'ID'<~String> - Id of bucket owner
+        def get_service
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => @host,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Google::Storage::GetService.new,
+            :url      => @host
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_service
+          response = Excon::Response.new
+          response.headers['Status'] = 200
+          buckets = @data[:buckets].values.map do |bucket|
+            bucket.reject do |key, value|
+              !['CreationDate', 'Name'].include?(key)
+            end
+          end
+          response.body = {
+            'Buckets' => buckets,
+            'Owner'   => { 'DisplayName' => 'owner', 'ID' => 'some_id'}
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/head_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/head_object.rb
new file mode 100644
index 0000000..30515f1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/head_object.rb
@@ -0,0 +1,64 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get headers for an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        def head_object(bucket_name, object_name, options={})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = options['If-Modified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = options['If-Unmodified-Since'].utc.strftime("%a, %d %b %Y %H:%M:%S +0000") if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'HEAD',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def head_object(bucket_name, object_name, options = {})
+          response = get_object(bucket_name, object_name, options)
+          response.body = nil
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket.rb
new file mode 100644
index 0000000..c2efd06
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket.rb
@@ -0,0 +1,76 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Create an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to create
+        # * options<~Hash> - config arguments for bucket.  Defaults to {}.
+        #   * 'LocationConstraint'<~Symbol> - sets the location for the bucket
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 200
+        def put_bucket(bucket_name, options = {})
+          if location_constraint = options.delete('LocationConstraint')
+            data =
+<<-DATA
+  <CreateBucketConfiguration>
+    <LocationConstraint>#{location_constraint}</LocationConstraint>
+  </CreateBucketConfiguration>
+DATA
+          else
+            data = nil
+          end
+          request({
+            :expects    => 200,
+            :body       => data,
+            :headers    => options,
+            :idempotent => true,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket(bucket_name, options = {})
+          if options['x-goog-acl']
+            unless ['private', 'public-read', 'public-read-write', 'authenticated-read']
+              raise Excon::Errors::BadRequest.new('invalid x-goog-acl')
+            else
+              @data[:acls][:bucket][bucket_name] = self.class.acls(options['x-goog-acl'])
+            end
+          end
+          response = Excon::Response.new
+          response.status = 200
+          bucket = {
+            :objects        => {},
+            'Name'          => bucket_name,
+            'CreationDate'  => Time.now,
+            'Owner'         => { 'DisplayName' => 'owner', 'ID' => 'some_id'},
+            'Payer'         => 'BucketOwner'
+          }
+          if options['LocationConstraint']
+            bucket['LocationConstraint'] = options['LocationConstraint']
+          else
+            bucket['LocationConstraint'] = ''
+          end
+          if @data[:buckets][bucket_name].nil?
+            @data[:buckets][bucket_name] = bucket
+          else
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket_acl.rb
new file mode 100644
index 0000000..bdb5bdf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_bucket_acl.rb
@@ -0,0 +1,81 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Change access control list for an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * scope<~Hash>:
+        #         * 'type'<~String> - 'UserById'
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'type'<~String> - 'UserByEmail'
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'type'<~String> - type of user to grant permission to
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        def put_bucket_acl(bucket_name, acl)
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket_acl(bucket_name, acl)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object.rb
new file mode 100644
index 0000000..b79ab7f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object.rb
@@ -0,0 +1,86 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Create an object in an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * data<~File> - File or String to create object from
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-Length'<~String> - Size of object in bytes (defaults to object.read.length)
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message (defaults to Base64 encoded MD5 of object.read)
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'x-goog-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-goog-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        def put_object(bucket_name, object_name, data, options = {})
+          data = parse_data(data)
+          headers = data[:headers].merge!(options)
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_object(bucket_name, object_name, data, options = {})
+          if options['x-goog-acl']
+            unless ['private', 'public-read', 'public-read-write', 'authenticated-read']
+              raise Excon::Errors::BadRequest.new('invalid x-goog-acl')
+            else
+              @data[:acls][:object][bucket_name] ||= {}
+              @data[:acls][:object][bucket_name][object_name] = self.class.acls(options['x-goog-acl'])
+            end
+          end
+          data = parse_data(data)
+          unless data[:body].is_a?(String)
+            data[:body] = data[:body].read
+          end
+          response = Excon::Response.new
+          if (bucket = @data[:buckets][bucket_name])
+            response.status = 200
+            object = {
+              :body           => data[:body],
+              'Content-Type'  => data[:headers]['Content-Type'],
+              'ETag'          => Fog::Google::Mock.etag,
+              'Key'           => object_name,
+              'LastModified'  => Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000"),
+              'Size'          => data[:headers]['Content-Length'],
+              'StorageClass'  => 'STANDARD'
+            }
+            bucket[:objects][object_name] = object
+            response.headers = {
+              'Content-Length'  => object['Size'],
+              'Content-Type'    => object['Content-Type'],
+              'ETag'            => object['ETag'],
+              'Last-Modified'   => object['LastModified']
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object_url.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object_url.rb
new file mode 100644
index 0000000..bdc4c6b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/requests/storage/put_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an expiring object url from Google Storage for putting an object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/storage.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/storage.rb
new file mode 100644
index 0000000..0304080
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/google/storage.rb
@@ -0,0 +1,243 @@
+module Fog
+  module Google
+    class Storage < Fog::Service
+
+      requires :google_storage_access_key_id, :google_storage_secret_access_key
+      recognizes :host, :port, :scheme, :persistent
+
+      model_path 'fog/google/models/storage'
+      collection  :directories
+      model       :directory
+      collection  :files
+      model       :file
+
+      request_path 'fog/google/requests/storage'
+      request :copy_object
+      request :delete_bucket
+      request :delete_object
+      request :get_bucket
+      request :get_bucket_acl
+      request :get_object
+      request :get_object_acl
+      request :get_object_torrent
+      request :get_object_url
+      request :get_service
+      request :head_object
+      request :put_bucket
+      request :put_bucket_acl
+      request :put_object
+      request :put_object_url
+
+      module Utils
+
+        def parse_data(data)
+          metadata = {
+            :body => nil,
+            :headers => {}
+          }
+
+          if data.is_a?(String)
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = metadata[:body].size.to_s
+          else
+            filename = ::File.basename(data.path)
+            unless (mime_types = MIME::Types.of(filename)).empty?
+              metadata[:headers]['Content-Type'] = mime_types.first.content_type
+            end
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = ::File.size(data.path).to_s
+          end
+          # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+          metadata
+        end
+
+        def url(params, expires)
+          params[:headers]['Date'] = expires.to_i
+          query = [params[:query]].compact
+          query << "GoogleAccessKeyId=#{@google_storage_access_key_id}"
+          query << "Signature=#{CGI.escape(signature(params))}"
+          query << "Expires=#{params[:headers]['Date']}"
+          path = CGI.escape(params[:path]).gsub('%2F', '/')
+          "http://#{params[:host]}/#{path}?#{query.join('&')}"
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.acls(type)
+          case type
+          when 'private'
+            @private ||= {
+              "AccessControlList"=> [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Scope" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0", "type" => "UserById"}
+                }
+              ],
+              "Owner" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read'
+            @public_read ||= begin
+              public_read = self.acls('private').dup
+              public_read['AccessControlList'] << {
+                "Permission" => "READ",
+                "Scope" => {"type" => "AllUsers"}
+              }
+              public_read
+            end
+          when 'public-read-write'
+            @public_read_write ||= begin
+              public_read_write = self.acls('private').dup
+              public_read_write['AccessControlList'] << {
+                "Permission" => "WRITE",
+                "Scope" => {"type" => "AllUsers"}
+              }
+              public_read_write
+            end
+          when 'authenticated-read'
+            @authenticated_read ||= begin
+              authenticated_read = self.acls('private').dup
+              authenticated_read['AccessControlList'] << {
+                "Permission" => "READ",
+                "Scope" => {"type" => "AllAuthenticatedUsers"}
+              }
+              authenticated_read
+            end
+          end
+        end
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :acls => {
+                :bucket => {},
+                :object => {}
+              },
+              :buckets => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          require 'mime/types'
+          @google_storage_access_key_id = options[:google_storage_access_key_id]
+          @data = self.class.data[@google_storage_access_key_id]
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+    
+      class Real
+        include Utils
+        extend Fog::Deprecation
+        deprecate(:reset, :reload)
+
+        # Initialize connection to Google Storage
+        #
+        # ==== Notes
+        # options parameter must include values for :google_storage_access_key_id and
+        # :google_storage_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   google_storage = Storage.new(
+        #     :google_storage_access_key_id => your_google_storage_access_key_id,
+        #     :google_storage_secret_access_key => your_google_storage_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * Storage object with connection to google.
+        def initialize(options={})
+          require 'mime/types'
+          @google_storage_access_key_id = options[:google_storage_access_key_id]
+          @google_storage_secret_access_key = options[:google_storage_secret_access_key]
+          @hmac = Fog::HMAC.new('sha1', @google_storage_secret_access_key)
+          @host = options[:host] || 'commondatastorage.googleapis.com'
+          @port   = options[:port]      || 443
+          @scheme = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent] || true)
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers]['Date'] = Time.now.utc.strftime("%a, %d %b %Y %H:%M:%S +0000")
+          params[:headers]['Authorization'] = "GOOG1 #{@google_storage_access_key_id}:#{signature(params)}"
+
+          response = @connection.request(params, &block)
+
+          response
+        end
+
+        def signature(params)
+          string_to_sign =
+<<-DATA
+#{params[:method]}
+#{params[:headers]['Content-MD5']}
+#{params[:headers]['Content-Type']}
+#{params[:headers]['Date']}
+DATA
+
+          google_headers, canonical_google_headers = {}, ''
+          for key, value in params[:headers]
+            if key[0..6] == 'x-goog-'
+              google_headers[key] = value
+            end
+          end
+
+          google_headers = google_headers.sort {|x, y| x[0] <=> y[0]}
+          for key, value in google_headers
+            canonical_google_headers << "#{key}:#{value}\n"
+          end
+          string_to_sign << "#{canonical_google_headers}"
+
+          subdomain = params[:host].split(".#{@host}").first
+          unless subdomain =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+            Formatador.display_line("[yellow][WARN] fog: the specified google storage bucket name(#{subdomain}) is not a valid dns name.  See: http://code.google.com/apis/storage/docs/developer-guide.html#naming[/]")
+            params[:host] = params[:host].split("#{subdomain}.")[-1]
+            if params[:path]
+              params[:path] = "#{subdomain}/#{params[:path]}"
+            else
+              params[:path] = "#{subdomain}"
+            end
+            subdomain = nil
+          end
+
+          canonical_resource  = "/"
+          unless subdomain.nil? || subdomain == @host
+            canonical_resource << "#{CGI.escape(subdomain).downcase}/"
+          end
+          canonical_resource << "#{params[:path]}"
+          canonical_resource << '?'
+          for key in (params[:query] || {}).keys
+            if ['acl', 'location', 'logging', 'requestPayment', 'torrent', 'versions', 'versioning'].include?(key)
+              canonical_resource << "#{key}&"
+            end
+          end
+          canonical_resource.chop!
+          string_to_sign << "#{canonical_resource}"
+
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode.rb
new file mode 100644
index 0000000..ffad05d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode.rb
@@ -0,0 +1,22 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module Linode
+
+    extend Fog::Provider
+
+    service_path 'fog/linode'
+    service 'compute'
+    service 'dns'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Linode#new is deprecated, use Fog::Linode::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Linode::Compute.new(attributes)
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/bin.rb
new file mode 100644
index 0000000..45333a9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/bin.rb
@@ -0,0 +1,33 @@
+class Linode < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Linode::Compute
+      when :dns
+        Fog::Linode::DNS
+      else
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :linode
+          location = caller.first
+          warning = "[yellow][WARN] Linode[:linode] is deprecated, use Linode[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute, :dns]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/compute.rb
new file mode 100644
index 0000000..a8903e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/compute.rb
@@ -0,0 +1,85 @@
+module Fog
+  module Linode
+    class Compute < Fog::Service
+
+      requires :linode_api_key
+      recognizes :port, :scheme, :persistent
+
+      model_path 'fog/linode/models/compute'
+
+      request_path 'fog/linode/requests/compute'
+      request :avail_datacenters
+      request :avail_distributions
+      request :avail_kernels
+      request :avail_linodeplans
+      request :avail_stackscripts
+      # request :linode_boot
+      request :linode_create
+      request :linode_delete
+      request :linode_list
+      request :linode_reboot
+      # request :linode_resize
+      # request :linode_shutdown
+      # request :linode_update
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @linode_api_key = options[:linode_api_key]
+          @data = self.class.data[@linode_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          @linode_api_key = options[:linode_api_key]
+          @host   = options[:host]    || "api.linode.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!(:api_key => @linode_api_key)
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+            if data = response.body['ERRORARRAY'].first
+              error = case data['ERRORCODE']
+              when 5
+                Fog::Linode::Compute::NotFound
+              else
+                Fog::Linode::Compute::Error
+              end
+              raise error.new(data['ERRORMESSAGE'])
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/dns.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/dns.rb
new file mode 100644
index 0000000..eea24fc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/dns.rb
@@ -0,0 +1,84 @@
+module Fog
+  module Linode
+    class DNS < Fog::Service
+
+      requires :linode_api_key
+      recognizes :port, :scheme, :persistent
+
+      model_path 'fog/linode/models/dns'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/linode/requests/dns'
+      request :domain_create
+      request :domain_delete
+      request :domain_list
+      request :domain_update
+      request :domain_resource_create
+      request :domain_resource_delete
+      request :domain_resource_list
+      request :domain_resource_update
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @linode_api_key = options[:linode_api_key]
+          @data = self.class.data[@linode_api_key]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          @linode_api_key = options[:linode_api_key]
+          @host   = options[:host]    || "api.linode.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!(:api_key => @linode_api_key)
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+            if data = response.body['ERRORARRAY'].first
+              error = case data['ERRORCODE']
+              when 5
+                Fog::Linode::DNS::NotFound
+              else
+                Fog::Linode::DNS::Error
+              end
+              raise error.new(data['ERRORMESSAGE'])
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/record.rb
new file mode 100644
index 0000000..300e634
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/record.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id,         :aliases => ['ResourceID', 'RESOURCEID']
+
+        attribute :ip,        :aliases => 'TARGET'
+        attribute :name,      :aliases => 'NAME'
+        attribute :priority,  :aliases => 'PRIORITY'
+        attribute :ttl,       :aliases => 'TTL_SEC'
+        attribute :type,      :aliases => 'TYPE'
+        attribute :zone_id,   :aliases => 'DOMAINID'
+
+        # "PROTOCOL":"",
+        # "WEIGHT":0,
+        # "PORT":0,
+
+        def initialize(attributes={})
+          self.ttl    ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity, :zone
+          connection.domain_resource_delete(zone.id, identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :type, :zone
+          options = {}
+          # * options<~Hash>
+          #   * weight<~Integer>: default: 5
+          #   * port<~Integer>: default: 80 
+          #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+          #                        types. default: udp
+          options[:name]      = name if name
+          options[:priority]  = priority if priority
+          options[:target]    = ip if ip
+          options[:ttl_sec]   = ttl if ttl
+          response = unless identity
+            connection.domain_resource_create(zone.identity, type, options)
+          else
+            options[:type] = type if type
+            connection.domain_resource_update(zone.identity, identity, options)
+          end
+          merge_attributes(response.body['DATA'])
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/records.rb
new file mode 100644
index 0000000..1cf4b21
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/records.rb
@@ -0,0 +1,37 @@
+require 'fog/core/collection'
+require 'fog/linode/models/dns/record'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Linode::DNS::Record
+
+        def all
+          requires :zone
+          data = connection.domain_resource_list(zone.id).body['DATA']
+          load(data)
+        end
+
+        def get(record_id)
+          if data = connection.domain_resource_list(zone.id, record_id).body['DATA'].first
+            new(data)
+          else
+            nil
+          end
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zone.rb
new file mode 100644
index 0000000..55e932e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zone.rb
@@ -0,0 +1,84 @@
+require 'fog/core/model'
+require 'fog/linode/models/dns/records'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id,           :aliases => ['DomainID', 'DOMAINID', 'ResourceID']
+
+        attribute :description, :aliases => 'DESCRIPTION'
+        attribute :domain,      :aliases => 'DOMAIN'
+        attribute :email,       :aliases => 'SOA_EMAIL'
+        attribute :ttl,         :aliases => 'TTL_SEC'
+        attribute :type,        :aliases => 'TYPE'
+
+        # "STATUS":1,
+        # "RETRY_SEC":0,
+        # "MASTER_IPS":"",
+        # "EXPIRE_SEC":0,
+        # "REFRESH_SEC":0,
+        # "TTL_SEC":0
+
+        def initialize(attributes={})
+          self.type ||= 'master'
+          self.ttl  ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.domain_delete(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Linode::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'ns1.linode.com',
+            'ns2.linode.com',
+            'ns3.linode.com',
+            'ns4.linode.com',
+            'ns5.linode.com'
+          ]
+        end
+
+        def save
+          requires :domain, :type
+          requires :email if type == 'master'
+          options = {}
+          # * options<~Hash>
+          #   * refresh_sec<~Integer> numeric, default: '0'
+          #   * retry_sec<~Integer> numeric, default: '0'
+          #   * expire_sec<~Integer> numeric, default: '0'
+          #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+          #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated
+          options[:description] = description if description
+          options[:soa_email]   = email if email
+          options[:ttl_sec]     = ttl if ttl
+          response = unless identity
+            connection.domain_create(domain, type, options)
+          else
+            options[:domain]  = domain if domain
+            options[:type]    = type if type
+            connection.domain_update(identity, options)
+          end
+          merge_attributes(response.body['DATA'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zones.rb
new file mode 100644
index 0000000..98e013b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/models/dns/zones.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/linode/models/dns/zone'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Linode::DNS::Zone
+
+        def all
+          data = connection.domain_list.body['DATA']
+          load(data)
+        end
+
+        def get(zone_id)
+          if data = connection.domain_list(zone_id).body['DATA'].first
+            new(data)
+          else
+            nil
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_datacenters.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_datacenters.rb
new file mode 100644
index 0000000..4517303
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_datacenters.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available data centers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_datacenters
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.datacenters' }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_datacenters
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_distributions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_distributions.rb
new file mode 100644
index 0000000..d61e382
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_distributions.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available distributions
+        #
+        # ==== Parameters
+        # * distributionId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_distributions(distribution_id=nil)
+          options = {}
+          if distribution_id
+            options.merge!(:distributionId => distribution_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.distributions' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_distributions(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_kernels.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_kernels.rb
new file mode 100644
index 0000000..f402fd8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_kernels.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available kernels
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * kernelId<~Integer>: id to limit results to
+        #   * isXen<~Integer>: if 1 limits results to only zen
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_kernels(options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.kernels' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_kernels(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_linodeplans.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_linodeplans.rb
new file mode 100644
index 0000000..fa268ce
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_linodeplans.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available plans
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_linodeplans(linodeplan_id = nil)
+          options = {}
+          if linodeplan_id
+            options.merge!(:planId => linodeplan_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.linodeplans' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_linodeplans(linodeplan_id = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_stackscripts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_stackscripts.rb
new file mode 100644
index 0000000..9570595
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/avail_stackscripts.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available stack scripts
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * distributionId<~Integer>: Limit the results to Stackscripts that can be applied to this distribution id
+        #   * distributionVendor<~String>: Debian, Ubuntu, Fedora, etc.
+        #   * keywords<~String>: Search terms
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_stackscripts(options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.stackscripts' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def avail_stackscripts(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_create.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_create.rb
new file mode 100644
index 0000000..4de8264
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_create.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Creates a linode and assigns you full privileges
+        #
+        # ==== Parameters
+        # * datacenter_id<~Integer>: id of datacenter to place new linode in
+        # * payment_term<~Integer>: Subscription term in months, in [1, 12, 24]
+        # * plan_id<~Integer>: id of plan to boot new linode with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_create(datacenter_id, payment_term, plan_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'linode.create',
+              :datacenterId => datacenter_id,
+              :paymentTerm  => payment_term,
+              :planId       => plan_id
+            }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_create(datacenter_id, payment_term, plan_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_delete.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_delete.rb
new file mode 100644
index 0000000..84938cb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_delete.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to delete
+        # * options<~Hash>:
+        #   * skipChecks<~Boolean>: skips safety checks and always deletes
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_delete(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.delete', :linodeId => linode_id }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_delete(linode_id, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_list.rb
new file mode 100644
index 0000000..3baf8d0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_list.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linodeId<~Integer>: Limit the list to the specified LinodeID
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_list(linode_id=nil)
+          options = {}
+          if linode_id
+            options.merge!(:linodeId => linode_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.list' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_list(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_reboot.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_reboot.rb
new file mode 100644
index 0000000..cc30baf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/compute/linode_reboot.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Issues a shutdown, and then a boot job for a given linode
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to reboot
+        # * options<~Hash>:
+        #   * configId<~Boolean>: id of config to boot server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_reboot(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.reboot', :linodeId => linode_id }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def linode_reboot(linode_id, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_create.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_create.rb
new file mode 100644
index 0000000..c17c8af
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_create.rb
@@ -0,0 +1,51 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Creates a domain record
+        #
+        # ==== Parameters
+        # * domain<~String>: The zone's name.  Note, if master zone, SOA_email is required and if slave
+        #                    master_ips is/are required
+        # * type<~String>: master or slave 
+        # * options<~Hash>
+        #   * description<~String> Currently undisplayed
+        #   * SOA_email<~String> Required when type=master
+        #   * refresh_sec<~Integer> numeric, default: '0'
+        #   * retry_sec<~Integer> numeric, default: '0'
+        #   * expire_sec<~Integer> numeric, default: '0'
+        #   * ttl_sec<~String> numeric, default: '0'
+        #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+        #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'DomainID'<~Integer>: domain ID
+        def domain_create(domain, type, options = {})
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.create',
+              :domain => domain,
+              :type  => type
+            }.merge!( options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_create(domain, type, options ={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_delete.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_delete.rb
new file mode 100644
index 0000000..012b2aa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_delete.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Delete the given domain from the list Linode hosts
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: id of domain to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        # TODO: docs
+        def domain_delete(domain_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.delete', :domainId => domain_id }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_delete(domain_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_list.rb
new file mode 100644
index 0000000..93ad2ed
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_list.rb
@@ -0,0 +1,50 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # List of domains (you have access to)
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * DATA<~Array>
+        #       * 'DOMAINID'<~Interger>
+        #       * 'SOA_EMAIL'<~String>
+        #       * 'DESCRIPTION'<~String>
+        #       * 'TTL_SEC'<~String>
+        #       * 'EXPIRE_SEC'<~Integer>
+        #       * 'RETRY_SEC'<~Integer>
+        #       * 'DOMAIN'<~String>
+        #       * 'STATUS'<~Integer>
+        #       * 'MASTER_IPS'<~String>
+        #       * 'REFRESH_SEC'<~Integer>
+        #       * 'TYPE'<~String>
+        def domain_list(domain_id = nil)
+          options = {}
+          if domain_id
+            options.merge!(:domainId => domain_id)
+          end
+          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.list' }.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_list(domain_id = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_create.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_create.rb
new file mode 100644
index 0000000..a5071b9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_create.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Creates a resource record in a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * type<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        # * options<~Hash>
+        #   * name<~String>: The hostname or FQDN. When Type=MX the subdomain to delegate to the 
+        #                    Target MX server
+        #   * target<~String> When Type=MX the hostname. When Type=CNAME the target of the alias.
+        #                    When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                    of '[remote_addr]' will be substituted with the IP address of the request. 
+        #   * priority<~Integer>: priority for MX and SRV records, 0-255 - default: 10 
+        #   * weight<~Integer>: default: 5
+        #   * port<~Integer>: default: 80 
+        #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+        #                        types. default: udp 
+        #   * ttl_sec<~Integer>: note, Linode will round the input to set values (300, 3600, 7200, etc)
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'ResourceID'<~Integer>: ID of the resource record created
+        def domain_resource_create(domain_id, type, options = {})
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.resource.create',
+              :domainID => domain_id,
+              :type  => type
+            }.merge!( options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_resource_create(domain_id, type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_delete.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_delete.rb
new file mode 100644
index 0000000..6b0a03f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_delete.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Delete the given resource from a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: id of domain resource belongs to
+        # * resource_id<~Integer>: id of resouce to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * resource_id<~Integer>:  resource id that was deleted
+        def domain_resource_delete(domain_id, resource_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.resource.delete', :domainId => domain_id, :resourceID => resource_id }
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_resource_delete(domain_id, resource_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_list.rb
new file mode 100644
index 0000000..6c0d8c3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_list.rb
@@ -0,0 +1,51 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # List of resource records for a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * resource_id<~Integer>: optional.  use if want only a specific resource record
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * DATA<~Array>
+        #       * 'PROTOCOL'<~String>:  for SRV records. default is UDP 
+        #       * 'TTL_SEC'<~Interger>: 
+        #       * 'PRIORITY'<~Interger>: for MX and SRV records
+        #       * 'TYPE'<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        #       * 'TARGET'<~String>: When Type=MX the hostname. When Type=CNAME the target of the alias. 
+        #                           When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                           of '[remote_addr]' will be substituted with the IP address of the request.
+        #       * 'WEIGHT'<~Interger>: 
+        #       * 'RESOURCEID'<~Interger>: ID of the resource record
+        #       * 'PORT'<~Interger>: 
+        #       * 'DOMAINID'<~Interger>: ID of the domain that this record belongs to
+        #       * 'NAME'<~Interger>: The hostname or FQDN. When Type=MX, the subdomain to delegate to        
+        def domain_resource_list(domain_id, resource_id = nil)
+          query = { :api_action => 'domain.resource.list', :domainID => domain_id }
+          if resource_id
+            query[:resourceID] = resource_id
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => query
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_resource_list(domain_id, resource_id = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_update.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_update.rb
new file mode 100644
index 0000000..bfd0628
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_resource_update.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Updates a resource record in a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * resource_id<~Integer>: id of resouce to delete
+        # * options<~Hash>
+        #   * type<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        #   * name<~String>: The hostname or FQDN. When Type=MX the subdomain to delegate to the 
+        #                    Target MX server
+        #   * target<~String> When Type=MX the hostname. When Type=CNAME the target of the alias. 
+        #                    When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                    of '[remote_addr]' will be substituted with the IP address of the request. 
+        #   * priority<~Integer>: priority for MX and SRV records, 0-255 - default: 10 
+        #   * weight<~Integer>: default: 5
+        #   * port<~Integer>: default: 80 
+        #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+        #                        types. default: udp 
+        #   * ttl_sec<~Integer>: note, Linode will round the input to set values (300, 3600, 7200, etc)
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'ResourceID'<~Integer>: ID of the resource record updated
+        def domain_resource_update(domain_id, resource_id, options = {})
+
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.resource.update',
+              :domainID => domain_id,
+              :resourceID => resource_id,
+            }.merge!( options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_resource_update(domain_id, resource_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_update.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_update.rb
new file mode 100644
index 0000000..3e8d25b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/linode/requests/dns/domain_update.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Update a domain record
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: The ID to identify the zone
+        # * options<~Hash>
+        #   * domain<~String>: The zone's name.  
+        #   * type<~String>: master or slave 
+        #   * description<~String> Currently undisplayed
+        #   * SOA_email<~String> Required when type=master
+        #   * refresh_sec<~Integer> numeric, default: '0'
+        #   * retry_sec<~Integer> numeric, default: '0'
+        #   * expire_sec<~Integer> numeric, default: '0'
+        #   * ttl_sec<~String> numeric, default: '0'
+        #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+        #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'DomainID'<~Integer>: domain ID
+        def domain_update(domain_id, options = {})
+          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.update', :domainId => domain_id }.merge!(options)
+          )
+
+        end
+
+      end
+
+      class Mock
+
+        def domain_update(domain_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local.rb
new file mode 100644
index 0000000..f85105a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local.rb
@@ -0,0 +1,20 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module Local
+
+    extend Fog::Provider
+
+    service_path 'fog/local'
+    service 'storage'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Local#new is deprecated, use Fog::Local::Storage#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Local::Storage.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/bin.rb
new file mode 100644
index 0000000..3ee8b83
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/bin.rb
@@ -0,0 +1,31 @@
+class Local < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :files, :storage
+        Fog::Local::Storage
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :files
+          location = caller.first
+          warning = "[yellow][WARN] Local[:files] is deprecated, use Local[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directories.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directories.rb
new file mode 100644
index 0000000..910584b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directories.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/local/models/storage/directory'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Local::Storage::Directory
+
+        def all
+          data = Dir.entries(connection.local_root).select do |entry|
+            entry[0...1] != '.' && ::File.directory?(connection.path_to(entry))
+          end.map do |entry|
+            {:key => entry}
+          end
+          load(data)
+        end
+
+        def get(key)
+          if ::File.directory?(connection.path_to(key))
+            new(:key => key)
+          else
+            nil
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directory.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directory.rb
new file mode 100644
index 0000000..4a1d4fc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/directory.rb
@@ -0,0 +1,60 @@
+require 'fog/core/model'
+require 'fog/local/models/storage/files'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key
+
+        def destroy
+          requires :key
+
+          if ::File.directory?(path)
+            Dir.rmdir(path)
+            true
+          else
+            false
+          end
+        end
+
+        def files
+          @files ||= begin
+            Fog::Local::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          nil
+        end
+
+        def save
+          requires :key
+
+          Dir.mkdir(path)
+          true
+        end
+
+        private
+
+        def path
+          connection.path_to(key)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/file.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/file.rb
new file mode 100644
index 0000000..efff3e0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/file.rb
@@ -0,0 +1,75 @@
+require 'fog/core/model'
+
+module Fog
+  module Local
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attribute :content_length,  :aliases => 'Content-Length'
+        # attribute :content_type,    :aliases => 'Content-Type'
+        attribute :last_modified,   :aliases => 'Last-Modified'
+
+        def body
+          attributes[:body] ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          ::File.delete(path)
+          true
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          nil
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          file = ::File.new(path, 'w')
+          if body.is_a?(String)
+            file.write(body)
+          else
+            file.write(body.read)
+          end
+          file.close
+          merge_attributes(
+            :content_length => ::File.size(path),
+            :last_modified  => ::File.mtime(path)
+          )
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+        def path
+          connection.path_to(::File.join(directory.key, CGI.escape(key)))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/files.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/files.rb
new file mode 100644
index 0000000..53ab05d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/models/storage/files.rb
@@ -0,0 +1,84 @@
+require 'fog/core/collection'
+require 'fog/local/models/storage/file'
+
+module Fog
+  module Local
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+
+        model Fog::Local::Storage::File
+
+        def all
+          requires :directory
+          if directory.collection.get(directory.key)
+            data = Dir.entries(connection.path_to(directory.key)).select do |key|
+              key[0...1] != '.' && !::File.directory?(connection.path_to(key))
+            end.map do |key|
+              path = file_path(key)
+              {
+                :content_length => ::File.size(path),
+                :key            => CGI.unescape(key),
+                :last_modified  => ::File.mtime(path)
+              }
+            end
+            load(data)
+          else
+            nil
+          end
+        end
+
+        def get(key, &block)
+          requires :directory
+          path = file_path(CGI.escape(key))
+          if ::File.exists?(path)
+            data = {
+              :content_length => ::File.size(path),
+              :key            => key,
+              :last_modified  => ::File.mtime(path)
+            }
+            if block_given?
+              file = ::File.open(path)
+              while (chunk = file.read(Excon::CHUNK_SIZE)) && yield(chunk); end
+              file.close
+              new(data)
+            else
+              body = ::File.read(path)
+              new(data.merge!(:body => body))
+            end
+          else
+            nil
+          end
+        end
+
+        def head(key)
+          requires :directory
+          path = file_path(CGI.escape(key))
+          if ::File.exists?(path)
+            new({
+              :content_length => ::File.size(path),
+              :key            => key,
+              :last_modified  => ::File.mtime(path)
+            })
+          else
+            nil
+          end
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+        private
+
+        def file_path(key)
+          connection.path_to(::File.join(directory.key, key))
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/storage.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/storage.rb
new file mode 100644
index 0000000..13419b2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/local/storage.rb
@@ -0,0 +1,58 @@
+module Fog
+  module Local
+    class Storage < Fog::Service
+
+      requires :local_root
+
+      model_path 'fog/local/models/storage'
+      collection  :directories
+      model       :directory
+      model       :file
+      collection  :files
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @local_root = ::File.expand_path(options[:local_root])
+          @data       = self.class.data[@local_root]
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path_to(partial)
+          ::File.join(@local_root, partial)
+        end
+      end
+
+      class Real
+
+        def initialize(options={})
+          @local_root = ::File.expand_path(options[:local_root])
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path_to(partial)
+          ::File.join(@local_root, partial)
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers.rb
new file mode 100644
index 0000000..935efea
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers.rb
@@ -0,0 +1,23 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+module Fog
+  module NewServers
+
+    extend Fog::Provider
+
+    service_path 'fog/new_servers'
+    service 'compute'
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::NewServers#new is deprecated, use Fog::NewServers::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::NewServers::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/bin.rb
new file mode 100644
index 0000000..64898b7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/bin.rb
@@ -0,0 +1,31 @@
+class NewServers < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute, :new_servers
+        Fog::NewServers::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :new_servers
+          location = caller.first
+          warning = "[yellow][WARN] NewServers[:servers] is deprecated, use NewServers[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/compute.rb
new file mode 100644
index 0000000..70aafba
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/compute.rb
@@ -0,0 +1,88 @@
+require 'fog/core/parser'
+
+module Fog
+  module NewServers
+    class Compute < Fog::Service
+
+      requires :new_servers_password, :new_servers_username
+      recognizes :host, :port, :scheme, :persistent
+
+      model_path 'fog/new_servers/models/compute'
+
+      request_path 'fog/new_servers/requests/compute'
+      request :add_server
+      request :cancel_server
+      request :get_server
+      request :list_images
+      request :list_plans
+      request :list_servers
+      request :reboot_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @new_server_username = options[:new_servers_username]
+          @data = self.class.data[@new_server_username]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @new_servers_password = options[:new_servers_password]
+          @new_servers_username = options[:new_servers_username]
+          @host   = options[:host]    || "noc.newservers.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!({
+            :password => @new_servers_password,
+            :username => @new_servers_username
+          })
+          params[:headers] ||= {}
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::NewServers::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/add_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/add_server.rb
new file mode 100644
index 0000000..1ad5770
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/add_server.rb
@@ -0,0 +1,41 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Boot a new server
+        #
+        # ==== Parameters
+        # * planId<~String> - The id of the plan to boot the server with
+        # * options<~Hash>: optional extra arguments
+        #   * imageId<~String>  - Optional image to boot server from
+        #   * name<~String>     - Name to boot new server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def add_server(plan_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/addServer',
+            :query    => {'planId' => plan_id}.merge!(options)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def add_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/cancel_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/cancel_server.rb
new file mode 100644
index 0000000..e81b551
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/cancel_server.rb
@@ -0,0 +1,38 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Shutdown a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to shutdown
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def cancel_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/cancelServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def cancel_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/get_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/get_server.rb
new file mode 100644
index 0000000..ffa24a2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/get_server.rb
@@ -0,0 +1,44 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * server<~Hash>:
+        #     * 'id'<~String>     - Id of the server
+        #     * 'ip'<~Hash>:
+        #       * 'address'<~String>  - Address of the ip
+        #       * 'name'<~String>     - Name of the ip
+        #     * 'login'<~Hash>:
+        #       * 'name'<~String>     - Name of the login
+        #       * 'password'<~String> - Password of the login
+        #       * 'username'<~String> - Username of the login
+        #     * 'name'<~String>   - Name of the server
+        #     * 'notes'<~String>  - Notes about the server
+        #     * 'state'<~String>  - State of the server
+        #
+        def get_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/getServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_images.rb
new file mode 100644
index 0000000..bf70fb2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_images.rb
@@ -0,0 +1,35 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String>  - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'size'<~String> - Size of the image
+        #
+        def list_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listImages'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_plans.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_plans.rb
new file mode 100644
index 0000000..bd30286
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_plans.rb
@@ -0,0 +1,38 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List available plans
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of the plan
+        #     * 'id'<~String>     - Id of the plan
+        #     * 'name'<~String>   - Name of the plan
+        #     * 'rate'<~String>   - Cost per hour of the plan
+        #     * 'os'<~String>     - Operating system of the plan
+        #     * 'config'<~String> - Configuration of the plan
+        #
+        def list_plans
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listPlans'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_plans
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_servers.rb
new file mode 100644
index 0000000..d4d0a14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/list_servers.rb
@@ -0,0 +1,44 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * server<~Hash>:
+        #       * 'id'<~String>     - Id of the server
+        #       * 'ip'<~Hash>:
+        #         * 'address'<~String>  - Address of the ip
+        #         * 'name'<~String>     - Name of the ip
+        #       * 'login'<~Hash>:
+        #         * 'name'<~String>     - Name of the login
+        #         * 'password'<~String> - Password of the login
+        #         * 'username'<~String> - Username of the login
+        #       * 'name'<~String>   - Name of the server
+        #       * 'notes'<~String>  - Notes about the server
+        #       * 'state'<~String>  - State of the server
+        #
+        def list_servers
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listServers'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/reboot_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/reboot_server.rb
new file mode 100644
index 0000000..5bcb197
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/new_servers/requests/compute/reboot_server.rb
@@ -0,0 +1,32 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Reboot a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to reboot
+        #
+        def reboot_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/rebootServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_server(server_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace.rb
new file mode 100644
index 0000000..e19285a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace.rb
@@ -0,0 +1,36 @@
+require File.join(File.dirname(__FILE__), 'core')
+
+module Fog
+  module Rackspace
+    
+    extend Fog::Provider
+
+    service_path 'fog/rackspace'
+    service 'cdn'
+    service 'compute'
+    service 'files'
+    service 'servers'
+    service 'storage'
+
+    def self.authenticate(options)
+      rackspace_auth_url = options[:rackspace_auth_url] || "auth.api.rackspacecloud.com"
+      connection = Fog::Connection.new("https://" + rackspace_auth_url)
+      @rackspace_api_key  = options[:rackspace_api_key]
+      @rackspace_username = options[:rackspace_username]
+      response = connection.request({
+        :expects  => 204,
+        :headers  => {
+          'X-Auth-Key'  => @rackspace_api_key,
+          'X-Auth-User' => @rackspace_username
+        },
+        :host     => rackspace_auth_url,
+        :method   => 'GET',
+        :path     => 'v1.0'
+      })
+      response.headers.reject do |key, value|
+        !['X-Server-Management-Url', 'X-Storage-Url', 'X-CDN-Management-Url', 'X-Auth-Token'].include?(key)
+      end
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/bin.rb
new file mode 100644
index 0000000..61460a0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/bin.rb
@@ -0,0 +1,45 @@
+class Rackspace < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :cdn
+        Fog::Rackspace::CDN
+      when :compute, :servers
+        Fog::Rackspace::Compute
+      when :files, :storage
+        Fog::Rackspace::Storage
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        klazz = class_for(key)
+        hash[key] = case key
+        when :files
+          location = caller.first
+          warning = "[yellow][WARN] Rackspace[:files] is deprecated, use Rackspace[:storage] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          klazz.new
+        when :servers
+          location = caller.first
+          warning = "[yellow][WARN] Rackspace[:servers] is deprecated, use Rackspace[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+          klazz.new
+        else
+          klazz.new
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:cdn, :compute, :storage]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/cdn.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/cdn.rb
new file mode 100644
index 0000000..b3ed311
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/cdn.rb
@@ -0,0 +1,82 @@
+module Fog
+  module Rackspace
+    class CDN < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :persistent
+
+      model_path 'fog/rackspace/models/cdn'
+
+      request_path 'fog/rackspace/requests/cdn'
+      request :get_containers
+      request :head_container
+      request :put_container
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @rackspace_username = options[:rackspace_username]
+          @data = self.class.data[@rackspace_username]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+
+          uri = URI.parse(credentials['X-CDN-Management-Url'])
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @cdn_connection.reset
+        end
+
+        def request(params, parse_json = true)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+            }))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/compute.rb
new file mode 100644
index 0000000..a07d8a6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/compute.rb
@@ -0,0 +1,113 @@
+module Fog
+  module Rackspace
+    class Compute < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :persistent
+
+      model_path 'fog/rackspace/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/rackspace/requests/compute'
+      request :confirm_resized_server
+      request :create_image
+      request :create_server
+      request :delete_image
+      request :delete_server
+      request :get_flavor_details
+      request :get_image_details
+      request :get_server_details
+      request :list_addresses
+      request :list_private_addresses
+      request :list_public_addresses
+      request :list_flavors
+      request :list_flavors_detail
+      request :list_images
+      request :list_images_detail
+      request :list_servers
+      request :list_servers_detail
+      request :reboot_server
+      request :revert_resized_server
+      request :resize_server
+      request :server_action
+      request :update_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :last_modified => {
+                :images  => {},
+                :servers => {}
+              },
+              :images  => {},
+              :servers => {}
+            }
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @rackspace_username = options[:rackspace_username]
+          @data = self.class.data[@rackspace_username]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+          uri = URI.parse(credentials['X-Server-Management-Url'])
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}"
+            }))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/files.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/files.rb
new file mode 100644
index 0000000..78bdc56
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/files.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Rackspace
+    class Files
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::Rackspace::Files#new is deprecated, use Fog::Rackspace::Storage#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::Rackspace::Storage.new(attributes)
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavor.rb
new file mode 100644
index 0000000..4e4f9e8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavor.rb
@@ -0,0 +1,43 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+        def bits
+          64
+        end
+
+        def cores
+          # 2 quad-cores >= 2Ghz = 8 cores
+          8 * case ram
+          when 256
+            1/64.0
+          when 512
+            1/32.0
+          when 1024
+            1/16.0
+          when 2048
+            1/8.0
+          when 4096
+            1/4.0
+          when 8192
+            1/2.0
+          when 15872
+            1
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavors.rb
new file mode 100644
index 0000000..24425f4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/rackspace/models/compute/flavor'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Rackspace::Compute::Flavor
+
+        def all
+          data = connection.list_flavors_detail.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor_details(flavor_id).body['flavor']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/image.rb
new file mode 100644
index 0000000..6dec92f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/image.rb
@@ -0,0 +1,48 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :created_at,  :aliases => 'created'
+        attribute :updated_at,  :aliases => 'updated'
+        attribute :progress
+        attribute :status
+        attribute :server_id,   :aliases => 'serverId'
+
+        def server=(new_server)
+          requires :id
+
+          self.server_id = new_server.id
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_image(id)
+          true
+        end
+
+        def ready?
+          status == 'ACTIVE'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :server_id
+
+          data = connection.create_image(server_id, 'name' => name)
+          merge_attributes(data.body['image'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/images.rb
new file mode 100644
index 0000000..e8c0b2e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/images.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/rackspace/models/compute/image'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Rackspace::Compute::Image
+
+        attribute :server
+
+        def all
+          data = connection.list_images_detail.body['images']
+          load(data)
+          if server
+            self.replace(self.select {|image| image.server_id == server.id})
+          end
+        end
+
+        def get(image_id)
+          data = connection.get_image_details(image_id).body['image']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/server.rb
new file mode 100644
index 0000000..87f7959
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/server.rb
@@ -0,0 +1,126 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :flavor_id,   :aliases => 'flavorId'
+        attribute :host_id,     :aliases => 'hostId'
+        attribute :image_id,    :aliases => 'imageId'
+        attribute :metadata
+        attribute :name
+        attribute :personality
+        attribute :progress
+        attribute :status
+
+        attr_reader :password
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id ||= 1
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_server(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def images
+          requires :id
+          connection.images(:server => self)
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          status == 'ACTIVE'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_server(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id
+          options = {
+            'metadata'    => metadata,
+            'name'        => name,
+            'personality' => personality
+          }
+          options = options.reject {|key, value| value.nil?}
+          data = connection.create_server(flavor_id, image_id, options)
+          merge_attributes(data.body['server'])
+          true
+        end
+
+        def setup(credentials = {})
+          requires :addresses, :identity, :public_key, :username
+          Fog::SSH.new(addresses['public'].first, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json},
+            %{echo "#{metadata.to_json}" >> ~/metadata.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :addresses, :identity, :private_key, :username
+          Fog::SSH.new(addresses['public'].first, username, :key_data => [private_key]).run(commands)
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        private
+
+        def adminPass=(new_admin_pass)
+          @password = new_admin_pass
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/servers.rb
new file mode 100644
index 0000000..6595120
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/compute/servers.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/rackspace/models/compute/server'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Rackspace::Compute::Server
+
+        def all
+          data = connection.list_servers_detail.body['servers']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:password => server.password)
+          server
+        end
+
+        def get(server_id)
+          if server = connection.get_server_details(server_id).body['server']
+            new(server)
+          end
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directories.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directories.rb
new file mode 100644
index 0000000..3bf37bb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directories.rb
@@ -0,0 +1,39 @@
+require 'fog/core/collection'
+require 'fog/rackspace/models/storage/directory'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Rackspace::Storage::Directory
+
+        def all
+          data = connection.get_containers.body
+          load(data)
+        end
+
+        def get(key, options = {})
+          data = connection.get_container(key, options)
+          directory = new(:key => key)
+          for key, value in data.headers
+            if ['X-Container-Bytes-Used', 'X-Container-Object-Count'].include?(key)
+              directory.merge_attributes(key => value)
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.instance_variable_set(:@loaded, true)
+          data.body.each do |file|
+            directory.files << directory.files.new(file)
+          end
+          directory
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directory.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directory.rb
new file mode 100644
index 0000000..5fb239c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/directory.rb
@@ -0,0 +1,66 @@
+require 'fog/core/model'
+require 'fog/rackspace/models/storage/files'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directory < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:name, :key)
+        deprecate(:name=, :key=)
+
+        identity  :key, :aliases => 'name'
+
+        attribute :bytes, :aliases => 'X-Container-Bytes-Used'
+        attribute :count, :aliases => 'X-Container-Object-Count'
+
+        def destroy
+          requires :key
+          connection.delete_container(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def files
+          @files ||= begin
+            Fog::Rackspace::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          @public = new_public
+        end
+
+        def public_url
+          requires :key
+          @public_url ||= begin
+            begin response = connection.cdn.head_container(key)
+              response.headers['X-CDN-Enabled'] == 'True' && response.headers['X-CDN-URI']
+            rescue Fog::Service::NotFound
+              nil
+            end
+          end
+        end
+
+        def save
+          requires :key
+          connection.put_container(key)
+          if @public
+            @public_url = connection.cdn.put_container(key, 'X-CDN-Enabled' => 'True').headers['X-CDN-URI']
+          else
+            connection.cdn.put_container(key, 'X-CDN-Enabled' => 'False')
+            @public_url = nil
+          end
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/file.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/file.rb
new file mode 100644
index 0000000..2c5d260
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/file.rb
@@ -0,0 +1,80 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'name'
+
+        attribute :content_length,  :aliases => ['bytes', 'Content-Length'], :type => :integer
+        attribute :content_type,    :aliases => ['content_type', 'Content-Type']
+        attribute :etag,            :aliases => ['hash', 'Etag']
+        attribute :last_modified,   :aliases => ['last_modified', 'Last-Modified'], :type => :time
+
+        def body
+          attributes[:body] ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.key, key)
+          true
+        end
+
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if @directory.public_url
+            "#{@directory.public_url}/#{key}"
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          data = connection.put_object(directory.key, key, body, options)
+          merge_attributes(data.headers)
+          if body.is_a?(String)
+            self.content_length = body.size
+          else
+            self.content_length = ::File.size(body.path)
+          end
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/files.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/files.rb
new file mode 100644
index 0000000..5ea76fc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/models/storage/files.rb
@@ -0,0 +1,75 @@
+require 'fog/core/collection'
+require 'fog/rackspace/models/storage/file'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+        attribute :limit
+        attribute :marker
+        attribute :path
+        attribute :prefix
+
+        model Fog::Rackspace::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'limit'   => limit,
+            'marker'  => marker,
+            'path'    => path,
+            'prefix'  => prefix
+          }.merge!(options)
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(key, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/get_containers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/get_containers.rb
new file mode 100644
index 0000000..3560641
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/get_containers.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # List existing cdn-enabled storage containers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'enabled_only'<~Boolean> - Set to true to limit results to cdn enabled containers
+        #   * 'limit'<~Integer> - Upper limit to number of results returned
+        #   * 'marker'<~String> - Only return objects with name greater than this value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * container<~String>: Name of container
+        def get_containers(options = {})
+          response = request(
+            :expects  => [200, 204],
+            :method   => 'GET',
+            :path     => '',
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_containers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/head_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/head_container.rb
new file mode 100644
index 0000000..3a43de8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/head_container.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # List cdn properties for a container
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-CDN-Enabled'<~Boolean> - cdn status for container
+        #     * 'X-CDN-URI'<~String> - cdn url for this container
+        #     * 'X-TTL'<~String> - integer seconds before data expires, defaults to 86400 (1 day)
+        #     * 'X-Log-Retention'<~Boolean> - ?
+        #     * 'X-User-Agent-ACL'<~String> - ?
+        #     * 'X-Referrer-ACL'<~String> - ?
+        def head_container(container)
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => container,
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_container(container)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/put_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/put_container.rb
new file mode 100644
index 0000000..a0f427a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/cdn/put_container.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # modify CDN properties for a container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        # # options<~Hash>:
+        #   * 'X-CDN-Enabled'<~Boolean> - cdn status for container
+        #   * 'X-CDN-URI'<~String> - cdn url for this container
+        #   * 'X-TTL'<~String> - integer seconds before data expires, defaults to 86400 (1 day), in 3600..259200
+        #   * 'X-Log-Retention'<~Boolean> - ?
+        #   * 'X-User-Agent-ACL'<~String> - ?
+        #   * 'X-Referrer-ACL'<~String> - ?
+        def put_container(name, options = {})
+          response = request(
+            :expects  => [201, 202],
+            :headers  => options,
+            :method   => 'PUT',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def put_container(name, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/confirm_resized_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/confirm_resized_server.rb
new file mode 100644
index 0000000..a74dd66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/confirm_resized_server.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Confirm resizing
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to confirm
+        #
+        def confirm_resized_server(server_id)
+          body = { 'confirmResize' => nil }
+          server_action(server_id, body, 204)
+        end
+
+      end
+
+      class Mock
+
+        def confirm_resized_server(server_id)
+          response = Excon::Response.new
+          response.status = 204
+
+          @data[:servers][server_id].delete('old_flavorId')
+          @data[:last_modified][:servers][server_id] = Time.now
+          @data[:servers][server_id]['status'] = 'ACTIVE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_image.rb
new file mode 100644
index 0000000..c0e4382
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_image.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create an image from a running server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to create image from
+        # * options<~Hash> - Name
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'image'<~Hash>:
+        #     * 'id'<~Integer> - Id of image
+        #     * 'name'<~String> - Name of image
+        #     * 'serverId'<~Integer> - Id of server
+        def create_image(server_id, options = {})
+          data = {
+            'image' => {
+              'serverId' => server_id
+            }
+          }
+          if options['name']
+            data['image']['name'] = options['name']
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => "images"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(server_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          now = Time.now
+          data = {
+            'created'   => now,
+            'id'        => Fog::Mock.random_numbers(6).to_i,
+            'name'      => options['name'] || '',
+            'serverId'  => server_id,
+            'status'    => 'SAVING',
+            'updated'   => now.to_s,
+          }
+
+          @data[:last_modified][:images][data['id']] = now
+          @data[:images][data['id']] = data
+          response.body = { 'image' => data.reject {|key, value| !['id', 'name', 'serverId', 'status', 'updated'].include?(key)} }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_server.rb
new file mode 100644
index 0000000..d9585d6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/create_server.rb
@@ -0,0 +1,94 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor for server
+        # * image_id<~Integer> - Id of image for server
+        # * name<~String> - Name of server
+        # * options<~Hash>:
+        #   * 'metadata'<~Hash> - Up to 5 key value pairs containing 255 bytes of info
+        #   * 'name'<~String> - Name of server, defaults to "slice#{id}"
+        #   * 'personality'<~Array>: Up to 5 files to customize server
+        #     * file<~Hash>:
+        #       * 'contents'<~String> - Contents of file (10kb total of contents)
+        #       * 'path'<~String> - Path to file (255 bytes total of path strings)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'adminPass'<~String> - Admin password for server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def create_server(flavor_id, image_id, options = {})
+          data = {
+            'server' => {
+              'flavorId'  => flavor_id,
+              'imageId'   => image_id
+            }
+          }
+          if options['metadata']
+            data['server']['metadata'] = options['metadata']
+          end
+          if options['name']
+            data['server']['name'] = options['name']
+          end
+          if options['personality']
+            data['server']['personality'] = []
+            for file in options['personality']
+              data['server']['personality'] << {
+                'contents'  => Base64.encode64(file['contents']),
+                'path'      => file['path']
+              }
+            end
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(flavor_id, image_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          data = {
+            'addresses' => { 'private' => ['0.0.0.0'], 'public' => ['0.0.0.0'] },
+            'flavorId'  => flavor_id,
+            'id'        => Fog::Mock.random_numbers(6).to_i,
+            'imageId'   => image_id,
+            'hostId'    => "123456789ABCDEF01234567890ABCDEF",
+            'metadata'  => options['metadata'] || {},
+            'name'      => options['name'] || "server_#{rand(999)}",
+            'progress'  => 0,
+            'status'    => 'BUILD'
+          }
+          @data[:last_modified][:servers][data['id']] = Time.now
+          @data[:servers][data['id']] = data
+          response.body = { 'server' => data.merge({'adminPass' => 'password'}) }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_image.rb
new file mode 100644
index 0000000..902d651
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_image.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to delete
+        #
+        def delete_image(image_id)
+          request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "images/#{image_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_image(image_id)
+          response = Excon::Response.new
+          if image = list_images_detail.body['images'].detect {|_| _['id'] == image_id}
+            if image['status'] == 'SAVING'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              @data[:last_modified][:images].delete(image_id)
+              @data[:images].delete(image_id)
+              response.status = 202
+            end
+            response
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 202}, response))
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_server.rb
new file mode 100644
index 0000000..39ae6b5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/delete_server.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an existing server
+        #
+        # ==== Parameters
+        # * id<~Integer> - Id of server to delete
+        #
+        def delete_server(server_id)
+          request(
+            :expects => 202,
+            :method => 'DELETE',
+            :path   => "servers/#{server_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_server(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            if server['status'] == 'BUILD'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              @data[:last_modified][:servers].delete(server_id)
+              @data[:servers].delete(server_id)
+              response.status = 202
+            end
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_flavor_details.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_flavor_details.rb
new file mode 100644
index 0000000..406ed64
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_flavor_details.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for flavor by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def get_flavor_details(flavor_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "flavors/#{flavor_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavor_details(flavor_id)
+          response = Excon::Response.new
+          flavor = {
+            1 => { 'name' => '256 server',    'ram' => 256,    'disk' => 10   },
+            2 => { 'name' => '512 server',    'ram' => 512,    'disk' => 20   },
+            3 => { 'name' => '1GB server',    'ram' => 1024,   'disk' => 40   },
+            4 => { 'name' => '2GB server',    'ram' => 2048,   'disk' => 80   },
+            5 => { 'name' => '4GB server',    'ram' => 4096,   'disk' => 160  },
+            6 => { 'name' => '8GB server',    'ram' => 8192,   'disk' => 320  },
+            7 => { 'name' => '15.5GB server', 'ram' => 15872,  'disk' => 620  }
+          }[flavor_id]
+          if flavor
+            response.status = 200
+            response.body = {
+              'flavor' => flavor
+            }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_image_details.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_image_details.rb
new file mode 100644
index 0000000..637b06e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_image_details.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for image by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'serverId'<~Integer> - Id of server image was created from
+        #     * 'status'<~Integer> - Status of image
+        #     * 'updated'<~String> - Timestamp of last update
+        def get_image_details(image_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "images/#{image_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image_details(image_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_server_details.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_server_details.rb
new file mode 100644
index 0000000..a6cc024
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/get_server_details.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details about a server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to get details for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def get_server_details(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_details(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'server' => server }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_addresses.rb
new file mode 100644
index 0000000..f22ac2d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_addresses.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'addresses'<~Array>:
+        #     * 'public'<~Array> - Public ip addresses
+        #     * 'private'<~Array> - Private ip addresses
+        def list_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'addresses' => server['addresses'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors.rb
new file mode 100644
index 0000000..bccea9d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        def list_flavors
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'flavors' => [
+              { 'name' => '256 server',    'id' => 1 },
+              { 'name' => '512 server',    'id' => 2 },
+              { 'name' => '1GB server',    'id' => 3 },
+              { 'name' => '2GB server',    'id' => 4 },
+              { 'name' => '4GB server',    'id' => 5 },
+              { 'name' => '8GB server',    'id' => 6 },
+              { 'name' => '15.5GB server', 'id' => 7 }
+            ]
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors_detail.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors_detail.rb
new file mode 100644
index 0000000..8b1b637
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_flavors_detail.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def list_flavors_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors_detail
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'flavors' => [
+              { 'name' => '256 server',    'id' => 1, 'ram' => 256,    'disk' => 10   },
+              { 'name' => '512 server',    'id' => 2, 'ram' => 512,    'disk' => 20   },
+              { 'name' => '1GB server',    'id' => 3, 'ram' => 1024,   'disk' => 40   },
+              { 'name' => '2GB server',    'id' => 4, 'ram' => 2048,   'disk' => 80   },
+              { 'name' => '4GB server',    'id' => 5, 'ram' => 4096,   'disk' => 160  },
+              { 'name' => '8GB server',    'id' => 6, 'ram' => 8192,   'disk' => 320  },
+              { 'name' => '15.5GB server', 'id' => 7, 'ram' => 15872,  'disk' => 620  }
+            ]
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images.rb
new file mode 100644
index 0000000..4af6333
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def list_images
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images
+          response = Excon::Response.new
+          data = list_images_detail.body['images']
+          images = []
+          for image in data
+            images << image.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images_detail.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images_detail.rb
new file mode 100644
index 0000000..deb1e2a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_images_detail.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'updated'<~String> - Last update timestamp for image
+        #     * 'created'<~String> - Creation timestamp for image
+        #     * 'status'<~String> - Status of image
+        def list_images_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images_detail
+          response = Excon::Response.new
+
+          images = @data[:images].values
+          for image in images
+            case image['status']
+            when 'SAVING'
+              if Time.now - @data[:last_modified][:images][image['id']] > Fog::Mock.delay
+                image['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images.map {|image| image.reject {|key, value| !['id', 'name', 'status', 'updated'].include?(key)}} }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_private_addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_private_addresses.rb
new file mode 100644
index 0000000..8576582
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_private_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List private server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'private'<~Array> - Public ip addresses
+        def list_private_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/private.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_private_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'private' => server['addresses']['private'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_public_addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_public_addresses.rb
new file mode 100644
index 0000000..1fbf386
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_public_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List public server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'public'<~Array> - Public ip addresses
+        def list_public_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/public.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_public_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'public' => server['addresses']['public'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers.rb
new file mode 100644
index 0000000..0bf2baf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        def list_servers
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers
+          response = Excon::Response.new
+          data = list_servers_detail.body['servers']
+          servers = []
+          for server in data
+            servers << server.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers_detail.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers_detail.rb
new file mode 100644
index 0000000..ade9314
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/list_servers_detail.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers details
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'status'<~String> - Current server status
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'metadata'<~Hash> - metadata
+        def list_servers_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers_detail
+          response = Excon::Response.new
+
+          servers = @data[:servers].values
+          for server in servers
+            case server['status']
+            when 'BUILD'
+              if Time.now - @data[:last_modified][:servers][server['id']] > 2
+                server['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/reboot_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/reboot_server.rb
new file mode 100644
index 0000000..e97c8aa
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/reboot_server.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        def reboot_server(server_id, type = 'SOFT')
+          body = { 'reboot' => { 'type' => type }}
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        def reboot_server(server_id, type = 'SOFT')
+          response = Excon::Response.new
+          response.status = 202
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/resize_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/resize_server.rb
new file mode 100644
index 0000000..64f4d95
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/resize_server.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to resize
+        # * size<~String> - new size. call list_flavors to get available flavors
+        #
+        def resize_server(server_id, flavor_id)
+          body = { 'resize' => { 'flavorId' => flavor_id }}
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        # FIXME: should probably transition instead of skipping to VERIFY_RESIZE
+        def resize_server(server_id, flavor_id)
+          response = Excon::Response.new
+          response.status = 202
+
+          # keep track of this for reverts
+          @data[:servers][server_id]['old_flavorId'] = @data[:servers][server_id]['flavorId']
+
+          @data[:servers][server_id]['flavorId'] = flavor_id
+          @data[:last_modified][:servers][server_id] = Time.now
+          @data[:servers][server_id]['status'] = 'VERIFY_RESIZE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/revert_resized_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/revert_resized_server.rb
new file mode 100644
index 0000000..6aa1a96
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/revert_resized_server.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Revert resizing
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to revert
+        #
+        def revert_resized_server(server_id)
+          body = { 'revertResize' => nil }
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        def revert_resized_server(server_id)
+          response = Excon::Response.new
+          response.status = 202
+
+          @data[:servers][server_id]['flavorId'] = @data[:servers][server_id]['old_flavorId']
+          @data[:servers][server_id].delete('old_flavorId')
+          @data[:last_modified][:servers][server_id] = Time.now
+          @data[:servers][server_id]['status'] = 'ACTIVE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/server_action.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/server_action.rb
new file mode 100644
index 0000000..fbe2df6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/server_action.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to reboot
+        # * body<~.to_json object> - Body of the request, describes the action (see reboot_server as an example)
+        # * expect<~Integer> - expected return, 202 except for confirm resize (204)
+        #
+        def server_action(server_id, body, expects=202)
+          request(
+            :body     => body.to_json,
+            :expects  => expects,
+            :method   => 'POST',
+            :path     => "servers/#{server_id}/action.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def server_action(server_id, body)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/update_server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/update_server.rb
new file mode 100644
index 0000000..80c3215
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/compute/update_server.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Update an existing server
+        #
+        # ==== Parameters
+        # # server_id<~Integer> - Id of server to update
+        # * options<~Hash>:
+        #   * adminPass<~String> - New admin password for server
+        #   * name<~String> - New name for server
+        def update_server(server_id, options = {})
+          request(
+            :body     => { 'server' => options }.to_json,
+            :expects  => 204,
+            :method   => 'PUT',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(server_id, options)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            if options['adminPass']
+              server['adminPass'] = options['adminPass']
+            end
+            if options['name']
+              server['name'] = options['name']
+            end
+            response.status = 204
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_container.rb
new file mode 100644
index 0000000..02c2832
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_container.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * name<~String> - Name of container to delete
+        #
+        def delete_container(name)
+          response = request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def delete_container(name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_object.rb
new file mode 100644
index 0000000..abca74a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/delete_object.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to delete
+        # * object<~String> - Name of object to delete
+        #
+        def delete_object(container, object)
+          response = request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def delete_object(container, object)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_container.rb
new file mode 100644
index 0000000..ba72035
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_container.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for container and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        # * options<~String>:
+        #   * 'limit'<~String> - Maximum number of objects to return
+        #   * 'marker'<~String> - Only return objects whose name is greater than marker
+        #   * 'prefix'<~String> - Limits results to those starting with prefix
+        #   * 'path'<~String> - Return objects nested in the pseudo path
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        #   * body<~Array>:
+        #     * 'bytes'<~Integer> - Number of bytes used by container
+        #     * 'count'<~Integer> - Number of items in container
+        #     * 'name'<~String> - Name of container
+        #     * item<~Hash>:
+        #       * 'bytes'<~String> - Size of object
+        #       * 'content_type'<~String> Content-Type of object
+        #       * 'hash'<~String> - Hash of object (etag?)
+        #       * 'last_modified'<~String> - Last modified timestamp
+        #       * 'name'<~String> - Name of object
+        def get_container(container, options = {})
+          response = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => container,
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_container(container, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_containers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_containers.rb
new file mode 100644
index 0000000..fd6edb2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_containers.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List existing storage containers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'limit'<~Integer> - Upper limit to number of results returned
+        #   * 'marker'<~String> - Only return objects with name greater than this value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * container<~Hash>:
+        #       * 'bytes'<~Integer>: - Number of bytes used by container
+        #       * 'count'<~Integer>: - Number of items in container
+        #       * 'name'<~String>: - Name of container
+        def get_containers(options = {})
+          response = request(
+            :expects  => [200, 204],
+            :method   => 'GET',
+            :path     => '',
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_containers(options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_object.rb
new file mode 100644
index 0000000..05dbab6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/get_object.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def get_object(container, object, &block)
+          response = request({
+            :block    => block,
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          }, false, &block)
+          response
+        end
+
+      end
+
+      class Mock
+
+        def get_object(container, object, &block)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_container.rb
new file mode 100644
index 0000000..8d82835
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_container.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of objects and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Container-Object-Count'<~String> - Count of containers
+        #     * 'X-Container-Bytes-Used'<~String>   - Bytes used
+        def head_container(container)
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => container,
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_container(container)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_containers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_containers.rb
new file mode 100644
index 0000000..ee8c117
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_containers.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of containers and total bytes stored
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        def head_containers
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => '',
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_containers
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_object.rb
new file mode 100644
index 0000000..55a5d39
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/head_object.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get headers for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def head_object(container, object)
+          response = request({
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          }, false)
+          response
+        end
+
+      end
+
+      class Mock
+
+        def head_object(container, object)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_container.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_container.rb
new file mode 100644
index 0000000..8becdca
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_container.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_container(name)
+          response = request(
+            :expects  => [201, 202],
+            :method   => 'PUT',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def put_container(name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_object.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_object.rb
new file mode 100644
index 0000000..61a712a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/requests/storage/put_object.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new object
+        #
+        # ==== Parameters
+        # * container<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_object(container, object, data, options = {})
+          data = parse_data(data)
+          headers = data[:headers].merge!(options)
+          response = request(
+            :body     => data[:body],
+            :expects  => 201,
+            :headers  => headers,
+            :method   => 'PUT',
+            :path     => "#{CGI.escape(container)}/#{CGI.escape(object)}"
+          )
+          response
+        end
+
+      end
+
+      class Mock
+
+        def put_object(container, object, data, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/servers.rb
new file mode 100644
index 0000000..2e33b60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/servers.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Rackspace
+    class Servers
+
+      def self.new(attributes = {})
+        location = caller.first
+        warning = "[yellow][WARN] Fog::Rackspace::Servers#new is deprecated, use Fog::Rackspace::Compute#new instead[/]"
+        warning << " [light_black](" << location << ")[/] "
+        Formatador.display_line(warning)
+        Fog::Rackspace::Compute.new(attributes)
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/storage.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/storage.rb
new file mode 100644
index 0000000..f700bf6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/rackspace/storage.rb
@@ -0,0 +1,132 @@
+module Fog
+  module Rackspace
+    class Storage < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :persistent
+
+      model_path 'fog/rackspace/models/storage'
+      model       :directory
+      collection  :directories
+      model       :file
+      collection  :files
+
+      request_path 'fog/rackspace/requests/storage'
+      request :delete_container
+      request :delete_object
+      request :get_container
+      request :get_containers
+      request :get_object
+      request :head_container
+      request :head_containers
+      request :head_object
+      request :put_container
+      request :put_object
+
+      module Utils
+
+        def cdn
+          @cdn ||= Fog::Rackspace::CDN.new(
+            :rackspace_api_key => @rackspace_api_key,
+            :rackspace_username => @rackspace_username
+          )
+        end
+
+        def parse_data(data)
+          metadata = {
+            :body => nil,
+            :headers => {}
+          }
+
+          if data.is_a?(String)
+            metadata[:body] = data
+            metadata[:headers]['Content-Length'] = metadata[:body].size.to_s
+          else
+            filename = ::File.basename(data.path)
+            unless (mime_types = MIME::Types.of(filename)).empty?
+              metadata[:headers]['Content-Type'] = mime_types.first.content_type
+            end
+            metadata[:body] = data.read
+            metadata[:headers]['Content-Length'] = ::File.size(data.path).to_s
+          end
+          # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+          metadata
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          require 'mime/types'
+          @rackspace_api_key = options[:rackspace_api_key]
+          @rackspace_username = options[:rackspace_username]
+          @data = self.class.data[@rackspace_username]
+        end
+
+      end
+
+      class Real
+        include Utils
+
+        def initialize(options={})
+          require 'mime/types'
+          require 'json'
+          @rackspace_api_key = options[:rackspace_api_key]
+          @rackspace_username = options[:rackspace_username]
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+
+          uri = URI.parse(credentials['X-Storage-Url'])
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @storage_connection.reset
+        end
+
+        def request(params, parse_json = true, &block)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+            }), &block)
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost.rb
new file mode 100644
index 0000000..80cfb89
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost.rb
@@ -0,0 +1,24 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+module Fog
+  module Slicehost
+
+    extend Fog::Provider
+
+    service_path 'fog/slicehost'
+    service :compute
+    service :dns
+
+    def self.new(attributes = {})
+      location = caller.first
+      warning = "[yellow][WARN] Fog::Slicehost#new is deprecated, use Fog::Slicehost::Compute#new instead[/]"
+      warning << " [light_black](" << location << ")[/] "
+      Formatador.display_line(warning)
+      Fog::Slicehost::Compute.new(attributes)
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/bin.rb
new file mode 100644
index 0000000..ba0fb77
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/bin.rb
@@ -0,0 +1,33 @@
+class Slicehost < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute, :slices
+        Fog::Slicehost::Compute
+      when :dns
+        Fog::Slicehost::DNS
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        if key == :slices
+          location = caller.first
+          warning = "[yellow][WARN] Slicehost[:blocks] is deprecated, use Bluebox[:compute] instead[/]"
+          warning << " [light_black](" << location << ")[/] "
+          Formatador.display_line(warning)
+        end
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:compute, :dns]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/compute.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/compute.rb
new file mode 100644
index 0000000..cb4a5df
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/compute.rb
@@ -0,0 +1,92 @@
+module Fog
+  module Slicehost
+    class Compute < Fog::Service
+
+      requires :slicehost_password
+      recognizes :host, :port, :scheme, :persistent
+
+      model_path 'fog/slicehost/models/compute'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/slicehost/requests/compute'
+      request :create_slice
+      request :delete_slice
+      request :get_backups
+      request :get_flavor
+      request :get_flavors
+      request :get_image
+      request :get_images
+      request :get_slice
+      request :get_slices
+      request :reboot_slice
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @data = self.class.data[@slicehost_password]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @host   = options[:host]    || "api.slicehost.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(@slicehost_password).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Slicehost::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/dns.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/dns.rb
new file mode 100644
index 0000000..627eff8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/dns.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Slicehost
+    class DNS < Fog::Service
+
+      requires :slicehost_password
+      recognizes :host, :port, :scheme, :persistent
+
+      model_path 'fog/slicehost/models/dns'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/slicehost/requests/dns'
+      request :create_record
+      request :create_zone
+      request :delete_record
+      request :delete_zone
+      request :get_record
+      request :get_records
+      request :get_zone
+      request :get_zones
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @data = self.class.data[@slicehost_password]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @slicehost_password = options[:slicehost_password]
+          @host   = options[:host]    || "api.slicehost.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(@slicehost_password).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Slicehost::DNS::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavor.rb
new file mode 100644
index 0000000..99844f2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :price
+        attribute :ram
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavors.rb
new file mode 100644
index 0000000..9b4277f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/slicehost/models/compute/flavor'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Slicehost::Compute::Flavor
+
+        def all
+          data = connection.get_flavors.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor(flavor_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/image.rb
new file mode 100644
index 0000000..05ac986
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/image.rb
@@ -0,0 +1,17 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/images.rb
new file mode 100644
index 0000000..dc3266d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/images.rb
@@ -0,0 +1,27 @@
+require 'fog/core/collection'
+require 'fog/slicehost/models/compute/image'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Slicehost::Compute::Image
+
+        def all
+          data = connection.get_images.body['images']
+          load(data)
+        end
+
+        def get(image_id)
+          connection.get_image(image_id)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/server.rb
new file mode 100644
index 0000000..b37c775
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/server.rb
@@ -0,0 +1,109 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :backup_id,     :aliases => 'backup-id'
+        attribute :bandwidth_in,  :aliases => 'bw-in'
+        attribute :bandwidth_out, :aliases => 'bw-out'
+        attribute :flavor_id,     :aliases => 'flavor-id'
+        attribute :image_id,      :aliases => 'image-id'
+        attribute :name
+        attribute :progress
+        attribute :status
+
+        attr_accessor :password
+        alias_method :'root-password=', :password=
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id ||= 1
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_slice(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          status == 'active'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_slice(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id, :name
+
+          data = connection.create_slice(flavor_id, image_id, name)
+          merge_attributes(data.body)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :addresses, :identity, :public_key, :username
+          Fog::SSH.new(addresses.first, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :addresses, :identity, :private_key, :username
+          Fog::SSH.new(addresses.first, username, :key_data => [private_key]).run(commands)
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/servers.rb
new file mode 100644
index 0000000..4bc46ec
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/compute/servers.rb
@@ -0,0 +1,38 @@
+require 'fog/core/collection'
+require 'fog/slicehost/models/compute/server'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Slicehost::Compute::Server
+
+        def all
+          data = connection.get_slices.body['slices']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:password => server.password)
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_slice(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/record.rb
new file mode 100644
index 0000000..977e3a5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/record.rb
@@ -0,0 +1,66 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :active
+        attribute :ip,          :aliases => 'ip'
+        attribute :name
+        attribute :description, :aliases => 'aux'
+        attribute :ttl
+        attribute :type,        :aliases => 'record_type'
+        attribute :zone_id
+
+        def initialize(attributes={})
+          self.active ||= true
+          self.ttl    ||= 3600
+          super
+        end
+
+        def active=(new_active)
+          attributes[:active] = case new_active
+          when false, 'N'
+            false
+          when true, 'Y'
+            true
+          end
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_record(identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :ip, :name, :type, :zone
+          options = {}
+          options[:active]  = active ? 'Y' : 'N'
+          options[:aux]     = description if description
+          options[:ttl]     = ttl if ttl
+          data = connection.create_record(type, zone.id, name, ip, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/records.rb
new file mode 100644
index 0000000..774e04a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/records.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/slicehost/models/dns/record'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Slicehost::DNS::Record
+
+        def all
+          requires :zone
+          data = connection.get_records.body['records']
+          load(data).reject {|record| record.zone_id != zone.id}
+        end
+
+        def get(record_id)
+          data = connection.get_record(record_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zone.rb
new file mode 100644
index 0000000..224d750
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zone.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+require 'fog/slicehost/models/dns/records'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :active
+        attribute :domain, :aliases => 'origin'
+        attribute :ttl
+
+        def initialize(attributes={})
+          self.active ||= true
+          self.ttl    ||= 3600
+          super
+        end
+
+        def active=(new_active)
+          attributes[:active] = case new_active
+          when false, 'N'
+            false
+          when true, 'Y'
+            true
+          end
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Slicehost::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'ns1.slicehost.net',
+            'ns2.slicehost.net',
+            'ns3.slicehost.net'
+          ]
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :active, :domain, :ttl
+          options = {}
+          options[:active]  = active ? 'Y' : 'N'
+          options[:ttl]     = ttl
+          data = connection.create_zone(domain, options)
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zones.rb
new file mode 100644
index 0000000..bcbffa0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/models/dns/zones.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/slicehost/models/dns/zone'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Slicehost::DNS::Zone
+
+        def all
+          data = connection.get_zones.body['zones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_zone(zone_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/create_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/create_slice.rb
new file mode 100644
index 0000000..99ed717
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/create_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class CreateSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = @value.to_f
+            when 'name', 'root-password', 'status'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_backups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_backups.rb
new file mode 100644
index 0000000..16a3af0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_backups.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetBackups < Fog::Parsers::Base
+
+          def reset
+            @backup = {}
+            @response = { 'backups' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'backup'
+              @response['backups'] << @backup
+              @backup = {}
+            when 'date'
+              @backup[name] = Time.parse(@value)
+            when 'id', 'slice-id'
+              @backup[name] = @value.to_i
+            when 'name'
+              @backup[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavor.rb
new file mode 100644
index 0000000..0d973d2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavor.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavor < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'price', 'ram'
+              @response[name] = @value.to_i
+            when 'name'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavors.rb
new file mode 100644
index 0000000..255d78b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_flavors.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavors < Fog::Parsers::Base
+
+          def reset
+            @flavor = {}
+            @response = { 'flavors' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'flavor'
+              @response['flavors'] << @flavor
+              @flavor = {}
+            when 'id', 'price', 'ram'
+              @flavor[name] = @value.to_i
+            when 'name'
+              @flavor[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_image.rb
new file mode 100644
index 0000000..6f62185
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_image.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImage < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @response[name] = @value.to_i
+            when 'name'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_images.rb
new file mode 100644
index 0000000..b9997fe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_images.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImages < Fog::Parsers::Base
+
+          def reset
+            @image = {}
+            @response = { 'images' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @image[name] = @value.to_i
+            when 'image'
+              @response['images'] << @image
+              @image = {}
+            when 'name'
+              @image[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slice.rb
new file mode 100644
index 0000000..46e1cdd
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = @value.to_f
+            when 'name', 'status'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slices.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slices.rb
new file mode 100644
index 0000000..4dfa919
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/compute/get_slices.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlices < Fog::Parsers::Base
+
+          def reset
+            @slice = {}
+            @response = { 'slices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @slice['addresses'] ||= []
+              @slice['addresses'] << @value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @slice[name] = @value.to_i
+            when 'bw-in', 'bw-out'
+              @slice[name] = @value.to_f
+            when 'name', 'status'
+              @slice[name] = @value
+            when 'slice'
+              @response['slices'] << @slice
+              @slice = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_record.rb
new file mode 100644
index 0000000..b1d74ed
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_record.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class CreateRecord < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl', 'id'
+              @response[name] = @value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_zone.rb
new file mode 100644
index 0000000..e4c6381
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/create_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class CreateZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @response[name] = @value.to_i
+            when 'origin', 'active'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_record.rb
new file mode 100644
index 0000000..9dbbf90
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_record.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetRecord < Fog::Parsers::Base
+
+          def reset
+            @response = { }
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl'
+              @response[name] = @value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_records.rb
new file mode 100644
index 0000000..594ae33
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_records.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetRecords < Fog::Parsers::Base
+
+          def reset
+            @record = {}
+            @response = { 'records' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl'
+              @record[name] = @value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @record[name] = @value
+            when 'record'
+              @response['records'] << @record
+              @record = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zone.rb
new file mode 100644
index 0000000..1064e7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @response[name] = @value.to_i
+            when 'origin', 'active'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zones.rb
new file mode 100644
index 0000000..97bd290
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/parsers/dns/get_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetZones < Fog::Parsers::Base
+
+          def reset
+            @zone = {}
+            @response = { 'zones' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @zone[name] = @value.to_i
+            when 'active', 'origin'
+              @zone[name] = @value
+            when 'zone'
+              @response['zones'] << @zone
+              @zone = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/create_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/create_slice.rb
new file mode 100644
index 0000000..d9e33d9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/create_slice.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/create_slice'
+
+        # Create a new slice
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to create slice with
+        # * image_id<~Integer> - Id of image to create slice with
+        # * name<~String> - Name of slice
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Integer> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Integer> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor-id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'root-password'<~String> - Root password of slice
+        #     * 'status'<~String> - Current status of the slice
+        def create_slice(flavor_id, image_id, name)
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><slice><flavor-id type="integer">#{flavor_id}</flavor-id><image-id type="integer">#{image_id}</image-id><name>#{name}</name></slice>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::Compute::CreateSlice.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_slice(flavor_id, image_id, name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/delete_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/delete_slice.rb
new file mode 100644
index 0000000..55eba09
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/delete_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Delete a given slice
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of slice to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code is the return value
+        def delete_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_slice(slice_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_backups.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_backups.rb
new file mode 100644
index 0000000..518c26e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_backups.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_backups'
+
+        # Get list of backups
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'date'<~Time> - Timestamp of backup creation
+        #     * 'id'<~Integer> - Id of the backup
+        #     * 'name'<~String> - Name of the backup
+        #     * 'slice-id'<~Integer> - Id of slice the backup was made from
+        def get_backups
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetBackups.new,
+            :path     => 'backups.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_backups
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavor.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavor.rb
new file mode 100644
index 0000000..ffedb5b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavor.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_flavor'
+
+        # Get details of a flavor
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavor(flavor_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavor.new,
+            :path     => "flavors/#{flavor_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavor(flavor_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavors.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavors.rb
new file mode 100644
index 0000000..5e8122e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_flavors.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_flavors'
+
+        # Get list of flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavors
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavors.new,
+            :path     => 'flavors.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavors
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_image.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_image.rb
new file mode 100644
index 0000000..366c71f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_image.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_image'
+
+        # Get details of an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_image(image_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImage.new,
+            :path     => "images/#{image_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_image(image_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_images.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_images.rb
new file mode 100644
index 0000000..8b72084
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_images.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_images'
+
+        # Get list of images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImages.new,
+            :path     => 'images.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_images
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slice.rb
new file mode 100644
index 0000000..7200595
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slice.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_slice'
+
+        # Get details of a slice
+        #
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of slice to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_slice(id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slices.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slices.rb
new file mode 100644
index 0000000..1ca6199
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/get_slices.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/slicehost/parsers/compute/get_slices'
+
+        # Get list of slices
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slices
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlices.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_slices
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/reboot_slice.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/reboot_slice.rb
new file mode 100644
index 0000000..d266e58
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/compute/reboot_slice.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Reboot slice
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def reboot_slice(slice_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}/#{'hard_' if type == 'HARD'}reboot.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def reboot_slice(id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_record.rb
new file mode 100644
index 0000000..bf048e0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_record.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/create_record'
+
+        # Create a new record in a DNS zone - or update an existing one
+        # ==== Parameters
+        # * record_type<~String> - type of DNS record to create (A, CNAME, etc)
+        # * zone_id<~Integer> - ID of the zone to update
+        # * name<~String> - host name this DNS record is for 
+        # * data<~String> - data for the DNS record (ie for an A record, the IP address)
+        # * options<~Hash> - extra parameters that are not mandatory
+        #   * ttl<~Integer> - time to live in seconds
+        #   * active<~String> - whether this record is active or not ('Y' or 'N')
+        #   * aux<~String> - extra data required by the record
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'name'<~String> - as above
+        #     * 'id'<~Integer> - Id of zone/domain - used in future API calls for this zone
+        #     * 'ttl'<~Integer> - as above
+        #     * 'data'<~String> - as above
+        #     * 'active'<~String> - as above
+        #     * 'aux'<~String> - as above
+        def create_record(record_type, zone_id, name, data, options = {})
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ttl
+              optional_tags+= "<ttl type='integer'>#{value}</ttl>"
+            when :active
+              optional_tags+= "<active>#{value}</active>"
+            when :aux
+              optional_tags+= "<aux>#{value}</aux>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><record><record_type>#{record_type}</record_type><zone_id type="integer">#{zone_id}</zone_id><name>#{name}</name><data>#{data}</data>#{optional_tags}</record>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::DNS::CreateRecord.new,
+            :path     => 'records.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_record(record_type, zone_id, name, data)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_zone.rb
new file mode 100644
index 0000000..4c78eec
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/create_zone.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/create_zone'
+
+        # Create a new zone for Slicehost's DNS servers to serve/host
+        # ==== Parameters
+        # * origin<~String> - domain name to host (ie example.com)
+        # * options<~Hash> - optional paramaters
+        #   * ttl<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #   * active<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'origin'<~String> - as above
+        #     * 'id'<~Integer> - Id of zone/domain - used in future API calls
+        #     * 'ttl'<~Integer> - as above
+        #     * 'active'<~String> - as above
+        def create_zone(origin, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ttl
+              optional_tags+= "<ttl type='interger'>#{value}</ttl>"
+            when :active
+              optional_tags+= "<active>#{value}</active>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone><origin>#{origin}</origin>#{optional_tags}</zone>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::DNS::CreateZone.new,
+            :path     => 'zones.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_zone(origin, ttl, active)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_record.rb
new file mode 100644
index 0000000..7bd5d98
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_record.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        # Delete a record from the specified DNS zone
+        # ==== Parameters
+        # * record_id<~Integer> - Id of DNS record to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_record(record_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "records/#{record_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_record(record_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_zone.rb
new file mode 100644
index 0000000..3835dc7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/delete_zone.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        # Delete a zone from Slicehost's DNS
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_record.rb
new file mode 100644
index 0000000..6cf0f84
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_record.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/get_record'
+
+        # Get an individual DNS record from the specified zone 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'record_type'<~String> - type of DNS record to create (A, CNAME, etc)
+        #     * 'zone_id'<~Integer> - ID of the zone to update
+        #     * 'name'<~String> - host name this DNS record is for 
+        #     * 'data'<~String> - data for the DNS record (ie for an A record, the IP address)
+        #     * 'ttl'<~Integer> - time to live in seconds
+        #     * 'active'<~String> - whether this record is active or not ('Y' or 'N')
+        #     * 'aux'<~String> - extra data required by the record
+        def get_record(record_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetRecords.new,
+            :path     => "records/#{record_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_record(record_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_records.rb
new file mode 100644
index 0000000..b990297
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_records.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/get_records'
+
+        # Get all the DNS records across all the DNS zones for this account 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_records
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetRecords.new,
+            :path     => "records.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_records
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zone.rb
new file mode 100644
index 0000000..e4d6d60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zone.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/get_zone'
+
+        # Get details of a DNS zone
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'origin'<~String> - domain name to host (ie example.com)
+        #     * 'id'<~Integer> - Id of the zone
+        #     * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #     * 'active'<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        def get_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetZone.new,
+            :path     => "/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zones.rb
new file mode 100644
index 0000000..ed8ca85
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/slicehost/requests/dns/get_zones.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/slicehost/parsers/dns/get_zones'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'zones'<~Array>
+        #       * 'origin'<~String> - domain name to host (ie example.com)
+        #       * 'id'<~Integer> - Id of the zone
+        #       * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #       * 'active'<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        def get_zones
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetZones.new,
+            :path     => 'zones.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zones
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark.rb
new file mode 100644
index 0000000..4f0c5a2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark.rb
@@ -0,0 +1,16 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+require 'fog/terremark/shared'
+require 'fog/terremark/parser'
+require 'fog/terremark/ecloud'
+require 'fog/terremark/vcloud'
+
+module Fog
+  module Terremark
+    ECLOUD_OPTIONS = [:terremark_ecloud_username, :terremark_ecloud_password]
+    VCLOUD_OPTIONS = [:terremark_vcloud_username, :terremark_vcloud_password]
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/bin.rb
new file mode 100644
index 0000000..3df7b3b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/bin.rb
@@ -0,0 +1,36 @@
+class Terremark < Fog::Bin
+  class << self
+
+    def available?
+      Fog::Terremark::ECLOUD_OPTIONS.all? {|requirement| Fog.credentials.include?(requirement)} ||
+      Fog::Terremark::VCLOUD_OPTIONS.all? {|requirement| Fog.credentials.include?(requirement)}
+    end
+
+    def terremark_service(service)
+      case service
+      when :ecloud
+        Fog::Terremark::Ecloud
+      when :vcloud
+        Fog::Terremark::Vcloud
+      else
+        raise "Unsupported Terremark Service"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        credentials = Fog.credentials.reject do |k,v|
+          case key
+          when :ecloud
+            !Fog::Terremark::ECLOUD_OPTIONS.include?(k)
+          when :vcloud
+            !Fog::Terremark::VCLOUD_OPTIONS.include?(k)
+          end
+        end
+        hash[key] = terremark_service(key).new(credentials)
+      end
+      @@connections[service]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/ecloud.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/ecloud.rb
new file mode 100644
index 0000000..32d6fb3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/ecloud.rb
@@ -0,0 +1,69 @@
+module Fog
+  module Terremark
+    module Ecloud
+
+      module Bin
+      end
+
+      module Defaults
+        HOST   = 'services.enterprisecloud.terremark.com'
+        PATH   = '/api/v0.8a-ext2.0'
+        PORT   = 443
+        SCHEME = 'https'
+      end
+
+      extend Fog::Terremark::Shared
+
+      def self.new(options={})
+
+        unless @required
+          shared_requires
+          @required = true
+        end
+
+        check_shared_options(options)
+
+        if Fog.mocking?
+          Fog::Terremark::Ecloud::Mock.new(options)
+        else
+          Fog::Terremark::Ecloud::Real.new(options)
+        end
+
+      end
+
+      class Real
+        # requires :terremark_ecloud_password, :terremark_ecloud_username
+        # recognizes :host, :path, :port, :scheme, :persistent
+        
+        include Fog::Terremark::Shared::Real
+        include Fog::Terremark::Shared::Parser
+
+        def initialize(options={})
+          @terremark_password = options[:terremark_ecloud_password]
+          @terremark_username = options[:terremark_ecloud_username]
+          @host   = options[:host]   || Fog::Terremark::Ecloud::Defaults::HOST
+          @path   = options[:path]   || Fog::Terremark::Ecloud::Defaults::PATH
+          @port   = options[:port]   || Fog::Terremark::Ecloud::Defaults::PORT
+          @scheme = options[:scheme] || Fog::Terremark::Ecloud::Defaults::SCHEME
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+      end
+
+      class Mock
+        include Fog::Terremark::Shared::Mock
+        include Fog::Terremark::Shared::Parser
+
+        def initialize(option = {})
+          super
+          @base_url = Fog::Terremark::Ecloud::Defaults::SCHEME + "://" +
+          Fog::Terremark::Ecloud::Defaults::HOST +
+          Fog::Terremark::Ecloud::Defaults::PATH
+          @data = self.class.data[:terremark_ecloud_username]
+        end
+      end
+
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/address.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/address.rb
new file mode 100644
index 0000000..70e4ac9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/address.rb
@@ -0,0 +1,29 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Address < Fog::Model
+
+        identity :id
+
+        attribute :ip, :aliases => 'name'
+
+        def destroy
+         requires :id
+         connection.delete_public_ip(id)
+         true
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/addresses.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/addresses.rb
new file mode 100644
index 0000000..decc67a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/addresses.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      class Addresses < Fog::Collection
+
+        model Fog::Terremark::Shared::Address
+
+        def all
+          load(connection.get_public_ips(vdc_id).body['PublicIpAddresses'])
+        end
+
+        def get(ip_id)
+          if ip_id && ip = connection.get_public_ip(ip_id).body
+            new(ip)
+          elsif !ip_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/network.rb
new file mode 100644
index 0000000..96aefae
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/network.rb
@@ -0,0 +1,35 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Network < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :subnet
+        attribute :gateway
+        attribute :netmask
+        attribute :fencemode
+        attribute :links
+
+        def ips
+          #Until there is a real model for these ?
+          connection.get_network_ips(id).body['IpAddresses']
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/networks.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/networks.rb
new file mode 100644
index 0000000..6e39c30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/networks.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      class Networks < Fog::Collection
+
+        model Fog::Terremark::Shared::Network
+
+        def all
+          data = connection.get_vdc(vdc_id).body['AvailableNetworks'].map do |network|
+            connection.get_network(network["href"].split("/").last).body
+          end
+          load(data)
+        end
+
+        def get(network_id)
+          if network_id && network = connection.get_network(network_id).body
+            new(network)
+          elsif !network_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/server.rb
new file mode 100644
index 0000000..aeccc60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/server.rb
@@ -0,0 +1,110 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :status
+        attribute :OperatingSystem
+        attribute :VirtualHardware
+
+        def destroy
+          requires :id
+          data = connection.power_off(id).body
+          task = connection.tasks.new(data)
+          task.wait_for { ready? }
+          connection.delete_vapp(id)
+          true
+        end
+
+        # { '0' => 'Being created', '2' => 'Powered Off', '4' => 'Powered On'}
+        def ready?
+          status == '2'
+        end
+
+        def on?
+          status == '4'
+        end
+
+        def off?
+          status == '2'
+        end
+
+        def power_on(options = {})
+          requires :id
+          begin
+            connection.power_on(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered on/
+          end
+          true
+        end
+
+        def power_off
+          requires :id
+          begin
+            connection.power_off(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def shutdown
+          requires :id
+          begin
+            connection.power_shutdown(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def power_reset
+          requires :id
+          connection.power_reset(id)
+          true
+        end
+
+        def graceful_restart
+          requires :id
+          shutdown
+          wait_for { off? }
+          power_on
+        end
+
+        def save
+          requires :name
+          data = connection.instantiate_vapp(name)
+          merge_attributes(data.body)
+          task = connection.deploy_vapp(id)
+          task.wait_for { ready? }
+          task = connection.power_on(id)
+          task.wait_for { ready? }
+          true
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); @type = new_type; end
+        def size=(new_size); @size = new_size; end
+        def IpAddress=(new_ipaddress); @IpAddress = new_ipaddress; end
+        def Links=(new_links); @Links = new_links; end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/servers.rb
new file mode 100644
index 0000000..2668d30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/servers.rb
@@ -0,0 +1,55 @@
+require 'fog/core/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      class Servers < Fog::Collection
+
+        model Fog::Terremark::Shared::Server
+
+        def all
+          data = connection.get_vdc(vdc_id).body['ResourceEntities'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vApp+xml'
+          end
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_vapp(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/task.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/task.rb
new file mode 100644
index 0000000..31307cb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/task.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Task < Fog::Model
+
+        identity :id
+
+        attribute :end_time,    :aliases => 'endTime'
+        attribute :owner,       :aliases => 'Owner'
+        attribute :result,      :aliases => 'Result'
+        attribute :start_time,  :aliases => 'startTime'
+        attribute :status
+        attribute :link,        :aliases => 'Link'
+        attribute :error,       :aliases => 'Error'
+
+        def initialize(attributes = {})
+          new_owner  = attributes.delete('Owner')
+          new_result = attributes.delete('Result')
+          new_error = attributes.delete('Error')
+          new_cancel_link = attributes.delete('Link')
+
+          super
+          self.owner = connection.parse(new_owner)
+          if new_result
+            self.result = connection.parse(new_result)
+          end
+          self.error = connection.parse(new_error) if new_error
+          @cancel_link = connection.parse(new_cancel_link) if new_cancel_link
+        end
+
+        def ready?
+          @status == 'success'
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/tasks.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/tasks.rb
new file mode 100644
index 0000000..9083a6e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/tasks.rb
@@ -0,0 +1,58 @@
+require 'fog/core/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      module Real
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      class Tasks < Fog::Collection
+
+        model Fog::Terremark::Shared::Task
+
+        def all
+          data = connection.get_tasks_list(task_list_id).body['Tasks']
+          load(data)
+        end
+
+        def get(task_id)
+          if task_id && task = connection.get_task(task_id).body
+            new(task)
+          elsif !task_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def task_list_id
+          @task_list_id ||=
+            if connection.default_organization_id && organization = connection.get_organization(connection.default_organization_id).body
+              organization['Links'].detect {|link| link['type'] == 'application/vnd.vmware.vcloud.tasksList+xml'}['href'].split('/').last.to_i
+            else
+              nil
+            end
+        end
+
+        private
+
+        def task_list_id=(new_task_list_id)
+          @task_list_id = new_task_list_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdc.rb
new file mode 100644
index 0000000..1a4788f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdc.rb
@@ -0,0 +1,39 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Vdc < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+        def networks
+          connection.networks(:vdc_id => id)
+        end
+
+        def addresses
+          connection.addresses(:vdc_id => id)
+        end
+
+        def servers
+          connection.servers(:vdc_id => id)
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+        def rel=(new_rel); end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdcs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdcs.rb
new file mode 100644
index 0000000..d47793f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/models/shared/vdcs.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      class Vdcs < Fog::Collection
+
+        model Fog::Terremark::Shared::Vdc
+
+        def all
+          data = connection.get_organization(organization_id).body['Links'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+          end
+          load(data)
+        end
+
+        def get(vdc_id)
+          if vdc_id && vdc = connection.get_vdc(vdc_id).body
+            new(vdc)
+          elsif !vdc_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def organization_id
+          @vdc_id ||= connection.default_organization_id
+        end
+
+        private
+
+        def organization_id=(new_organization_id)
+          @organization_id = new_organization_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parser.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parser.rb
new file mode 100644
index 0000000..14325c1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parser.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Terremark
+    module Shared
+      module Parser
+
+        remove_method :parse
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog.rb
new file mode 100644
index 0000000..f426c31
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalog < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CatalogItems' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                catalog_item[attributes.shift] = attributes.shift
+              end            
+              @response['CatalogItems'] << catalog_item
+            when 'Catalog'
+              catalog = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog[attribute.first] = attribute.last
+                else
+                  catalog[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog_item.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog_item.rb
new file mode 100644
index 0000000..b6effc2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_catalog_item.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalogItem < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Entity' => {}, 'Properties' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Entity'
+              until attributes.empty?
+                @response['Entity'][attributes.shift] = attributes.shift
+              end
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog_item[attribute.first] = attribute.last
+                else
+                  catalog_item[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog_item['name']
+            when 'Property'
+              @property_key = attributes.last
+            end
+          end
+
+          def end_element(name)
+            if name == 'Property'
+              @response['Properties'][@property_key] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_internet_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_internet_services.rb
new file mode 100644
index 0000000..1aaf049
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_internet_services.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetInternetServices < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @internet_service = {}
+            @response = { 'InternetServices' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @internet_service[name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @internet_service[name] = true
+              else
+                @internet_service[name] = false
+              end
+            when 'Href', 'Name'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = @value
+              else
+                @internet_service[name] = @value
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = @value.to_i
+              else
+                @internet_service[name] = @value.to_i
+              end
+            when 'InternetService'
+              @response['InternetServices'] << @internet_service
+              @internet_service = {}
+            when 'Port', 'Timeout'
+              @internet_service[name] = @value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_network_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_network_ips.rb
new file mode 100644
index 0000000..12e5970
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_network_ips.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNetworkIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'IpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Name', 'Status', 'Server'
+              @ip_address[name.downcase] = @value
+            when 'IpAddress'
+              @response['IpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_node_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_node_services.rb
new file mode 100644
index 0000000..8acae66
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_node_services.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNodeServices < Fog::Parsers::Base
+
+          def reset
+            @node_service = {}
+            @response = { 'NodeServices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'Name', 'IpAddress'
+              @node_service[name] = @value
+            when 'Enabled'
+              if @value == 'true'
+                @node_service[name] = true
+              else
+                @node_service[name] = false
+              end
+            when 'Id', 'Port'
+              @node_service[name] = @value.to_i
+            when 'NodeService'
+              @response['NodeServices'] << @node_service
+              @node_service = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organization.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organization.rb
new file mode 100644
index 0000000..1f3d865
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organization.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganization < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  link[attribute.first] = attribute.last
+                else
+                  link[attributes.shift] = attributes.shift
+                end
+              end
+              @response['Links'] << link
+            when 'Org'
+              org = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  org[attribute.first] = attribute.last
+                else
+                  org[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = org['href']
+              @response['name'] = org['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organizations.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organizations.rb
new file mode 100644
index 0000000..6216f3c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_organizations.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganizations < Fog::Parsers::Base
+
+          def reset
+            @response = { 'OrgList' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            if name == 'Org'
+              organization = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  organization[attribute.first] = attribute.last
+                else
+                  organization[attributes.shift] = attributes.shift
+                end
+              end
+              @response['OrgList'] << organization
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_public_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_public_ips.rb
new file mode 100644
index 0000000..98d9d2e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_public_ips.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetPublicIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'PublicIpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @ip_address[name.downcase] = @value
+            when 'Id'
+              @ip_address['id'] = @value.to_i
+            when 'PublicIPAddress'
+              @response['PublicIpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_tasks_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_tasks_list.rb
new file mode 100644
index 0000000..4cffd45
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_tasks_list.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetTasksList < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Tasks' => [] }
+            @task = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @task[name] = data
+            when 'Task'
+              until attributes.empty?
+                @task[attributes.shift] = attributes.shift
+              end
+            when 'TasksList'
+              tasks_list = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  tasks_list[attribute.first] = attribute.last
+                else
+                  tasks_list[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = tasks_list['href']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Task'
+              @response['Tasks'] << @task
+              @task = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vapp_template.rb
new file mode 100644
index 0000000..0bda28b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vapp_template.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end            
+              @response['Links'] << link
+            when 'VAppTemplate'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = vapp_template['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response['Description'] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vdc.rb
new file mode 100644
index 0000000..9ed1d30
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/get_vdc.rb
@@ -0,0 +1,123 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVdc < Fog::Parsers::Base
+
+          def reset
+            @in_storage_capacity = false
+            @in_cpu = false
+            @in_memory = false
+            @in_instantiated_vms_quota = false
+            @in_deployed_vms_quota = false
+            @response = { 
+              'links' => [],
+              'AvailableNetworks' => [],
+              'ComputeCapacity'   => {
+                'Cpu' => {},
+                'DeployedVmsQuota' => {},
+                'InstantiatedVmsQuota' => {},
+                'Memory' => {}
+              },
+              'StorageCapacity'  => {},
+              'ResourceEntities' => []
+            }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Cpu'
+              @in_cpu = true
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = true
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = true
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  link[attribute.first] = attribute.last
+                else
+                  link[attributes.shift] = attributes.shift
+                end
+              end
+              @response['links'] << link
+            when 'Memory'
+              @in_memory = true
+            when 'Network'
+              network = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  network[attribute.first] = attribute.last
+                else
+                  network[attributes.shift] = attributes.shift
+                end
+              end
+              @response['AvailableNetworks'] << network
+            when 'ResourceEntity'
+              resource_entity = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  resource_entity[attribute.first] = attribute.last
+                else
+                  resource_entity[attributes.shift] = attributes.shift
+                end
+              end
+              @response['ResourceEntities'] << resource_entity
+            when 'StorageCapacity'
+              @in_storage_capacity = true
+            when 'Vdc'
+              vdc = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vdc[attribute.first] = attribute.last
+                else
+                  vdc[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = vdc['href']
+              @response['name'] = vdc['name']
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Allocated', 'Limit', 'Units', 'Used'
+              if @in_cpu
+                @response['ComputeCapacity']['Cpu'][name] = @value
+              elsif @in_deployed_vms_quota
+                @response['ComputeCapacity']['DeployedVmsQuota'][name] = @value
+              elsif @in_instantiated_vms_quota
+                @response['ComputeCapacity']['InstantiatedVmsQuota'][name] = @value
+              elsif @in_memory
+                @response['ComputeCapacity']['Memory'][name] = @value
+              elsif @in_storage_capacity
+                @response['StorageCapacity'][name] = @value
+              end
+            when 'Cpu'
+              @in_cpu = false
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = false
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = false
+            when 'Memory'
+              @in_memory = false
+            when 'StorageCapacity'
+              @in_storage_capacity = false
+            when 'Type'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..1f27a60
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InstantiateVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @property_key
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response['Links'] << link
+            when 'VApp'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(vapp_template.reject {|key, value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/internet_service.rb
new file mode 100644
index 0000000..86bc25f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/internet_service.rb
@@ -0,0 +1,65 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InternetService < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @response = { 'PublicIpAddress' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Href'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = data
+              else
+                @response[name] = data
+              end
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @response[name] = @value
+            when 'Enabled'
+              if @value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = @value.to_i
+              else
+                @response[name] = @value.to_i
+              end
+            when 'Name'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = @value
+              else
+                @response[name] = @value
+              end
+            when 'Port', 'Timeout'
+              @response[name] = @value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/network.rb
new file mode 100644
index 0000000..24f5481
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/network.rb
@@ -0,0 +1,51 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Network < Fog::Parsers::Base
+
+          def reset
+            @response = {
+              "links" => []
+            }
+          end
+
+          def start_element(name,attributes=[])
+            super
+            case name
+            when "Network"
+              until attributes.empty?
+                val = attributes.shift
+                if val.is_a?(String)
+                  @response[val] = attributes.shift
+                end
+              end
+              if @response.has_key?("name")
+                @response["subnet"] = @response["name"]
+              end
+              if @response.has_key?("href")
+                @response["id"] = @response["href"].split("/").last
+              end
+            when "Link"
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response["links"] << link
+            end
+          end
+
+          def end_element(name)
+            case name
+            when "Gateway", "Netmask", "FenceMode"
+              @response[name.downcase] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/node_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/node_service.rb
new file mode 100644
index 0000000..d4e4338
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/node_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class NodeService < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'IpAddress', 'Name', 'Protocol'
+              @response[name] = @value
+            when 'Enabled'
+              if @value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id', 'Port'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/public_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/public_ip.rb
new file mode 100644
index 0000000..40191e2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/public_ip.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class PublicIp < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @response[name.downcase] = @value
+            when 'Id'
+              @response['id'] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/task.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/task.rb
new file mode 100644
index 0000000..23f5987
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/task.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Task < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result', 'Link', 'Error'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @response[name] = data
+            when 'Task'
+              task = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  task[attribute.first] = attribute.last
+                else
+                  task[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(task.reject {|key,value| !['endTime', 'href', 'startTime', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/vapp.rb
new file mode 100644
index 0000000..5778316
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/parsers/shared/vapp.rb
@@ -0,0 +1,77 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Vapp < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [], 'VirtualHardware' => {}, 'OperatingSystem' => {} }
+            @in_operating_system = false
+            @resource_type = nil
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+              when 'Link'
+                link = {}
+                until attributes.empty?
+                  link[attributes.shift] = attributes.shift
+                end
+                @response['Links'] << link
+              when 'OperatingSystemSection'
+                @in_operating_system = true
+             when 'VApp'
+                vapp = {}
+                until attributes.empty?
+                  if attributes.first.is_a?(Array)
+                    attribute = attributes.shift
+                    vapp[attribute.first] = attribute.last
+                  else
+                    vapp[attributes.shift] = attributes.shift
+                  end
+                end
+                @response.merge!(vapp.reject {|key,value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+             end
+          end
+
+          def end_element(name)
+            case name
+            when 'IpAddress'
+              @response['IpAddress'] = @value
+            when 'Description'
+              if @in_operating_system
+                @response['OperatingSystem'][name] = @value
+                @in_operating_system = false
+              end
+            when 'ResourceType'
+              @resource_type = @value
+              case @value
+              when '3'
+                @get_cpu = true # cpu
+              when '4'  # memory
+                @get_ram = true
+              when '17' # disks
+                @get_disks = true
+              end
+            when 'VirtualQuantity'
+              case @resource_type
+              when '3'
+                @response['VirtualHardware']['cpu'] = @value
+              when '4'
+                @response['VirtualHardware']['ram'] = @value
+              when '17'
+                @response['VirtualHardware']['disks'] ||= []
+                @response['VirtualHardware']['disks'] << @value
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_internet_service.rb
new file mode 100644
index 0000000..f8d683e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_internet_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * ip_id<~Integer> - Id of ip to add service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_internet_service(ip_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "publicIps/#{ip_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def add_internet_service(ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_node_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_node_service.rb
new file mode 100644
index 0000000..fbb2ca0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/add_node_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * service_id<~String> - Id of service to add node to
+        # * ip<~String> - Private ip of server to add to node
+        # * name<~String> - Name of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_node_service(service_id, ip, name, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <NodeService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createNodeService">
+    <IpAddress>#{ip}</IpAddress>
+    <Name>#{name}</Name>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </NodeService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "internetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def add_node_service(ip)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/create_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/create_internet_service.rb
new file mode 100644
index 0000000..8040d44
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/create_internet_service.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to add internet service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def create_internet_service(vdc_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def create_internet_service(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_internet_service.rb
new file mode 100644
index 0000000..d835b4b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_internet_service.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy an internet service
+        #
+        # ==== Parameters
+        # * internet_service_id<~Integer> - Id of service to destroy
+        #
+        def delete_internet_service(internet_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "InternetServices/#{internet_service_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_internet_service(internet_service_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_node_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_node_service.rb
new file mode 100644
index 0000000..100d0c0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_node_service.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a node
+        #
+        # ==== Parameters
+        # * node_service_id<~Integer> - Id of node to destroy
+        #
+        def delete_node_service(node_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "nodeServices/#{node_service_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_node_service(node_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_public_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_public_ip.rb
new file mode 100644
index 0000000..2646635
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_public_ip.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to destroy
+        #
+        def delete_public_ip(public_ip_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "publicIps/#{public_ip_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_public_ip(public_ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_vapp.rb
new file mode 100644
index 0000000..60134d4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/delete_vapp.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to destroy
+        #
+        def delete_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'DELETE',
+            :path     => "vApp/#{vapp_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def delete_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/deploy_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/deploy_vapp.rb
new file mode 100644
index 0000000..0c252ad
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/deploy_vapp.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vApp to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def deploy_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/action/deploy"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def deploy_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog.rb
new file mode 100644
index 0000000..44fdee7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to view catalog for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalog.new,
+            :path     => "vdc/#{vdc_id}/catalog"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_catalog(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog_item.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog_item.rb
new file mode 100644
index 0000000..e039937
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_catalog_item.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog item
+        #
+        # ==== Parameters
+        # * catalog_item_id<~Integer> - Id of catalog item to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog_item(catalog_item_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalogItem.new,
+            :path     => "catalogItem/#{catalog_item_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_catalog_item(catalog_item_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_internet_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_internet_services.rb
new file mode 100644
index 0000000..1e48e83
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_internet_services.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_internet_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to get list of internet services for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'InternetServices'<~Array>
+        #       * 'id'<~String> => id of the internet service
+        #       * 'name'<~String> => name of service
+        #       * 'PublicIPAddress'<~Hash>
+        #       *   'Id'<~String> => id of the public IP
+        #       *   'name'<~String> => actual ip address
+        #
+        def get_internet_services(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetInternetServices.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_internet_services(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network.rb
new file mode 100644
index 0000000..c45878b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network(network_id)
+         request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Network.new,
+            :path     => "network/#{network_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_network(network_id)
+          network_id = network_id.to_i
+          response = Excon::Response.new
+          if network = @data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:id] == network_id }
+
+            body = { "links" => [],
+                     "type" => "application/vnd.vmware.vcloud.network+xml",
+                     "href" => "#{@base_url}/network/#{network_id}" }
+
+            network.each_key do |key|
+              body[key.to_s] = network[key]
+            end
+
+            link = { "name" => "IP Addresses",
+                     "rel"  => "down",
+                     "type" => "application/xml" }
+            link["href"] = case self
+            when Fog::Terremark::Ecloud::Mock
+              "#{@base_url}/extensions/network/#{network_id}/ips"
+            when Fog::Terremark::Vcloud::Mock
+              "#{@base_url}/network/#{network_id}/ipAddresses"
+            end
+            body["links"] << link
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, 
+              case self
+              when Fog::Terremark::Ecloud::Mock
+                "application/vnd.vmware.vcloud.network+xml"
+              when Fog::Terremark::Vcloud::Mock
+                "application/xml; charset=utf-8"
+              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network_ips.rb
new file mode 100644
index 0000000..c131b9a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_network_ips.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network_ips(network_id)
+          opts =  {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNetworkIps.new,
+            :path     => "network/#{network_id}/ipAddresses"
+          }
+          if self.is_a?(Fog::Terremark::Ecloud::Real)
+            opts[:path] = "/extensions/network/#{network_id}/ips"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_network_ips(network_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_node_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_node_services.rb
new file mode 100644
index 0000000..ef615c7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_node_services.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_node_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * service_id<~Integer> - Id of internet service that we want a list of nodes for
+         #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+       
+        #       
+        def get_node_services(service_id)
+           request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNodeServices.new,
+            :path     => "InternetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_node_services(vdc_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organization.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organization.rb
new file mode 100644
index 0000000..40247d3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organization.rb
@@ -0,0 +1,86 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of an organization
+        #
+        # ==== Parameters
+        # * organization_id<~Integer> - Id of organization to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #       * 'href'<~String> - location of link
+        #       * 'name'<~String> - name of link
+        #       * 'rel'<~String> - action to perform
+        #       * 'type'<~String> - type of link
+        #     * 'name'<~String> - Name of organization
+        def get_organization(organization_id)
+          response = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganization.new,
+            :path     => "org/#{organization_id}"
+          )
+          response
+        end
+
+      end
+
+      module Mock
+
+        def get_organization(organization_id)
+          organization_id = organization_id.to_i
+          response = Excon::Response.new
+
+          if org = @data[:organizations].detect { |org| org[:info][:id] == organization_id }
+
+            body = { "name" => org[:info][:name],
+                     "href" => "#{@base_url}/org/#{org[:info][:id]}",
+                     "Links" => [] }
+
+            body["Links"] = case self
+            when Fog::Terremark::Vcloud::Mock
+              _vdc_links(org[:vdcs][0])
+            when Fog::Terremark::Ecloud::Mock
+              org[:vdcs].map do |vdc|
+                _vdc_links(vdc)
+              end.flatten
+            end
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+        private
+
+        def _vdc_links(vdc)
+          [{ "name" => vdc[:name],
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.vdc+xml" },
+           { "name" => "#{vdc[:name]} Catalog",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.catalog+xml" },
+           { "name" => "#{vdc[:name]} Tasks List",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/taskslist",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.tasksList+xml" }
+          ]
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organizations.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organizations.rb
new file mode 100644
index 0000000..0036526
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_organizations.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of organizations
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #     * 'name'<~String> - Name of organization
+        def get_organizations
+          request({
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              # Terremark said they're going to remove passing in the Content-Type to login in a future release
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path     => 'login'
+          })
+        end
+
+      end
+
+      module Mock
+
+        def get_organizations
+          response = Excon::Response.new
+          org_list = @data[:organizations].map do |organization|
+            { "name" => organization[:info][:name],
+              "href" => "#{@base_url}/org/#{organization[:info][:id]}",
+              "type" => "application/vnd.vmware.vcloud.org+xml"
+            }
+          end
+          response.body = { "OrgList" => org_list }
+          response.status = 200
+          response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.orgList+xml")
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ip.rb
new file mode 100644
index 0000000..a3cc166
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ip.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        def get_public_ip(public_ip_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::PublicIp.new,
+            :path     => "publicIps/#{public_ip_id}"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/publicIp/#{public_ip_id}"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_public_ip(public_ip_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ips.rb
new file mode 100644
index 0000000..3a6ac41
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_public_ips.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of public ips
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to find public ips for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - link to item
+        #       * 'name'<~String> - name of item
+        def get_public_ips(vdc_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetPublicIps.new,
+            :path     => "vdc/#{vdc_id}/publicIps"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/vdc/#{vdc_id}/publicIps"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_public_ips(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = @data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+            body = { "PublicIpAddresses" => [] }
+            vdc[:public_ips].each do |ip|
+              ip = { "name" => ip[:name],
+                     "href" => case self
+                                when Fog::Terremark::Ecloud::Mock
+                                  "#{@base_url}/extensions/publicIp/#{ip[:id]}"
+                                when Fog::Terremark::Vcloud::Mock
+                                  "#{@base_url}/PublicIps/#{ip[:id]}"
+                                end,
+                     "id"   => ip[:id].to_s }
+              body["PublicIpAddresses"] << ip
+            end
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body,
+                              case self
+                              when Fog::Terremark::Ecloud::Mock
+                                "application/vnd.tmrk.ecloud.publicIpsList+xml"
+                              when Fog::Terremark::Vcloud::Mock
+                                "application/xml; charset=utf-8"
+                              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_task.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_task.rb
new file mode 100644
index 0000000..37be4dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_task.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a task
+        #
+        # ==== Parameters
+        # * task_id<~Integer> - Id of task to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_task(task_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "task/#{task_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_task(task_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_tasks_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_tasks_list.rb
new file mode 100644
index 0000000..a700175
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_tasks_list.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of tasks
+        #
+        # ==== Parameters
+        # * tasks_list_id<~Integer> - Id of tasks lists to view
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_tasks_list(tasks_list_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetTasksList.new,
+            :path     => "tasksList/#{tasks_list_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_tasks_list(tasks_list_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp.rb
new file mode 100644
index 0000000..47f9b7e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp.rb
@@ -0,0 +1,50 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_vapp(vapp_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Vapp.new,
+            :path     => "vapp/#{vapp_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vapp(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp_template.rb
new file mode 100644
index 0000000..e382ebb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vapp_template.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp template
+        #
+        # ==== Parameters
+        # * vapp_template_id<~Integer> - Id of vapp template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vapp_template(vapp_template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVappTemplate.new,
+            :path     => "vAppTemplate/#{vapp_template_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vapp_template(vapp_template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vdc.rb
new file mode 100644
index 0000000..2eb2d10
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/get_vdc.rb
@@ -0,0 +1,125 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vdc(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVdc.new,
+            :path     => "vdc/#{vdc_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vdc(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = @data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+
+            body = { "name" => vdc[:name],
+                     "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+                     "StorageCapacity" => {},
+                     "ComputeCapacity" => { "InstantiatedVmsQuota" => {},
+                                            "DeployedVmsQuota" => {},
+                                            "Cpu" => {},
+                                            "Memory" => {} },
+                     "ResourceEntities" => [],
+                     "AvailableNetworks" => [],
+                     "links" => [] }
+
+            case self
+            when Fog::Terremark::Ecloud::Mock
+              body["StorageCapacity"] = { "Units" => "bytes * 10^9" }
+              vdc[:storage].each { |k,v| body["StorageCapacity"][k.to_s.capitalize] = v.to_s }
+
+              body["ComputeCapacity"] = { "InstantiatedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "DeployedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "Cpu" => { "Units" => "hz * 10^6" },
+                                           "Memory" => { "Units" => "bytes * 2^20" } }
+
+              [:cpu, :memory].each do |key|
+                vdc[key].each { |k,v| body["ComputeCapacity"][key.to_s.capitalize][k.to_s.capitalize] = v.to_s }
+              end
+
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.publicIpsList+xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.internetServicesList+xml" }
+
+              body["links"] << { "name" => "Firewall Access List",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/firewallAcls",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.firewallAclsList+xml" }
+
+            when Fog::Terremark::Vcloud::Mock
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+            end
+
+            vdc[:vms].each do |vm|
+              body["ResourceEntities"] << { "name" => vm[:name],
+                                            "href" => "#{@base_url}/vapp/#{vm[:id]}",
+                                            "type" => "application/vnd.vmware.vcloud.vApp+xml" }
+            end
+
+            vdc[:networks].each do |network|
+              body["AvailableNetworks"] << { "name" => network[:name],
+                                             "href" => "#{@base_url}/network/#{network[:id]}",
+                                             "type" => "application/vnd.vmware.vcloud.network+xml" }
+            end
+
+            body["links"] << { "name" => vdc[:name],
+                               "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+                               "rel"  => "down",
+                               "type" => "application/vnd.vmware.vcloud.catalog+xml" }
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..4a463dc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
@@ -0,0 +1,79 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Instatiate a vapp template
+        #
+        # ==== Parameters
+        # * name<~String>: Name of the resulting vapp .. must start with letter, up to 15 chars alphanumeric.
+        # * options<~Hash>:
+        # * cpus<~Integer>: Number of cpus in [1, 2, 4, 8], defaults to 1
+        # * memory<~Integer>: Amount of memory either 512 or a multiple of 1024, defaults to 512
+        # * vapp_template<~String>: id of the vapp template to be instantiated
+        # ==== Returns
+        # * response<~Excon::Response>:
+        # * body<~Hash>:
+        # * 'Links;<~Array> (e.g. up to vdc)
+        # * 'href'<~String> Link to the resulting vapp
+        # * 'name'<~String> - name of item
+        # * 'type'<~String> - type of item
+        # * 'status'<~String> - 0(pending) --> 2(off) -->4(on)
+        def instantiate_vapp_template(name, vapp_template, options = {})
+          unless name.length < 15
+            raise ArgumentError.new('Name must be fewer than 15 characters')
+          end
+          options['cpus'] ||= 1
+          options['memory'] ||= 512
+          options['network_id'] ||= default_network_id
+          options['vdc_id'] ||= default_vdc_id
+
+          data = <<-DATA
+<?xml version="1.0" encoding="UTF-8"?>
+<InstantiateVAppTemplateParams name="#{name}" xmlns="http://www.vmware.com/vcloud/v0.8" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.vmware.com/vcloud/v0.8 http://services.vcloudexpress.terremark.com/api/v0.8/ns/vcloud.xsd">
+  <VAppTemplate href="#{@scheme}://#{@host}/#{@path}/vAppTemplate/#{vapp_template}" />
+  <InstantiationParams xmlns:vmw="http://www.vmware.com/schema/ovf">
+    <ProductSection xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1" xmlns:q1="http://www.vmware.com/vcloud/v0.8"/>
+    <VirtualHardwareSection xmlns:q1="http://www.vmware.com/vcloud/v0.8">
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">1</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">3</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['cpus']}</VirtualQuantity>
+      </Item>
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">2</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">4</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['memory']}</VirtualQuantity>
+      </Item>
+    </VirtualHardwareSection>
+    <NetworkConfigSection>
+      <NetworkConfig>
+        <NetworkAssociation href="#{@scheme}://#{@host}/#{@path}/network/#{options['network_id']}"/>
+      </NetworkConfig>
+    </NetworkConfigSection>
+  </InstantiationParams>
+</InstantiateVAppTemplateParams>
+DATA
+
+          request(
+            :body => data,
+            :expects => 200,
+            :headers => { 'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml' },
+            :method => 'POST',
+            :parser => Fog::Parsers::Terremark::Shared::InstantiateVappTemplate.new,
+            :path => "vdc/#{options['vdc_id']}/action/instantiatevAppTemplate"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def instatiate_vapp_template(vapp_template_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_off.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_off.rb
new file mode 100644
index 0000000..947712c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_off.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power off a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power off
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_off(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOff"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_off(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_on.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_on.rb
new file mode 100644
index 0000000..abb2672
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_on.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power on a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_on(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOn"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_on(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_reset.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_reset.rb
new file mode 100644
index 0000000..d513a22
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_reset.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reset a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to reset
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_reset(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/reset"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def reset(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_shutdown.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_shutdown.rb
new file mode 100644
index 0000000..9cf51f0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/requests/shared/power_shutdown.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Shutdown a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to shutdown
+        #
+        # ==== Returns
+        # Nothing
+        def power_shutdown(vapp_id)
+          request(
+            :expects  => 204,
+            :method   => 'POST',
+            :path     => "vApp/#{vapp_id}/power/action/shutdown"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def power_shutdown(vapp_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/shared.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/shared.rb
new file mode 100644
index 0000000..88f3e33
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/shared.rb
@@ -0,0 +1,289 @@
+module Fog
+  module Terremark
+    module Shared
+
+      # Commond methods shared by Real and Mock
+      module Common
+
+        def default_organization_id
+          @default_organization_id ||= begin
+            org_list = get_organizations.body['OrgList']
+            if org_list.length == 1
+              org_list.first['href'].split('/').last.to_i
+            else
+              nil
+            end
+          end
+        end
+
+      end
+
+      module Parser
+
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+
+      module Real
+        include Common
+
+        private
+
+        def auth_token
+          response = @connection.request({
+            :expects   => 200,
+            :headers   => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :host      => @host,
+            :method    => 'POST',
+            :parser    => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path      => "#{@path}/login"
+          })
+          response.headers['Set-Cookie']
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          unless @cookie
+            @cookie = auth_token
+          end
+          begin
+            do_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            @cookie = auth_token
+            do_request(params)
+          end
+        end
+
+        def do_request(params)
+          headers = {}
+          if @cookie
+            headers.merge!('Cookie' => @cookie)
+          end
+          @connection.request({
+            :body     => params[:body],
+            :expects  => params[:expects],
+            :headers  => headers.merge!(params[:headers] || {}),
+            :host     => @host,
+            :method   => params[:method],
+            :parser   => params[:parser],
+            :path     => "#{@path}/#{params[:path]}"
+          })
+        end
+
+      end
+
+      module Mock
+        include Common
+
+        def self.mock_data
+        {
+          :organizations =>
+          [
+            {
+              :info => {
+                :name => "Boom Inc.",
+                :id => 1
+              },
+              :vdcs => [
+                { :id => 21,
+                  :name => "Boomstick",
+                  :storage => { :used => 105, :allocated => 200 },
+                  :cpu => { :allocated => 10000 },
+                  :memory => { :allocated => 20480 },
+                  :networks => [
+                    { :id => 31,
+                      :name => "1.2.3.0/24",
+                      :subnet => "1.2.3.0/24",
+                      :gateway => "1.2.3.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                    { :id => 32,
+                      :name => "4.5.6.0/24",
+                      :subnet => "4.5.6.0/24",
+                      :gateway => "4.5.6.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                  ],
+                  :vms => [
+                    { :id => 41,
+                      :name => "Broom 1"
+                    },
+                    { :id => 42,
+                      :name => "Broom 2"
+                    },
+                    { :id => 43,
+                      :name => "Email!"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 51,
+                      :name => "99.1.2.3"
+                    },
+                    { :id => 52,
+                      :name => "99.1.2.4"
+                    },
+                    { :id => 53,
+                      :name => "99.1.9.7"
+                    }
+                  ]
+                },
+                { :id => 22,
+                  :storage => { :used => 40, :allocated => 150 },
+                  :cpu => { :allocated => 1000 },
+                  :memory => { :allocated => 2048 },
+                  :name => "Rock-n-Roll",
+                  :networks => [
+                    { :id => 33,
+                      :name => "7.8.9.0/24",
+                      :subnet => "7.8.9.0/24",
+                      :gateway => "7.8.9.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    }
+                  ],
+                  :vms => [
+                    { :id => 44,
+                      :name => "Master Blaster"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 54,
+                      :name => "99.99.99.99"
+                    }
+                  ]
+                }
+              ]
+            }
+          ]
+        }
+        end
+
+        def self.error_headers
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=>"text/html",
+           "Content-Length"=>"0",
+           "Server"=>"Microsoft-IIS/7.0",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.unathorized_status
+          401
+        end
+
+        def self.headers(body, content_type)
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=> content_type,
+           "Content-Length"=> body.to_s.length,
+           "Server"=>"Microsoft-IIS/7.0",
+           "Set-Cookie"=>"vcloud-token=ecb37bfc-56f0-421d-97e5-bf2gdf789457; path=/",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.status
+          200
+        end
+
+        def initialize(options={})
+          self.class.instance_eval '
+            def self.data
+              @data ||= Hash.new do |hash, key|
+                hash[key] = Fog::Terremark::Shared::Mock.mock_data
+              end
+            end'
+          self.class.instance_eval '
+            def self.reset_data(keys=data.keys)
+              for key in [*keys]
+                data.delete(key)
+              end
+            end'
+        end
+      end
+
+      def check_shared_options(options)
+        %w{ecloud vcloud}.each do |cloud|
+          cloud_option_keys = options.keys.select { |key| key.to_s =~ /^terremark_#{cloud}_.*/ }
+          unless cloud_option_keys.length == 0 || cloud_option_keys.length == 2
+            raise ArgumentError.new("terremark_#{cloud}_username and terremark_#{cloud}_password required to access teremark")
+          end
+        end
+      end
+
+      def shared_requires
+        require 'fog/terremark/models/shared/address'
+        require 'fog/terremark/models/shared/addresses'
+        require 'fog/terremark/models/shared/network'
+        require 'fog/terremark/models/shared/networks'
+        require 'fog/terremark/models/shared/server'
+        require 'fog/terremark/models/shared/servers'
+        require 'fog/terremark/models/shared/task'
+        require 'fog/terremark/models/shared/tasks'
+        require 'fog/terremark/models/shared/vdc'
+        require 'fog/terremark/models/shared/vdcs'
+        require 'fog/terremark/parsers/shared/get_catalog'
+        require 'fog/terremark/parsers/shared/get_catalog_item'
+        require 'fog/terremark/parsers/shared/get_internet_services'
+        require 'fog/terremark/parsers/shared/get_network_ips'
+        require 'fog/terremark/parsers/shared/get_node_services'
+        require 'fog/terremark/parsers/shared/get_organization'
+        require 'fog/terremark/parsers/shared/get_organizations'
+        require 'fog/terremark/parsers/shared/get_public_ips'
+        require 'fog/terremark/parsers/shared/get_tasks_list'
+        require 'fog/terremark/parsers/shared/get_vapp_template'
+        require 'fog/terremark/parsers/shared/get_vdc'
+        require 'fog/terremark/parsers/shared/instantiate_vapp_template'
+        require 'fog/terremark/parsers/shared/internet_service'
+        require 'fog/terremark/parsers/shared/network'
+        require 'fog/terremark/parsers/shared/node_service'
+        require 'fog/terremark/parsers/shared/public_ip'
+        require 'fog/terremark/parsers/shared/task'
+        require 'fog/terremark/parsers/shared/vapp'
+        require 'fog/terremark/requests/shared/add_internet_service'
+        require 'fog/terremark/requests/shared/add_node_service'
+        require 'fog/terremark/requests/shared/create_internet_service'
+        require 'fog/terremark/requests/shared/delete_internet_service'
+        require 'fog/terremark/requests/shared/delete_public_ip'
+        require 'fog/terremark/requests/shared/delete_node_service'
+        require 'fog/terremark/requests/shared/delete_vapp'
+        require 'fog/terremark/requests/shared/deploy_vapp'
+        require 'fog/terremark/requests/shared/get_catalog'
+        require 'fog/terremark/requests/shared/get_catalog_item'
+        require 'fog/terremark/requests/shared/get_internet_services'
+        require 'fog/terremark/requests/shared/get_network'
+        require 'fog/terremark/requests/shared/get_network_ips'
+        require 'fog/terremark/requests/shared/get_node_services'
+        require 'fog/terremark/requests/shared/get_organization'
+        require 'fog/terremark/requests/shared/get_organizations'
+        require 'fog/terremark/requests/shared/get_public_ip'
+        require 'fog/terremark/requests/shared/get_public_ips'
+        require 'fog/terremark/requests/shared/get_task'
+        require 'fog/terremark/requests/shared/get_tasks_list'
+        require 'fog/terremark/requests/shared/get_vapp'
+        require 'fog/terremark/requests/shared/get_vapp_template'
+        require 'fog/terremark/requests/shared/get_vdc'
+        require 'fog/terremark/requests/shared/instantiate_vapp_template'
+        require 'fog/terremark/requests/shared/power_off'
+        require 'fog/terremark/requests/shared/power_on'
+        require 'fog/terremark/requests/shared/power_reset'
+        require 'fog/terremark/requests/shared/power_shutdown'
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/vcloud.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/vcloud.rb
new file mode 100644
index 0000000..efa5b14
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/terremark/vcloud.rb
@@ -0,0 +1,113 @@
+module Fog
+  module Terremark
+   module Vcloud
+
+     module Bin
+     end
+
+     module Defaults
+       HOST   = 'services.vcloudexpress.terremark.com'
+       PATH   = '/api/v0.8'
+       PORT   = 443
+       SCHEME = 'https'
+     end
+
+     extend Fog::Terremark::Shared
+
+     def self.new(options={})
+
+       unless @required
+         shared_requires
+         @required = true
+       end
+
+       check_shared_options(options)
+
+       if Fog.mocking?
+          Fog::Terremark::Vcloud::Mock.new(options)
+       else
+          Fog::Terremark::Vcloud::Real.new(options)
+       end
+     end
+
+     class Real
+
+       include Fog::Terremark::Shared::Real
+       include Fog::Terremark::Shared::Parser
+
+        def initialize(options={})
+          @terremark_password = options[:terremark_vcloud_password]
+          @terremark_username = options[:terremark_vcloud_username]
+          @host   = options[:host]   || Fog::Terremark::Vcloud::Defaults::HOST
+          @path   = options[:path]   || Fog::Terremark::Vcloud::Defaults::PATH
+          @port   = options[:port]   || Fog::Terremark::Vcloud::Defaults::PORT
+          @scheme = options[:scheme] || Fog::Terremark::Vcloud::Defaults::SCHEME
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def default_vdc_id
+          if default_organization_id
+            @default_vdc_id ||= begin
+              vdcs = get_organization(default_organization_id).body['Links'].select {|link|
+                link['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+              }
+              if vdcs.length == 1
+                vdcs.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_network_id
+          if default_vdc_id
+            @default_network_id ||= begin
+              networks = get_vdc(default_vdc_id).body['AvailableNetworks']
+              if networks.length == 1
+                networks.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_public_ip_id
+          if default_vdc_id
+            @default_public_ip_id ||= begin
+              ips = get_public_ips(default_vdc_id).body['PublicIpAddresses']
+              if ips.length == 1
+                ips.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+     end
+
+     class Mock
+       include Fog::Terremark::Shared::Mock
+       include Fog::Terremark::Shared::Parser
+
+       def initialize(option = {})
+         super
+         @base_url = Fog::Terremark::Vcloud::Defaults::SCHEME + "://" +
+                     Fog::Terremark::Vcloud::Defaults::HOST +
+                     Fog::Terremark::Vcloud::Defaults::PATH
+         @data = self.class.data[:terremark_vcloud_username]
+       end
+     end
+
+   end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud.rb
new file mode 100644
index 0000000..f1e1dcf
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud.rb
@@ -0,0 +1,337 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+require 'builder'
+require 'fog/vcloud/model'
+require 'fog/vcloud/collection'
+require 'fog/vcloud/generators'
+require 'fog/vcloud/mock_data_classes'
+# ecloud/vcloud requires at the bottom so that the following will be defined
+
+module URI
+  class Generic
+    def host_url
+      @host_url ||= "#{self.scheme}://#{self.host}#{self.port ? ":#{self.port}" : ''}"
+    end
+  end
+end
+
+module Fog
+  class Vcloud < Fog::Service
+
+    requires :username, :password, :versions_uri
+    recognizes :version, :persistent
+
+    model_path 'fog/vcloud/models'
+    model :vdc
+    collection :vdcs
+
+    request_path 'fog/vcloud/requests'
+    request :login
+    request :get_versions
+    request :get_vdc
+    request :get_organization
+    request :get_network
+
+    class UnsupportedVersion < Exception ; end
+
+    module Shared
+      attr_reader :versions_uri
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      def supported_versions
+        @supported_versions ||= get_versions(@versions_uri).body[:VersionInfo]
+      end
+
+      def xmlns
+        { "xmlns" => "http://www.vmware.com/vcloud/v0.8",
+          "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+          "xmlns:xsd" => "http://www.w3.org/2001/XMLSchema" }
+      end
+
+      # private
+
+      def ensure_unparsed(uri)
+        if uri.is_a?(String)
+          uri
+        else
+          uri.to_s
+        end
+      end
+
+    end
+
+    class Real
+      include Shared
+      extend Fog::Vcloud::Generators
+
+      def supporting_versions
+        ["0.8"]
+      end
+
+      def initialize(options = {})
+        @connections = {}
+        @versions_uri = URI.parse(options[:versions_uri])
+        @module = options[:module]
+        @version = options[:version]
+        @username = options[:username]
+        @password = options[:password]
+        @persistent = options[:persistent]
+      end
+
+      def default_organization_uri
+        @default_organization_uri ||= begin
+          unless @login_results
+            do_login
+          end
+          case @login_results.body[:Org]
+          when Array
+            @login_results.body[:Org].first[:href]
+          when Hash
+            @login_results.body[:Org][:href]
+          else
+            nil
+          end
+        end
+      end
+
+      def reload
+        @connections.each_value { |k,v| v.reset if v }
+      end
+
+      # If the cookie isn't set, do a get_organizations call to set it
+      # and try the request.
+      # If we get an Unauthorized error, we assume the token expired, re-auth and try again
+      def request(params)
+        unless @cookie
+          do_login
+        end
+        begin
+          do_request(params)
+        rescue Excon::Errors::Unauthorized => e
+          do_login
+          do_request(params)
+        end
+      end
+
+      private
+
+      def ensure_parsed(uri)
+        if uri.is_a?(String)
+          URI.parse(uri)
+        else
+          uri
+        end
+      end
+
+      def supported_version_numbers
+        case supported_versions
+        when Array
+          supported_versions.map { |version| version[:Version] }
+        when Hash
+          [ supported_versions[:Version] ]
+        end
+      end
+
+      def get_login_uri
+        check_versions
+        URI.parse case supported_versions
+        when Array
+          supported_versions.detect {|version| version[:Version] == @version }[:LoginUrl]
+        when Hash
+          supported_versions[:LoginUrl]
+        end
+      end
+
+      # If we don't support any versions the service does, then raise an error.
+      # If the @version that super selected isn't in our supported list, then select one that is.
+      def check_versions
+        if @version
+          unless supported_version_numbers.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by the server.")
+          end
+          unless supporting_versions.include?(@version.to_s)
+            raise UnsupportedVersion.new("#{@version} is not supported by #{self.class}")
+          end
+        else
+          unless @version = (supported_version_numbers & supporting_versions).sort.first
+            raise UnsupportedVersion.new("\nService @ #{@versions_uri} supports: #{supported_version_numbers.join(', ')}\n" +
+                                         "#{self.class} supports: #{supporting_versions.join(', ')}")
+          end
+        end
+      end
+
+      # Don't need to  set the cookie for these or retry them if the cookie timed out
+      def unauthenticated_request(params)
+        do_request(params)
+      end
+
+      # Use this to set the Authorization header for login
+      def authorization_header
+        "Basic #{Base64.encode64("#{@username}:#{@password}").chomp!}"
+      end
+
+      def login_uri
+        @login_uri ||= get_login_uri
+      end
+
+      # login handles the auth, but we just need the Set-Cookie
+      # header from that call.
+      def do_login
+        @login_results = login
+        @cookie = @login_results.headers['Set-Cookie']
+      end
+
+      # Actually do the request
+      def do_request(params)
+        # Convert the uri to a URI if it's a string.
+        if params[:uri].is_a?(String)
+          params[:uri] = URI.parse(params[:uri])
+        end
+
+        # Hash connections on the host_url ... There's nothing to say we won't get URI's that go to
+        # different hosts.
+        @connections[params[:uri].host_url] ||= Fog::Connection.new(params[:uri].host_url, @persistent)
+
+        # Set headers to an empty hash if none are set.
+        headers = params[:headers] || {}
+
+        # Add our auth cookie to the headers
+        if @cookie
+          headers.merge!('Cookie' => @cookie)
+        end
+
+        # Make the request
+        response = @connections[params[:uri].host_url].request({
+          :body     => params[:body] || '',
+          :expects  => params[:expects] || 200,
+          :headers  => headers,
+          :method   => params[:method] || 'GET',
+          :path     => params[:uri].path
+        })
+
+        # Parse the response body into a hash
+        #puts response.body
+        unless response.body.empty?
+          if params[:parse]
+            document = Fog::ToHashDocument.new
+            parser = Nokogiri::XML::SAX::PushParser.new(document)
+            parser << response.body
+            parser.finish
+
+            response.body = document.body
+          end
+        end
+
+        response
+      end
+    end
+
+    class Mock
+      include Shared
+      include MockDataClasses
+
+      def self.base_url
+        "https://fakey.com/api/v0.8"
+      end
+
+      def self.data_reset
+        @mock_data = nil
+      end
+
+      def self.data( base_url = self.base_url )
+        MockDataClasses::Base.base_url = base_url
+
+        @mock_data ||= MockData.new.tap do |mock_data|
+          mock_data.versions << MockVersion.new(:version => "v0.8", :supported => true)
+
+          mock_data.organizations << MockOrganization.new(:name => "Boom Inc.").tap do |mock_organization|
+            mock_organization.vdcs << MockVdc.new(:name => "Boomstick").tap do |mock_vdc|
+              mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 0").tap do |mock_catalog_item|
+                mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+              end
+              mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 1").tap do |mock_catalog_item|
+                mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+              end
+              mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 2").tap do |mock_catalog_item|
+                mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+              end
+
+              mock_vdc.networks << MockNetwork.new({ :subnet => "1.2.3.0/24" }, mock_vdc)
+              mock_vdc.networks << MockNetwork.new({ :subnet => "4.5.6.0/24" }, mock_vdc)
+
+              mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Broom 1", :ip => "1.2.3.3" }, mock_vdc)
+              mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Broom 2", :ip => "1.2.3.4" }, mock_vdc)
+              mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Email!", :ip => "1.2.3.10" }, mock_vdc)
+            end
+
+            mock_organization.vdcs << MockVdc.new(:name => "Rock-n-Roll", :storage_allocated => 150, :storage_used => 40, :cpu_allocated => 1000, :memory_allocated => 2048).tap do |mock_vdc|
+              mock_vdc.networks << MockNetwork.new({ :subnet => "7.8.9.0/24" }, mock_vdc)
+
+              mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Master Blaster", :ip => "7.8.9.10" }, mock_vdc)
+            end
+          end
+        end
+      end
+
+      def initialize(options = {})
+        @versions_uri = URI.parse('https://vcloud.fakey.com/api/versions')
+      end
+
+      def mock_it(status, mock_data, mock_headers = {})
+        response = Excon::Response.new
+
+        #Parse the response body into a hash
+        if mock_data.empty?
+          response.body = mock_data
+        else
+          document = Fog::ToHashDocument.new
+          parser = Nokogiri::XML::SAX::PushParser.new(document)
+          parser << mock_data
+          parser.finish
+          response.body = document.body
+        end
+
+        response.status = status
+        response.headers = mock_headers
+        response
+      end
+
+      def mock_error(expected, status, body='', headers={})
+        raise Excon::Errors::Unauthorized.new("Expected(#{expected}) <=> Actual(#{status})")
+      end
+
+      def mock_data
+        Fog::Vcloud::Mock.data
+      end
+
+    end
+  end
+end
+
+require 'fog/vcloud/terremark/ecloud'
+require 'fog/vcloud/terremark/vcloud'
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/bin.rb
new file mode 100644
index 0000000..726cc81
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/bin.rb
@@ -0,0 +1,59 @@
+module Vcloud
+  class << self
+
+    def services
+      if Fog.credentials.has_key?(:vcloud)
+        Fog.credentials[:vcloud].keys.sort { |a,b| a.to_s <=> b.to_s }
+      else
+        []
+      end
+    end
+
+    def registered_services
+      Vcloud.services.map { |service| ":" << service.to_s }.join(", ")
+    end
+
+    def complete_service_options?(service)
+      if Fog.credentials.has_key?(:vcloud)
+        if Fog.credentials[:vcloud].has_key?(service)
+          service = Fog.credentials[:vcloud][service]
+          if Fog::Vcloud.requirements.all? { |option| service.has_key?(option) }
+            return true
+          end
+        end
+      end
+      false
+    end
+
+    if Vcloud.services.any? && Vcloud.services.all? { |service| Vcloud.complete_service_options?(service) }
+
+      def initialized?
+        true
+      end
+
+      def startup_notice
+        Formatador.display_line("You have access to the following Vcloud services: #{Vcloud.registered_services}.")
+      end
+
+      def [](service)
+        @@connections ||= Hash.new do |hash, key|
+          if credentials = Fog.credentials[:vcloud][key]
+            credentials = credentials.dup
+            _module_ = eval(credentials.delete(:module))
+            hash[key] = _module_.new(credentials)
+          else
+            raise ArgumentError.new("Unregistered service: :#{key}. Registered services are: #{Vcloud.registered_services}")
+          end
+        end
+        @@connections[service]
+      end
+
+    else
+
+      def initialized?
+        false
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/collection.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/collection.rb
new file mode 100644
index 0000000..262f5c5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/collection.rb
@@ -0,0 +1,30 @@
+module Fog
+  class Vcloud < Fog::Service
+    class Collection < Fog::Collection
+
+      def load(objects)
+        objects = [ objects ] if objects.is_a?(Hash)
+        super
+      end
+
+      def check_href!(opts = {})
+        unless href
+          if opts.is_a?(String)
+            t = Hash.new
+            t[:parent] = opts
+            opts = t
+          end
+          msg = ":href missing, call with a :href pointing to #{if opts[:message]
+                  opts[:message]
+                elsif opts[:parent]
+                  "the #{opts[:parent]} whos #{self.class.to_s.split('::').last.downcase} you want to enumerate"
+                else
+                  "the resource"
+                end}"
+          raise Fog::Errors::Error.new(msg)
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/generators.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/generators.rb
new file mode 100644
index 0000000..c975339
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/generators.rb
@@ -0,0 +1,33 @@
+module Fog
+  class Vcloud < Fog::Service
+    module Generators
+
+      def unauthenticated_basic_request(*args)
+        self.class_eval <<-EOS, __FILE__,__LINE__
+          def #{args[0]}(uri)
+            unauthenticated_request({
+              :expects => #{args[1] || 200},
+              :method  => '#{args[2] || 'GET'}',
+              :headers => #{args[3] ? args[3].inspect : '{}'},
+              :parse => true,
+              :uri     => uri })
+          end
+        EOS
+      end
+
+      def basic_request(*args)
+        self.class_eval <<-EOS, __FILE__,__LINE__
+          def #{args[0]}(uri)
+            request({
+              :expects => #{args[1] || 200},
+              :method  => '#{args[2] || 'GET'}',
+              :headers => #{args[3] ? args[3].inspect : '{}'},
+              :body => '#{args[4] ? args[4] : ''}',
+              :parse => true,
+              :uri     => uri })
+          end
+        EOS
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/mock_data_classes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/mock_data_classes.rb
new file mode 100644
index 0000000..6f0372c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/mock_data_classes.rb
@@ -0,0 +1,767 @@
+require "ipaddr"
+
+class IPAddr
+  def mask
+    _to_string(@mask_addr)
+  end
+end
+
+module Fog
+  class Vcloud
+    module MockDataClasses
+      class Base < Hash
+        def self.base_url=(url)
+          @base_url = url
+        end
+
+        self.base_url = "http://vcloud.example.com"
+
+        def self.base_url
+          @base_url
+        end
+
+        def first
+          raise "Don't do this"
+        end
+
+        def last
+          raise "Don't do this"
+        end
+
+        def initialize(data = {}, parent = nil)
+          @parent = parent
+
+          replace(data)
+        end
+
+        def _parent
+          @parent
+        end
+
+        def base_url
+          Base.base_url
+        end
+
+        def href
+          [base_url, self.class.name.split("::").last, object_id].join("/")
+        end
+
+        def inspect
+          "<#{self.class.name} #{object_id} data=#{super}>"
+        end
+      end
+
+      class MockData < Base
+        def versions
+          @versions ||= []
+        end
+
+        def organizations
+          @organizations ||= []
+        end
+
+        def organization_from_href(href)
+          find_href_in(href, organizations)
+        end
+
+        def all_vdcs
+          organizations.map(&:vdcs).flatten
+        end
+
+        def vdc_from_href(href)
+          find_href_in(href, all_vdcs)
+        end
+
+        def all_catalogs
+          all_vdcs.map(&:catalog).flatten
+        end
+
+        def catalog_from_href(href)
+          find_href_in(href, all_catalogs)
+        end
+
+        def all_catalog_items
+          all_catalogs.map(&:items).flatten
+        end
+
+        def catalog_item_from_href(href)
+          find_href_in(href, all_catalog_items)
+        end
+
+        def all_virtual_machines
+          all_vdcs.map(&:virtual_machines).flatten
+        end
+
+        def virtual_machine_from_href(href)
+          find_href_prefixed_in(href, all_virtual_machines)
+        end
+
+
+        def all_networks
+          all_vdcs.map(&:networks).flatten
+        end
+
+        def network_from_href(href)
+          find_href_in(href, all_networks)
+        end
+
+        def all_network_extensions
+          all_networks.map(&:extensions).flatten
+        end
+
+        def network_extension_from_href(href)
+          find_href_in(href, all_network_extensions)
+        end
+
+        def all_vdc_internet_service_collections
+          all_vdcs.map(&:internet_service_collection).flatten
+        end
+
+        def vdc_internet_service_collection_from_href(href)
+          find_href_in(href, all_vdc_internet_service_collections)
+        end
+
+        def all_backup_internet_services
+          all_vdc_internet_service_collections.map(&:backup_internet_services).flatten
+        end
+
+        def backup_internet_service_from_href(href)
+          find_href_in(href, all_backup_internet_services)
+        end
+
+        def all_public_ip_collections
+          all_vdcs.map {|v| v.public_ip_collection }.flatten
+        end
+
+        def public_ip_collection_from_href(href)
+          find_href_in(href, all_public_ip_collections)
+        end
+
+        def all_public_ips
+          all_public_ip_collections.map(&:items).flatten
+        end
+
+        def public_ip_from_href(href)
+          find_href_in(href, all_public_ips)
+        end
+
+        def all_public_ip_internet_service_collections
+          all_public_ips.map(&:internet_service_collection).flatten
+        end
+
+        def public_ip_internet_service_collection_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_collections)
+        end
+
+        def all_public_ip_internet_services
+          all_public_ip_internet_service_collections.map(&:items).flatten
+        end
+
+        def public_ip_internet_service_from_href(href)
+          find_href_in(href, all_public_ip_internet_services)
+        end
+
+        def all_public_ip_internet_service_node_collections
+          all_public_ip_internet_services.map(&:node_collection).flatten
+        end
+
+        def public_ip_internet_service_node_collection_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_node_collections)
+        end
+
+        def all_public_ip_internet_service_nodes
+          all_public_ip_internet_service_node_collections.map(&:items).flatten
+        end
+
+        def public_ip_internet_service_node_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_nodes)
+        end
+
+        def all_network_ip_collections
+          all_networks.map(&:ip_collection)
+        end
+
+        def network_ip_collection_from_href(href)
+          find_href_in(href, all_network_ip_collections)
+        end
+
+        def all_network_ips
+          all_network_ip_collections.map {|c| c.items.values }.flatten
+        end
+
+        def network_ip_from_href(href)
+          find_href_in(href, all_network_ips)
+        end
+
+        private
+
+        def find_href_in(href, objects)
+          objects.detect {|o| o.href == href }
+        end
+
+        def find_href_prefixed_in(href, objects)
+          objects.detect {|o| href =~ %r{^#{o.href}($|/)} }
+        end
+      end
+
+      class MockVersion < Base
+        def version
+          self[:version]
+        end
+
+        def supported
+          !!self[:supported]
+        end
+
+        def login_url
+          href
+        end
+      end
+
+      class MockOrganization < Base
+        def name
+          self[:name]
+        end
+
+        def vdcs
+          @vdcs ||= []
+        end
+      end
+
+      class MockVdc < Base
+        def name
+          self[:name]
+        end
+
+        def storage_allocated
+          self[:storage_allocated] || 200
+        end
+
+        def storage_used
+          self[:storage_used] || 105
+        end
+
+        def cpu_allocated
+          self[:cpu_allocated] || 10000
+        end
+
+        def memory_allocated
+          self[:memory_allocated] || 20480
+        end
+
+        def catalog
+          @catalog ||= MockCatalog.new({}, self)
+        end
+
+        def networks
+          @networks ||= []
+        end
+
+        def virtual_machines
+          @virtual_machines ||= []
+        end
+
+        def task_list
+          @task_list ||= MockTaskList.new({}, self)
+        end
+
+        # for TM eCloud, should probably be subclassed
+        def public_ip_collection
+          @public_ip_collection ||= MockPublicIps.new({}, self)
+        end
+
+        def internet_service_collection
+          @internet_service_collection ||= MockVdcInternetServices.new({}, self)
+        end
+
+        def firewall_acls
+          @firewall_acls ||= MockFirewallAcls.new({}, self)
+        end
+      end
+
+      class MockTaskList < Base
+        def name
+          self[:name] || "Tasks List"
+        end
+      end
+
+      class MockCatalog < Base
+        def name
+          self[:name] || "Catalog"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockCatalogItem < Base
+        def name
+          self[:name]
+        end
+
+        def disks
+          @disks ||= MockVirtualMachineDisks.new(self)
+        end
+
+        def customization
+          @customization ||= MockCatalogItemCustomization.new({}, self)
+        end
+
+        def vapp_template
+          @vapp_template ||= MockCatalogItemVappTemplate.new({ :name => name }, self)
+        end
+      end
+
+      class MockCatalogItemCustomization < Base
+        def name
+          self[:name] || "Customization Options"
+        end
+      end
+
+      class MockCatalogItemVappTemplate < Base
+        def name
+          self[:name]
+        end
+      end
+
+      class MockNetwork < Base
+        def name
+          self[:name] || subnet
+        end
+
+        def subnet
+          self[:subnet]
+        end
+
+        def gateway
+          self[:gateway] || subnet_ips[1]
+        end
+
+        def netmask
+          self[:netmask] || subnet_ipaddr.mask
+        end
+
+        def dns
+          "8.8.8.8"
+        end
+
+        def features
+          [
+           { :type => :FenceMode, :value => "isolated" }
+          ]
+        end
+
+        def ip_collection
+          @ip_collection ||= MockNetworkIps.new({}, self)
+        end
+
+        def extensions
+          @extensions ||= MockNetworkExtensions.new({}, self)
+        end
+
+        def random_ip
+          usable_subnet_ips[rand(usable_subnet_ips.length)]
+        end
+
+        # for TM eCloud. should probably be a subclass
+        def rnat
+          self[:rnat]
+        end
+
+        def usable_subnet_ips
+          subnet_ips[3..-2]
+        end
+
+        def address
+          subnet_ips.first
+        end
+
+        def broadcast
+          subnet_ips.last
+        end
+
+        private
+
+        def subnet_ipaddr
+          @ipaddr ||= IPAddr.new(subnet)
+        end
+
+        def subnet_ips
+          subnet_ipaddr.to_range.to_a.map(&:to_s)
+        end
+      end
+
+      class MockNetworkIps < Base
+        def items
+          @items ||= _parent.usable_subnet_ips.inject({}) do |out, subnet_ip|
+            out.update(subnet_ip => MockNetworkIp.new({ :ip => subnet_ip }, self))
+          end
+        end
+
+        def ordered_ips
+          items.values.sort_by {|i| i.ip.split(".").map(&:to_i) }
+        end
+
+        def name
+          "IP Addresses"
+        end
+      end
+
+      class MockNetworkIp < Base
+        def name
+          self[:name] || ip
+        end
+
+        def ip
+          self[:ip]
+        end
+
+        def used_by
+          self[:used_by] || _parent._parent._parent.virtual_machines.detect {|v| v.ip == ip }
+        end
+
+        def status
+          if used_by
+            "Assigned"
+          else
+            "Available"
+          end
+        end
+
+        def rnat
+          self[:rnat] || _parent._parent.rnat
+        end
+
+        def rnat_set?
+          !!self[:rnat]
+        end
+      end
+
+      class MockNetworkExtensions < Base
+        def name
+          _parent.name
+        end
+
+        def gateway
+          _parent.gateway
+        end
+
+        def broadcast
+          _parent.broadcast
+        end
+
+        def address
+          _parent.address
+        end
+
+        def rnat
+          _parent.rnat
+        end
+
+        def type
+          self[:type] || "DMZ"
+        end
+
+        def vlan
+          object_id.to_s
+        end
+
+        def friendly_name
+          "#{name} (#{type}_#{object_id})"
+        end
+      end
+
+      class MockVirtualMachine < Base
+        def name
+          self[:name]
+        end
+
+        def ip
+          self[:ip]
+        end
+
+        def cpus
+          self[:cpus] || 1
+        end
+
+        def memory
+          self[:memory] || 1024
+        end
+
+        def disks
+          @disks ||= MockVirtualMachineDisks.new(self)
+        end
+
+        def status
+          self[:status] || 2
+        end
+
+        def power_off!
+          self[:status] = 2
+        end
+
+        def power_on!
+          self[:status] = 4
+        end
+
+        def size
+          disks.inject(0) {|s, d| s + d.vcloud_size }
+        end
+
+        def network_ip
+          if network = _parent.networks.detect {|n| n.ip_collection.items[ip] }
+            network.ip_collection.items[ip]
+          end
+        end
+
+        # from fog ecloud server's _compose_vapp_data
+        def to_configure_vapp_hash
+          {
+            :name   => name,
+            :cpus   => cpus,
+            :memory => memory,
+            :disks  => disks.map {|d| { :number => d.address.to_s, :size => d.vcloud_size, :resource => d.vcloud_size.to_s } }
+          }
+        end
+
+        def href(purpose = :base)
+          case purpose
+          when :base
+            super()
+          when :power_on
+            super() + "/power/action/powerOn"
+          when :power_off
+            super() + "/power/action/powerOff"
+          end
+        end
+      end
+
+      class MockVirtualMachineDisks < Array
+        def initialize(parent = nil)
+          @parent = parent
+        end
+
+        def _parent
+          @parent
+        end
+
+        def <<(disk)
+          next_address = 0
+          disk_with_max_address = max {|a, b| a[:address] <=> b[:address] }
+          disk_with_max_address && next_address = disk_with_max_address.address + 1
+          disk[:address] ||= next_address
+
+          super(disk)
+
+          if (addresses = map {|d| d.address }).uniq.size != size
+            raise "Duplicate disk address in: #{addresses.inspect} (#{size})"
+          end
+
+          sort! {|a, b| a.address <=> b.address }
+          self
+        end
+
+        def at_address(address)
+          detect {|d| d.address == address }
+        end
+      end
+
+      class MockVirtualMachineDisk < Base
+        def size
+          self[:size].to_i
+        end
+
+        def vcloud_size
+          # kilobytes
+          size * 1024
+        end
+
+        def address
+          self[:address].to_i
+        end
+      end
+
+      # for Terremark eCloud
+
+      class MockVdcInternetServices < Base
+        def href
+          _parent.href + "/internetServices"
+        end
+
+        def name
+          "Internet Services"
+        end
+
+        def items
+          public_ip_internet_services + backup_internet_services
+        end
+
+        def public_ip_internet_services
+          _parent.public_ip_collection.items.inject([]) do |services, public_ip|
+            services + public_ip.internet_service_collection.items
+          end
+        end
+
+        def backup_internet_services
+          @backup_internet_services ||= []
+        end
+      end
+
+      class MockBackupInternetService < Base
+        def name
+          self[:name] || "Backup Internet Service #{object_id}"
+        end
+
+        def protocol
+          self[:protocol]
+        end
+
+        def port
+          0
+        end
+
+        def enabled
+          self[:enabled].to_s.downcase != "false"
+        end
+
+        def timeout
+          self[:timeout] || 2
+        end
+
+        def description
+          self[:description] || "Description for Backup Service #{name}"
+        end
+
+        def redirect_url
+          nil
+        end
+
+        def node_collection
+          @node_collection ||= MockPublicIpInternetServiceNodes.new({}, self)
+        end
+      end
+
+      class MockFirewallAcls < Base
+        def name
+          "Firewall Access List"
+        end
+      end
+
+      class MockPublicIps < Base
+        def name
+          self[:name] || "Public IPs"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockPublicIp < Base
+        def name
+          self[:name]
+        end
+
+        def internet_service_collection
+          @internet_service_collection ||= MockPublicIpInternetServices.new({}, self)
+        end
+      end
+
+      class MockPublicIpInternetServices < Base
+        def href
+          _parent.href + "/internetServices"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockPublicIpInternetService < Base
+        def name
+          self[:name] || "Public IP Service #{object_id}"
+        end
+
+        def description
+          self[:description] || "Description for Public IP Service #{name}"
+        end
+
+        def protocol
+          self[:protocol]
+        end
+
+        def port
+          self[:port]
+        end
+
+        def enabled
+          !!self[:enabled]
+        end
+
+        def redirect_url
+          self[:redirect_url]
+        end
+
+        def timeout
+          self[:timeout] || 2
+        end
+
+        def node_collection
+          @node_collection ||= MockPublicIpInternetServiceNodes.new({}, self)
+        end
+
+        def monitor
+          nil
+        end
+
+        def backup_service
+          self[:backup_service]
+        end
+      end
+
+      class MockPublicIpInternetServiceNodes < Base
+        def href
+          _parent.href + "/nodeServices"
+        end
+
+        def items
+          @items ||= [].tap do |node_array|
+            node_array.instance_variable_set("@default_port", _parent.port)
+
+            def node_array.<<(node)
+              node[:port] ||= @default_port
+              super
+            end
+          end
+        end
+      end
+
+      class MockPublicIpInternetServiceNode < Base
+        def ip_address
+          self[:ip_address]
+        end
+
+        def name
+          self[:name] || "Public IP Service Node #{object_id}"
+        end
+
+        def description
+          self[:description] || "Description for Public IP Service Node #{name}"
+        end
+
+        def port
+          self[:port]
+        end
+
+        def enabled
+          self[:enabled].to_s.downcase != "false"
+        end
+
+        def enabled=(new_value)
+          self[:enabled] = new_value
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/model.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/model.rb
new file mode 100644
index 0000000..a11d17b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/model.rb
@@ -0,0 +1,22 @@
+module Fog
+  class Vcloud < Fog::Service
+    class Model < Fog::Model
+
+      attr_accessor :loaded
+      alias_method :loaded?, :loaded
+
+      def reload
+        instance = super
+        @loaded = true
+        instance
+      end
+
+      def load_unless_loaded!
+        unless @loaded
+          reload
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdc.rb
new file mode 100644
index 0000000..bf1ec7d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdc.rb
@@ -0,0 +1,26 @@
+module Fog
+  class Vcloud
+    class Vdc < Fog::Vcloud::Model
+
+      identity :href
+
+      ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd
+
+      attribute :name
+      attribute :type
+      attribute :description, :aliases => :Description
+      attribute :other_links, :aliases => :Link
+      attribute :compute_capacity, :aliases => :ComputeCapacity
+      attribute :storage_capacity, :aliases => :StorageCapacity
+      attribute :available_networks, :aliases => :AvailableNetworks, :squash => :Network
+      attribute :resource_entities, :aliases => :ResourceEntities, :squash => :ResourceEntity
+      attribute :enabled, :aliases => :IsEnabled
+      attribute :vm_quota, :aliases => :VmQuota
+      attribute :nic_quota, :aliases => :NicQuota
+      attribute :network_quota, :aliases => :NetworkQuota
+      attribute :allocation_model, :aliases => :AllocationModel
+
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdcs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdcs.rb
new file mode 100644
index 0000000..9ffa986
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/models/vdcs.rb
@@ -0,0 +1,35 @@
+require 'fog/vcloud/models/vdc'
+
+module Fog
+  class Vcloud
+    class Vdcs < Fog::Vcloud::Collection
+
+      model Fog::Vcloud::Vdc
+
+      def all
+        data = connection.get_organization(organization_uri).body[:Link].select { |link| link[:type] == "application/vnd.vmware.vcloud.vdc+xml" }
+        data.each { |link| link.delete_if { |key, value| [:rel].include?(key) } }
+        load(data)
+      end
+
+      def get(uri)
+        if data = connection.get_vdc(uri)
+          new(data.body)
+        end
+      rescue Fog::Errors::NotFound
+        nil
+      end
+
+      def organization_uri
+        @organizatio_uri ||= connection.default_organization_uri
+      end
+
+      private
+
+      def organization_uri=(new_organization_uri)
+        @organization_uri = new_organization_uri
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_network.rb
new file mode 100644
index 0000000..862abfe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_network.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_network
+    end
+
+    class Mock
+
+      def get_network(network_uri)
+        #
+        # Based off of:
+        # vCloud API Guide v0.8 - Page 50
+        #
+        # Did not implement AssociatedNetwork, seems redundant, haven't seen it in use yet
+        # Did not implement the following features: Dhcp, Nat & Firewall
+        #
+        network_uri = ensure_unparsed(network_uri)
+        type = "application/vnd.vmware.vcloud.network+xml"
+        response = Excon::Response.new
+        if network = mock_data.organizations.map { |org| org.vdcs.map { |vdc| vdc.networks } }.flatten.detect { |network| network.href == network_uri.to_s }
+          xml = Builder::XmlMarkup.new
+          mock_it 200,
+            xml.Network(xmlns.merge(:href => network.href, :name => network.name, :type => type)) {
+              xml.Description(network.name)
+              xml.Configuration {
+                xml.Gateway(network.gateway)
+                xml.Netmask(network.netmask)
+                xml.Dns(network.dns)
+              }
+              if network.features
+                xml.Features {
+                  if feature = network.features.detect { |feature| feature[:type] == :FenceMode }
+                    xml.FenceMode(feature[:value])
+                  end
+                }
+              end
+            },
+            { 'Content-Type' => type }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_organization.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_organization.rb
new file mode 100644
index 0000000..d5140de
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_organization.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_organization
+    end
+
+    class Mock
+
+      def get_organization(organization_uri)
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=540&Lang=1&SID=
+        #
+        # vCloud API Guide v0.9 - Page 26
+        #
+        organization_uri = ensure_unparsed(organization_uri)
+        if organization = mock_data.organization_from_href(organization_uri)
+          xml = Builder::XmlMarkup.new
+
+          mock_it 200,
+            xml.Org(xmlns.merge(:href => organization.href, :name => organization.name)) {
+
+              organization.vdcs.each do |vdc|
+                xml.Link(:rel => "down",
+                         :href => vdc.href,
+                         :type => "application/vnd.vmware.vcloud.vdc+xml",
+                         :name => vdc.name)
+                xml.Link(:rel => "down",
+                         :href => vdc.catalog.href,
+                         :type => "application/vnd.vmware.vcloud.catalog+xml",
+                         :name => vdc.catalog.name)
+                xml.Link(:rel => "down",
+                         :href => vdc.task_list.href,
+                         :type => "application/vnd.vmware.vcloud.tasksList+xml",
+                         :name => vdc.task_list.name)
+              end
+            },
+            {'Content-Type' => "application/vnd.vmware.vcloud.org+xml" }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_vdc.rb
new file mode 100644
index 0000000..bf32918
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_vdc.rb
@@ -0,0 +1,82 @@
+module Fog
+  class Vcloud
+
+    class Real
+      basic_request :get_vdc
+    end
+
+    class Mock
+      # WARNING: Incomplete
+      #Based off of:
+      #vCloud API Guide v0.9 - Page 27
+
+      def get_vdc(vdc_uri)
+        vdc_uri = ensure_unparsed(vdc_uri)
+        if vdc = mock_data.organizations.map { |org| org.vdcs }.flatten.detect { |vdc| vdc.href == vdc_uri }
+          xml = Builder::XmlMarkup.new
+          mock_it 200,
+            xml.Vdc(xmlns.merge(:href => vdc.href, :name => vdc.name)) {
+              xml.Link(:rel => "up",
+                       :href => mock_data.organizations.detect { |org| org.vdcs.detect { |_vdc| vdc.href == _vdc.href }.href == vdc.href }.href,
+                       :type => "application/vnd.vmware.vcloud.org+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc.href + "/action/uploadVAppTemplate",
+                       :type => "application/vnd.vmware.vcloud.uploadVAppTemplateParams+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc.href + "/media",
+                       :type => "application/vnd.vmware.vcloud.media+xml")
+              xml.Link(:rel => "add",
+                       :href => vdc.href + "/action/instantiateVAppTemplate",
+                       :type => "application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.cloneVAppParams+xml",
+                       :href => vdc.href + "/action/cloneVApp")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.captureVAppParams+xml",
+                       :href => vdc.href + "/action/captureVApp")
+              xml.Link(:rel => "add",
+                       :type => "application/vnd.vmware.vcloud.composeVAppParams+xml",
+                       :href => vdc.href + "/action/composeVApp")
+              xml.AllocationModel("AllocationPool")
+              xml.Description(vdc[:name] + " VDC")
+              xml.ResourceEntities {
+                mock_data.organizations.first.vdcs.first.virtual_machines.each do |resource|
+                  xml.ResourceEntity(resource)
+                end
+              }
+              xml.AvailableNetworks {
+                vdc.networks.each do |network|
+                  xml.Network( :name => network.name, :href => network.href, :type => "application/vnd.vmware.vcloud.network+xml" )
+                end
+              }
+              xml.ComputeCapacity{
+                xml.Cpu {
+                  xml.Units("Mhz")
+                  xml.Allocated(vdc.cpu_allocated)
+                  xml.Limit(vdc.cpu_allocated)
+                }
+                xml.Memory {
+                  xml.Units("MB")
+                  xml.Allocated(vdc.memory_allocated)
+                  xml.Limit(vdc.memory_allocated)
+                }
+              }
+              xml.StorageCapacity{
+                xml.Units("MB")
+                xml.Allocated(vdc.storage_allocated)
+                xml.Limit(vdc.storage_allocated)
+              }
+              xml.VmQuota(0)
+              xml.NicQuota(0)
+              xml.IsEnabled('true')
+              xml.NetworkQuota(0)
+              #FIXME: Incomplete
+            }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml' }
+        else
+          mock_error 200, "401 Unauthorized"
+        end
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_versions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_versions.rb
new file mode 100644
index 0000000..178d386
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/get_versions.rb
@@ -0,0 +1,34 @@
+module Fog
+  class Vcloud
+
+    class Real
+      unauthenticated_basic_request :get_versions
+    end
+
+    class Mock
+
+      def get_versions(versions_uri)
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=535&Lang=1&SID=
+        # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/02-get-versions.aspx
+        # vCloud API Guide v0.9 - Page 89
+        #
+        xml = Builder::XmlMarkup.new
+
+        mock_it 200,
+          xml.SupportedVersions( xmlns.merge("xmlns" => "http://www.vmware.com/vcloud/versions")) {
+
+            mock_data.versions.select {|version| version.supported }.each do |version|
+              xml.VersionInfo {
+                xml.Version(version.version)
+                xml.LoginUrl(version.login_url)
+              }
+            end
+          }
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/login.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/login.rb
new file mode 100644
index 0000000..7bcc12c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/requests/login.rb
@@ -0,0 +1,46 @@
+module Fog
+  class Vcloud
+
+    class Real
+
+
+      def login
+        unauthenticated_request({
+          :expects  => 200,
+          :headers  => {
+            'Authorization' => authorization_header
+          },
+          :method   => 'POST',
+          :parse    => true,
+          :uri      => login_uri
+        })
+      end
+
+    end
+
+    class Mock
+
+      def login
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=536&Lang=1&SID=
+        # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/01-get-login-token.aspx
+        # vCloud API Guide v0.9 - Page 17
+        #
+        xml = Builder::XmlMarkup.new
+
+        mock_it 200,
+          xml.OrgList(xmlns) {
+              mock_data.organizations.each do |organization|
+                xml.Org( :type => "application/vnd.vmware.vcloud.org+xml", :href => organization.href, :name => organization.name )
+              end
+            },
+            { 'Set-Cookie' => 'vcloud-token=fc020a05-21d7-4f33-9b2a-25d8cd05a44e; path=/',
+              'Content-Type' => 'application/vnd.vmware.vcloud.orgslist+xml' }
+
+      end
+
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud.rb
new file mode 100644
index 0000000..19d0e91
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud.rb
@@ -0,0 +1,187 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud < Fog::Vcloud
+
+        requires   :username, :password, :versions_uri
+        recognizes :module, :version
+
+        model_path 'fog/vcloud/terremark/ecloud/models'
+        model :catalog_item
+        model :catalog
+        model :firewall_acl
+        collection :firewall_acls
+        model :internet_service
+        collection :internet_services
+        model :backup_internet_service
+        collection :backup_internet_services
+        model :ip
+        collection :ips
+        model :network
+        collection :networks
+        model :node
+        collection :nodes
+        model :public_ip
+        collection :public_ips
+        model :server
+        collection :servers
+        model :task
+        collection :tasks
+        model :vdc
+        collection :vdcs
+
+        request_path 'fog/vcloud/terremark/ecloud/requests'
+        request :add_internet_service
+        request :add_backup_internet_service
+        request :add_node
+        request :clone_vapp
+        request :configure_internet_service
+        request :configure_network
+        request :configure_network_ip
+        request :configure_node
+        request :configure_vapp
+        request :delete_internet_service
+        request :delete_node
+        request :delete_vapp
+        request :get_catalog
+        request :get_catalog_item
+        request :get_customization_options
+        request :get_firewall_acls
+        request :get_firewall_acl
+        request :get_internet_services
+        request :get_network
+        request :get_network_ip
+        request :get_network_ips
+        request :get_network_extensions
+        request :get_node
+        request :get_nodes
+        request :get_public_ip
+        request :get_public_ips
+        request :get_task
+        request :get_task_list
+        request :get_vapp
+        request :get_vapp_template
+        request :get_vdc
+        request :instantiate_vapp_template
+        request :power_off
+        request :power_on
+        request :power_reset
+        request :power_shutdown
+
+        module Shared
+          def ecloud_xmlns
+            {
+              "xmlns"     => "urn:tmrk:eCloudExtensions-2.5",
+              "xmlns:i"   => "http://www.w3.org/2001/XMLSchema-instance"
+            }
+          end
+        end
+
+        class Mock < Fog::Vcloud::Mock
+          include Shared
+
+          def initialize(options={})
+          end
+
+          def self.base_url
+            "https://fakey.com/api/v0.8b-ext2.5"
+          end
+
+          def self.data_reset
+            @mock_data = nil
+            Fog::Vcloud::Mock.data_reset
+          end
+
+          def self.data( base_url = self.base_url )
+            @mock_data ||= Fog::Vcloud::Mock.data(base_url).tap do |vcloud_mock_data|
+              vcloud_mock_data.versions.clear
+              vcloud_mock_data.versions << MockVersion.new(:version => "v0.8b-ext2.5")
+
+              vcloud_mock_data.organizations.detect {|o| o.name == "Boom Inc." }.tap do |mock_organization|
+                mock_organization.vdcs.detect {|v| v.name == "Boomstick" }.tap do |mock_vdc|
+                  mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.2.3").tap do |mock_public_ip|
+                    mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                          :protocol => "HTTP",
+                                                                                                          :port => 80,
+                                                                                                          :name => "Web Site",
+                                                                                                          :description => "Web Servers",
+                                                                                                          :redirect_url => "http://fakey.com"
+                                                                                                        }, mock_public_ip.internet_service_collection
+                                                                                                        ).tap do |mock_public_ip_service|
+                      mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.5", :name => "Test Node 1", :description => "web 1"}, mock_public_ip_service.node_collection)
+                      mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.6", :name => "Test Node 2", :description => "web 2"}, mock_public_ip_service.node_collection)
+                      mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.7", :name => "Test Node 3", :description => "web 3"}, mock_public_ip_service.node_collection)
+                    end
+
+                    mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                          :protocol => "TCP",
+                                                                                                          :port => 7000,
+                                                                                                          :name => "An SSH Map",
+                                                                                                          :description => "SSH 1"
+                                                                                                        }, mock_public_ip.internet_service_collection
+                                                                                                        ).tap do |mock_public_ip_service|
+                      mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({ :ip_address => "1.2.3.5", :port => 22, :name => "SSH", :description => "web ssh" }, mock_public_ip_service.node_collection)
+                    end
+                  end
+
+                  mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.2.4").tap do |mock_public_ip|
+                    mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                          :protocol => "HTTP",
+                                                                                                          :port => 80,
+                                                                                                          :name => "Web Site",
+                                                                                                          :description => "Web Servers",
+                                                                                                          :redirect_url => "http://fakey.com"
+                                                                                                        }, mock_public_ip.internet_service_collection
+                                                                                                        )
+
+                    mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                          :protocol => "TCP",
+                                                                                                          :port => 7000,
+                                                                                                          :name => "An SSH Map",
+                                                                                                          :description => "SSH 2"
+                                                                                                        }, mock_public_ip.internet_service_collection
+                                                                                                        )
+                  end
+
+                  mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.9.7")
+
+                  mock_vdc.internet_service_collection.backup_internet_services << MockBackupInternetService.new({ :port => 10000, :protocol => "TCP"}, self)
+                end
+
+                mock_organization.vdcs.detect {|v| v.name == "Rock-n-Roll" }.tap do |mock_vdc|
+                  mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.99.99.99")
+                end
+              end
+
+              vcloud_mock_data.organizations.each do |organization|
+                organization.vdcs.each do |vdc|
+                  vdc.networks.each do |network|
+                    network[:rnat] = vdc.public_ip_collection.items.first.name
+                  end
+                  vdc.virtual_machines.each do |virtual_machine|
+                    virtual_machine.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+                    virtual_machine.disks << MockVirtualMachineDisk.new(:size => 50 * 1024)
+                  end
+                end
+              end
+            end
+          end
+
+          def mock_data
+            Fog::Vcloud::Terremark::Ecloud::Mock.data
+          end
+        end
+
+        class Real < Fog::Vcloud::Real
+          include Shared
+
+          def supporting_versions
+            ["v0.8b-ext2.5", "0.8b-ext2.5"]
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_service.rb
new file mode 100644
index 0000000..dd91a33
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_service.rb
@@ -0,0 +1,60 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class BackupInternetService < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :protocol, :aliases => :Protocol
+          attribute :enabled, :aliases => :Enabled
+          attribute :description, :aliases => :Description
+          attribute :timeout, :aliases => :Timeout
+          attribute :redirect_url, :aliases => :RedirectURL
+          attribute :monitor, :aliases => :Monitor
+
+          def delete
+            requires :href
+
+            connection.delete_internet_service( href )
+          end
+
+          def monitor=(new_monitor = {})
+            if new_monitor.nil? || new_monitor.empty?
+              attributes[:monitor] = nil
+            end
+          end
+
+          def save
+            if new_record?
+              result = connection.add_backup_internet_service( collection.href, _compose_service_data )
+              merge_attributes(result.body)
+            else
+              connection.configure_backup_internet_service( href, _compose_service_data )
+            end
+          end
+
+          def nodes
+            @nodes ||= Fog::Vcloud::Terremark::Ecloud::Nodes.new( :connection => connection, :href => href + "/nodeServices" )
+          end
+
+          private
+
+          def _compose_service_data
+            #For some reason inject didn't work
+            service_data = {}
+            self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| service_data[attribute] = send(attribute) }
+            service_data
+          end
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_services.rb
new file mode 100644
index 0000000..f7f3d4d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/backup_internet_services.rb
@@ -0,0 +1,36 @@
+require 'fog/vcloud/terremark/ecloud/models/backup_internet_service'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class BackupInternetServices < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::BackupInternetService
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href! :message => "the Internet Services for the Vdc you want to enumerate"
+            if data = connection.get_internet_services(href).body[:InternetService].find_all {|i| i[:IsBackupService] == "true" }
+              load(data)
+            end
+          end
+
+          # Optimize later, no need to get_internet_services again?
+          def get(uri)
+            internet_services = connection.get_internet_services(href).body[:InternetService]
+            internet_services = [ internet_services ] if internet_services.is_a?(Hash)
+            if data = internet_services.detect { |service| service[:Href] == uri }
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog.rb
new file mode 100644
index 0000000..357d551
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog.rb
@@ -0,0 +1,31 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Catalog < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::CatalogItem
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href!
+            if data = connection.get_catalog(href).body[:CatalogItems][:CatalogItem]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_catalog_item(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
new file mode 100644
index 0000000..2314565
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/catalog_item.rb
@@ -0,0 +1,31 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class CatalogItem < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :type
+          attribute :name
+          attribute :entity, :aliases => :Entity
+          attribute :link, :aliases => :Link
+          attribute :property, :aliases => :Property
+
+          def customization_options
+            load_unless_loaded!
+            if data = connection.get_customization_options( link[:href] ).body
+              data.delete_if { |key, value| [:xmlns_i, :xmlns].include?(key) }
+              data
+            else
+              nil
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
new file mode 100644
index 0000000..d75e027
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acl.rb
@@ -0,0 +1,28 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class FirewallAcl < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :protocol, :aliases => :Protocol
+          attribute :source, :aliases => :Source
+          attribute :destination, :aliases => :Destination
+          attribute :permission, :aliases => :Permission
+          attribute :port_start, :aliases => :PortStart
+          attribute :port_end, :aliases => :PortEnd
+          attribute :port_type, :aliases => :PortType
+          attribute :type, :aliases => :Type
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
new file mode 100644
index 0000000..3c8a831
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/firewall_acls.rb
@@ -0,0 +1,34 @@
+require 'fog/vcloud/terremark/ecloud/models/firewall_acl'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class FirewallAcls < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::FirewallAcl
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href! :message => "the Firewall ACL href for the network you want to enumerate"
+            if data = connection.get_firewall_acls(href).body[:FirewallAcl]
+              data = [ data ] if data.is_a?(Hash)
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_firewall_acl(uri).body
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
new file mode 100644
index 0000000..27dde75
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_service.rb
@@ -0,0 +1,99 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class InternetService < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+          attribute :protocol, :aliases => :Protocol
+          attribute :port, :aliases => :Port
+          attribute :enabled, :aliases => :Enabled
+          attribute :description, :aliases => :Description
+          attribute :public_ip, :aliases => :PublicIpAddress
+          attribute :timeout, :aliases => :Timeout
+          attribute :redirect_url, :aliases => :RedirectURL
+          attribute :monitor, :aliases => :Monitor
+          attribute :backup_service_data, :aliases => :BackupService
+
+          def delete
+            requires :href
+
+            connection.delete_internet_service( href )
+          end
+
+          def save
+            if new_record?
+              result = connection.add_internet_service( collection.href, _compose_service_data )
+              merge_attributes(result.body)
+            else
+              connection.configure_internet_service( href, _compose_service_data, _compose_ip_data )
+            end
+          end
+
+          def monitor=(new_monitor = {})
+            if new_monitor.nil? || new_monitor.empty?
+              attributes[:monitor] = nil
+            elsif new_monitor.is_a?(Hash)
+              attributes[:monitor] = {}
+              attributes[:monitor][:type] = new_monitor[:MonitorType] || new_monitor[:type]
+              attributes[:monitor][:url_send_string] = new_monitor[:UrlSendString] || new_monitor[:url_send_string]
+              attributes[:monitor][:http_headers] = new_monitor[:HttpHeader] || new_monitor[:http_headers]
+              attributes[:monitor][:http_headers] = attributes[:monitor][:http_headers].split("\n") unless attributes[:monitor][:http_headers].is_a?(Array)
+              attributes[:monitor][:receive_string] = new_monitor[:ReceiveString] || new_monitor[:receive_string]
+              attributes[:monitor][:interval] = new_monitor[:Interval] || new_monitor[:interval]
+              attributes[:monitor][:response_timeout] = new_monitor[:ResponseTimeOut] || new_monitor[:response_timeout]
+              attributes[:monitor][:downtime] = new_monitor[:DownTime] || new_monitor[:downtime]
+              attributes[:monitor][:retries] = new_monitor[:Retries] || new_monitor[:retries]
+              attributes[:monitor][:is_enabled] = new_monitor[:IsEnabled] || new_monitor[:is_enabled]
+            else
+              raise RuntimeError.new("monitor needs to either be nil or a Hash")
+            end
+          end
+
+          def nodes
+            @nodes ||= Fog::Vcloud::Terremark::Ecloud::Nodes.new( :connection => connection, :href => href + "/nodeServices" )
+          end
+
+          def backup_service_uri
+            if backup_service_data
+              backup_service_data[:Href]
+            end
+          end
+
+          def backup_service_uri=(new_value)
+            self.backup_service_data = {
+              :Href => new_value
+            }
+          end
+
+          private
+
+          def _compose_service_data
+            #For some reason inject didn't work
+            service_data = {}
+            self.class.attributes.select{ |attribute| attribute != :backup_service_data }.each { |attribute| service_data[attribute] = send(attribute) }
+            service_data[:backup_service_uri] = backup_service_uri
+            service_data.reject! {|k, v| v.nil? }
+            service_data
+          end
+
+          def _compose_ip_data
+            if public_ip.nil?
+              {}
+            else
+              { :id => public_ip[:Id], :href => public_ip[:Href], :name => public_ip[:Name] }
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
new file mode 100644
index 0000000..b302b4a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/internet_services.rb
@@ -0,0 +1,36 @@
+require 'fog/vcloud/terremark/ecloud/models/internet_service'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class InternetServices < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::InternetService
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href! :message => "the Internet Services for the Vdc you want to enumerate"
+            if internet_service_data = connection.get_internet_services(href).body[:InternetService]
+              load(Array[internet_service_data].flatten.find_all {|i| i[:IsBackupService] == "false" })
+            end
+          end
+
+          # Optimize later, no need to get_internet_services again?
+          def get(uri)
+            internet_services = connection.get_internet_services(href).body[:InternetService]
+            internet_services = [ internet_services ] if internet_services.is_a?(Hash)
+            if data = internet_services.detect { |service| service[:Href] == uri }
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ip.rb
new file mode 100644
index 0000000..395e8de
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ip.rb
@@ -0,0 +1,51 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Ip < Fog::Vcloud::Model
+
+          ignore_attributes :xmlns_i, :xmlns
+
+          identity :href, :aliases => :Href
+
+          attribute :name, :aliases => :Name
+          attribute :status, :aliases => :Status
+          attribute :server, :aliases => :Server
+          attribute :rnat, :aliases => :RnatAddress
+          attribute :id, :aliases => :Id, :type => :integer
+
+          def rnat=(new_rnat)
+            attributes[:rnat] = new_rnat
+            @changed = true
+          end
+
+          def save
+            if @changed
+              connection.configure_network_ip( href, _compose_network_ip_data )
+            end
+            true
+          end
+
+          def reload
+            super
+            @changed = false
+            self
+          end
+
+          private
+          def _compose_network_ip_data
+            {
+              :id => id,
+              :href => href,
+              :name => name,
+              :status => status,
+              :server => server,
+              :rnat => rnat
+            }
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ips.rb
new file mode 100644
index 0000000..c686eed
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/ips.rb
@@ -0,0 +1,35 @@
+require 'fog/vcloud/terremark/ecloud/models/ip'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Ips < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Ip
+
+          undef_method :create
+
+          attribute :href
+
+          def all
+            check_href!( :messages => "Ips href of a Network you want to enumerate" )
+            if data = connection.get_network_ips(href).body[:IpAddress]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_network_ip(uri).body
+              new(data)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/network.rb
new file mode 100644
index 0000000..ee9be57
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/network.rb
@@ -0,0 +1,77 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Network < Fog::Vcloud::Model
+
+          identity :href
+
+          ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd, :xmlns_i, :Configuration, :Id
+
+          attribute :name, :aliases => :Name
+          #attribute :id, :aliases => :Id
+          attribute :features, :aliases => :Features, :type => :array
+          attribute :links, :aliases => :Link, :type => :array
+          attribute :type
+          attribute :gateway, :aliases => :GatewayAddress
+          attribute :broadcast, :aliases => :BroadcastAddress
+          attribute :address, :aliases => :Address
+          attribute :rnat, :aliases => :RnatAddress
+          attribute :extension_href, :aliases => :Href
+          attribute :network_type, :aliases => :NetworkType
+          attribute :vlan, :aliases => :Vlan
+          attribute :friendly_name, :aliases => :FriendlyName
+
+          def ips
+            load_unless_loaded!
+            @ips ||= Fog::Vcloud::Terremark::Ecloud::Ips.
+              new( :connection => connection,
+                   :href => links.detect { |link| link[:name] == "IP Addresses" }[:href] )
+          end
+
+          def rnat=(new_rnat)
+            attributes[:rnat] = new_rnat
+            @changed = true
+          end
+
+          def save
+            if @changed
+              connection.configure_network( extension_href, _compose_network_data )
+            end
+            true
+          end
+
+          def reload
+            super
+            merge_attributes(extension_data.body)
+            self
+          end
+
+          private
+
+          def extension_data
+            connection.get_network_extensions( extensions_link[:href] )
+          end
+
+          def extensions_link
+            links.detect { |link| link[:name] == name }
+          end
+
+          def _compose_network_data
+            {
+              :id => id,
+              :href => extension_href,
+              :name => name,
+              :rnat => rnat,
+              :address => address,
+              :broadcast => broadcast,
+              :gateway => gateway
+            }
+          end
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/networks.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/networks.rb
new file mode 100644
index 0000000..ccd901c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/networks.rb
@@ -0,0 +1,36 @@
+require 'fog/vcloud/terremark/ecloud/models/network'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Networks < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          model Fog::Vcloud::Terremark::Ecloud::Network
+
+          attribute :href
+
+          def all
+            check_href!("Vdc")
+            if data = connection.get_vdc(href).body[:AvailableNetworks][:Network]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_network(uri)
+              new(data.body)
+            end
+            rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/node.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/node.rb
new file mode 100644
index 0000000..c699117
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/node.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Node < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+          
+          attribute :ip_address, :aliases => :IpAddress
+          attribute :description, :aliases => :Description
+          attribute :name, :aliases => :Name
+          attribute :port, :aliases => :Port
+          attribute :enabled, :aliases => :Enabled
+          attribute :id, :aliases => :Id
+
+          def delete
+            requires :href
+
+            connection.delete_node( href )
+          end
+
+          def save
+            if new_record?
+              result = connection.add_node( collection.href, _compose_node_data )
+              merge_attributes(result.body)
+            else
+              connection.configure_node( href, _compose_node_data )
+            end
+          end
+
+          private
+
+          def _compose_node_data
+            node_data = {}
+            self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| node_data[attribute] = send(attribute).to_s }
+            node_data
+          end
+
+        end
+      end
+    end
+  end
+end
+
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/nodes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/nodes.rb
new file mode 100644
index 0000000..e02c38d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/nodes.rb
@@ -0,0 +1,33 @@
+require 'fog/vcloud/terremark/ecloud/models/node'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Nodes < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Node
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href!( :messages => "the Nodes href of the Internet Service you want to enumerate" )
+            if data = connection.get_nodes(href).body[:NodeService]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_node(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
new file mode 100644
index 0000000..d042af8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ip.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class PublicIp < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i
+
+          attribute :name, :aliases => :Name
+          attribute :id, :aliases => :Id
+
+          def internet_services
+            load_unless_loaded!
+            @internet_services ||= Fog::Vcloud::Terremark::Ecloud::InternetServices.
+              new( :connection => connection,
+                   :href => href.to_s + "/internetServices" )
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
new file mode 100644
index 0000000..7c10a27
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/public_ips.rb
@@ -0,0 +1,39 @@
+require 'fog/vcloud/terremark/ecloud/models/public_ip'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class PublicIps < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          attribute :href, :aliases => :Href
+
+          model Fog::Vcloud::Terremark::Ecloud::PublicIp
+
+          #get_request :get_public_ip
+          #vcloud_type "application/vnd.tmrk.ecloud.publicIp+xml"
+          #all_request lambda { |public_ips| public_ips.connection.get_public_ips(public_ips.href) }
+
+          def all
+            check_href!(:message => "the Public Ips href of the Vdc you want to enumerate")
+            if data = connection.get_public_ips(href).body[:PublicIPAddress]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_public_ip(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/server.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/server.rb
new file mode 100644
index 0000000..5eae70b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/server.rb
@@ -0,0 +1,211 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Server < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :type
+          attribute :name
+          attribute :status
+          attribute :network_connections, :aliases => :NetworkConnectionSection, :squash => :NetworkConnection
+          attribute :os, :aliases => :OperatingSystemSection
+          attribute :virtual_hardware, :aliases => :VirtualHardwareSection
+          attribute :storage_size, :aliases => :size
+          attribute :links, :aliases => :Link, :type => :array
+
+          def friendly_status
+            load_unless_loaded!
+            case status
+            when '0'
+              'creating'
+            when '2'
+              'off'
+            when '4'
+              'on'
+            else
+              'unkown'
+            end
+          end
+
+          def ready?
+            load_unless_loaded!
+            status == '2'
+          end
+
+          def on?
+            load_unless_loaded!
+            status == '4'
+          end
+
+          def off?
+            load_unless_loaded!
+            status == '2'
+          end
+
+          def power_on
+            power_operation( :power_on => :powerOn )
+          end
+
+          def power_off
+            power_operation( :power_off => :powerOff )
+          end
+
+          def shutdown
+            power_operation( :power_shutdown => :shutdown )
+          end
+
+          def power_reset
+            power_operation( :power_reset => :reset )
+          end
+
+          def graceful_restart
+            requires :href
+            shutdown
+            wait_for { off? }
+            power_on
+          end
+
+          def delete
+            requires :href
+            connection.delete_vapp( href)
+          end
+
+          def name=(new_name)
+            attributes[:name] = new_name
+            @changed = true
+          end
+
+          def cpus
+            if cpu_mess
+              { :count => cpu_mess[:VirtualQuantity].to_i,
+                :units => cpu_mess[:AllocationUnits] }
+            end
+          end
+
+          def cpus=(qty)
+            @changed = true
+            cpu_mess[:VirtualQuantity] = qty.to_s
+          end
+
+          def memory
+            if memory_mess
+              { :amount => memory_mess[:VirtualQuantity].to_i,
+                :units => memory_mess[:AllocationUnits] }
+            end
+          end
+
+          def memory=(amount)
+            @changed = true
+            memory_mess[:VirtualQuantity] = amount.to_s
+          end
+
+          def disks
+            disk_mess.map do |dm|
+              { :number => dm[:AddressOnParent], :size => dm[:VirtualQuantity].to_i, :resource => dm[:HostResource] }
+            end
+          end
+
+          def add_disk(size)
+            if @disk_change == :deleted
+              raise RuntimeError, "Can't add a disk w/o saving changes or reloading"
+            else
+              @disk_change = :added
+              load_unless_loaded!
+              virtual_hardware[:Item] << { :ResourceType => '17',
+                                           :AddressOnParent => (disk_mess.map { |dm| dm[:AddressOnParent] }.sort.last.to_i + 1).to_s,
+                                           :VirtualQuantity => size.to_s }
+            end
+            true
+          end
+
+          def delete_disk(number)
+            if @disk_change == :added
+              raise RuntimeError, "Can't delete a disk w/o saving changes or reloading"
+            else
+              @disk_change = :deleted
+              load_unless_loaded!
+              unless number == 0
+                virtual_hardware[:Item].delete_if { |vh| vh[:ResourceType] == '17' && vh[:AddressOnParent].to_i == number }
+              end
+            end
+            true
+          end
+
+          def reload
+            reset_tracking
+            super
+          end
+
+          def save
+            if new_record?
+              #Lame ...
+              raise RuntimeError, "Should not be here"
+            else
+              if on?
+                if @changed
+                  raise RuntimeError, "Can't save cpu, name or memory changes while the VM is on."
+                end
+              end
+              connection.configure_vapp( href, _compose_vapp_data )
+            end
+            reset_tracking
+          end
+
+          private
+
+          def reset_tracking
+            @disk_change = false
+            @changed = false
+          end
+
+          def _compose_vapp_data
+            { :name   => name,
+              :cpus   => cpus[:count],
+              :memory => memory[:amount],
+              :disks  => disks
+            }
+          end
+
+          def memory_mess
+            load_unless_loaded!
+            if virtual_hardware && virtual_hardware[:Item]
+              virtual_hardware[:Item].detect { |item| item[:ResourceType] == "4" }
+            end
+          end
+
+          def cpu_mess
+            load_unless_loaded!
+            if virtual_hardware && virtual_hardware[:Item]
+              virtual_hardware[:Item].detect { |item| item[:ResourceType] == "3" }
+            end
+          end
+
+          def disk_mess
+            load_unless_loaded!
+            if virtual_hardware && virtual_hardware[:Item]
+              virtual_hardware[:Item].select { |item| item[:ResourceType] == "17" }
+            else
+              []
+            end
+          end
+
+          def power_operation(op)
+            requires :href
+            begin
+              connection.send(op.keys.first, href + "/power/action/#{op.values.first}" )
+            rescue Excon::Errors::InternalServerError => e
+              #Frankly we shouldn't get here ...
+              raise e unless e.to_s =~ /because it is already powered o(n|ff)/
+            end
+            true
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/servers.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/servers.rb
new file mode 100644
index 0000000..b79f2e7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/servers.rb
@@ -0,0 +1,57 @@
+require 'fog/vcloud/terremark/ecloud/models/server'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Servers < Fog::Vcloud::Collection
+
+          undef_method :create
+
+          model Fog::Vcloud::Terremark::Ecloud::Server
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href!(:parent => "Vdc")
+            load(_vapps)
+          end
+
+          def get(uri)
+            if data = connection.get_vapp(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+          def create( catalog_item_uri, options )
+            options[:vdc_uri] = href
+            options[:cpus] ||= 1
+            options[:memory] ||= 512
+            data = connection.instantiate_vapp_template( catalog_item_uri, options ).body
+            object = new(data)
+            object
+          end
+
+          private
+
+          def _resource_entities
+            connection.get_vdc(href).body[:ResourceEntities][:ResourceEntity]
+          end
+
+          def _vapps
+            resource_entities = _resource_entities
+            if resource_entities.nil?
+              []
+            else
+              resource_entities
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/task.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/task.rb
new file mode 100644
index 0000000..a063c84
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/task.rb
@@ -0,0 +1,23 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Task < Fog::Vcloud::Model
+
+          identity :href, :aliases => :Href
+
+          ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+          attribute :status
+          attribute :type
+          attribute :result, :aliases => :Result
+          attribute :owner, :aliases => :Owner
+          attribute :start_time, :aliases => :startTime, :type => :time
+          attribute :end_time, :aliases => :endTime, :type => :time
+          attribute :error, :aliases => :Error
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/tasks.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/tasks.rb
new file mode 100644
index 0000000..775baf7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/tasks.rb
@@ -0,0 +1,33 @@
+require 'fog/vcloud/terremark/ecloud/models/task'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Tasks < Fog::Vcloud::Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Task
+
+          attribute :href, :aliases => :Href
+
+          def all
+            check_href!
+            if data = connection.get_task_list(href).body[:Task]
+              load(data)
+            end
+          end
+
+          def get(uri)
+            if data = connection.get_task(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdc.rb
new file mode 100644
index 0000000..3436d38
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdc.rb
@@ -0,0 +1,83 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Vdc < Fog::Vcloud::Model
+
+          identity :href
+
+          ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd
+
+          attribute :name
+          attribute :type
+          attribute :description, :aliases => :Description
+          attribute :other_links, :aliases => :Link
+          attribute :compute_capacity, :aliases => :ComputeCapacity
+          attribute :storage_capacity, :aliases => :StorageCapacity
+          attribute :available_networks, :aliases => :AvailableNetworks, :squash => :Network
+          attribute :resource_entities, :aliases => :ResourceEntities, :squash => :ResourceEntity
+          attribute :deployed_vm_quota
+          attribute :instantiated_vm_quota
+
+          def public_ips
+            @public_ips ||= collection_based_on_type("application/vnd.tmrk.ecloud.publicIpsList+xml")
+          end
+
+          def internet_services
+            @internet_services ||= collection_based_on_type("application/vnd.tmrk.ecloud.internetServicesList+xml")
+          end
+
+          def backup_internet_services
+            @backup_internet_services ||= collection_based_on_type("application/vnd.tmrk.ecloud.internetServicesList+xml", BackupInternetServices)
+          end
+
+          def networks
+            @networks ||= Fog::Vcloud::Terremark::Ecloud::Networks.
+              new( :connection => connection,
+                   :href => href )
+          end
+
+          def servers
+            @servers ||= Fog::Vcloud::Terremark::Ecloud::Servers.
+              new( :connection => connection,
+                   :href => href )
+          end
+
+          def tasks
+            @tasks ||= Fog::Vcloud::Terremark::Ecloud::Tasks.
+              new( :connection => connection,
+                   :href => href + "/tasksList" )
+          end
+
+          def catalog
+            @catalog ||= collection_based_on_type("application/vnd.vmware.vcloud.catalog+xml")
+          end
+
+          def firewall_acls
+            @firewall_acls ||= collection_based_on_type("application/vnd.tmrk.ecloud.firewallAclsList+xml")
+          end
+
+          private
+
+          def collection_based_on_type(type, klass = nil)
+            load_unless_loaded!
+            if link = other_links.detect { |link| link[:type] == type }
+              case type
+              when "application/vnd.tmrk.ecloud.publicIpsList+xml"
+                Fog::Vcloud::Terremark::Ecloud::PublicIps
+              when "application/vnd.tmrk.ecloud.internetServicesList+xml"
+                klass || Fog::Vcloud::Terremark::Ecloud::InternetServices
+              when "application/vnd.vmware.vcloud.catalog+xml"
+                Fog::Vcloud::Terremark::Ecloud::Catalog
+              when "application/vnd.tmrk.ecloud.firewallAclsList+xml"
+                Fog::Vcloud::Terremark::Ecloud::FirewallAcls
+              end.new( :connection => connection, :href => link[:href] )
+            else
+              [ ]
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
new file mode 100644
index 0000000..b7cd51b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/models/vdcs.rb
@@ -0,0 +1,42 @@
+require 'fog/vcloud/terremark/ecloud/models/vdc'
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Vdcs < Collection
+
+          model Fog::Vcloud::Terremark::Ecloud::Vdc
+
+          undef_method :create
+
+          def all
+            data = connection.get_organization(organization_uri).body[:Link].select { |link| link[:type] == "application/vnd.vmware.vcloud.vdc+xml" }
+            data.each { |link| link.delete_if { |key, value| [:rel].include?(key) } }
+            load(data)
+          end
+
+          def get(uri)
+            if data = connection.get_vdc(uri)
+              new(data.body)
+            end
+          rescue Fog::Errors::NotFound
+            nil
+          end
+
+          def organization_uri
+            @organizatio_uri ||= connection.default_organization_uri
+          end
+
+          private
+
+          def organization_uri=(new_organization_uri)
+            @organization_uri = new_organization_uri
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_backup_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_backup_internet_service.rb
new file mode 100644
index 0000000..adc66c3
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_backup_internet_service.rb
@@ -0,0 +1,111 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          def validate_backup_internet_service_data(service_data, configure=false)
+            required_opts = [:name, :protocol, :description, :enabled]
+            if configure
+              required_opts + [ :id, :href, :timeout ]
+            end
+            unless required_opts.all? { |opt| service_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Backup Internet Service data missing: #{(required_opts - service_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def add_backup_internet_service(internet_services_uri, service_data)
+            validate_backup_internet_service_data(service_data)
+            if monitor = service_data[:monitor]
+              validate_internet_service_monitor(monitor)
+              ensure_monitor_defaults!(monitor)
+            end
+
+            request(
+              :body     => generate_backup_internet_service_request(service_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/xml'},
+              :method   => 'POST',
+              :uri      => internet_services_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_backup_internet_service_request(service_data)
+            builder = Builder::XmlMarkup.new
+            builder.CreateBackupInternetServiceRequest("xmlns" => "urn:tmrk:eCloudExtensions-2.5") {
+              builder.Name(service_data[:name])
+              builder.Protocol(service_data[:protocol])
+              builder.Enabled(service_data[:enabled])
+              builder.Description(service_data[:description])
+              builder.RedirectURL(service_data[:redirect_url])
+              if monitor = service_data[:monitor]
+                generate_monitor_section(builder,monitor)
+              end
+            }
+          end
+        end
+
+        class Mock
+          include Shared
+
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=729&Lang=1&SID=
+          # and many tears shed.
+          #
+
+          def add_backup_internet_service(internet_services_uri, service_data)
+            validate_backup_internet_service_data(service_data)
+
+            internet_services_uri = ensure_unparsed(internet_services_uri)
+
+            if vdc_internet_service_collection = mock_data.vdc_internet_service_collection_from_href(internet_services_uri)
+              new_backup_internet_service = MockBackupInternetService.new(service_data, vdc_internet_service_collection.backup_internet_services)
+              vdc_internet_service_collection.backup_internet_services << new_backup_internet_service
+              xml = generate_backup_internet_service_added_response(new_backup_internet_service)
+
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+          private
+
+          def generate_backup_internet_service_added_response(new_backup_internet_service)
+            builder = Builder::XmlMarkup.new
+            builder.InternetService("xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+              builder.Id new_backup_internet_service.object_id
+              builder.Href new_backup_internet_service.href
+              builder.Name new_backup_internet_service.name
+              # so broken
+              builder.PublicIpAddress do
+                builder.Id -2147483648
+                builder.Id "http://totally.invalid/1234"
+                builder.Name
+              end
+              builder.Port new_backup_internet_service.port
+              builder.Protocol new_backup_internet_service.protocol
+              builder.Enabled new_backup_internet_service.enabled
+              builder.Timeout new_backup_internet_service.timeout
+              builder.Description new_backup_internet_service.description
+              builder.RedirectURL new_backup_internet_service.redirect_url
+              builder.Monitor "i:nil" => true
+              # so broken
+              builder.IsBackupService false
+              builder.BackupService "i:nil" => true
+              builder.BackupOf "i:nil" => true
+            }
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
new file mode 100644
index 0000000..c9cdf2a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_internet_service.rb
@@ -0,0 +1,140 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          def validate_internet_service_monitor(monitor)
+            #FIXME: Refactor this type of function into something generic
+            required_opts = [:type, :url_send_string, :http_headers, :receive_string, :is_enabled]
+
+            unless required_opts.all? { |opt| monitor.keys.include?(opt) && monitor[opt] }
+              raise ArgumentError.new("Required Monitor data missing: #{(required_opts - monitor.keys).map(&:inspect).join(", ")}")
+            end
+
+            unless ['HTTP','ECV'].include?(monitor[:type])
+              raise ArgumentError.new("Supported monitor types are: ECV & HTTP")
+            end
+
+            unless monitor[:http_headers].is_a?(Array) || monitor[:http_headers].is_a?(String)
+              raise ArgumentError.new("Monitor :http_headers must be a String or Array")
+            end
+
+            unless [true, false, "true", "false"].include?(monitor[:is_enabled])
+              raise ArgumentError.new("Monitor :is_enabled must be true or false")
+            end
+          end
+
+          def validate_internet_service_data(service_data, configure=false)
+            required_opts = [:name, :protocol, :port, :description, :enabled]
+            if configure
+              required_opts + [ :id, :href, :timeout ]
+            end
+            unless required_opts.all? { |opt| service_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Internet Service data missing: #{(required_opts - service_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def add_internet_service(internet_services_uri, service_data)
+            validate_internet_service_data(service_data)
+            if monitor = service_data[:monitor]
+              validate_internet_service_monitor(monitor)
+              ensure_monitor_defaults!(monitor)
+            end
+
+            request(
+              :body     => generate_internet_service_request(service_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+              :method   => 'POST',
+              :uri      => internet_services_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_internet_service_request(service_data)
+            builder = Builder::XmlMarkup.new
+            builder.CreateInternetServiceRequest(ecloud_xmlns) {
+              builder.Name(service_data[:name])
+              builder.Protocol(service_data[:protocol])
+              builder.Port(service_data[:port])
+              builder.Enabled(service_data[:enabled])
+              builder.Description(service_data[:description])
+              builder.RedirectURL(service_data[:redirect_url])
+              if monitor = service_data[:monitor]
+                generate_monitor_section(builder,monitor)
+              end
+            }
+          end
+
+          def generate_monitor_section(builder, monitor)
+            builder.Monitor {
+              builder.MonitorType(monitor[:type])
+              builder.UrlSendString(monitor[:url_send_string])
+              builder.HttpHeader(monitor[:http_headers].join("\n"))
+              builder.ReceiveString(monitor[:receive_string])
+              builder.Interval(monitor[:interval])
+              builder.ResponseTimeOut(monitor[:response_timeout])
+              builder.DownTime(monitor[:downtime])
+              builder.Retries(monitor[:retries])
+              builder.IsEnabled(monitor[:is_enabled])
+            }
+          end
+
+          def ensure_monitor_defaults!(monitor)
+            if monitor[:http_headers].is_a?(String)
+              monitor[:http_headers] = [ monitor[:http_headers] ]
+            end
+
+            unless monitor[:retries]
+              monitor[:retries] = 3
+            end
+
+            unless monitor[:response_timeout]
+              monitor[:response_timeout] = 2
+            end
+
+            unless monitor[:down_time]
+              monitor[:down_time] = 30
+            end
+
+            unless monitor[:interval]
+              monitor[:interval] = 5
+            end
+          end
+        end
+
+        class Mock
+          include Shared
+
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=561&Lang=1&SID=
+          #
+
+          def add_internet_service(internet_services_uri, service_data)
+            validate_internet_service_data(service_data)
+
+            internet_services_uri = ensure_unparsed(internet_services_uri)
+
+            if public_ip_internet_service_collection = mock_data.public_ip_internet_service_collection_from_href(internet_services_uri)
+              new_public_ip_internet_service = MockPublicIpInternetService.new(service_data, public_ip_internet_service_collection)
+              public_ip_internet_service_collection.items << new_public_ip_internet_service
+              xml = generate_internet_service(Builder::XmlMarkup.new, new_public_ip_internet_service, true)
+
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
new file mode 100644
index 0000000..d70b69a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/add_node.rb
@@ -0,0 +1,64 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def generate_node_request(node_data)
+            builder = Builder::XmlMarkup.new
+            builder.CreateNodeServiceRequest(ecloud_xmlns) {
+              builder.IpAddress(node_data[:ip_address])
+              builder.Name(node_data[:name])
+              builder.Port(node_data[:port])
+              builder.Enabled(node_data[:enabled])
+              builder.Description(node_data[:description])
+            }
+          end
+
+          def validate_node_data(node_data, configure=false)
+            valid_opts = [:name, :port, :enabled, :description, :ip_address]
+            if configure
+              valid_opts.delete_if { |opt| ![:name, :enabled, :description].include?(opt) }
+            end
+            unless valid_opts.all? { |opt| node_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - node_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def add_node(nodes_uri, node_data)
+            validate_node_data(node_data)
+
+            request(
+              :body     => generate_node_request(node_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+              :method   => 'POST',
+              :uri      => nodes_uri,
+              :parse    => true
+            )
+          end
+        end
+
+        class Mock
+          include Shared
+
+          def add_node(nodes_uri, node_data)
+            validate_node_data(node_data)
+            if node_collection = mock_data.public_ip_internet_service_node_collection_from_href(ensure_unparsed(nodes_uri))
+              new_node = MockPublicIpInternetServiceNode.new(node_data, node_collection)
+              node_collection.items << new_node
+              mock_it 200, mock_node_service_response(new_node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
new file mode 100644
index 0000000..a5e6583
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/clone_vapp.rb
@@ -0,0 +1,50 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+
+          def validate_clone_vapp_options(options)
+            valid_opts = [:name, :poweron]
+            unless valid_opts.all? { |opt| options.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def generate_clone_vapp_request(uri, options)
+            xml = Builder::XmlMarkup.new
+            xml.CloneVAppParams(xmlns.merge!(:name => options[:name], :deploy => "true", :powerOn => options[:poweron])) {
+              xml.VApp( :href => uri, :type => "application/vnd.vmware.vcloud.vApp+xml",
+                        :xmlns => "http://www.vmware.com/vcloud/v0.8")
+            }
+          end
+
+          def clone_vapp(vdc_uri, vapp_uri, options = {})
+            unless options.has_key?(:poweron)
+              options[:poweron] = "false"
+            end
+
+            validate_clone_vapp_options(options)
+
+            request(
+              :body     => generate_clone_vapp_request(vapp_uri, options),
+              :expects  => 202,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.cloneVAppParams+xml'},
+              :method   => 'POST',
+              :uri      => vdc_uri + '/action/clonevapp',
+              :parse    => true
+            )
+          end
+        end
+
+        class Mock
+          def clone_vapp(vdc_uri, vapp_uri, customization_data)
+            validate_customization_data(customization_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
new file mode 100644
index 0000000..b9db045
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_internet_service.rb
@@ -0,0 +1,110 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def validate_public_ip_address_data(ip_address_data)
+            valid_opts = [:name, :href, :id]
+            unless valid_opts.all? { |opt| ip_address_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Internet Service data missing: #{(valid_opts - ip_address_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+            validate_internet_service_data(service_data, true)
+
+            validate_public_ip_address_data(ip_address_data)
+
+            if monitor = service_data[:monitor]
+              validate_internet_service_monitor(monitor)
+              ensure_monitor_defaults!(monitor)
+            end
+
+            request(
+              :body     => generate_configure_internet_service_request(service_data, ip_address_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+              :method   => 'PUT',
+              :uri      => internet_service_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_internet_service_request(service_data, ip_address_data)
+            builder = Builder::XmlMarkup.new
+            builder.InternetService(ecloud_xmlns) {
+              builder.Id(service_data[:id])
+              builder.Href(service_data[:href])
+              builder.Name(service_data[:name])
+              builder.Protocol(service_data[:protocol])
+              builder.Port(service_data[:port])
+              builder.Enabled(service_data[:enabled])
+              builder.Description(service_data[:description])
+              builder.Timeout(service_data[:timeout])
+              builder.RedirectURL(service_data[:redirect_url])
+              builder.PublicIpAddress {
+                builder.Id(ip_address_data[:id])
+                builder.Href(ip_address_data[:href])
+                builder.Name(ip_address_data[:name])
+              }
+              if monitor = service_data[:monitor]
+                generate_monitor_section(builder, monitor)
+              end
+              if service_data[:backup_service_uri]
+                builder.BackupService do
+                  builder.Href(service_data[:backup_service_uri])
+                end
+              end
+            }
+          end
+        end
+
+        class Mock
+          include Shared
+
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=583&Lang=1&SID=
+          #
+
+          def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+            service_data = service_data.dup
+
+            validate_internet_service_data(service_data, true)
+
+            validate_public_ip_address_data(ip_address_data)
+
+            internet_service_uri = ensure_unparsed(internet_service_uri)
+
+            backup_service_uri = service_data.delete(:backup_service_uri)
+            backup_service = backup_service_uri && mock_data.backup_internet_service_from_href(backup_service_uri)
+
+            xml = nil
+
+            if (public_ip_internet_service = mock_data.public_ip_internet_service_from_href(internet_service_uri)) &&
+                (backup_service_uri.nil? || backup_service)
+              public_ip_internet_service.update(service_data.reject {|k, v| [:id, :href].include?(k) })
+              public_ip_internet_service[:backup_service] = backup_service
+              xml = generate_internet_service(Builder::XmlMarkup.new, public_ip_internet_service, true)
+            end
+
+            if xml
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
new file mode 100644
index 0000000..4dcdbd6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network.rb
@@ -0,0 +1,53 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        class Real
+
+          def validate_network_data(network_data, configure=false)
+            valid_opts = [:id, :href, :name, :rnat, :address, :broadcast, :gateway]
+            unless valid_opts.all? { |opt| network_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - network_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+
+          def configure_network(network_uri, network_data)
+            validate_network_data(network_data)
+
+            request(
+              :body     => generate_configure_network_request(network_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.networkService+xml'},
+              :method   => 'PUT',
+              :uri      => network_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_network_request(network_data)
+            builder = Builder::XmlMarkup.new
+            builder.Network(ecloud_xmlns) {
+              builder.Id(network_data[:id])
+              builder.Href(network_data[:href])
+              builder.Name(network_data[:name])
+              builder.RnatAddress(network_data[:rnat])
+              builder.Address(network_data[:address])
+              builder.BroadcastAddress(network_data[:broadcast])
+              builder.GatewayAddress(network_data[:gateway])
+            }
+          end
+
+        end
+
+        class Mock
+
+          def configure_network(network_uri, network_data)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
new file mode 100644
index 0000000..c0caf1e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_network_ip.rb
@@ -0,0 +1,68 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def validate_network_ip_data(network_ip_data)
+            valid_opts = [:id, :href, :name, :status, :server, :rnat]
+            unless valid_opts.all? { |opt| network_ip_data.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - network_ip_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def configure_network_ip(network_ip_uri, network_ip_data)
+            validate_network_ip_data(network_ip_data)
+
+            request(
+              :body     => generate_configure_network_ip_request(network_ip_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' },
+              :method   => 'PUT',
+              :uri      => network_ip_uri,
+              :parse    => true
+            )
+          end
+
+          private
+
+          def generate_configure_network_ip_request(network_ip_data)
+            builder = Builder::XmlMarkup.new
+            builder.IpAddress(ecloud_xmlns) {
+              builder.Id(network_ip_data[:id])
+              builder.Href(network_ip_data[:href])
+              builder.Name(network_ip_data[:name])
+              builder.Status(network_ip_data[:status])
+              builder.Server(network_ip_data[:server])
+              builder.RnatAddress(network_ip_data[:rnat])
+            }
+          end
+        end
+
+        class Mock
+          include Shared
+
+          def configure_network_ip(network_ip_uri, network_ip_data)
+            validate_network_ip_data(network_ip_data)
+
+            if network_ip = mock_data.network_ip_from_href(network_ip_uri)
+              network_ip[:rnat] = network_ip_data[:rnat]
+
+              builder = Builder::XmlMarkup.new
+              xml = network_ip_response(builder, network_ip, ecloud_xmlns)
+
+              mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
new file mode 100644
index 0000000..6ee1bc2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_node.rb
@@ -0,0 +1,58 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def generate_configure_node_request(node_data)
+            builder = Builder::XmlMarkup.new
+            builder.NodeService(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                                    :xmlns => "urn:tmrk:eCloudExtensions-2.0") {
+              builder.Name(node_data[:name])
+              builder.Enabled(node_data[:enabled].to_s)
+              builder.Description(node_data[:description])
+            }
+          end
+
+        end
+
+        class Real
+          include Shared
+
+          def configure_node(node_uri, node_data)
+            validate_node_data(node_data, true)
+
+            request(
+              :body     => generate_configure_node_request(node_data),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+              :method   => 'PUT',
+              :uri      => node_uri,
+              :parse    => true
+            )
+          end
+
+        end
+
+        class Mock
+          include Shared
+
+          def configure_node(node_uri, node_data)
+            validate_node_data(node_data, true)
+
+            if node = mock_data.public_ip_internet_service_node_from_href(ensure_unparsed(node_uri))
+              node.update(node_data)
+              #if node_data[:enabled] 
+              #  node.enabled = (node_data[:enabled] == "true") ? true : false
+              #end
+              mock_it 200, mock_node_service_response(node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
new file mode 100644
index 0000000..084bf7c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/configure_vapp.rb
@@ -0,0 +1,147 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def validate_vapp_data(vapp_data)
+            valid_opts = [:name, :cpus, :memory, :disks]
+            unless valid_opts.all? { |opt| vapp_data.keys.include?(opt) }
+              raise ArgumentError.new("Required Vapp data missing: #{(valid_opts - vapp_data.keys).map(&:inspect).join(", ")}")
+            end
+          end
+        end
+
+        class Real
+          include Shared
+
+          def generate_configure_vapp_request(vapp_uri, vapp_data)
+            rasd_xmlns = { "xmlns" => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData" }
+
+            xml = Nokogiri::XML(request( :uri => vapp_uri).body)
+            xml.root['name'] = vapp_data[:name]
+
+            #cpu
+            xml.at("//xmlns:ResourceType[.='3']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:cpus]
+
+            #memory
+            xml.at("//xmlns:ResourceType[.='4']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:memory]
+
+            #disks
+            real_disks = xml.xpath("//xmlns:ResourceType[ .='17']/..", rasd_xmlns)
+            real_disk_numbers = real_disks.map { |disk| disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content }
+            disk_numbers = vapp_data[:disks].map { |vdisk| vdisk[:number].to_s }
+
+            if vapp_data[:disks].length < real_disks.length
+              #Assume we're removing a disk
+              remove_disk_numbers = real_disk_numbers - disk_numbers
+              remove_disk_numbers.each do |number|
+                if result = xml.at("//xmlns:ResourceType[ .='17']/../xmlns:AddressOnParent[.='#{number}']/..", rasd_xmlns)
+                  result.remove
+                end
+              end
+            elsif vapp_data[:disks].length > real_disks.length
+              add_disk_numbers = disk_numbers - real_disk_numbers
+
+              add_disk_numbers.each do |number|
+                new_disk = real_disks.first.dup
+                new_disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content = -1
+                new_disk.at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:disks].detect { |disk| disk[:number].to_s == number.to_s }[:size]
+                real_disks.first.parent << new_disk
+              end
+            end
+
+            #puts xml.root.to_s
+            xml.root.to_s
+
+            #builder = Builder::XmlMarkup.new
+            #builder.Vapp(:href => vapp_uri.to_s,
+            #             :type => 'application/vnd.vmware.vcloud.vApp+xml',
+            #             :name => vapp_data[:name],
+            #             :status => 2,
+            #             :size => 0,
+            #             :xmlns => 'http://www.vmware.com/vcloud/v0.8',
+            #             :"xmlns:xsi" => 'http://www.w3.org/2001/XMLSchema-instance',
+            #             :"xmlns:xsd" => 'http://www.w3.org/2001/XMLSchema') {
+            #  #builder.VirtualHardwareSection(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #  builder.Section(:"xsi:type" => "q2:VirtualHardwareSection_Type", :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"xmlns:q2" => "http://www.vmware.com/vcloud/v0.8") {
+            #    builder.Info('Virtual Hardware')
+            #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #    #builder.Item {
+            #      builder.InstanceID(1, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.ResourceType(3, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.VirtualQuantity(vapp_data[:cpus], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #    }
+            #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #    #builder.Item {
+            #      builder.InstanceID(2, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.ResourceType(4, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      builder.VirtualQuantity(vapp_data[:memory], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #    }
+            #    vapp_data[:disks].each do |disk_data|
+            #      #builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+            #      builder.Item {
+            #        builder.AddressOnParent(disk_data[:number], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.HostResource(disk_data[:resource], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.InstanceID(9, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.ResourceType(17, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #        builder.VirtualQuantity(disk_data[:size], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+            #      }
+            #    end
+            #
+            #  }
+            #}
+          end
+
+          def configure_vapp(vapp_uri, vapp_data)
+            validate_vapp_data(vapp_data)
+
+            request(
+              :body     => generate_configure_vapp_request(vapp_uri, vapp_data),
+              :expects  => 202,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.vApp+xml' },
+              :method   => 'PUT',
+              :uri      => vapp_uri,
+              :parse    => true
+            )
+          end
+
+        end
+
+        class Mock
+          include Shared
+
+          def configure_vapp(vapp_uri, vapp_data)
+            validate_vapp_data(vapp_data)
+
+            if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+              vapp_data.each do |key, value|
+                case key
+                when :cpus, :memory
+                  vapp[key] = value
+                when :disks
+                  addresses_to_delete = vapp.disks.map {|d| d.address } - value.map {|d| d[:number] }
+                  addresses_to_delete.each do |address_to_delete|
+                    vapp.disks.delete(vapp.disks.at_address(address_to_delete))
+                  end
+
+                  current_addresses = vapp.disks.map {|d| d.address }
+                  disks_to_add = value.find_all {|d| !current_addresses.include?(d[:number]) }
+                  disks_to_add.each do |disk_to_add|
+                    vapp.disks << MockVirtualMachineDisk.new(:size => disk_to_add[:size] / 1024, :address => disk_to_add[:number])
+                  end
+                end
+              end
+
+              mock_it 200, '', { "Location" => mock_data.base_url + "/some_tasks/1234" }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
new file mode 100644
index 0000000..d38d25a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_internet_service.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_internet_service, 200, 'DELETE', {}, ""
+        end
+
+        class Mock
+          def delete_internet_service(service_uri)
+            if public_ip_internet_service = mock_data.public_ip_internet_service_from_href(service_uri)
+              public_ip_internet_service._parent.items.delete(public_ip_internet_service)
+
+              mock_it 200, '', { }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
new file mode 100644
index 0000000..df69035
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_node.rb
@@ -0,0 +1,24 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_node, 200, 'DELETE', {}, ""
+        end
+
+        class Mock
+
+          def delete_node(node_uri)
+            if node = mock_data.public_ip_internet_service_node_from_href(ensure_unparsed(node_uri))
+              node._parent.items.delete(node)
+              mock_it 200, '', {}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
new file mode 100644
index 0000000..7b7897d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/delete_vapp.rb
@@ -0,0 +1,32 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :delete_vapp, 202, "DELETE"
+        end
+
+        class Mock
+          def delete_vapp(vapp_uri)
+            if virtual_machine = mock_data.virtual_machine_from_href(vapp_uri)
+              vdc = virtual_machine._parent
+
+              if vdc.internet_service_collection.items.detect {|is| is.node_collection.items.any? {|isn| isn.ip_address == virtual_machine.ip } } ||
+                  virtual_machine.status != 2 ||
+                  virtual_machine.network_ip.rnat_set?
+                mock_it 202, '', {}
+              else
+                vdc.virtual_machines.delete(virtual_machine)
+                mock_it 202, '', { "Location" => mock_data.base_url + "/some_tasks/1234" }
+              end
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
new file mode 100644
index 0000000..0e6613f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog.rb
@@ -0,0 +1,46 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_catalog
+        end
+
+        class Mock
+          def get_catalog(catalog_uri)
+            catalog_uri = ensure_unparsed(catalog_uri)
+            xml = nil
+
+            if catalog = mock_data.catalog_from_href(catalog_uri)
+              builder = Builder::XmlMarkup.new
+
+              xml = builder.Catalog(xmlns.merge(
+                                                :type => "application/vnd.vmware.vcloud.catalog+xml",
+                                                :href => catalog.href,
+                                                :name => catalog.name
+                                    )) do |xml|
+                xml.CatalogItems do |xml|
+                  catalog.items.each do |catalog_item|
+                    xml.CatalogItem(
+                                    :type => "application/vnd.vmware.vcloud.catalogItem+xml",
+                                    :href => catalog_item.href,
+                                    :name => catalog_item.name
+                                    )
+                  end
+                end
+              end
+            end
+
+            if xml
+              mock_it 200,
+                xml, { 'Content-Type' => 'application/vnd.vmware.vcloud.catalog+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
new file mode 100644
index 0000000..a6a337d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_catalog_item.rb
@@ -0,0 +1,49 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_catalog_item
+        end
+
+        class Mock
+
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=542&Lang=1&SID=
+          #
+
+          def get_catalog_item(catalog_item_uri)
+            if catalog_item = mock_data.catalog_item_from_href(catalog_item_uri)
+              builder = Builder::XmlMarkup.new
+
+              xml = builder.CatalogItem(xmlns.merge(:href => catalog_item.href, :name => catalog_item.name)) do
+                builder.Link(
+                             :rel => "down",
+                             :href => catalog_item.customization.href,
+                             :type => "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml",
+                             :name => catalog_item.customization.name
+                             )
+
+                builder.Entity(
+                               :href => catalog_item.vapp_template.href,
+                               :type => "application/vnd.vmware.vcloud.vAppTemplate+xml",
+                               :name => catalog_item.vapp_template.name
+                               )
+
+                builder.Property(0, :key => "LicensingCost")
+              end
+            end
+
+            if xml
+              mock_it 200, xml, {'Content-Type' => 'application/vnd.vmware.vcloud.catalogItem+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
new file mode 100644
index 0000000..598f010
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_customization_options.rb
@@ -0,0 +1,24 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_customization_options
+        end
+
+        class Mock
+          def get_customization_options(options_uri)
+            builder = Builder::XmlMarkup.new
+            xml = builder.CustomizationParameters(xmlns) do
+              builder.CustomizeNetwork "true"
+              builder.CustomizePassword "false"
+            end
+
+            mock_it 200, xml, "Content-Type" => "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
new file mode 100644
index 0000000..fa48874
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acl.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_firewall_acl
+        end
+
+        class Mock
+          def get_firewall_acl(firewall_acl_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
new file mode 100644
index 0000000..0683f1a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_firewall_acls.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_firewall_acls
+        end
+
+        class Mock
+          def get_firewall_acls(firewall_acls_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
new file mode 100644
index 0000000..2394ab9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_internet_services.rb
@@ -0,0 +1,84 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_internet_services
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=580&Lang=1&SID=
+          #http://support.theenterprisecloud.com/kb/default.asp?id=560&Lang=1&SID=
+          #
+          #
+
+          def get_internet_services(internet_services_uri)
+            internet_services_uri = ensure_unparsed(internet_services_uri)
+            xml = nil
+
+            if vdc_internet_service_collection = mock_data.vdc_internet_service_collection_from_href(internet_services_uri)
+              xml = generate_internet_services(vdc_internet_service_collection.items)
+            elsif public_ip_internet_service_collection = mock_data.public_ip_internet_service_collection_from_href(internet_services_uri)
+              xml = generate_internet_services(public_ip_internet_service_collection.items)
+            end
+
+            if xml
+              mock_it 200,
+                xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.internetServicesList+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+          private
+
+          def generate_internet_services(services)
+            builder = Builder::XmlMarkup.new
+
+            builder.InternetServices("xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {|xml|
+              services.each do |service|
+                generate_internet_service(xml, service)
+              end
+            }
+          end
+
+          def generate_internet_service(xml, service, by_itself = false)
+            xml.InternetService(by_itself ? { "xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance" } : {}) {
+              xml.Id service.object_id
+              xml.Href service.href
+              xml.Name service.name
+              if MockDataClasses::MockBackupInternetService === service
+                xml.PublicIpAddress "i:nil" => true
+              else
+                xml.PublicIpAddress {
+                  xml.Id service._parent._parent.object_id
+                  xml.Href service._parent._parent.href
+                  xml.Name service._parent._parent.name
+                }
+              end
+              xml.Port service.port
+              xml.Protocol service.protocol
+              xml.Enabled service.enabled
+              xml.Timeout service.timeout
+              xml.Description service.description
+              xml.RedirectURL service.redirect_url
+              xml.Monitor "i:nil" => true
+              xml.IsBackupService MockDataClasses::MockBackupInternetService === service
+              if MockDataClasses::MockPublicIpInternetService === service && service.backup_service
+                xml.BackupService do
+                  xml.Href service.backup_service.href
+                end
+              else
+                xml.BackupService "i:nil" => true
+              end
+              xml.BackupOf
+            }
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
new file mode 100644
index 0000000..3d160c4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network.rb
@@ -0,0 +1,47 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          # Handled by the main Vcloud get_network
+        end
+
+        class Mock
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=546&Lang=1&SID=
+          #
+
+          def get_network(network_uri)
+            network_uri = ensure_unparsed(network_uri)
+
+            if network = mock_data.network_from_href(network_uri)
+              builder = Builder::XmlMarkup.new
+              xml = builder.Network(xmlns.merge(:href => network.href, :name => network.name, :type => "application/vnd.vmware.vcloud.network+xml")) {
+                builder.Link(:rel => "down", :href => network.ip_collection.href, :type => "application/xml", :name => network.ip_collection.name)
+                builder.Link(:rel => "down", :href => network.extensions.href, :type => "application/xml", :name => network.name)
+                builder.Configuration {
+                  builder.Gateway(network.gateway)
+                  builder.Netmask(network.netmask)
+                }
+                if network.features
+                  builder.Features {
+                    network.features.each do |feature|
+                      builder.tag!(feature[:type], feature[:value])
+                    end
+                  }
+                end
+              }
+
+              mock_it 200, xml, { "Content-Type" => "application/vnd.vmware.vcloud.network+xml" }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
new file mode 100644
index 0000000..d6a9fa4
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_extensions.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_extensions
+        end
+
+        class Mock
+
+          def get_network_extensions(network_extension_uri)
+            if network_extension = mock_data.network_extension_from_href(ensure_unparsed(network_extension_uri))
+              xml = Builder::XmlMarkup.new
+              mock_it 200, xml.Network(ecloud_xmlns) {
+                xml.Address network_extension.address
+                xml.RnatAddress network_extension.rnat
+                xml.Href network_extension.href
+                xml.Id network_extension.object_id
+                xml.Name network_extension.name
+                xml.GatewayAddress network_extension.gateway
+                xml.BroadcastAddress network_extension.broadcast
+                xml.NetworkType network_extension.type
+                xml.Vlan network_extension.vlan
+                xml.FriendlyName network_extension.friendly_name
+              }, { 'Content-Type' => "application/vnd.tmrk.ecloud.network+xml" }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
new file mode 100644
index 0000000..8462a37
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ip.rb
@@ -0,0 +1,45 @@
+#
+# AFAICT this is basically undocumented ATM - 6/18/2010 - freeformz
+#
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_ip
+        end
+
+        class Mock
+
+          def get_network_ip(network_ip_uri)
+            if network_ip = mock_data.network_ip_from_href(network_ip_uri)
+              builder = Builder::XmlMarkup.new
+              xml = network_ip_response(builder, network_ip, ecloud_xmlns)
+
+              mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+          def network_ip_response(builder, network_ip, xmlns = {})
+            builder.IpAddress(xmlns) do
+              builder.Id network_ip.object_id
+              builder.Href network_ip.href
+              builder.Name network_ip.name
+
+              builder.Status network_ip.status
+              if network_ip.used_by
+                builder.Server network_ip.used_by.name
+              end
+
+              builder.RnatAddress(network_ip.rnat)
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
new file mode 100644
index 0000000..11ec22c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_network_ips.rb
@@ -0,0 +1,37 @@
+#
+# AFAICT - This is basically undocumented - 6/18/2010 - freeformz
+#
+
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_network_ips
+        end
+
+        class Mock
+
+          def get_network_ips(network_ips_uri)
+            network_ips_uri = ensure_unparsed(network_ips_uri)
+
+            if network_ip_collection = mock_data.network_ip_collection_from_href(network_ips_uri)
+              builder = Builder::XmlMarkup.new
+              xml = builder.IpAddresses do
+                network_ip_collection.ordered_ips.each do |network_ip|
+                  network_ip_response(builder, network_ip)
+                end
+              end
+
+              mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ipAddressesList+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
new file mode 100644
index 0000000..60b786d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_node.rb
@@ -0,0 +1,42 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_node
+        end
+
+        class Mock
+          #
+          # Based on http://support.theenterprisecloud.com/kb/default.asp?id=641&Lang=1&SID=
+          #
+
+          def mock_node_service_response(node)
+            xml = Builder::XmlMarkup.new
+            xml.NodeService(ecloud_xmlns) {
+              xml.Id(node.object_id)
+              xml.Href(node.href)
+              xml.Name(node.name)
+              xml.IpAddress(node.ip_address)
+              xml.Port(node.port)
+              xml.Enabled(node.enabled)
+              xml.Description(node.description)
+            }
+          end
+
+          def get_node(node_uri)
+            node_uri = ensure_unparsed(node_uri)
+
+            if public_ip_internet_service_node = mock_data.public_ip_internet_service_node_from_href(node_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200, mock_node_service_response(public_ip_internet_service_node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
new file mode 100644
index 0000000..b0a74b0
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_nodes.rb
@@ -0,0 +1,43 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_nodes
+        end
+
+        class Mock
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=637&Lang=1&SID=
+          #
+
+          def get_nodes(nodes_uri)
+            nodes_uri = ensure_unparsed(nodes_uri)
+
+            if public_ip_internet_service_node_collection = mock_data.public_ip_internet_service_node_collection_from_href(nodes_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.NodeServices(ecloud_xmlns) {
+                  public_ip_internet_service_node_collection.items.each do |node|
+                    xml.NodeService {
+                      xml.Id node.object_id
+                      xml.Href node.href
+                      xml.Name node.name
+                      xml.IpAddress node.ip_address
+                      xml.Port node.port
+                      xml.Enabled node.enabled
+                      xml.Description node.description
+                    }
+                  end
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
new file mode 100644
index 0000000..26bb7e8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ip.rb
@@ -0,0 +1,36 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_public_ip
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=567&Lang=1&SID=
+          #
+
+          def get_public_ip(public_ip_uri)
+            public_ip_uri = ensure_unparsed(public_ip_uri)
+
+            if public_ip = mock_data.public_ip_from_href(public_ip_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.PublicIp(:xmlns => "urn:tmrk:eCloudExtensions-2.0", :"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+                  xml.Id public_ip.object_id
+                  xml.Href public_ip.href
+                  xml.Name public_ip.name
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIp+xml' }
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
new file mode 100644
index 0000000..7fabb4a
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_public_ips.rb
@@ -0,0 +1,41 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_public_ips
+        end
+
+        class Mock
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=577&Lang=1&SID=
+          #
+
+          def get_public_ips(public_ips_uri)
+            public_ips_uri = ensure_unparsed(public_ips_uri)
+
+            if public_ip_collection = mock_data.public_ip_collection_from_href(public_ips_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.PublicIPAddresses {
+                  public_ip_collection.items.each do |ip|
+                    xml.PublicIPAddress {
+                      xml.Id ip.object_id
+                      xml.Href ip.href
+                      xml.Name ip.name
+                    }
+                  end
+                }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIpsList+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
new file mode 100644
index 0000000..786892b
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_task
+        end
+
+        class Mock
+          def get_task(task__uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
new file mode 100644
index 0000000..a266a5e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_task_list.rb
@@ -0,0 +1,19 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_task_list
+        end
+
+        class Mock
+          def get_task_list(task_list_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
new file mode 100644
index 0000000..7c4f524
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp.rb
@@ -0,0 +1,101 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_vapp
+        end
+
+        class Mock
+          def return_vapp_as_creating!(name)
+            vapps_to_return_as_creating[name] = true
+          end
+
+          def vapps_to_return_as_creating
+            @vapps_to_return_as_creating ||= {}
+          end
+
+          def get_vapp(vapp_uri)
+            xml = nil
+
+            if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+              if vapps_to_return_as_creating[vapp.name]
+                xml = generate_instantiate_vapp_template_response(vapp)
+              else
+                xml = generate_get_vapp_response(vapp)
+              end
+            end
+
+            if xml
+              mock_it 200, xml, "Content-Type" => "application/vnd.vmware.vcloud.vApp+xml"
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+          private
+
+          def generate_get_vapp_response(vapp)
+            builder = Builder::XmlMarkup.new
+            builder.VApp(xmlns.merge(
+                                     :href => vapp.href,
+                                     :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                     :name => vapp.name,
+                                     :status => vapp.status,
+                                     :size => vapp.size
+                                     )) do
+              builder.Link(:rel => "up", :href => vapp._parent.href, :type => "application/vnd.vmware.vcloud.vdc+xml")
+
+              builder.NetworkConnectionSection(:xmlns => "http://schemas.dmtf.org/ovf/envelope/1") do
+                builder.NetworkConnection(:Network => "Internal", :xmlns => "http://www.vmware.com/vcloud/v0.8") do
+                  builder.IpAddress vapp.ip
+                end
+              end
+
+              builder.OperatingSystemSection(
+                                             "d2p1:id" => 4,
+                                             :xmlns => "http://schemas.dmtf.org/ovf/envelope/1",
+                                             "xmlns:d2p1" => "http://schemas.dmtf.org/ovf/envelope/1") do
+                builder.Info "The kind of installed guest operating system"
+                builder.Description "Red Hat Enterprise Linux 5 (64-bit)"
+              end
+
+              builder.VirtualHardwareSection(:xmlns => "http://schemas.dmtf.org/ovf/envelope/1") do
+                builder.Info
+                builder.System
+                builder.Item do
+                  # CPUs
+                  builder.VirtualQuantity vapp.cpus
+                  builder.ResourceType 3
+                end
+                builder.Item do
+                  # memory
+                  builder.VirtualQuantity vapp.memory
+                  builder.ResourceType 4
+                end
+                builder.Item do
+                  # SCSI controller
+                  builder.Address 0
+                  builder.ResourceType 6
+                  builder.InstanceId 3
+                end
+
+                # Hard Disks
+                vapp.disks.each do |disk|
+                  builder.Item do
+                    builder.Parent 3
+                    builder.VirtualQuantity disk.vcloud_size
+                    builder.HostResource disk.vcloud_size
+                    builder.ResourceType 17
+                    builder.AddressOnParent disk.address
+                  end
+                end
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
new file mode 100644
index 0000000..cfbb13e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vapp_template.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :get_vapp_template
+        end
+
+        class Mock
+          def get_vapp_template(templace_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
new file mode 100644
index 0000000..95b9acc
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/get_vdc.rb
@@ -0,0 +1,87 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          # Handled by the main Vcloud get_vdc
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #http://support.theenterprisecloud.com/kb/default.asp?id=545&Lang=1&SID=
+
+          def get_vdc(vdc_uri)
+            vdc_uri = ensure_unparsed(vdc_uri)
+
+            if vdc = mock_data.vdc_from_href(vdc_uri)
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+              xml.Vdc(xmlns.merge(:href => vdc.href, :name => vdc.name)) {
+                xml.Link(:rel => "down",
+                         :href => vdc.catalog.href,
+                         :type => "application/vnd.vmware.vcloud.catalog+xml",
+                         :name => vdc.catalog.name)
+                xml.Link(:rel => "down",
+                         :href => vdc.public_ip_collection.href,
+                         :type => "application/vnd.tmrk.ecloud.publicIpsList+xml",
+                         :name => vdc.public_ip_collection.name)
+                xml.Link(:rel => "down",
+                         :href => vdc.internet_service_collection.href,
+                         :type => "application/vnd.tmrk.ecloud.internetServicesList+xml",
+                         :name => vdc.internet_service_collection.name)
+                xml.Link(:rel => "down",
+                         :href => vdc.firewall_acls.href,
+                         :type => "application/vnd.tmrk.ecloud.firewallAclsList+xml",
+                         :name => vdc.firewall_acls.name)
+                xml.Description("")
+                xml.StorageCapacity {
+                  xml.Units("bytes * 10^9")
+                  xml.Allocated(vdc.storage_allocated)
+                  xml.Used(vdc.storage_used)
+                }
+                xml.ComputeCapacity {
+                  xml.Cpu {
+                    xml.Units("hz * 10^6")
+                    xml.Allocated(vdc.cpu_allocated)
+                  }
+                  xml.Memory {
+                    xml.Units("bytes * 2^20")
+                    xml.Allocated(vdc.memory_allocated)
+                  }
+                  xml.DeployedVmsQuota {
+                    xml.Limit("-1")
+                    xml.Used("-1")
+                  }
+                  xml.InstantiatedVmsQuota {
+                    xml.Limit("-1")
+                    xml.Used("-1")
+                  }
+                }
+                xml.ResourceEntities {
+                  vdc.virtual_machines.each do |virtual_machine|
+                    xml.ResourceEntity(:href => virtual_machine.href,
+                                       :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                       :name => virtual_machine.name)
+                  end
+                }
+                xml.AvailableNetworks {
+                  vdc.networks.each do |network|
+                    xml.Network(:href => network.href,
+                                :type => "application/vnd.vmware.vcloud.network+xml",
+                                :name => network.name)
+                  end
+                }
+              }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
new file mode 100644
index 0000000..c9dc260
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/instantiate_vapp_template.rb
@@ -0,0 +1,144 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+        module Shared
+          private
+
+          def validate_instantiate_vapp_template_options(catalog_item_uri, options)
+            valid_opts = [:name, :vdc_uri, :network_uri, :cpus, :memory, :row, :group]
+            unless valid_opts.all? { |opt| options.keys.include?(opt) }
+              raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+            end
+
+            # Figure out the template_uri
+            catalog_item = get_catalog_item( catalog_item_uri ).body
+            catalog_item[:Entity] = [ catalog_item[:Entity] ] if catalog_item[:Entity].is_a?(Hash)
+            catalog_item[:Link] = [ catalog_item[:Link] ] if catalog_item[:Link].is_a?(Hash)
+
+            options[:template_uri] = begin
+               catalog_item[:Entity].detect { |entity| entity[:type] == "application/vnd.vmware.vcloud.vAppTemplate+xml" }[:href]
+            rescue
+              raise RuntimeError.new("Unable to locate template uri for #{catalog_item_uri}")
+            end
+
+            customization_options = begin
+                customization_href = catalog_item[:Link].detect { |link| link[:type] == "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml" }[:href]
+                get_customization_options( customization_href ).body
+            rescue
+              raise RuntimeError.new("Unable to get customization options for #{catalog_item_uri}")
+            end
+
+            # Check to see if we can set the password
+            if options[:password] and customization_options[:CustomizePassword] == "false"
+              raise ArgumentError.new("This catalog item (#{catalog_item_uri}) does not allow setting a password.")
+            end
+
+            # According to the docs if CustomizePassword is "true" then we NEED to set a password
+            if customization_options[:CustomizePassword] == "true" and ( options[:password].nil? or options[:password].empty? )
+              raise ArgumentError.new("This catalog item (#{catalog_item_uri}) requires a :password to instantiate.")
+            end
+          end
+
+          def generate_instantiate_vapp_template_request(options)
+            xml = Builder::XmlMarkup.new
+            xml.InstantiateVAppTemplateParams(xmlns.merge!(:name => options[:name], :"xml:lang" => "en")) {
+              xml.VAppTemplate(:href => options[:template_uri])
+              xml.InstantiationParams {
+                xml.ProductSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8", :"xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1") {
+                  if options[:password]
+                    xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "password", :"ovf:value" => options[:password] )
+                  end
+                  xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "row", :"ovf:value" => options[:row] )
+                  xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "group", :"ovf:value" => options[:group] )
+                }
+                xml.VirtualHardwareSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8" ) {
+                  # # of CPUS
+                  xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                    xml.InstanceID(1, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.ResourceType(3, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.VirtualQuantity(options[:cpus], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  }
+                  # Memory
+                  xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                    xml.InstanceID(2, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.ResourceType(4, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                    xml.VirtualQuantity(options[:memory], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  }
+                }
+                xml.NetworkConfigSection {
+                  xml.NetworkConfig {
+                    xml.NetworkAssociation( :href => options[:network_uri] )
+                  }
+                }
+              }
+            }
+          end
+        end
+
+        class Real
+          include Shared
+
+          def instantiate_vapp_template(catalog_item_uri, options = {})
+            validate_instantiate_vapp_template_options(catalog_item_uri, options)
+
+            request(
+              :body     => generate_instantiate_vapp_template_request(options),
+              :expects  => 200,
+              :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml'},
+              :method   => 'POST',
+              :uri      => options[:vdc_uri] + '/action/instantiatevAppTemplate',
+              :parse    => true
+            )
+          end
+        end
+
+        class Mock
+          include Shared
+
+          #
+          # Based on
+          # http://support.theenterprisecloud.com/kb/default.asp?id=554&Lang=1&SID=
+          #
+
+          def instantiate_vapp_template(catalog_item_uri, options = {})
+            validate_instantiate_vapp_template_options(catalog_item_uri, options)
+            catalog_item = mock_data.catalog_item_from_href(catalog_item_uri)
+
+            xml = nil
+            if vdc = mock_data.vdc_from_href(options[:vdc_uri])
+              if network = mock_data.network_from_href(options[:network_uri])
+                new_vm = MockVirtualMachine.new({ :name => options[:name], :ip => network.random_ip, :cpus => options[:cpus], :memory => options[:memory] }, vdc)
+                new_vm.disks.push(*catalog_item.disks.dup)
+                vdc.virtual_machines << new_vm
+
+                xml = generate_instantiate_vapp_template_response(new_vm)
+              end
+            end
+
+            if xml
+              mock_it 200, xml, {'Content-Type' => 'application/xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+          private
+
+          def generate_instantiate_vapp_template_response(vapp)
+            builder = Builder::XmlMarkup.new
+            builder.VApp(xmlns.merge(
+                                     :href => vapp.href,
+                                     :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                     :name => vapp.name,
+                                     :status => 0,
+                                     :size => 4
+                                     )) {
+              builder.Link(:rel => "up", :href => vapp._parent.href, :type => "application/vnd.vmware.vcloud.vdc+xml")
+            }
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
new file mode 100644
index 0000000..059fe41
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_off.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_off, 202, 'POST'
+        end
+
+        class Mock
+          def power_off(vapp_uri)
+            if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+              vapp.power_off!
+
+              builder = Builder::XmlMarkup.new
+              mock_it 200, builder.Task(xmlns)
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
new file mode 100644
index 0000000..c98c5f6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_on.rb
@@ -0,0 +1,25 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_on, 202, 'POST'
+        end
+
+        class Mock
+          def power_on(vapp_uri)
+            if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+              vapp.power_on!
+
+              builder = Builder::XmlMarkup.new
+              mock_it 200, builder.Task(xmlns)
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
new file mode 100644
index 0000000..f96ac57
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_reset.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_reset, 202, 'POST'
+        end
+
+        class Mock
+          def power_reset(reset_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
new file mode 100644
index 0000000..832d24f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/ecloud/requests/power_shutdown.rb
@@ -0,0 +1,18 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Ecloud
+
+        class Real
+          basic_request :power_shutdown, 204, 'POST'
+        end
+
+        class Mock
+          def power_shutdown(shutdown_uri)
+            Fog::Mock.not_implemented
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud.rb
new file mode 100644
index 0000000..ecf8320
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud.rb
@@ -0,0 +1,22 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Vcloud < Fog::Vcloud
+        request_path 'fog/vcloud/terremark/vcloud/requests'
+        request :get_vdc
+
+        class Real < Fog::Vcloud::Real
+
+          def supporting_versions
+            ["0.8", "0.8a-ext1.6"]
+          end
+
+        end
+
+        class Mock < Fog::Vcloud::Mock
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
new file mode 100644
index 0000000..1fb76d8
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/vcloud/terremark/vcloud/requests/get_vdc.rb
@@ -0,0 +1,57 @@
+module Fog
+  class Vcloud
+    module Terremark
+      class Vcloud
+
+        class Real
+          # Handled by the main Vcloud get_vdc
+        end
+
+        class Mock
+          #
+          #Based off of:
+          #https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/09-get-vdc.aspx
+
+          def get_vdc(vdc_uri)
+            vdc_uri = ensure_unparsed(vdc_uri)
+            if vdc = mock_data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:href] == vdc_uri }
+              xml = Builder::XmlMarkup.new
+              mock_it 200,
+                xml.Vdc(xmlns.merge(:href => vdc[:href], :name => vdc[:name])) {
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/catalog",
+                           :type => "application/vnd.vmware.vcloud.catalog+xml",
+                           :name => vdc[:name])
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/publicIps",
+                           :type => "application/xml",
+                           :name => "Public IPs")
+                  xml.Link(:rel => "down",
+                           :href => vdc[:href] + "/internetServices",
+                           :type => "application/xml",
+                           :name => "Internet Services")
+                  xml.ResourceEntities {
+                    vdc[:vms].each do |vm|
+                      xml.ResourceEntity(:href => vm[:href],
+                                         :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                         :name => vm[:name])
+                    end
+                  }
+                  xml.AvailableNetworks {
+                    vdc[:networks].each do |network|
+                      xml.Network(:href => network[:href],
+                                  :type => "application/vnd.vmware.vcloud.network+xml",
+                                  :name => network[:name])
+                    end
+                  }
+                }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml'}
+            else
+              mock_error 200, "401 Unauthorized"
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo.rb
new file mode 100644
index 0000000..fb5784d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo.rb
@@ -0,0 +1,15 @@
+require 'nokogiri'
+
+require File.join(File.dirname(__FILE__), 'core')
+require 'fog/core/parser'
+
+module Fog
+  module Zerigo
+
+    extend Fog::Provider
+
+    service_path 'fog/zerigo'
+    service :dns
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/bin.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/bin.rb
new file mode 100644
index 0000000..e4a38f5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/bin.rb
@@ -0,0 +1,25 @@
+class Zerigo < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :dns
+        Fog::Zerigo::DNS
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = class_for(key).new
+      end
+      @@connections[service]
+    end
+
+    def services
+      [:dns]
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/dns.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/dns.rb
new file mode 100644
index 0000000..7dcccb7
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/dns.rb
@@ -0,0 +1,98 @@
+module Fog
+  module Zerigo
+    class DNS < Fog::Service
+
+      requires :zerigo_email, :zerigo_token
+      recognizes :timeout, :persistent
+
+      model_path 'fog/zerigo/models/dns'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/zerigo/requests/dns'
+      request :count_hosts
+      request :count_zones
+      request :create_host
+      request :create_zone
+      request :delete_host
+      request :delete_zone
+      request :find_hosts
+      request :get_host
+      request :get_zone
+      request :get_zone_stats
+      request :list_zones
+      request :list_hosts
+      request :update_host
+      request :update_zone
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @zerigo_email = options[:zerigo_email]
+          @zerigo_token = options[:zerigo_token]
+          @data = self.class.data[@zerigo_email]
+          @data = self.class.data[@zerigo_password]
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          @zerigo_email     = options[:zerigo_email]
+          @zerigo_token  = options[:zerigo_token]
+          @host   = options[:host]    || "ns.zerigo.com"
+          @port   = options[:port]    || 80
+          @scheme = options[:scheme]  || 'http'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          key= "#{@zerigo_email}:#{@zerigo_token}"
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(key).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Zerigo::DNS::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/record.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/record.rb
new file mode 100644
index 0000000..4ad8aa9
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/record.rb
@@ -0,0 +1,65 @@
+require 'fog/core/model'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :created_at,  :aliases => 'created-at'
+        attribute :ip,          :aliases => 'data'
+        attribute :domain,      :aliases => 'fqdn'
+        attribute :name,        :aliases => 'hostname'
+        attribute :description, :aliases => 'notes'
+        attribute :priority
+        attribute :ttl
+        attribute :type,        :aliases => 'host-type'
+        attribute :updated_at,  :aliases => 'updated-at'
+        attribute :zone_id,     :aliases => 'zone-id'
+
+        def initialize(attributes={})
+          self.ttl    ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_host(identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :zone, :type, :ip
+          options = {}
+          options[:hostname]  = name if name
+          options[:notes]     = description if description
+          options[:priority]  = priority if priority
+          options[:ttl]       = ttl if ttl
+          data = unless identity
+            connection.create_host(@zone.id, type, ip, options)
+          else
+            options[:host_type] = type
+            options[:data]      = data
+            connection.update_host(identity, options)
+          end
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/records.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/records.rb
new file mode 100644
index 0000000..991fdae
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/records.rb
@@ -0,0 +1,41 @@
+require 'fog/core/collection'
+require 'fog/zerigo/models/dns/record'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Zerigo::DNS::Record
+
+        def all
+          requires :zone
+          parent = zone.collection.get(zone.identity)
+          if parent
+            merge_attributes(parent.records.attributes)
+            load(parent.records.map {|record| record.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(record_id)
+          data = connection.get_host(record_id).body
+          new(data)
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zone.rb
new file mode 100644
index 0000000..c5ae581
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zone.rb
@@ -0,0 +1,88 @@
+require 'fog/core/model'
+require 'fog/zerigo/models/dns/records'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :created_at,  :aliases => 'created-at'
+        attribute :domain
+        attribute :ttl,         :aliases => 'default-ttl'
+        attribute :type,        :aliases => 'ns-type'
+        attribute :updated_at,  :aliases => 'updated-at'
+
+        # <custom-nameservers>ns1.example.com,ns2.example.com</custom-nameservers>
+        # <custom-ns type="boolean">true</custom-ns> 
+        # <hostmaster>dnsadmin@example.com</hostmaster> 
+        # <notes nil="true"/>
+        # <ns1 nil="true"/>
+        # <nx-ttl nil="true"></nx-ttl>
+        # <slave-nameservers nil="true"/>
+        # <tag-list>one two</tag-list>
+        # <hosts-count>1</hosts-count>
+
+        def initialize(attributes={})
+          self.type ||= 'pri_sec'
+          self.ttl  ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Zerigo::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'a.ns.zerigo.net',
+            'b.ns.zerigo.net',
+            'c.ns.zerigo.net',
+            'd.ns.zerigo.net',
+            'e.ns.zerigo.net'
+          ]
+        end
+
+        def save
+          requires :domain, :type, :ttl
+          options = {}
+          # * options<~Hash> - optional paramaters
+          #   * ns1<~String> - required if ns_type == sec
+          #   * nx_ttl<~Integer> -
+          #   * slave_nameservers<~String> - required if ns_type == pri
+          #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+          #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+          #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+          #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+          #   * notes<~String> - notes about the domain
+          #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+          #   * tag_list<~String> - List of all tags associated with this domain
+          data = unless identity
+            connection.create_zone(domain, ttl, type, options)
+          else
+            options[:default_ttl] = ttl
+            options[:ns_type]     = type
+            connection.update_zone(identity, options)
+          end
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zones.rb
new file mode 100644
index 0000000..f80dffe
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/models/dns/zones.rb
@@ -0,0 +1,30 @@
+require 'fog/core/collection'
+require 'fog/zerigo/models/dns/zone'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Zerigo::DNS::Zone
+
+        def all
+          data = connection.list_zones.body['zones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_zone(zone_id).body
+          zone = new(data)
+          zone.records.load(data['hosts'])
+          zone
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_hosts.rb
new file mode 100644
index 0000000..1baa30f
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_hosts.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CountHosts < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'count'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_zones.rb
new file mode 100644
index 0000000..4a5f9b5
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/count_zones.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CountZones < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'count'
+              @response[name] = @value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_host.rb
new file mode 100644
index 0000000..c20f253
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_host.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CreateHost < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @response[name] = @value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_zone.rb
new file mode 100644
index 0000000..9644727
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/create_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CreateZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+              @response[name] = @value.to_i
+            when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/find_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/find_hosts.rb
new file mode 100644
index 0000000..c8b468c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/find_hosts.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class FindHosts < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @response = { 'hosts' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @host[name] = @value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @host[name] = @value
+            when 'host'
+              @response['hosts'] << @host
+              @host = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_host.rb
new file mode 100644
index 0000000..7fc9673
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_host.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetHost < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @response[name] = @value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @response[name] = @value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone.rb
new file mode 100644
index 0000000..4bf9f2c
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetZone < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @hosts = []
+            @response = {}
+            @in_hosts = false
+          end
+
+          def start_element(name, attrs = [])
+            super(name, attrs)
+            #look out for start of <hosts> section
+            #needed as some of the tags have the same name as the parent <zone> section
+            if name == 'hosts'
+              @in_hosts= true
+            end
+          end
+          
+          def end_element(name)
+            if (@in_hosts)
+              #in hosts part of response
+              case name
+              when 'id', 'priority', 'ttl', 'zone-id'
+                @host[name] = @value.to_i
+              when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+                @host[name] = @value
+              when 'host'
+                @hosts << @host
+                @host = {}
+              when 'hosts'
+                @response[name] = @hosts
+                @in_hosts = false
+              end
+            else
+              #in zone part of data
+              case name
+              when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+                @response[name] = @value.to_i
+              when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+                @response[name] = @value
+              end
+            end
+            
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone_stats.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone_stats.rb
new file mode 100644
index 0000000..db19b78
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/get_zone_stats.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetZoneStats < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'queries'
+              @response[name] = @value.to_i
+            when 'domain', 'period-begin', 'period-end'
+              @response[name] = @value
+            end            
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_hosts.rb
new file mode 100644
index 0000000..6e3ffed
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_hosts.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class ListHosts < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @response = { 'hosts' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @host[name] = @value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @host[name] = @value
+            when 'host'
+              @response['hosts'] << @host
+              @host = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_zones.rb
new file mode 100644
index 0000000..18716d6
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/parsers/dns/list_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class ListZones < Fog::Parsers::Base
+
+          def reset
+            @zone = {}
+            @response = { 'zones' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+              @zone[name] = @value.to_i
+            when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+              @zone[name] = @value
+            when 'zone'
+              @response['zones'] << @zone
+              @zone = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_hosts.rb
new file mode 100644
index 0000000..7cd7b1d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_hosts.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/count_hosts'
+
+        # total number of hosts available for the specified zone. It is the same value as provided 
+        # in the X-Query-Count header in the list_hosts API method
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'count'<~Integer> 
+        #   * 'status'<~Integer> - 200 indicates success
+        def count_hosts( zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::CountHosts.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts/count.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def count_hosts( zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_zones.rb
new file mode 100644
index 0000000..99fb987
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/count_zones.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/count_zones'
+
+        # Total number of zones hosted Zerigo for this account. It is the same value as provided 
+        # in the X-Query-Count header in the list_zones API method
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'count'<~Integer> 
+        #   * 'status'<~Integer> - 200 indicates success
+        def count_zones()
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::CountZones.new,
+            :path     => "/api/1.1/zones/count.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def count_zones()
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_host.rb
new file mode 100644
index 0000000..bb053bb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_host.rb
@@ -0,0 +1,70 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/create_host'
+
+        # Create a new host in the specified zone
+        #
+        # ==== Parameters
+        # * zone_id<~Integer>
+        # * host_type<~String>
+        # * data<~String>
+        # * options<~Hash> - optional paramaters
+        #   * hostname<~String> - Note: normally this is set/required!!
+        #   * notes<~String>
+        #   * priority<~Integer> - Note: required for MX or SRV records
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'created-at'<~String>
+        #     * 'data'<~String>
+        #     * 'fqdn'<~String>
+        #     * 'host-type'<~String>
+        #     * 'hostname'<~String>
+        #     * 'id'<~Integer>
+        #     * 'notes'<~String>
+        #     * 'priority'<~Integer>
+        #     * 'ttl'<~Integer>
+        #     * 'updated-at'<~String>
+        #     * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 201 if successful        
+        def create_host(zone_id, host_type, data, options = {})
+          
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :hostname
+              optional_tags+= "<hostname>#{value}</hostname>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :priority
+              optional_tags+= "<priority>#{value}</priority>"
+            when :ttl
+              optional_tags+= "<ttl>#{value}</ttl>"
+            end
+          }
+            
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><host><host-type>#{host_type}</host-type><data>#{data}</data>#{optional_tags}</host>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Zerigo::DNS::CreateHost.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_host( zone_id, host_type, data, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_zone.rb
new file mode 100644
index 0000000..3555eeb
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/create_zone.rb
@@ -0,0 +1,97 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/create_zone'
+
+        # Create a new zone for Zerigo's DNS servers to serve/host
+        # ==== Parameters
+        #
+        # * domain<~String>
+        # * default_ttl<~Integer>
+        # * ns_type<~String>
+        # * options<~Hash> - optional paramaters
+        #   * ns1<~String> - required if ns_type == sec
+        #   * nx_ttl<~Integer> -
+        #   * slave_nameservers<~String> - required if ns_type == pri
+        #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+        #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+        #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+        #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+        #   * notes<~String> - notes about the domain
+        #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+        #   * tag_list<~String> - List of all tags associated with this domain
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - zone ID to use for future calls
+        #     * 'default-ttl'<~Integer>
+        #     * 'nx-ttl'<~Integer>
+        #     * 'hosts-count'<~Integer>
+        #     * 'created-at'<~String>
+        #     * 'custom-nameservers'<~String>
+        #     * 'custom-ns'<~String>
+        #     * 'domain'<~String>
+        #     * 'hostmaster'<~String>
+        #     * 'notes'<~String>
+        #     * 'ns1'<~String>
+        #     * 'ns-type'<~String>
+        #     * 'slave-nameservers'<~String>
+        #     * 'tag-list'<~String>
+        #     * 'updated-at'<~String>
+        #     * 'hosts'<~String>
+        #     * 'axfr-ips'<~String>
+        #     * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 201 if successful        
+        
+        def create_zone( domain, default_ttl, ns_type, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ns1
+              optional_tags+= "<ns1>#{value}</ns1>"
+            when :nx_ttl
+              optional_tags+= "<nx-ttl type='interger'>#{value}</nx-ttl>"
+            when :slave_nameservers
+              optional_tags+= "<slave-nameservers>#{value}</slave-nameservers>"
+            when :axfr_ips
+              optional_tags+= "<axfr-ips>#{value}</axfr-ips>"
+            when :custom_nameservers
+              optional_tags+= "<custom-nameservers>#{value}</custom-nameservers>"
+            when :custom_ns
+              optional_tags+= "<custom-ns>#{value}</custom-ns>"
+            when :hostmaster
+              optional_tags+= "<hostmaster>#{value}</hostmaster>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :restrict_axfr
+              optional_tags+= "<restrict-axfr>#{value}</restrict-axfr>"
+            when :tag_list
+              optional_tags+= "<tag-list>#{value}</tag-list>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone><domain>#{domain}</domain><default-ttl type="integer">#{default_ttl}</default-ttl><ns-type>#{ns_type}</ns-type>#{optional_tags}</zone>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Zerigo::DNS::CreateZone.new,
+            :path     => '/api/1.1/zones.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_zone(domain, default_ttl, ns_type, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_host.rb
new file mode 100644
index 0000000..4d4ca4d
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_host.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Delete a host record 
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - Id of host record to delete
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * 'status'<~Integer> - 200 indicates success
+        def delete_host(host_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_host(host_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_zone.rb
new file mode 100644
index 0000000..233f8f1
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/delete_zone.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Delete a zone from Zerigo
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to delete
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def delete_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/1.1/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/find_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/find_hosts.rb
new file mode 100644
index 0000000..d3c61c2
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/find_hosts.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/find_hosts'
+
+        # Get list of all the host records that match the FQDN.  If desired, can limit
+        # search to a specific zone
+        #
+        #
+        # ==== Parameters
+        # * fqdn<~String> - domain to look for
+        # * zone_id<~Integer> - if want to limit search to specific zone
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'hosts'<~Hash>
+        #       * 'created-at'<~String>
+        #       * 'data'<~String>
+        #       * 'fqdn'<~String>
+        #       * 'host-type'<~String>
+        #       * 'hostname'<~String>
+        #       * 'id'<~Integer>
+        #       * 'notes'<~String>
+        #       * 'priority'<~Integer>
+        #       * 'ttl'<~Integer>
+        #       * 'updated-at'<~String>
+        #       * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 200 indicated success
+        #
+        def find_hosts( fqdn, zone_id = nil)
+          if zone_id.nil?
+            #look for matching host across all zones
+            request(
+              :expects  => 200,
+              :method   => 'GET',
+              :parser   => Fog::Parsers::Zerigo::DNS::FindHosts.new,
+              :path     => "/api/1.1/hosts.xml?fqdn=#{fqdn}"
+            )
+          else
+            #look for hosts in a specific zone
+            request(
+              :expects  => 200,
+              :method   => 'GET',
+              :parser   => Fog::Parsers::Zerigo::DNS::FindHosts.new,
+              :path     => "/api/1.1/zones/#{zone_id}/hosts.xml?fqdn=#{fqdn}"
+            )
+          end
+        end
+
+      end
+
+      class Mock
+
+        def find_hosts( fqdn, zone_id = nil)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_host.rb
new file mode 100644
index 0000000..c5c5777
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_host.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/get_host'
+
+        # get details about a given host record
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - ID of the host record to retrieve
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>:
+        #     * 'created-at'<~String>
+        #     * 'data'<~String>
+        #     * 'fqdn'<~String>
+        #     * 'host-type'<~String>
+        #     * 'hostname'<~String>
+        #     * 'id'<~Integer>
+        #     * 'notes'<~String>
+        #     * 'priority'<~Integer>
+        #     * 'ttl'<~Integer>
+        #     * 'updated-at'<~String>
+        #     * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 200 indicates success
+        def get_host( host_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetHost.new,
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_host( host_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone.rb
new file mode 100644
index 0000000..5cd6302
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone.rb
@@ -0,0 +1,57 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/get_zone'
+
+        # Get details of a DNS zone. The response is similar to list_zones, with the 
+        # addition of hosts-count and possibly hosts.
+        #
+        # ==== Parameters
+        # * zone<~String> - Either the zone ID or the zone name (ie sample-domain.com)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'default-ttl'<~Integer>
+        #     * 'id'<~Integer>
+        #     * 'nx-ttl'<~Integer>
+        #     * 'hosts-count'<~Integer>
+        #     * 'created-at'<~String>
+        #     * 'custom-nameservers'<~String>
+        #     * 'custom-ns'<~String>
+        #     * 'domain'<~String>
+        #     * 'hostmaster'<~String>
+        #     * 'notes'<~String>
+        #     * 'ns1'<~String>
+        #     * 'ns-type'<~String>
+        #     * 'slave-nameservers'<~String>
+        #     * 'tag-list'<~String>
+        #     * 'updated-at'<~String>
+        #     * 'hosts'<~Array> - a list of all host records. For the format of host info, see get_host() 
+        #     * 'axfr-ips'<~String>
+        #     * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def get_zone(zone)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetZone.new,
+            :path     => "/api/1.1/zones/#{zone}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(zone)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone_stats.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone_stats.rb
new file mode 100644
index 0000000..2f87186
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/get_zone_stats.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/get_zone_stats'
+
+        # returns current traffic statistics about this zone. Queries is measured from the 
+        # beginning of the current period through the time of the API call.
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - the zone ID 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'domain'<~String> - domain name  (ie example.com)
+        #     * 'id'<~Integer> - Id of the zone
+        #     * 'period-being'<~String> - date in following format 2010-07-01
+        #     * 'period-end'<~String> - date
+        #     * 'queries'<~Integer> - # of queries for the zone during period
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def get_zone_stats(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetZoneStats.new,
+            :path     => "/api/1.1/zones/#{zone_id}/stats.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone_stats(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_hosts.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_hosts.rb
new file mode 100644
index 0000000..c16e874
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_hosts.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/list_hosts'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - the zone ID of the zone from which to get the host records for
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'hosts'<~Array>
+        #       * 'created-at'<~String>
+        #       * 'data'<~String>
+        #       * 'fqdn'<~String>
+        #       * 'host-type'<~String>
+        #       * 'hostname'<~String>
+        #       * 'id'<~Integer>
+        #       * 'notes'<~String>
+        #       * 'priority'<~Integer>
+        #       * 'ttl'<~Integer>
+        #       * 'updated-at'<~String>
+        #       * 'zone-id'<~String>
+        # * 'status'<~Integer> - 200 indicates success
+        def list_hosts( zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::ListHosts.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_hosts( zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_zones.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_zones.rb
new file mode 100644
index 0000000..6aa0f8e
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/list_zones.rb
@@ -0,0 +1,53 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/zerigo/parsers/dns/list_zones'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'zones'<~Array>
+        #       * 'default-ttl'<~Integer>
+        #       * 'id'<~Integer>
+        #       * 'nx-ttl'<~Integer>
+        #       * 'hosts-count'<~Integer>
+        #       * 'created-at'<~String>
+        #       * 'custom-nameservers'<~String>
+        #       * 'custom-ns'<~String>
+        #       * 'domain'<~String>
+        #       * 'hostmaster'<~String>
+        #       * 'notes'<~String>
+        #       * 'ns1'<~String>
+        #       * 'ns-type'<~String>
+        #       * 'slave-nameservers'<~String>
+        #       * 'tag-list'<~String>
+        #       * 'updated-at'<~String>
+        #       * 'hosts'<~String>
+        #       * 'axfr-ips'<~String>
+        #       * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 200 indicates success
+        def list_zones
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::ListZones.new,
+            :path     => '/api/1.1/zones.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_zones
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_host.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_host.rb
new file mode 100644
index 0000000..9cb5807
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_host.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Update a host record
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - host ID of the record to update
+        # * options<~Hash> - optional paramaters
+        #   * host_type<~String>
+        #   * data<~String>
+        #   * hostname<~String> - Note: normally this is set/required!!
+        #   * notes<~String>
+        #   * priority<~Integer> - Note: required for MX or SRV records
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * 'status'<~Integer> - 200 for success
+        #
+        def update_host( host_id, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :host_type
+              optional_tags+= "<host-type>#{host_type}</host-type>"
+            when :data
+              optional_tags+= "<data>#{data}</data>"
+            when :hostname
+              optional_tags+= "<hostname>#{value}</hostname>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :priority
+              optional_tags+= "<priority>#{value}</priority>"
+            when :ttl
+              optional_tags+= "<ttl>#{value}</ttl>"
+            end
+          }
+
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><host>#{optional_tags}</host>},
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_host( host_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_zone.rb b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_zone.rb
new file mode 100644
index 0000000..5c639af
--- /dev/null
+++ b/lib/bbcloud/vendor/fog-0.4.0/lib/fog/zerigo/requests/dns/update_zone.rb
@@ -0,0 +1,78 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Update the parameters of a zone
+        # ==== Parameters
+        #
+        # * zone_id<~Integer>
+        # * options<~Hash> - optional paramaters
+        #   * default_ttl<~Integer>
+        #   * ns_type<~String>
+        #   * ns1<~String> - required if ns_type == sec
+        #   * nx_ttl<~Integer> -
+        #   * slave_nameservers<~String> - required if ns_type == pri
+        #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+        #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+        #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+        #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+        #   * notes<~String> - notes about the domain
+        #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+        #   * tag_list<~String> - List of all tags associated with this domain
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'status'<~Integer> - 200 for success
+        def update_zone( zone_id, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :default_ttl
+              optional_tags+= "<default-ttl>#{value}</default-ttl>"
+            when :ns_type
+              optional_tags+= "<ns-type>#{value}</ns-type>"
+            when :ns1
+              optional_tags+= "<ns1>#{value}</ns1>"
+            when :nx_ttl
+              optional_tags+= "<nx-ttl type='interger'>#{value}</nx-ttl>"
+            when :slave_nameservers
+              optional_tags+= "<slave-nameservers>#{value}</slave-nameservers>"
+            when :axfr_ips
+              optional_tags+= "<axfr-ips>#{value}</axfr-ips>"
+            when :custom_nameservers
+              optional_tags+= "<custom-nameservers>#{value}</custom-nameservers>"
+            when :custom_ns
+              optional_tags+= "<custom-ns>#{value}</custom-ns>"
+            when :hostmaster
+              optional_tags+= "<hostmaster>#{value}</hostmaster>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :restrict_axfr
+              optional_tags+= "<restrict-axfr>#{value}</restrict-axfr>"
+            when :tag_list
+              optional_tags+= "<tag-list>#{value}</tag-list>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone>#{optional_tags}</zone>},
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "/api/1.1/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_zone(zone_id, options = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/README.rdoc b/lib/bbcloud/vendor/formatador-0.0.16/README.rdoc
new file mode 100644
index 0000000..f851a18
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/README.rdoc
@@ -0,0 +1,63 @@
+= formatador
+
+STDOUT text formatting
+
+== Quick and dirty
+
+You can call class methods to print out single lines like this:
+
+  Formatador.display_line('Hello World')
+
+You use tags, similar to html, to set formatting options:
+
+  Formatador.display_line('[green]Hello World[/]')
+
+  [/] resets everything to normal, colors are supported and [_color_] sets the background color.
+
+== Standard options
+
+* format - and adds color codes if STDOUT.tty? is true
+* display - calls format on the input and prints it
+* display_line - calls display, but adds on a newline (\n)
+* redisplay - Displays text, prepended with \r which will overwrite the last existing line
+
+== Extensions
+
+* display_table: takes an array of hashes. Each hash is a row, with the keys being the headers and values being the data. An optional second argument can specify which headers/columns to include and in what order they should appear.
+* redisplay_progressbar: takes the current and total values as its first two arguments and redisplays a progressbar (until current = total and then it display_lines). An optional third argument represents the start time and will add an elapsed time counter.
+
+== Indentation
+
+By initializing a formatador object you can keep track of indentation:
+
+  formatador = Formatador.new
+  formatador.display_line('one level of indentation')
+  formatador.indent {
+    formatador.display_line('two levels of indentation')
+  }
+  formatador.display_line('one level of indentation')
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2009 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/Rakefile b/lib/bbcloud/vendor/formatador-0.0.16/Rakefile
new file mode 100644
index 0000000..5f393c8
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/Rakefile
@@ -0,0 +1,147 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+require 'rake/testtask'
+Rake::TestTask.new(:test) do |test|
+  test.libs << 'lib' << 'test'
+  test.pattern = 'test/**/test_*.rb'
+  test.verbose = true
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/formatador.gemspec b/lib/bbcloud/vendor/formatador-0.0.16/formatador.gemspec
new file mode 100644
index 0000000..8f7b101
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/formatador.gemspec
@@ -0,0 +1,76 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'formatador'
+  s.version           = '0.0.16'
+  s.date              = '2010-11-18'
+  s.rubyforge_project = 'formatador'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "Ruby STDOUT text formatting"
+  s.description = "STDOUT text formatting"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    README.rdoc
+    Rakefile
+    formatador.gemspec
+    lib/formatador.rb
+    lib/formatador/progressbar.rb
+    lib/formatador/table.rb
+    tests/formatador_tests.rb
+    tests/tests_helper.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador.rb b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador.rb
new file mode 100644
index 0000000..3eab0f5
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador.rb
@@ -0,0 +1,128 @@
+require File.join(File.dirname(__FILE__), 'formatador', 'table')
+require File.join(File.dirname(__FILE__), 'formatador', 'progressbar')
+
+class Formatador
+
+  VERSION = '0.0.16'
+
+  STYLES = {
+    :"\/"             => "0",
+    :reset            => "0",
+    :bold             => "1",
+    :underline        => "4",
+    :blink_slow       => "5",
+    :blink_fast       => "6",
+    :negative         => "7", # invert color/color
+    :normal           => "22",
+    :underline_none   => "24",
+    :blink_off        => "25",
+    :positive         => "27", # revert color/color
+    :black            => "30",
+    :red              => "31",
+    :green            => "32",
+    :yellow           => "33",
+    :blue             => "34",
+    :magenta          => "35",
+    :purple           => "35",
+    :cyan             => "36",
+    :white            => "37",
+    :_black_          => "40",
+    :_red_            => "41",
+    :_green_          => "42",
+    :_yellow_         => "43",
+    :_blue_           => "44",
+    :_magenta_        => "45",
+    :_purple_         => "45",
+    :_cyan_           => "46",
+    :_white_          => "47",
+    :light_black      => "90",
+    :light_red        => "91",
+    :light_green      => "92",
+    :light_yellow     => "93",
+    :light_blue       => "94",
+    :light_magenta    => "95",
+    :light_purple     => "95",
+    :light_cyan       => "96",
+    :_light_black_    => "100",
+    :_light_red_      => "101",
+    :_light_green_    => "102",
+    :_light_yellow_   => "103",
+    :_light_blue_     => "104",
+    :_light_magenta_  => "105",
+    :_light_purple_   => "105",
+    :_light_cyan_     => "106",
+  }
+
+  PARSE_REGEX  = /\[(#{ STYLES.keys.join('|') })\]/ix
+  INDENT_REGEX = /\[indent\]/ix
+
+  def initialize
+    @indent = 1
+  end
+
+  def display(string = '')
+    print(parse("[indent]#{string}"))
+    STDOUT.flush
+    nil
+  end
+
+  def display_line(string = '')
+    display(string)
+    print("\n")
+    nil
+  end
+
+  def display_lines(lines = [])
+    for line in [*lines]
+      display_line(line)
+    end
+    nil
+  end
+
+  def parse(string)
+    if STDOUT.tty?
+      string.gsub(PARSE_REGEX) { "\e[#{STYLES[$1.to_sym]}m" }.gsub(INDENT_REGEX) { indentation }
+    else
+      string.gsub(PARSE_REGEX, '').gsub(INDENT_REGEX) { indentation }
+    end
+  end
+
+  def indent(&block)
+    @indent += 1
+    yield
+    @indent -= 1
+  end
+
+  def indentation
+    '  ' * @indent
+  end
+
+  def redisplay(string = '')
+    print("\r")
+    display("#{string}")
+    nil
+  end
+
+  %w{display display_line display_lines display_table indent parse redisplay redisplay_progressbar}.each do |method|
+    eval <<-DEF
+      def self.#{method}(*args, &block)
+        Thread.current[:formatador] ||= new
+        Thread.current[:formatador].#{method}(*args, &block)
+      end
+    DEF
+  end
+
+end
+
+if __FILE__ == $0
+
+  Formatador.display_line("[negative]Formatador![/]")
+  Formatador.indent do
+    Formatador.display_lines([
+      'one',
+      'two'
+    ])
+  end
+  Formatador.display_table([], [:foo])
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/progressbar.rb b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/progressbar.rb
new file mode 100644
index 0000000..7c386fc
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/progressbar.rb
@@ -0,0 +1,46 @@
+class Formatador
+
+  def redisplay_progressbar(current, total, options = {})
+    options = { :color => 'white', :width => 50 }.merge!(options)
+    data = progressbar(current, total, options)
+    if current < total
+      redisplay(data)
+    else
+      redisplay("#{data}\n")
+      @progressbar_started_at = nil
+    end
+  end
+
+  private
+
+  def progressbar(current, total, options)
+    color = options[:color]
+    started_at = options[:started_at]
+    width = options[:width]
+
+    output = []
+
+    if options[:label]
+      output << options[:label]
+    end
+
+    padding = ' ' * (total.to_s.size - current.to_s.size)
+    output << "[#{color}]#{padding}#{current}/#{total}[/]"
+
+    percent = current.to_f / total.to_f
+    done = '*' * (percent * width).ceil
+    remaining = ' ' * (width - done.length)
+    output << "[_white_]|[/][#{color}][_#{color}_]#{done}[/]#{remaining}[_white_]|[/]"
+
+    if started_at
+      elapsed = Time.now - started_at
+      minutes = (elapsed / 60).round.to_s
+      seconds = (elapsed % 60).round.to_s
+      output << "#{minutes}:#{'0' if seconds.size < 2}#{seconds}"
+    end
+
+    output << ''
+    output.join('  ')
+  end
+
+end
diff --git a/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/table.rb b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/table.rb
new file mode 100644
index 0000000..b6f600f
--- /dev/null
+++ b/lib/bbcloud/vendor/formatador-0.0.16/lib/formatador/table.rb
@@ -0,0 +1,57 @@
+class Formatador
+
+  def display_table(hashes, keys = nil, &block)
+    headers = keys || []
+    widths = {}
+    if hashes.empty? && keys
+      for key in keys
+        widths[key] = key.to_s.length
+      end
+    else
+      for hash in hashes
+        for key in hash.keys
+          unless keys
+            headers << key
+          end
+          widths[key] = [key.to_s.length, widths[key] || 0, hash[key] && hash[key].to_s.length || 0].max
+        end
+        headers = headers.uniq
+      end
+    end
+
+    if block_given?
+      headers = headers.sort(&block)
+    elsif !keys
+      headers = headers.sort {|x,y| x.to_s <=> y.to_s}
+    end
+
+    split = "+"
+    if headers.empty?
+      split << '--+'
+    else
+      for header in headers
+        split << ('-' * (widths[header] + 2)) << '+'
+      end
+    end
+
+    display_line(split)
+    columns = []
+    for header in headers
+      columns << "[bold]#{header}[/]#{' ' * (widths[header] - header.to_s.length)}"
+    end
+    display_line("| #{columns.join(' | ')} |")
+    display_line(split)
+
+    for hash in hashes
+      columns = []
+      for header in headers
+        datum = hash[header] || ''
+        columns << "#{datum}#{' ' * (widths[header] - datum.to_s.length)}"
+      end
+      display_line("| #{columns.join(' | ')} |")
+      display_line(split)
+    end
+    nil
+  end
+
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/gli-1.2.5/.require_paths b/lib/bbcloud/vendor/gli-1.2.5/.require_paths
new file mode 100644
index 0000000..3f37be2
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/.require_paths
@@ -0,0 +1,3 @@
+lib
+lib
+bin
diff --git a/lib/bbcloud/vendor/gli-1.2.5/README.rdoc b/lib/bbcloud/vendor/gli-1.2.5/README.rdoc
new file mode 100644
index 0000000..91dc8f3
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/README.rdoc
@@ -0,0 +1,51 @@
+= Git-Like Interface Command Line Parser
+
+Author::  Dave Copeland (mailto:davetron5000 at g mail dot com)
+Copyright:: Copyright (c) 2010 by Dave Copeland
+License:: Distributes under the Apache License, see LICENSE.txt in the source distro
+
+This is a DSL you can use to create a command line interface like git, gem or svn, in that the first argument is a command, and there are global and command specific flags.
+
+* {Source on Github}[http://github.com/davetron5000/gli]
+* RDoc[http://davetron5000.github.com/gli]
+
+== Use
+
+Install if you need to:
+
+    gem install gli
+
+The simplest way to get started is to create a scaffold project
+
+    gli init my_proj command_name other_command_name
+
+This will create a basic scaffold project in <tt>./my_proj</tt> with:
+
+* executable in <tt>./my_proj/bin/my_proj</tt>.  This file demonstrates most of what you need to describe your command line interface.
+* an empty test in <tt>./my_proj/test/tc_nothing.rb</tt> that can bootstrap your tests
+* a gemspec shell
+* a README shell
+* Rakefile that can generate RDoc, package your Gem and run tests
+* A <tt>Gemfile</tt> suitable for use with Bundler to manage development-time dependencies
+
+== Supported Platforms
+
+Known to work on
+
+* 1.8.7
+* 1.9.2
+
+Though likely works on various other versions.
+
+== Documentation
+
+Extensive documentation is {available at the wiki}[https://github.com/davetron5000/gli/wiki]
+
+== Links
+
+* [http://davetron5000.github.com/gli] - RubyDoc
+* [http://www.github.com/davetron5000/gli] - Source on GitHub
+* [http://www.github.com/davetron5000/gli/wiki] - Documentation Wiki
+* [http://www.github.com/davetron5000/gli/wiki/Changelog] - Changelog
+
+:include:gli.rdoc
diff --git a/lib/bbcloud/vendor/gli-1.2.5/bin/gli b/lib/bbcloud/vendor/gli-1.2.5/bin/gli
new file mode 100755
index 0000000..fb9260f
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/bin/gli
@@ -0,0 +1,70 @@
+#!/usr/bin/ruby
+# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
+# have this method, so we add it so we get resolved symlinks
+# and compatibility
+unless File.respond_to? :realpath
+  class File
+    def self.realpath path
+      return realpath(File.readlink(path)) if symlink?(path)
+      path
+    end
+  end
+end
+
+$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + '/../lib') 
+
+require 'gli'
+require 'support/scaffold'
+require 'gli_version'
+
+include GLI
+
+version GLI::VERSION
+desc 'Be verbose'
+switch :v
+
+desc 'Dry run; don''t change the disk'
+switch :n
+
+desc 'Root dir of project'
+long_desc 'This is the directory where the project''s directory will be made, so if you specify a project name ''foo'' and the root dir of ''.'', the directory ''./foo'' will be created'
+default_value '.'
+flag [:r,:root]
+
+desc 'Create a new GLI-based project'
+long_desc <<EOS
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+EOS
+arg_name 'project_name [command[ command]*]'
+command [:init,:scaffold] do |c|
+
+  c.desc 'Create an ext dir'
+  c.switch [:e,:ext]
+
+  c.desc 'Do not create a test dir'
+  c.switch [:notest]
+
+  c.desc 'Overwrite/ignore existing files and directories'
+  c.switch [:force]
+
+  c.action do |g,o,args|
+    if args.length < 1
+      raise 'You must specify the name of your project'
+    end
+    Scaffold.create_scaffold(g[:r],!o[:notest],o[:e],args[0],args[1..-1],o[:force],g[:n])
+  end
+end
+
+pre do |global,command,options,args|
+  puts "Executing #{command.name}" if global[:v]
+  true
+end
+
+post do |global,command,options,args|
+  puts "Executed #{command.name}" if global[:v]
+end
+
+run(ARGV)
diff --git a/lib/bbcloud/vendor/gli-1.2.5/gli.rdoc b/lib/bbcloud/vendor/gli-1.2.5/gli.rdoc
new file mode 100644
index 0000000..6f5c252
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/gli.rdoc
@@ -0,0 +1,51 @@
+= <tt>gli</tt>
+
+    gli [global options] command_name [command-specific options] [--] arguments...
+
+* Use the command +help+ to get a summary of commands
+* Use the command <tt>help command_name</tt> to get a help for +command_name+
+* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them
+
+== Global Options
+These options are available for any command and are specified before the name of the command
+
+[<tt>-n</tt>] Dry run; dont change the disk
+[<tt>-r, --root=arg</tt>] Root dir of project <i>( default: <tt>.</tt>)</i>
+
+                          This is the directory where the projects directory will be made, so if you specify a project name foo and the root dir of ., the directory ./foo will be created
+
+[<tt>-v</tt>] Be verbose
+[<tt>--version</tt>] Show version
+== Commands
+[<tt>help</tt>] Shows list of commands or help for one command
+[<tt>init</tt>] Create a new GLI-based project
+
+=== <tt>help [command]</tt>
+
+Shows list of commands or help for one command
+
+Gets help for the application or its commands.  Can also list the commands in a way helpful to creating a bash-style completion function
+
+==== Options
+These options are specified *after* the command.
+
+[<tt>-c, --completion</tt>] List all commands one line at a time, for use with shell completion ([command] argument is partial command to match)
+=== <tt>init project_name [command[ command]*]</tt>
+
+Create a new GLI-based project
+
+*Aliases*
+* <tt><b>scaffold</b></tt>
+
+This will create a scaffold command line project that uses GLI
+for command line processing.  Specifically, this will create
+an executable ready to go, as well as a lib and test directory, all
+inside the directory named for your project
+
+
+==== Options
+These options are specified *after* the command.
+
+[<tt>-e, --ext</tt>] Create an ext dir
+[<tt>--force</tt>] Overwrite/ignore existing files and directories
+[<tt>--notest</tt>] Do not create a test dir
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli.rb
new file mode 100644
index 0000000..b60e355
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli.rb
@@ -0,0 +1,423 @@
+require 'gli/command_line_token.rb'
+require 'gli/command.rb'
+require 'gli/switch.rb'
+require 'gli/flag.rb'
+require 'gli/options.rb'
+require 'gli/exceptions.rb'
+require 'gli_version.rb'
+require 'support/help.rb'
+require 'support/rdoc.rb'
+require 'support/initconfig.rb'
+require 'etc'
+
+# A means to define and parse a command line interface that works as
+# Git's does, in that you specify global options, a command name, command
+# specific options, and then command arguments.
+module GLI
+  extend self
+
+  @@program_name = $0.split(/\//)[-1]
+  @@post_block = nil
+  @@pre_block = nil
+  @@error_block = nil
+  @@config_file = nil
+  @@use_openstruct = false
+  @@version = nil
+
+  # Reset the GLI module internal data structures; mostly for testing
+  def reset
+    switches.clear
+    flags.clear
+    commands.clear
+    @@version = nil
+    @@config_file = nil
+    @@use_openstruct = false
+    clear_nexts
+  end
+
+  # describe the next switch, flag, or command.  This should be a
+  # short, one-line description
+  def desc(description); @@next_desc = description; end
+
+  # Provide a longer, more detailed description.  This
+  # will be reformatted and wrapped to fit in 80 columns
+  def long_desc(long_desc); @@next_long_desc = long_desc; end
+
+  # describe the argument name of the next flag
+  def arg_name(name); @@next_arg_name = name; end
+
+  # set the default value of the next flag
+  def default_value(val); @@next_default_value = val; end
+
+  # Create a flag, which is a switch that takes an argument
+  def flag(*names)
+    names = [names].flatten
+    verify_unused(names,flags,switches,"in global options")
+    flag = Flag.new(names,@@next_desc,@@next_arg_name,@@next_default_value,@@next_long_desc)
+    flags[flag.name] = flag
+    clear_nexts
+  end
+
+  # Create a switch
+  def switch(*names)
+    names = [names].flatten
+    verify_unused(names,flags,switches,"in global options")
+    switch = Switch.new(names,@@next_desc,@@next_long_desc)
+    switches[switch.name] = switch
+    clear_nexts
+  end
+
+  # Sets the config file.  If not an absolute path
+  # sets the path to the user's home directory
+  def config_file(filename)
+    if filename =~ /^\//
+      @@config_file = filename
+    else
+      @@config_file = Etc.getpwuid.dir + '/' + filename
+    end
+    commands[:initconfig] = InitConfig.new(@@config_file)
+    @@config_file
+  end
+
+  # Define a command.
+  def command(*names)
+    command = Command.new([names].flatten,@@next_desc,@@next_arg_name,@@next_long_desc)
+    commands[command.name] = command
+    yield command
+    clear_nexts
+  end
+
+  # Define a block to run after command line arguments are parsed
+  # but before any command is run.  If this block raises an exception
+  # the command specified will not be executed.
+  # The block will receive the global-options,command,options, and arguments
+  # If this block evaluates to true, the program will proceed; otherwise
+  # the program will end immediately
+  def pre(&a_proc)
+    @@pre_block = a_proc
+  end
+
+  # Define a block to run after command hase been executed, only
+  # if there was not an error.
+  # The block will receive the global-options,command,options, and arguments
+  def post(&a_proc)
+    @@post_block = a_proc
+  end
+
+  # Define a block to run if an error occurs.
+  # The block will receive any Exception that was caught.
+  # It should return false to avoid the built-in error handling (which basically just
+  # prints out a message)
+  def on_error(&a_proc)
+    @@error_block = a_proc
+  end
+
+  # Indicate the version of your application
+  def version(version)
+    @@version = version
+  end
+
+  # Call this with "true" will cause the <tt>global_options</tt> and
+  # <tt>options</tt> passed to your code to be wrapped in
+  # GLI::Option, which is a subclass of OpenStruct that adds
+  # <tt>[]</tt> and <tt>[]=</tt> methods.
+  def use_openstruct(use_openstruct)
+    @@use_openstruct = use_openstruct
+  end
+
+  # Runs whatever command is needed based on the arguments. 
+  #
+  # args - the command line ARGV array
+  #
+  # Returns a number that would be a reasonable exit code
+  def run(args)
+    rdoc = RDocCommand.new
+    commands[:rdoc] = rdoc if !commands[:rdoc]
+    commands[:help] = DefaultHelpCommand.new(@@version,rdoc) if !commands[:help]
+    begin
+      config = parse_config
+      global_options,command,options,arguments = parse_options(args,config)
+      copy_options_to_aliased_versions(global_options,command,options)
+      proceed = true
+      global_options = convert_to_option?(global_options)
+      options = convert_to_option?(options)
+      proceed = @@pre_block.call(global_options,command,options,arguments) if @@pre_block 
+      if proceed
+        command = commands[:help] if !command
+        command.execute(global_options,options,arguments)
+        @@post_block.call(global_options,command,options,arguments) if @@post_block 
+      end
+      0
+    rescue Exception => ex
+      regular_error_handling = true
+      regular_error_handling = @@error_block.call(ex) if @@error_block
+
+      if regular_error_handling
+        $stderr.puts "error: #{ex.message}"
+      end
+
+      raise ex if ENV['GLI_DEBUG'] == 'true'
+
+      case ex
+      when BadCommandLine then -1
+      when CustomExit then ex.exit_code
+      else 
+        -2
+      end
+    end
+  end
+
+  # Simpler means of exiting with a custom exit code.  This will 
+  # raise a CustomExit with the given message and exit code, which will ultimatley
+  # cause your application to exit with the given exit_code as its exit status
+  def exit_now!(message,exit_code)
+    raise CustomExit.new(message,exit_code)
+  end
+
+  # Possibly returns a copy of the passed-in Hash as an instance of GLI::Option.
+  # By default, it will *not*, however by putting <tt>use_openstruct true</tt>
+  # in your CLI definition, it will
+  def convert_to_option?(options)
+    @@use_openstruct ? Options.new(options) : options
+  end
+
+  # Copies all options in both global_options and options to keys for the aliases of those flags.
+  # For example, if a flag works with either -f or --flag, this will copy the value from [:f] to [:flag]
+  # to allow the user to access the options by any alias
+  def copy_options_to_aliased_versions(global_options,command,options)
+    copy_options_to_aliases(global_options,self)
+    copy_options_to_aliases(options,command)
+  end
+
+  # For each option in options, copies its value to keys for the aliases of the flags or
+  # switches in gli_like
+  #
+  # options - Hash of options parsed from command line; this is an I/O param
+  # gli_like - Object resonding to flags and switches in the same way that GLI or a Command instance do
+  def copy_options_to_aliases(options,gli_like)
+    new_options = {}
+    options.each do |key,value|
+      if gli_like.flags[key] && gli_like.flags[key].aliases
+        gli_like.flags[key].aliases.each do |alias_name|
+          new_options[alias_name] = value
+        end
+      elsif gli_like.switches[key] && gli_like.switches[key].aliases
+        gli_like.switches[key].aliases.each do |alias_name|
+          new_options[alias_name] = value
+        end
+      end
+    end
+    options.merge!(new_options)
+  end
+
+  def parse_config
+    return nil if @@config_file.nil?
+    require 'yaml'
+    if File.exist?(@@config_file)
+      File.open(@@config_file) { |f| YAML::load(f) }
+    else
+      {}
+    end
+  end
+
+  def program_name(override=nil)
+    if override
+      @@program_name = override
+    end
+    @@program_name
+  end
+
+  # Returns an array of four values:
+  #  * global options (as a Hash)
+  #  * Command 
+  #  * command options (as a Hash)
+  #  * arguments (as an Array)
+  def parse_options(args,config=nil)
+    command_configs = {}
+    if config.nil?
+      config = {}
+    else
+      command_configs = config.delete(GLI::InitConfig::COMMANDS_KEY) if !config.nil?
+    end
+    global_options,command,options,arguments = parse_options_helper(args.clone,config,nil,Hash.new,Array.new,command_configs)
+    flags.each { |name,flag| global_options[name] = flag.default_value if !global_options[name] }
+    command.flags.each { |name,flag| options[name] = flag.default_value if !options[name] }
+    return [global_options,command,options,arguments]
+  end
+
+  # Finds the index of the first non-flag
+  # argument or -1 if there wasn't one.
+  def find_non_flag_index(args)
+    args.each_index do |i|
+      return i if args[i] =~ /^[^\-]/;
+      return i-1 if args[i] =~ /^\-\-$/;
+    end
+    -1;
+  end
+
+  alias :d :desc
+  alias :f :flag
+  alias :s :switch
+  alias :c :command
+
+  def clear_nexts
+    @@next_desc = nil
+    @@next_arg_name = nil
+    @@next_default_value = nil
+    @@next_long_desc = nil
+  end
+
+  clear_nexts
+
+  def flags; @@flags ||= {}; end
+  def switches; @@switches ||= {}; end
+  def commands; @@commands ||= {}; end
+
+  # Recursive helper for parsing command line options
+  # [args] the arguments that have yet to be processed
+  # [global_options] the global options hash
+  # [command] the Command that has been identified (or nil if not identified yet)
+  # [command_options] options for Command
+  # [arguments] the arguments for Command
+  # [command_configs] the configuration file for all commands, used as defaults
+  #
+  # This works by finding the first non-switch/flag argument, and taking that sublist and trying to pick out
+  # flags and switches.  After this is done, one of the following is true:
+  #   * the sublist is empty - in this case, go again, as there might be more flags to parse
+  #   * the sublist has a flag left in it - unknown flag; we bail
+  #   * the sublist has a non-flag left in it - this is the command (or the start of the arguments list)
+  #
+  # This sort of does the same thing in two phases; in the first phase, the command hasn't been identified, so
+  # we are looking for global switches and flags, ending when we get the command.
+  #
+  # Once the command has been found, we start looking for command-specific flags and switches.
+  # When those have been found, we know the rest of the argument list is arguments for the command
+  def parse_options_helper(args,global_options,command,command_options,arguments,command_configs)
+    non_flag_i = find_non_flag_index(args)
+    all_flags = false
+    if non_flag_i == 0
+      # no flags
+      if !command
+        command_name = args.shift
+        command = find_command(command_name)
+        raise BadCommandLine.new("Unknown command '#{command_name}'") if !command
+        return parse_options_helper(args,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      else
+        return global_options,command,command_options,arguments + args
+      end
+    elsif non_flag_i == -1
+      all_flags = true
+    end
+
+    try_me = args[0..non_flag_i]
+    rest = args[(non_flag_i+1)..args.length]
+    if all_flags
+      try_me = args 
+      rest = []
+    end
+
+    # Suck up whatever options we can
+    switch_hash = switches
+    flag_hash = flags
+    options = global_options
+    if command
+      switch_hash = command.switches
+      flag_hash = command.flags
+      options = command_options
+    end
+
+    switch_hash.each do |name,switch|
+      value = switch.get_value!(try_me)
+      options[name] = value if !options[name]
+    end
+
+    flag_hash.each do |name,flag|
+      value = flag.get_value!(try_me)
+      # So, there's a case where the first time we request the value for a flag,
+      # we get the default and not the user-provided value.  The next time we request
+      # it, we want to override it with the real value.
+      # HOWEVER, sometimes this happens in reverse, so we want to err on taking the
+      # user-provided, non-default value where possible.
+      if value 
+        if options[name]
+          options[name] = value if options[name] == flag.default_value
+        else
+          options[name] = value
+        end
+      end
+    end
+
+    if try_me.empty?
+      return [global_options,command,command_options,arguments] if rest.empty?
+      # If we have no more options we've parsed them all
+      # and rest may have more
+      return parse_options_helper(rest,global_options,command,command_options,arguments,command_configs)
+    else
+      if command
+        check = rest
+        check = rest + try_me if all_flags 
+        check.each() do |arg| 
+          if arg =~ /^\-\-$/
+            try_me.delete arg
+            break 
+          end
+          raise BadCommandLine.new("Unknown argument #{arg}") if arg =~ /^\-/ 
+        end
+        return [global_options,command,command_options,try_me + rest]
+      else
+        # Now we have our command name
+        command_name = try_me.shift
+        raise BadCommandLine.new("Unknown argument #{command_name}") if command_name =~ /^\-/
+
+        command = find_command(command_name)
+        raise BadCommandLine.new("Unknown command '#{command_name}'") if !command
+
+        return parse_options_helper(rest,
+                                    global_options,
+                                    command,
+                                    default_command_options(command,command_configs),
+                                    arguments,
+                                    command_configs)
+      end
+    end
+
+  end
+
+  def default_command_options(command,command_configs)
+    options = (command_configs && command_configs[command.name.to_sym]) || {}
+  end
+
+  def find_command(name)
+    sym = name.to_sym
+    return commands[name.to_sym] if commands[sym]
+    commands.keys.each do |command_name|
+      command = commands[command_name]
+      return command if (command.aliases && command.aliases.include?(sym))
+    end
+    nil
+  end
+
+  # Checks that the names passed in have not been used in another flag or option
+  def verify_unused(names,flags,switches,context)
+    names.each do |name|
+      verify_unused_in_option(name,flags,"flag",context)
+      verify_unused_in_option(name,switches,"switch",context)
+    end
+  end
+
+  private
+
+  def verify_unused_in_option(name,option_like,type,context)
+    raise ArgumentError.new("#{name} has already been specified as a #{type} #{context}") if option_like[name]
+    option_like.each do |one_option_name,one_option|
+      if one_option.aliases
+        raise ArgumentError.new("#{name} has already been specified as an alias of #{type} #{one_option_name} #{context}") if one_option.aliases.include? name
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command.rb
new file mode 100644
index 0000000..96ff7f8
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command.rb
@@ -0,0 +1,81 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # A command to be run, in context of global flags and switches
+  class Command < CommandLineToken
+
+    # Create a new command
+    #
+    # [names] the name or names of this command (symbol or Array of symbols)
+    # [description] description of this command
+    # [arguments_name] description of the arguments, or nil if this command doesn't take arguments
+    # [long_desc] a longer description of the command, possibly with multiple lines and text formatting
+    #
+    def initialize(names,description,arguments_name=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @arguments_description = arguments_name || ''
+      clear_nexts
+    end
+
+    def arguments_description; @arguments_description; end
+
+    def names
+      all_forms
+    end
+
+    def usage
+      usage = name.to_s
+      usage += ' [options]' if !flags.empty? || !switches.empty?
+      usage += ' ' + @arguments_description if @arguments_description
+      usage
+    end
+
+    def flags; @flags ||= {}; end
+    def switches; @switches ||= {}; end
+
+    # describe the next switch or flag
+    def desc(description); @next_desc = description; end
+    # long description of this flag/switch
+    def long_desc(long_desc); @next_long_desc = long_desc; end
+    # describe the argument name of the next flag
+    def arg_name(name); @next_arg_name = name; end
+    # set the default value of the next flag
+    def default_value(val); @next_default_value = val; end
+
+    def flag(*names)
+      names = [names].flatten
+      GLI.verify_unused(names,flags,switches,"in command #{name}")
+      flag = Flag.new(names,@next_desc,@next_arg_name,@next_default_value,@next_long_desc)
+      flags[flag.name] = flag
+      clear_nexts
+    end
+
+    # Create a switch
+    def switch(*names)
+      names = [names].flatten
+      GLI.verify_unused(names,flags,switches,"in command #{name}")
+      switch = Switch.new(names,@next_desc,@next_long_desc)
+      switches[switch.name] = switch
+      clear_nexts
+    end
+
+    def action(&block)
+      @action = block
+    end
+
+    def self.name_as_string(name)
+      name.to_s
+    end
+
+    def clear_nexts
+      @next_desc = nil
+      @next_arg_name = nil
+      @next_default_value = nil
+      @next_long_desc = nil
+    end
+
+    def execute(global_options,options,arguments)
+      @action.call(global_options,options,arguments)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command_line_token.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command_line_token.rb
new file mode 100644
index 0000000..cb32f3d
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/command_line_token.rb
@@ -0,0 +1,57 @@
+module GLI
+  # Logical element of a command line, mostly so that subclasses can have similar
+  # initialization and interface
+  class CommandLineToken
+    attr_reader :name
+    attr_reader :aliases
+    attr_reader :description
+    attr_reader :long_description
+
+    def initialize(names,description,long_description=nil)
+      @description = description
+      @long_description = long_description
+      @name,@aliases,@names = parse_names(names)
+    end
+
+    def usage
+      all_forms
+    end
+
+    def <=>(other)
+      self.name.to_s <=> other.name.to_s
+    end
+
+    private
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      forms.join(joiner)
+    end
+
+
+    # Handles dealing with the "names" param, parsing
+    # it into the primary name and aliases list
+    def parse_names(names)
+      # Allow strings; convert to symbols
+      names = [names].flatten.map { |name| name.to_sym } 
+      names_hash = Hash.new
+      names.each do |n| 
+        raise ArgumentError.new("#{n} has spaces; they are not allowed") if n.to_s =~ /\s/
+        names_hash[self.class.name_as_string(n)] = true
+      end
+      name = names.shift
+      aliases = names.length > 0 ? names : nil
+      [name,aliases,names_hash]
+    end
+
+    def all_forms_a
+      forms = [self.class.name_as_string(name)]
+      if aliases
+        forms |= aliases.collect { |a| self.class.name_as_string(a) }.sort { |x,y| y.length <=> x.length }
+      end
+      forms
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/exceptions.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/exceptions.rb
new file mode 100644
index 0000000..0565bf1
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/exceptions.rb
@@ -0,0 +1,28 @@
+module GLI
+  # Indicates that the command line invocation was bad
+  class BadCommandLine < Exception
+    def initialize(message)
+      super(message)
+    end
+  end
+
+  # Raise this if you want to use an exit status that isn't the default
+  # provided by GLI.
+  #
+  # Example:
+  #
+  #     raise CustomExit.new("Not connected to DB",-5) unless connected?
+  #     raise CustomExit.new("Bad SQL",-6) unless valid_sql?(args[0])
+  #
+  class CustomExit < Exception
+    attr_reader :exit_code
+    # Create a custom exit exception
+    #
+    # message - String containing error message to show the user
+    # exit_code - the exit code to use, overridding GLI's default
+    def initialize(message,exit_code)
+      super(message)
+      @exit_code = exit_code
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/flag.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/flag.rb
new file mode 100644
index 0000000..c773466
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/flag.rb
@@ -0,0 +1,66 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a flag, which is to say a switch that takes an argument
+  class Flag < Switch
+
+    attr_reader :default_value
+
+    def initialize(names,description,argument_name=nil,default=nil,long_desc=nil)
+      super(names,description,long_desc)
+      @argument_name = argument_name || "arg"
+      @default_value = default
+    end
+
+    def get_value!(args)
+      args.each_index() do |index|
+        arg = args[index]
+        present,matched,value = find_me(arg)
+        if present
+          args.delete_at index
+          if !value || value == ''
+            if args[index]
+              value = args[index]
+              args.delete_at index
+              return value
+            else
+              raise BadCommandLine.new("#{matched} requires an argument")
+            end
+          else
+            return value
+          end
+        end
+      end
+      return @default_value
+    end
+
+    def find_me(arg)
+      if @names[arg]
+        return [true,arg,nil] if arg.length == 2
+        # This means we matched the long-form, but there's no argument
+        raise BadCommandLine.new("#{arg} requires an argument via #{arg}=argument")
+      end
+      @names.keys.each() do |name|
+        match_string = "^#{name}=(.*)$"
+        match_data = arg.match(match_string)
+        return [true,name,$1] if match_data;
+      end
+      [false,nil,nil]
+    end
+
+    # Returns a string of all possible forms
+    # of this flag.  Mostly intended for printing
+    # to the user.
+    def all_forms(joiner=', ')
+      forms = all_forms_a
+      string = forms.join(joiner)
+      if forms[-1] =~ /^\-\-/
+        string += '='
+      else
+        string += ' '
+      end
+      string += @argument_name
+      return string
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/options.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/options.rb
new file mode 100644
index 0000000..ae43c9b
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/options.rb
@@ -0,0 +1,16 @@
+require 'ostruct'
+
+module GLI
+  class Options < OpenStruct
+
+    def[](k)
+      @table[k.to_sym]
+    end
+
+    def[]=(k, v)
+      @table[k.to_sym] = v
+    end
+
+  end
+end
+
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/switch.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/switch.rb
new file mode 100644
index 0000000..66ebe20
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/switch.rb
@@ -0,0 +1,56 @@
+require 'gli/command_line_token.rb'
+
+module GLI
+  # Defines a command line switch
+  class Switch < CommandLineToken
+
+    def initialize(names,description,long_desc=nil)
+      super(names,description,long_desc)
+    end
+
+    # Given the argument list, scans it looking for this switch
+    # returning true if it's in the argumennt list (and removing it from the argument list)
+    def get_value!(args)
+      idx = -1
+      args.each_index do |i|
+        result = find_me(args[i])
+        if result[0]
+          if result[1]
+            args[i] = result[1]
+          else
+            args.delete_at i
+          end
+          return result[0]
+        end
+      end
+      false
+    end
+
+    # Finds the switch in the given arg, returning the arg to keep.
+    # Returns an array of size 2:
+    # [0] true or false if the arg was found
+    # [1] the remaining arg to keep in the command line or nil to remove it
+    def find_me(arg)
+      if @names[arg]
+        return [true,nil]
+      end
+      @names.keys.each() do |name|
+        if name =~ /^-(\w)$/
+          match_string = "^\\-(\\w*)#{$1}(\\w*)$"
+          match_data = arg.match(match_string)
+          if match_data
+            # Note that if [1] and [2] were both empty 
+            # we'd have returned above
+            return [true, "-" + match_data[1] + match_data[2]]
+          end
+        end
+      end
+      [false]
+    end
+
+    def self.name_as_string(name)
+      string = name.to_s
+      string.length == 1 ? "-#{string}" : "--#{string}"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli/terminal.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/terminal.rb
new file mode 100644
index 0000000..06caca0
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli/terminal.rb
@@ -0,0 +1,72 @@
+module GLI
+  # Class to encapsulate stuff about the terminal.  This is a singleton, mostly to facilitate testing.
+  #
+  # Example:
+  #
+  #     Terminal.instance.size[0] # => columns in the terminal
+  #     Terminal.default_size = [128,24] # => change default when we can't figure it out
+  #     raise "no ls?!?!?" unless Terminal.instance.command_exists?("ls")
+  #
+  class Terminal
+
+    @@default_size = [80,24]
+
+    # Get the default size of the terminal when we can't figure it out
+    # 
+    # Returns an array of int [cols,rows]
+    def self.default_size
+      @@default_size
+    end
+
+    # Set the default size of the terminal to use when we can't figure it out
+    #
+    # size - array of two int [cols,rows]
+    def self.default_size=(size)
+      @@default_size = size
+    end
+
+    # Provide access to the shared instance
+    def self.instance; @@instance ||= Terminal.new; end
+
+    # Call this to cause methods to throw exceptions rather than return a sane default.  You
+    # probably don't want to call this unless you are writing tests
+    def make_unsafe!;
+      @unsafe = true
+    end
+
+    # Returns true if the given command exists on this system
+    #
+    # command - The command to check for
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Ripped from hirb https://github.com/cldwalker/hirb/blob/master/lib/hirb/util.rb
+    # Returns an array of size two ints representing the terminal width and height
+    def size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (jruby? || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [run_command('tput cols').to_i, run_command('tput lines').to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        run_command('stty size').scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        Terminal.default_size
+      end
+    rescue Exception => ex
+      raise ex if @unsafe
+      Terminal.default_size
+    end
+
+    private
+
+    # Runs a command using backticks.  Extracted to allow for testing
+    def run_command(command)
+      `#{command}`
+    end
+
+    # True if we are JRuby; exposed to allow for testing
+    def jruby?; RUBY_PLATFORM =~ /java/; end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/gli_version.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/gli_version.rb
new file mode 100644
index 0000000..fdd3c10
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/gli_version.rb
@@ -0,0 +1,3 @@
+module GLI
+  VERSION = '1.2.5'
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/support/help.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/support/help.rb
new file mode 100644
index 0000000..f5ff359
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/support/help.rb
@@ -0,0 +1,156 @@
+require 'gli'
+require 'gli/command'
+require 'gli/terminal'
+
+module GLI
+  class DefaultHelpCommand < Command
+    @@output = $stdout
+    # Exposed for testing :nodoc:
+    def self.output_device=(o); @@output = o; end
+
+    def initialize(version,*omit_from_list)
+      @omit_from_list = omit_from_list
+      @version = version
+      super(:help,
+            'Shows list of commands or help for one command',
+            '[command]',
+            'Gets help for the application or its commands.  Can also list the commands in a way helpful to creating a bash-style completion function')
+      self.desc 'List all commands one line at a time, for use with shell completion ([command] argument is partial command to match)'
+      self.switch [:c,:completion]
+    end
+
+    def execute(global_options,options,arguments)
+      if options[:c]
+        names = commands_to_show.reduce([]) do |memo,obj|
+          memo << obj[0]
+          memo << obj[1].aliases
+          memo = memo.flatten
+        end
+        names.map! { |name| name.to_s } 
+        if arguments && arguments.size > 0
+          names = names.select { |name| name =~ /^#{arguments[0]}/ }
+        end
+        names.sort.each do |command|
+          next if command.empty?
+          @@output.puts command
+        end
+      else
+        if arguments.empty?
+          list_global_flags
+          list_commands
+        else
+          list_one_command_help(arguments[0])
+        end
+      end
+    end
+
+    private
+
+    def list_global_flags
+      usage = "usage: #{GLI.program_name} command"
+      all_options = GLI.switches.merge(GLI.flags)
+      if !all_options.empty?
+        usage += ' [options]'
+      end
+      @@output.puts usage
+      @@output.puts
+      if @version
+        @@output.puts "Version: #{@version}"
+        @@output.puts
+      end
+      @@output.puts 'Options:' if !all_options.empty?
+      output_command_tokens_for_help(all_options)
+      @@output.puts if !all_options.empty?
+    end
+
+    def list_commands
+      @@output.puts 'Commands:'
+      output_command_tokens_for_help(commands_to_show,:names)
+    end
+
+    def commands_to_show
+      GLI.commands.reject{ |name,c| @omit_from_list.include?(c) }
+    end
+
+    def list_one_command_help(command_name)
+      command = GLI.find_command(command_name)
+      if command
+        @@output.puts command.usage
+        description = wrap(command.description,4)
+        @@output.puts "    #{description}"
+        if command.long_description
+          @@output.puts
+          @@output.puts "    #{wrap(command.long_description,4)}"
+        end
+        all_options = command.switches.merge(command.flags)
+        if !all_options.empty?
+          @@output.puts
+          @@output.puts "Options:"
+          output_command_tokens_for_help(all_options)
+        end
+      else
+        @@output.puts "No such command #{command_name}"
+      end
+    end
+
+    def output_command_tokens_for_help(tokens,usage_name=:usage)
+      max = 0
+      tokens.values.each do |token| 
+        len = token.send(usage_name).length
+        if len > max 
+          max = len
+        end
+      end
+      names = tokens.keys.sort { |x,y| x.to_s <=> y.to_s }
+      names.each do |name|
+        token = tokens[name]
+        description = token.description || ''
+        if token.kind_of? Flag 
+          description += " (default: #{token.default_value})" if token.default_value
+        end
+        description = wrap(description,max+7)
+        string = sprintf "    %-#{max}s - %s",token.send(usage_name),description
+        @@output.puts string
+      end
+    end
+  end
+
+  private
+
+  # Wraps the line at the given column length, using the given line padding.
+  # Assumes that the first line doesn't need the padding, as its filled
+  # up with other stuff
+  def wrap(line,pad_length=0,line_length=nil)
+    if line_length.nil?
+      line_length = Terminal.instance.size[0]
+    end
+    line_padding = sprintf("%#{pad_length}s",'')
+    words = line.split(/\s+/)
+    return line if !words || words.empty?
+    wrapped = ''
+    while wrapped.length + line_padding.length < line_length
+      wrapped += ' ' if wrapped.length > 0
+      word = words.shift
+      if (wrapped.length + line_padding.length + word.length > line_length)
+        words.unshift word
+        break;
+      end
+      wrapped += word
+      return wrapped if words.empty?
+    end
+    wrapped += "\n"
+    this_line = line_padding
+    words.each do |word|
+      if this_line.length + word.length > line_length
+        wrapped += this_line
+        wrapped += "\n"
+        this_line = line_padding + word
+      else
+        this_line += ' ' if this_line.length > line_padding.length
+        this_line += word
+      end
+    end
+    wrapped.chomp!
+    wrapped + "\n" + this_line
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/support/initconfig.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/support/initconfig.rb
new file mode 100644
index 0000000..2c6a190
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/support/initconfig.rb
@@ -0,0 +1,35 @@
+require 'gli'
+require 'gli/command'
+require 'yaml'
+
+module GLI
+  class InitConfig < Command
+    COMMANDS_KEY = 'commands'
+
+    def initialize(config_file_name)
+      @filename = config_file_name
+      super(:initconfig,"Initialize the config file using current global options",nil,'Initializes a configuration file where you can set default options for command line flags, both globally and on a per-command basis.  These defaults override the built-in defaults and allow you to omit commonly-used command line flags when invoking this program')
+
+      self.desc 'force overwrite of existing config file'
+      self.switch :force
+    end
+
+    def execute(global_options,options,arguments)
+      if options[:force] || !File.exist?(@filename)
+        config = global_options
+        config[COMMANDS_KEY] = {}
+        GLI.commands.each do |name,command|
+          if (command != self) && (name != :rdoc) && (name != :help)
+            config[COMMANDS_KEY][name.to_sym] = {} if command != self
+          end
+        end
+        File.open(@filename,'w') do |file|
+          YAML.dump(config,file)
+        end
+      else
+        puts "Not overwriting existing config file #{@filename}"
+        puts 'Use --force to override'
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/support/rdoc.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/support/rdoc.rb
new file mode 100644
index 0000000..062c19e
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/support/rdoc.rb
@@ -0,0 +1,78 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class RDocCommand < Command
+
+    def initialize
+      super(:rdoc,'Generates RDoc for your command line interface')
+    end
+
+    def execute(g,o,a)
+      File.open("#{GLI.program_name}.rdoc",'w') do |file|
+        file << "= <tt>#{GLI.program_name}</tt>\n\n"
+        file << "    "
+        file << GLI.program_name
+        file << " "
+        global_options = GLI.switches.merge(GLI.flags)
+        if (global_options && global_options.length > 0)
+          file << "[global options] "
+        end
+        file << "command_name"
+        file << " [command-specific options]"
+        file << " [--] arguments...\n\n"
+        file << "* Use the command +help+ to get a summary of commands\n"
+        file << "* Use the command <tt>help command_name</tt> to get a help for +command_name+\n"
+        file << "* Use <tt>--</tt> to stop command line argument processing; useful if your arguments have dashes in them\n"
+        file << "\n"
+        if (global_options && global_options.length > 0)
+          file << "== Global Options\n"
+          file << "These options are available for any command and are specified before the name of the command\n\n"
+          output_flags(file,global_options)
+        end
+        file << "== Commands\n"
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "[<tt>#{command.name}</tt>] #{command.description}\n"
+        end
+        file << "\n"
+
+        GLI.commands.values.sort.each do |command|
+          next if command == self
+          file << "=== <tt>#{command.name} #{command.arguments_description}</tt>\n\n"
+          file << "#{command.description}\n\n"
+          if command.aliases
+            file << "*Aliases*\n"
+            command.aliases.each do |al|
+              file << "* <tt><b>#{al}</b></tt>\n"
+            end 
+            file << "\n"
+          end
+          all_options = command.switches.merge(command.flags)
+          file << "#{command.long_description}\n\n" if command.long_description
+          if (all_options && all_options.length > 0)
+            file << "==== Options\n"
+            file << "These options are specified *after* the command.\n\n"
+            output_flags(file,all_options)
+          end
+        end
+      end
+    end
+
+    def output_flags(file,flags)
+      flags.values.sort.each do |flag|
+        file << "[<tt>#{flag.usage}</tt>] #{flag.description}"
+        if flag.kind_of? Flag
+          file << " <i>( default: <tt>#{flag.default_value}</tt>)</i>" if flag.default_value
+        end
+        file << "\n"
+        if flag.long_description
+          file << "\n"
+          # 12 is: 4 for tt, 5 for /tt, 2 for the brackets and 1 for spacing
+          (flag.usage.length + 12).times { file << " " }
+          file << "#{flag.long_description}\n\n"
+        end
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/gli-1.2.5/lib/support/scaffold.rb b/lib/bbcloud/vendor/gli-1.2.5/lib/support/scaffold.rb
new file mode 100644
index 0000000..81c8859
--- /dev/null
+++ b/lib/bbcloud/vendor/gli-1.2.5/lib/support/scaffold.rb
@@ -0,0 +1,278 @@
+require 'gli'
+require 'fileutils'
+
+module GLI
+  class Scaffold
+
+    def self.create_scaffold(root_dir,create_test_dir,create_ext_dir,project_name,commands,force=false,dry_run=false)
+      dirs = [File.join(root_dir,project_name,'lib')]
+      dirs << File.join(root_dir,project_name,'bin')
+      dirs << File.join(root_dir,project_name,'test') if create_test_dir
+      dirs << File.join(root_dir,project_name,'ext') if create_ext_dir
+
+      if mkdirs(dirs,force,dry_run)
+        mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+        mk_readme(root_dir,dry_run,project_name)
+        mk_gemspec(root_dir,dry_run,project_name)
+        mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+        mk_version(root_dir,dry_run,project_name)
+      end
+    end
+
+    def self.mk_readme(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/README.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Describe your project here\n\n"
+        file << ":include:#{project_name}.rdoc\n\n"
+      end
+      puts "Created #{root_dir}/#{project_name}/README.rdoc"
+      File.open("#{root_dir}/#{project_name}/#{project_name}.rdoc",'w') do |file|
+        file << "= #{project_name}\n\n"
+        file << "Generate this with\n    #{project_name} rdoc\nAfter you have described your command line interface"
+      end
+      puts "Created #{root_dir}/#{project_name}/#{project_name}.rdoc"
+    end
+
+    def self.mk_gemspec(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/#{project_name}.gemspec",'w') do |file|
+        file.puts <<EOS
+# Ensure we require the local version and not one we might have installed already
+require File.join([File.dirname(__FILE__),'lib','#{project_name}_version.rb'])
+spec = Gem::Specification.new do |s| 
+  s.name = '#{project_name}'
+  s.version = #{project_name_as_module_name(project_name)}::VERSION
+  s.author = 'Your Name Here'
+  s.email = 'your@email.address.com'
+  s.homepage = 'http://your.website.com'
+  s.platform = Gem::Platform::RUBY
+  s.summary = 'A description of your project'
+# Add your other files here if you make them
+  s.files = %w(
+bin/#{project_name}
+  )
+  s.require_paths << 'lib'
+  s.has_rdoc = true
+  s.extra_rdoc_files = ['README.rdoc','#{project_name}.rdoc']
+  s.rdoc_options << '--title' << '#{project_name}' << '--main' << 'README.rdoc' << '-ri'
+  s.bindir = 'bin'
+  s.executables << '#{project_name}'
+end
+EOS
+      end
+      puts "Created #{root_dir}/#{project_name}/#{project_name}.gemspec"
+    end
+
+    def self.project_name_as_module_name(project_name)
+      project_name.split(/_/).map { |part| part[0..0].upcase + part[1..-1] }.join('')
+    end
+
+    def self.mk_version(root_dir,dry_run,project_name)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/lib/#{project_name}_version.rb",'w') do |file|
+        file.puts <<EOS
+module #{project_name_as_module_name(project_name)}
+  VERSION = '0.0.1'
+end
+EOS
+      end
+      puts "Created #{root_dir}/#{project_name}/lib/#{project_name}_version.rb"
+    end
+    def self.mk_rakefile(root_dir,dry_run,project_name,create_test_dir)
+      return if dry_run
+      File.open("#{root_dir}/#{project_name}/Rakefile",'w') do |file|
+        file.puts <<EOS
+require 'rake/clean'
+require 'rubygems'
+require 'rake/gempackagetask'
+require 'rake/rdoctask'
+
+Rake::RDocTask.new do |rd|
+  rd.main = "README.rdoc"
+  rd.rdoc_files.include("README.rdoc","lib/**/*.rb","bin/**/*")
+  rd.title = 'Your application title'
+end
+
+spec = eval(File.read('#{project_name}.gemspec'))
+
+Rake::GemPackageTask.new(spec) do |pkg|
+end
+
+EOS
+        if create_test_dir
+          file.puts <<EOS
+require 'rake/testtask'
+Rake::TestTask.new do |t|
+  t.libs << "test"
+  t.test_files = FileList['test/tc_*.rb']
+end
+
+task :default => :test
+EOS
+          File.open("#{root_dir}/#{project_name}/test/tc_nothing.rb",'w') do |test_file|
+            test_file.puts <<EOS
+require 'test/unit'
+require 'test/unit/ui/console/testrunner'
+
+class TC_testNothing < Test::Unit::TestCase
+
+  def setup
+  end
+
+  def teardown
+  end
+
+  def test_the_truth
+    assert true
+  end
+end
+EOS
+          end
+          puts "Created #{root_dir}/#{project_name}/test/tc_nothing.rb"
+        else
+          file.puts "task :default => :package\n"
+        end
+      end
+      puts "Created #{root_dir}/#{project_name}/Rakefile"
+      File.open("#{root_dir}/#{project_name}/Gemfile",'w') do |bundler_file|
+        bundler_file.puts "source :rubygems"
+        bundler_file.puts "gem: 'rake'"
+        bundler_file.puts "gem: 'rdoc'"
+      end
+      puts "Created #{root_dir}/#{project_name}/Gemfile"
+    end
+
+    def self.mk_binfile(root_dir,create_ext_dir,force,dry_run,project_name,commands)
+      bin_file = File.join(root_dir,project_name,'bin',project_name)
+      if !File.exist?(bin_file) || force
+        if !dry_run
+          File.open(bin_file,'w') do |file|
+            file.chmod(0755)
+            file.puts '#!/usr/bin/ruby'
+            file.puts <<EOS
+# 1.9 adds realpath to resolve symlinks; 1.8 doesn't
+# have this method, so we add it so we get resolved symlinks
+# and compatibility
+unless File.respond_to? :realpath
+  class File
+    def self.realpath path
+      return realpath(File.readlink(path)) if symlink?(path)
+      path
+    end
+  end
+end
+EOS
+            file.puts '$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + \'/../lib\')'
+            file.puts '$: << File.expand_path(File.dirname(File.realpath(__FILE__)) + \'/../ext\')' if create_ext_dir
+            file.puts <<EOS
+require 'rubygems'
+require 'gli'
+require '#{project_name}_version'
+
+include GLI
+
+version #{project_name_as_module_name(project_name)}::VERSION
+
+desc 'Describe some switch here'
+switch [:s,:switch]
+
+desc 'Describe some flag here'
+default_value 'the default'
+arg_name 'The name of the argument'
+flag [:f,:flagname]
+EOS
+            first = true
+            commands.each do |command|
+              file.puts <<EOS
+
+desc 'Describe #{command} here'
+arg_name 'Describe arguments to #{command} here'
+EOS
+              if first
+                file.puts <<EOS
+command :#{command} do |c|
+  c.desc 'Describe a switch to #{command}'
+  c.switch :s
+
+  c.desc 'Describe a flag to #{command}'
+  c.default_value 'default'
+  c.flag :f
+  c.action do |global_options,options,args|
+
+    # Your command logic here
+     
+    # If you have any errors, just raise them
+    # raise "that command made no sense"
+  end
+end
+EOS
+              else
+                file.puts <<EOS
+command :#{command} do |c|
+  c.action do |global_options,options,args|
+  end
+end
+EOS
+              end
+              first = false
+            end
+            file.puts <<EOS
+
+pre do |global,command,options,args|
+  # Pre logic here
+  # Return true to proceed; false to abourt and not call the
+  # chosen command
+  true
+end
+
+post do |global,command,options,args|
+  # Post logic here
+end
+
+on_error do |exception|
+  # Error logic here
+  # return false to skip default error handling
+  true
+end
+
+exit GLI.run(ARGV)
+EOS
+            puts "Created #{bin_file}"
+          end
+        end
+      else
+        puts bin_file + " exists; use --force to override"
+        return false
+      end
+      true
+    end
+
+    def self.mkdirs(dirs,force,dry_run)
+      exists = false
+      if !force
+        dirs.each do |dir|
+          if File.exist? dir
+            puts "#{dir} exists; use --force to override"
+            exists = true
+          end
+        end
+      end
+      if !exists
+        dirs.each do |dir|
+          puts "Creating dir #{dir}..."
+          if dry_run
+            $stderr.puts "dry-run; #{dir} not created"
+          else
+            FileUtils.mkdir_p dir
+          end
+        end
+      else
+        puts "Exiting..."
+        return false
+      end
+      true
+    end
+
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/.gemspec b/lib/bbcloud/vendor/hirb-0.3.5/.gemspec
new file mode 100644
index 0000000..3490062
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/.gemspec
@@ -0,0 +1,22 @@
+# -*- encoding: utf-8 -*-
+require 'rubygems' unless Object.const_defined?(:Gem)
+require File.dirname(__FILE__) + "/lib/hirb/version"
+ 
+Gem::Specification.new do |s|
+  s.name        = "hirb"
+  s.version     = Hirb::VERSION
+  s.authors     = ["Gabriel Horner"]
+  s.email       = "gabriel.horner@gmail.com"
+  s.homepage    = "http://tagaholic.me/hirb/"
+  s.summary     = "A mini view framework for console/irb that's easy to use, even while under its influence."
+  s.description = "Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output. Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer two dimensional menus."
+  s.required_rubygems_version = ">= 1.3.5"
+  s.rubyforge_project = 'tagaholic'
+  s.add_development_dependency 'bacon', '>= 1.1.0'
+  s.add_development_dependency 'mocha'
+  s.add_development_dependency 'mocha-on-bacon'
+  s.add_development_dependency 'bacon-bits'
+  s.files = Dir.glob(%w[{lib,test}/**/*.rb bin/* [A-Z]*.{txt,rdoc} ext/**/*.{rb,c} **/deps.rip]) + %w{Rakefile .gemspec}
+  s.extra_rdoc_files = ["README.rdoc", "LICENSE.txt"]
+  s.license = 'MIT'
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/CHANGELOG.rdoc b/lib/bbcloud/vendor/hirb-0.3.5/CHANGELOG.rdoc
new file mode 100644
index 0000000..7a65e28
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/CHANGELOG.rdoc
@@ -0,0 +1,112 @@
+== 0.3.5
+* Add ripl support
+* Fix Formatter#determine_output_class for IO and Hash
+* Remove :output_method option for Hirb.enable
+* Allow rubygems 1.3.5
+
+== 0.3.4
+* Added auto format of array-like objects i.e. ActiveRecord::Relation and Set.
+* Fixed bug when Hirb::Console#table is used without Hirb enabled.
+* Fixed bug when hirb is running within cron and uses tput.
+
+== 0.3.3
+* Added ignore_errors option to ignore view errors and continue with original view.
+* Added support for array menu items.
+* Added support to ObjectTable for objects with an undefined :send method.
+
+== 0.3.2
+* Added irb autocompletions for bond.
+* Fixed tests for ruby 1.9.
+* Changed tests to use bacon.
+* Removed jeweler in Rakefile and pointless $LOAD_PATH manipulation.
+
+== 0.3.1
+* Bug fix on DynamicView.class_to_method to allow overrides of default views.
+* Modified mongo_mapper view to have _id first.
+
+== 0.3.0
+* Added dynamic views.
+* Added default table views for the following database classes/modules:
+  CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+  DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+  Mongoid::Document, Ripple::Document and Sequel::Model.
+* Added Hirb.add_view and Hirb.add_dynamic_view for easier view manipulation.
+* Added :multi_line_nodes option for Tree.
+* Fixed :change_fields option bug in Table.
+* Fixed no headers and nil fields bug in Table.
+* Removed deprecations in Hirb.config_file + View.enable.
+* Removed Views classes and View.format_class.
+* Removed :return_rows option for Table.
+
+== 0.2.10
+* Added multiple options to Menu, most importantly :two_d and :action.
+* Improved table resizing algorithm.
+* Added merging of configs for multiple Hirb.enable calls.
+* Added :max_fields, :hide_empty, :delete_callbacks, :resize, :header_filter
+  and :return_rows options to Table.
+* Added escaping for \t and \r in Table.
+* Renamed Table's :no_newlines option to :escape_special_chars.
+* Removed Table's :field_lengths option.
+* Removed Menu's :validate_one option.
+* Bug fix for table header of a basic array.
+* Deprecating Hirb.config_file + View.enable in next release.
+
+== 0.2.9
+* Added newline filtering and :no_newlines option for table helper.
+* Added default filters for hashes that have hash values.
+* Bug fix for deprecated to_a call.
+
+== 0.2.8
+* Added callbacks to Hirb::Helpers::Table.
+* Added :change_fields option to Hirb::Helpers::Table.
+* Added terminal size detection for jruby.
+* Bug fix for paging long outputs.
+* Bug fix to make unexpected hirb rendering errors more clear.
+
+== 0.2.7
+* 2 ruby 1.9 bug fixes.
+* Bug fix in :fields of Hirb::Helpers::ObjectTable.
+* Made :class option in Hirb::Formatter friendlier to external apps.
+
+== 0.2.6
+* Added :description option and added proc ability to :children_method option for helpers.
+* Bug fix for no ENV['HOME'] on Windows.
+* Bug fix on unaliasing output_method.
+* Bug fix on multiple renders of vertical table.
+
+== 0.2.5
+* Added ability to use Hirb.enable with non-irb ruby shells.
+* Helper configs now recursively merge when inheriting from others via :ancestor option.
+
+== 0.2.4
+* Bug fix on UTF-8 support.
+
+== 0.2.3
+* Added UTF-8 support for Ruby 1.8.x
+* Added :all_fields option to Table helper.
+
+== 0.2.2
+* Added a friendlier default (a vertical table) to incorrectly configured tables.
+* Added vertical table helper thanks to chrononaut.
+* Added detection of :select option from ActiveRecord queries in ActiveRecordTable helper.
+* Added handling anything that responds to :to_a in AutoTable helper.
+
+== 0.2.1
+* Fixed typo in Hirb::Console.view
+
+== 0.2.0
+* Major refactoring with bug fixes and better tests.
+* Improved table algorithm to ensure that tables don't wrap.
+* Added a pager which detects if output should be paged, Hirb::Pager.
+* Added a selection menu, Hirb::Menu
+* Following API changes: Hirb::Helpers::Table.max_width removed and config files don't use
+  the :view key anymore.
+== 0.1.2
+* Added tree views.
+* Added output_method option to Hirb::View.render_output.
+
+== 0.1.1
+* Fixed bug when rendering table with many fields.
+
+== 0.1.0
+* Initial release
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/LICENSE.txt b/lib/bbcloud/vendor/hirb-0.3.5/LICENSE.txt
new file mode 100644
index 0000000..5b44505
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/LICENSE.txt
@@ -0,0 +1,22 @@
+The MIT LICENSE
+
+Copyright (c) 2010 Gabriel Horner
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/README.rdoc b/lib/bbcloud/vendor/hirb-0.3.5/README.rdoc
new file mode 100644
index 0000000..1e86139
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/README.rdoc
@@ -0,0 +1,182 @@
+To read a linked version of this README, {click here}[http://tagaholic.me/hirb/doc/].
+
+== Description
+
+Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output.
+Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable
+views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options
+for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems
+i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager
+only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer
+{two dimensional menus}[http://tagaholic.me/2010/02/16/two-dimensional-console-menus-with-hirb.html].
+
+== Install
+
+Install the gem with:
+
+    sudo gem install hirb
+
+== View Tutorials
+
+* To create and configure views, see Hirb::View or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/View.html].
+* To create dynamic views, see Hirb::DynamicView or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/DynamicView.html].
+
+== Printing Ascii Tables
+
+To print ascii tables from an array of arrays, hashes or any objects:
+
+  puts Hirb::Helpers::AutoTable.render(ARRAY_OF_OBJECTS)
+
+Hirb will intelligently pick up on field names from an array of hashes and create properly-aligned
+fields from an array of arrays. See
+{here}[http://tagaholic.me/2009/10/15/boson-and-hirb-interactions.html#hirbs_handy_tables] for examples.
+
+== Rails Example
+
+Let's load and enable the view framework:
+  $ script/console
+  Loading local environment (Rails 2.3.5)
+  >> require 'hirb'
+  => true
+  >> Hirb.enable
+  => nil
+
+The default configuration provides table views for ActiveRecord::Base descendants.
+If a class isn't configured, Hirb reverts to irb's default echo mode.
+  >> Hirb::Formatter.dynamic_config['ActiveRecord::Base']
+  => {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+
+  # Tag is a model class and descendant of ActiveRecord::Base
+  >> Tag.last
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | id  | created_at              | description | name          | namespace | predicate | value |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml | gem       | tags      | yaml  |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  1 row in set
+
+  >> Hirb::Formatter.dynamic_config['String']
+  => nil
+  >> 'plain ol irb'
+  => 'plain ol irb'
+  >> Hirb::Formatter.dynamic_config['Symbol']
+  => nil
+  >> :blah
+  => :blah
+
+From above you can see there are no views configured for a String or a Symbol so Hirb defaults to
+irb's echo mode. On the other hand, Tag has a view thanks to being a descendant of ActiveRecord::Base
+and there being an :ancestor option.
+
+Having seen hirb display views based on an output object's class, let's see it handle an array of objects:
+
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | id  | created_at              | description | name              | namespace | predicate | value    |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml     | gem       | tags      | yaml     |
+  | 906 | 2009-03-06 08:47:04 UTC |             | gem:tags=nomonkey | gem       | tags      | nomonkey |
+  | 905 | 2009-03-04 00:30:10 UTC |             | article:tags=ruby | article   | tags      | ruby     |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  3 rows in set
+
+At any time you can disable Hirb if you really like irb's lovely echo mode:
+  >> Hirb.disable
+  => nil
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  => [#<Tag id: 907, name: "gem:tags=yaml", description: nil, created_at: "2009-03-06 21:10:41",
+  namespace: "gem", predicate: "tags", value: "yaml">, #<Tag id: 906, name: "gem:tags=nomonkey",
+  description: nil, created_at: "2009-03-06 08:47:04", namespace: "gem", predicate: "tags", value:
+  "nomonkey">, #<Tag id: 905, name: "article:tags=ruby", description: nil, created_at: "2009-03-04
+  00:30:10", namespace: "article", predicate: "tags", value: "ruby">]
+
+== Views: Anytime, Anywhere
+While preconfigured tables are great for database records, sometimes you just want to create
+tables/views for any output object:
+  
+  #These examples don't need to have Hirb::View enabled.
+  >> Hirb.disable
+  => nil
+
+  # Imports table() and view()
+  >> extend Hirb::Console
+  => main
+
+  # Create a table of Dates comparing them with different formats.
+  >> table [Date.today, Date.today.next_month], :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+  +------------+--------+-----------+-------+--------------------------+
+  | to_s       | ld     | ajd       | amjd  | asctime                  |
+  +------------+--------+-----------+-------+--------------------------+
+  | 2009-03-11 | 155742 | 4909803/2 | 54901 | Wed Mar 11 00:00:00 2009 |
+  | 2009-04-11 | 155773 | 4909865/2 | 54932 | Sat Apr 11 00:00:00 2009 |
+  +------------+--------+-----------+-------+--------------------------+
+  2 rows in set
+
+  # Same table as the previous method. However view() will be able to call any helper.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+If these console methods weren't convenient enough, try:
+
+  # Imports view() to all objects.
+  >> require 'hirb/import_object'
+  =>true
+  # Yields same table as above examples.
+  >> [Date.today, Date.today.next_month].view :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+Although views by default are printed to STDOUT, they can be easily modified to write anywhere:
+  # Setup views to write to file 'console.log'.
+  >> Hirb::View.render_method = lambda {|output| File.open("console.log", 'w') {|f| f.write(output) } }
+
+  # Writes to file with same table output as above example.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+  # Doesn't write to file because Symbol doesn't have a view and thus defaults to irb's echo mode.
+  >> :blah
+  =>:blah
+
+  # Go back to printing Hirb views to STDOUT.
+  >> Hirb::View.reset_render_method
+
+== Pager
+
+Hirb has both pager and formatter functionality enabled by default.
+If you want to turn off the functionality of either you can pass that in at startup:
+
+  Hirb.enable :pager=>false
+  Hirb.enable :formatter=>false
+
+or toggle their state at runtime:
+
+  Hirb::View.toggle_pager
+  Hirb::View.toggle_formatter
+
+== Sharing Helpers and Views
+If you have tested helpers you'd like to share, fork Hirb and put them under lib/hirb/helpers. To share
+views for certain classes, put them under lib/hirb/views. Please submit views for gems that have a nontrivial
+number of users.
+
+== Limitations
+If using Wirble, you should call Hirb after it since they both override irb's default output.
+
+== Motivation
+Table code from http://gist.github.com/72234 and {my console app's needs}[http://github.com/cldwalker/tag-tree].
+
+== Credits
+* Chrononaut for vertical table helper.
+* crafterm, spastorino, xaviershay, bogdan and joshua for patches.
+
+== Bugs/Issues
+Please report them {on github}[http://github.com/cldwalker/hirb/issues].
+
+== Links
+* http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html
+* http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html
+* http://tagaholic.me/2009/06/19/page-irb-output-and-improve-ri-with-hirb.html
+
+== Todo
+* Consider generating views based on methods an object responds to.
+* Provide helper methods to all views.
+* Consider adding a template helper.
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/Rakefile b/lib/bbcloud/vendor/hirb-0.3.5/Rakefile
new file mode 100644
index 0000000..a88c05a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/Rakefile
@@ -0,0 +1,35 @@
+require 'rake'
+require 'fileutils'
+
+def gemspec
+  @gemspec ||= eval(File.read('.gemspec'), binding, '.gemspec')
+end
+
+desc "Build the gem"
+task :gem=>:gemspec do
+  sh "gem build .gemspec"
+  FileUtils.mkdir_p 'pkg'
+  FileUtils.mv "#{gemspec.name}-#{gemspec.version}.gem", 'pkg'
+end
+
+desc "Install the gem locally"
+task :install => :gem do
+  sh %{gem install pkg/#{gemspec.name}-#{gemspec.version}}
+end
+
+desc "Generate the gemspec"
+task :generate do
+  puts gemspec.to_ruby
+end
+
+desc "Validate the gemspec"
+task :gemspec do
+  gemspec.validate
+end
+
+desc 'Run tests'
+task :test do |t|
+  sh 'bacon -q -Ilib -I. test/*_test.rb'
+end
+
+task :default => :test
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
new file mode 100644
index 0000000..ca9a642
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
@@ -0,0 +1,15 @@
+complete(:methods=>%w{Hirb::View.enable Hirb.enable}) {
+  %w{config_file output_method output width height formatter pager pager_command}
+}
+complete(:methods=>%w{Hirb::Helpers::Table.render table}) {
+  %w{fields headers max_fields max_width resize number change_fields}+
+  %w{filters header_filter filter_any filter_classes vertical all_fields}+
+  %w{description escape_special_chars table_class hide_empty}
+}
+complete(:method=>"Hirb::Helpers::Tree.render") {
+  %w{type validate indent limit description multi_line_nodes value_method children_method}
+}
+complete(:methods=>%w{Hirb::Menu.render menu}) {
+  %w{helper_class prompt ask directions readline two_d default_field action multi_action} +
+    %w{action_object command reopen}
+}
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb.rb
new file mode 100644
index 0000000..e3f77ab
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb.rb
@@ -0,0 +1,81 @@
+# Needed by Hirb::String to handle multibyte characters
+$KCODE = 'u' if RUBY_VERSION < '1.9'
+
+require 'hirb/util'
+require 'hirb/string'
+require 'hirb/formatter' # must come before helpers/auto_table
+require 'hirb/dynamic_view'
+require 'hirb/helpers'
+require 'hirb/views'
+require 'hirb/view'
+require 'hirb/console'
+require 'hirb/pager'
+require 'hirb/menu'
+require 'hirb/version'
+
+# Most of Hirb's functionality is in Hirb::View.
+# For a tutorial  on configuring and creating views see Hirb::View. For a tutorial on dynamic views see Hirb::DynamicView.
+#
+# == Config Files
+# Hirb can have multiple config files defined by config_files(). These config files
+# have the following top level keys:
+# [*:output*] This hash is used by the formatter object. See Hirb::Formatter.config for its format.
+# [*:width*]  Width of the terminal/console. Defaults to Hirb::View::DEFAULT_WIDTH or possibly autodetected when Hirb is enabled.
+# [*:height*]  Height of the terminal/console. Defaults to Hirb::View::DEFAULT_HEIGHT or possibly autodetected when Hirb is enabled.
+# [*:formatter*] Boolean which determines if the formatter is enabled. Defaults to true.
+# [*:pager*] Boolean which determines if the pager is enabled. Defaults to true.
+# [*:pager_command*] Command to be used for paging. Command can have options after it i.e. 'less -r'.
+#                    Defaults to common pagers i.e. less and more if detected.
+# [*:ignore_errors*] Boolean which ignores internal view errors and continues with original view
+#                    (i.e. #inspect for irb). Defaults to false.
+module Hirb
+  class <<self
+    attr_accessor :config_files, :config
+
+    # Enables view functionality. See Hirb::View.enable for details.
+    def enable(options={}, &block)
+      View.enable(options, &block)
+    end
+
+    # Disables view functionality. See Hirb::View.disable for details.
+    def disable
+      View.disable
+    end
+
+    # Adds views. See Hirb::View.add for details.
+    def add_view(view, options, &block)
+      View.add(view, options, &block)
+    end
+
+    # Adds views. See Hirb::DynamicView.add for details.
+    def add_dynamic_view(view, options, &block)
+      DynamicView.add(view, options, &block)
+    end
+
+    # Array of config files which are merged sequentially to produce config.
+    # Defaults to config/hirb.yml and ~/.hirb_yml
+    def config_files
+      @config_files ||= default_config_files
+    end
+
+    #:stopdoc:
+    def default_config_files
+      [File.join(Util.find_home, ".hirb.yml")] +
+        (File.exists?('config/hirb.yml') ? ['config/hirb.yml'] : [])
+    end
+
+    def read_config_file(file=config_file)
+      File.exists?(file) ? YAML::load_file(file) : {}
+    end
+
+    def config(reload=false)
+      if (@config.nil? || reload)
+        @config = config_files.inject({}) {|acc,e|
+          Util.recursive_hash_merge(acc,read_config_file(e))
+        }
+      end
+      @config
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/console.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/console.rb
new file mode 100644
index 0000000..fefb134
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/console.rb
@@ -0,0 +1,43 @@
+module Hirb
+  # This module is meant to be extended to provide methods for use in a console/irb shell.
+  # For example:
+  #    >> extend Hirb::Console
+  #    >> view 'some string', :class=>Some::String::Formatter
+  #    >> table [[:row1], [:row2]]
+  module Console
+    class<<self
+      # A console version of render_output() which takes its same options but allows for shorthand. All options are passed to
+      # the helper except for the formatter options. Formatter options are :class, :method and :output_method.
+      # Examples:
+      #   render_output output, :class=>:tree :type=>:directory
+      #   # is the same as:
+      #   render_output output, :class=>:tree, :options=> {:type=>:directory}
+      #
+      def render_output(output, options={})
+        View.load_config unless View.config_loaded?
+        View.render_output(output, options.merge(:console=>true))
+      end
+
+      # Takes same arguments and options as render_output() but returns formatted output instead of rendering it.
+      def format_output(output, options={}, &block)
+        View.load_config unless View.config_loaded?
+        View.formatter.format_output(output, options.merge(:console=>true), &block)
+      end
+    end
+
+    # Renders a table for the given object. Takes same options as Hirb::Helpers::Table.render.
+    def table(output, options={})
+      Console.render_output(output, options.merge(:class=>"Hirb::Helpers::AutoTable"))
+    end
+
+    # Renders any specified view for the given object. Takes same options as Hirb::View.render_output.
+    def view(output, options={})
+      Console.render_output(output, options)
+    end
+
+    # Renders a menu given an array using Hirb::Menu.render.
+    def menu(output, options={}, &block)
+      Console.format_output(output, options.merge(:class=>"Hirb::Menu"), &block)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
new file mode 100644
index 0000000..31929f6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
@@ -0,0 +1,113 @@
+module Hirb
+  # This module extends a Helper with the ability to have dynamic views for configured output classes.
+  # After a Helper has extended this module, it can use it within a render() by calling
+  # dynamic_options() to get dynamically generated options for the object it's rendering. See Hirb::Helpers::AutoTable as an example.
+  #
+  # == Dynamic Views
+  # Whereas normal views are generated from helpers with static helper options, dynamic views are generated from helpers and
+  # dynamically generated helper options. Let's look at an example for Rails' ActiveRecord classes:
+  #
+  #   Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj|
+  #    {:fields=>obj.class.column_names} }
+  #
+  # From this dynamic view definition, _any_ ActiveRecord model class will render a table with the correct fields, since the fields
+  # are extracted from the output object's class at runtime. Note that dynamic view definitions should return a hash of helper options.
+  #
+  # To define multiple dynamic views, create a Views module where each method ending in '\_view' maps to a class/module:
+  #
+  #   module Hirb::Views::ORM
+  #     def data_mapper__resource_view(obj)
+  #       {:fields=>obj.class.properties.map {|e| e.name }}
+  #     end
+  #
+  #     def sequel__model_view(obj)
+  #       {:fields=>obj.class.columns}
+  #     end
+  #   end
+  #
+  #   Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+  #
+  # In this example, 'data_mapper__resource_view' maps to DataMapper::Resource and 'sequel__model_view' maps to Sequel::Model.
+  # Note that when mapping method names to class names, '__' maps to '::' and '_' signals the next letter to be capitalized.
+  module DynamicView
+    # Add dynamic views to output class(es) for a given helper. If defining one view, the first argument is the output class
+    # and a block defines the dynamic view. If defining multiple views, the first argument should be a Views::* module where
+    # each method in the module ending in _view defines a view for an output class. To map output classes to method names in
+    # a Views module, translate'::' to '__' and a capital letter translates to a '_' and a lowercase letter.
+    # ==== Options:
+    # [*:helper*] Required option. Helper class that view(s) use to format. Hirb::Helpers::AutoTable is the only valid
+    #             helper among default helpers. Can be given in aliased form i.e. :auto_table -> Hirb::Helpers::AutoTable.
+    #
+    # Examples:
+    #    Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+    #    Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj| {:fields=>obj.class.column_names} }
+    def self.add(view, options, &block)
+      raise ArgumentError, ":helper option is required" unless options[:helper]
+      helper = Helpers.helper_class options[:helper]
+      unless helper.is_a?(Module) && class << helper; self.ancestors; end.include?(self)
+        raise ArgumentError, ":helper option must be a helper that has extended DynamicView"
+      end
+      mod = block ? generate_single_view_module(view, &block) : view
+      raise ArgumentError, "'#{mod}' must be a module" unless mod.is_a?(Module)
+      helper.add_module mod
+    end
+
+    def self.generate_single_view_module(output_mod, &block) #:nodoc:
+      meth = class_to_method output_mod.to_s
+      view_mod = meth.capitalize
+      Views::Single.send(:remove_const, view_mod) if Views::Single.const_defined?(view_mod)
+      mod = Views::Single.const_set(view_mod, Module.new)
+      mod.send(:define_method, meth, block)
+      mod
+    end
+
+    def self.class_to_method(mod) #:nodoc:
+      mod.gsub(/(?!^)([A-Z])/) {|e| '_'+e }.gsub('::_', '__').downcase + '_view'
+    end
+
+    # Returns a hash of options based on dynamic views defined for the object's ancestry. If no config is found returns nil.
+    def dynamic_options(obj)
+      view_methods.each do |meth|
+        if obj.class.ancestors.map {|e| e.to_s }.include?(method_to_class(meth))
+          begin
+            return send(meth, obj)
+          rescue
+            raise "View failed to generate for '#{method_to_class(meth)}' "+
+              "while in '#{meth}' with error:\n#{$!.message}"
+          end
+        end
+      end
+      nil
+    end
+
+    #:stopdoc:
+    def add_module(mod)
+      new_methods = mod.instance_methods.select {|e| e.to_s =~ /_view$/ }.map {|e| e.to_s}
+      return if new_methods.empty?
+      extend mod
+      view_methods.replace(view_methods + new_methods).uniq!
+      update_config(new_methods)
+    end
+
+    def update_config(meths)
+      output_config = meths.inject({}) {|t,e|
+        t[method_to_class(e)] = {:class=>self, :ancestor=>true}; t
+      }
+      Formatter.dynamic_config.merge! output_config
+    end
+
+    def method_to_class(meth)
+      view_method_classes[meth] ||= Util.camelize meth.sub(/_view$/, '').gsub('__', '/')
+    end
+
+    def view_method_classes
+      @view_method_classes ||= {}
+    end
+    #:startdoc:
+
+    # Stores view methods that a Helper has been given via DynamicView.add
+    def view_methods
+      @view_methods ||= []
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/formatter.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/formatter.rb
new file mode 100644
index 0000000..df1269a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/formatter.rb
@@ -0,0 +1,119 @@
+module Hirb
+  # A Formatter object formats an output object (using Formatter.format_output) into a string based on the views defined
+  # for its class and/or ancestry.
+  class Formatter
+    TO_A_EXCEPTIONS = ['Hash', 'IO']
+
+    class<<self
+      # This config is used by Formatter.format_output to lazily load dynamic views defined with Hirb::DynamicView.
+      # This hash has the same format as Formatter.config.
+      attr_accessor :dynamic_config
+    end
+    self.dynamic_config = {}
+
+    def initialize(additional_config={}) #:nodoc:
+      @klass_config = {}
+      @config = additional_config || {}
+    end
+
+    # A hash of Ruby class strings mapped to view hashes. A view hash must have at least a :method, :output_method
+    # or :class option for a view to be applied to an output. A view hash has the following keys:
+    # [*:method*] Specifies a global (Kernel) method to do the formatting.
+    # [*:class*] Specifies a class to do the formatting, using its render() class method. If a symbol it's converted to a corresponding
+    #            Hirb::Helpers::* class if it exists.
+    # [*:output_method*] Specifies a method or proc to call on output before passing it to a helper. If the output is an array, it's applied
+    #                    to every element in the array.
+    # [*:options*] Options to pass the helper method or class.
+    # [*:ancestor*] Boolean which when true causes subclasses of the output class to inherit its config. This doesn't effect the current
+    #               output class. Defaults to false. This is used by ActiveRecord classes.
+    # 
+    #   Examples:
+    #     {'WWW::Delicious::Element'=>{:class=>'Hirb::Helpers::ObjectTable', :ancestor=>true, :options=>{:max_width=>180}}}
+    #     {'Date'=>{:class=>:auto_table, :ancestor=>true}}
+    #     {'Hash'=>{:method=>:puts}}
+    def config
+      @config
+    end
+
+    # Adds the view for the given class and view hash config. See Formatter.config for valid keys for view hash.
+    def add_view(klass, view_config)
+      @klass_config.delete(klass)
+      @config[klass.to_s] = view_config
+      true
+    end
+
+    # This method looks for an output object's view in Formatter.config and then Formatter.dynamic_config.
+    # If a view is found, a stringified view is returned based on the object. If no view is found, nil is returned. The options this
+    # class takes are a view hash as described in Formatter.config. These options will be merged with any existing helper
+    # config hash an output class has in Formatter.config. Any block given is passed along to a helper class.
+    def format_output(output, options={}, &block)
+      output_class = determine_output_class(output)
+      options = parse_console_options(options) if options.delete(:console)
+      options = Util.recursive_hash_merge(klass_config(output_class), options)
+      _format_output(output, options, &block)
+    end
+
+    #:stopdoc:
+    def _format_output(output, options, &block)
+      output = options[:output_method] ? (output.is_a?(Array) ?
+        output.map {|e| call_output_method(options[:output_method], e) } :
+        call_output_method(options[:output_method], output) ) : output
+      args = [output]
+      args << options[:options] if options[:options] && !options[:options].empty?
+      if options[:method]
+        send(options[:method],*args)
+      elsif options[:class] && (helper_class = Helpers.helper_class(options[:class]))
+        helper_class.render(*args, &block)
+      elsif options[:output_method]
+        output
+      end
+    end
+
+    def parse_console_options(options) #:nodoc:
+      real_options = [:method, :class, :output_method].inject({}) do |h, e|
+        h[e] = options.delete(e) if options[e]; h
+      end
+      real_options.merge! :options=>options
+    end
+
+    def determine_output_class(output)
+      output.respond_to?(:to_a) && !TO_A_EXCEPTIONS.include?(output.class.to_s) ?
+        Array(output)[0].class : output.class
+    end
+
+    def call_output_method(output_method, output)
+      output_method.is_a?(Proc) ? output_method.call(output) : output.send(output_method)
+    end
+
+    # Internal view options built from user-defined ones. Options are built by recursively merging options from oldest
+    # ancestors to the most recent ones.
+    def klass_config(output_class)
+      @klass_config[output_class] ||= build_klass_config(output_class)
+    end
+
+    def build_klass_config(output_class)
+      output_ancestors = output_class.ancestors.map {|e| e.to_s}.reverse
+      output_ancestors.pop
+      hash = output_ancestors.inject({}) {|h, klass|
+        add_klass_config_if_true(h, klass) {|c,klass| c[klass] && c[klass][:ancestor] }
+      }
+      add_klass_config_if_true(hash, output_class.to_s) {|c,klass| c[klass] }
+    end
+
+    def add_klass_config_if_true(hash, klass)
+      if yield(@config, klass)
+        Util.recursive_hash_merge hash, @config[klass]
+      elsif yield(self.class.dynamic_config, klass)
+        @config[klass] = self.class.dynamic_config[klass].dup # copy to local
+        Util.recursive_hash_merge hash, self.class.dynamic_config[klass]
+      else
+        hash
+      end
+    end
+
+    def reset_klass_config
+      @klass_config = {}
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers.rb
new file mode 100644
index 0000000..4c8bbd6
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers.rb
@@ -0,0 +1,17 @@
+module Hirb
+  module Helpers #:nodoc:
+    @helper_classes ||= {}
+    def self.helper_class(klass)
+      @helper_classes[klass.to_s] ||= begin
+        if (helper_class = constants.find {|e| e.to_s == Util.camelize(klass.to_s)})
+          klass = "Hirb::Helpers::#{helper_class}"
+        end
+        Util.any_const_get(klass)
+      end
+    end
+  end
+end
+
+%w{table object_table auto_table tree parent_child_tree vertical_table}.each do |e|
+  require "hirb/helpers/#{e}"
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
new file mode 100644
index 0000000..ed31357
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
@@ -0,0 +1,24 @@
+# This helper wraps around the other table helpers i.e. Hirb::Helpers::Table while
+# providing default helper options via Hirb::DynamicView. Using these default options, this
+# helper supports views for the following modules/classes:
+# ActiveRecord::Base, CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+# DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+# Mongoid::Document, Ripple::Document, Sequel::Model.
+class Hirb::Helpers::AutoTable < Hirb::Helpers::Table
+  extend Hirb::DynamicView
+
+  # Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:table_class] Explicit table class to use for rendering. Defaults to
+  #                Hirb::Helpers::ObjectTable if output is not an Array or Hash. Otherwise
+  #                defaults to Hirb::Helpers::Table.
+  def self.render(output, options={})
+    output = Array(output)
+    (defaults = dynamic_options(output[0])) && (options = defaults.merge(options))
+    klass = options.delete(:table_class) || (
+      !(output[0].is_a?(Hash) || output[0].is_a?(Array)) ?
+      Hirb::Helpers::ObjectTable : Hirb::Helpers::Table)
+    klass.render(output, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
new file mode 100644
index 0000000..6227dac
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
@@ -0,0 +1,14 @@
+class Hirb::Helpers::ObjectTable < Hirb::Helpers::Table
+  # Rows are any ruby objects. Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:fields] Methods of the object to represent as columns. Defaults to [:to_s].
+  def self.render(rows, options ={})
+    options[:fields] ||= [:to_s]
+    options[:headers] ||= {:to_s=>'value'} if options[:fields] == [:to_s]
+    item_hashes = options[:fields].empty? ? [] : Array(rows).inject([]) {|t,item|
+      t << options[:fields].inject({}) {|h,f| h[f] = item.__send__(f); h}
+    }
+    super(item_hashes, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
new file mode 100644
index 0000000..d056057
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
@@ -0,0 +1,24 @@
+class Hirb::Helpers::ParentChildTree < Hirb::Helpers::Tree
+  class <<self
+    # Starting with the given node, this builds a tree by recursively calling a children method.
+    # Takes same options as Hirb::Helper::Table.render with some additional ones below.
+    # ==== Options:
+    # [:value_method] Method or proc to call to display as a node's value. If not given, uses :name if node
+    #                 responds to :name or defaults to :object_id.
+    # [:children_method] Method or proc to call to obtain a node's children. Default is :children.
+    def render(root_node, options={})
+      value_method = options[:value_method] || (root_node.respond_to?(:name) ? :name : :object_id)
+      @value_method = value_method.is_a?(Proc) ? value_method : lambda {|n| n.send(value_method) }
+      children_method = options[:children_method] || :children
+      @children_method = children_method.is_a?(Proc) ? children_method : lambda {|n| n.send(children_method)}
+      @nodes = []
+      build_node(root_node, 0)
+      super(@nodes, options)
+    end
+
+    def build_node(node, level) #:nodoc:
+      @nodes << {:value=>@value_method.call(node), :level=>level}
+      @children_method.call(node).each {|e| build_node(e, level + 1)}
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
new file mode 100644
index 0000000..de51309
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
@@ -0,0 +1,323 @@
+require 'hirb/helpers/table/filters'
+require 'hirb/helpers/table/resizer'
+
+module Hirb
+# Base Table class from which other table classes inherit.
+# By default, a table is constrained to a default width but this can be adjusted
+# via the max_width option or Hirb::View.width.
+# Rows can be an array of arrays or an array of hashes.
+#
+# An array of arrays ie [[1,2], [2,3]], would render:
+#   +---+---+
+#   | 0 | 1 |
+#   +---+---+
+#   | 1 | 2 |
+#   | 2 | 3 |
+#   +---+---+
+#
+# By default, the fields/columns are the numerical indices of the array.
+# 
+# An array of hashes ie [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], would render:
+#   +-----+--------+
+#   | age | weight |
+#   +-----+--------+
+#   | 10  | 100    |
+#   | 80  | 500    |
+#   +-----+--------+
+#
+# By default, the fields/columns are the keys of the first hash.
+#
+# === Custom Callbacks
+# Callback methods can be defined to add your own options that modify rows right before they are rendered.
+# Here's an example that allows for searching with a :query option:
+#   module Query
+#     # Searches fields given a query hash
+#     def query_callback(rows, options)
+#       return rows unless options[:query]
+#       options[:query].map {|field,query|
+#         rows.select {|e| e[field].to_s =~ /#{query}/i }
+#       }.flatten.uniq
+#     end
+#   end
+#   Hirb::Helpers::Table.send :include, Query
+#
+#   >> puts Hirb::Helpers::Table.render [{:name=>'batman'}, {:name=>'robin'}], :query=>{:name=>'rob'}
+#   +-------+
+#   | name  |
+#   +-------+
+#   | robin |
+#   +-------+
+#   1 row in set
+#
+# Callback methods:
+# * must be defined in Helpers::Table and end in '_callback'.
+# * should expect rows and a hash of render options. Rows will be an array of hashes.
+# * are expected to return an array of hashes.
+# * are invoked in alphabetical order.
+# For a thorough example, see {Boson::Pipe}[http://github.com/cldwalker/boson/blob/master/lib/boson/pipe.rb].
+#--
+# derived from http://gist.github.com/72234
+ class Helpers::Table
+  BORDER_LENGTH = 3 # " | " and "-+-" are the borders
+  MIN_FIELD_LENGTH = 3
+  class TooManyFieldsForWidthError < StandardError; end
+
+  class << self
+    
+    # Main method which returns a formatted table.
+    # ==== Options:
+    # [*:fields*] An array which overrides the default fields and can be used to indicate field order.
+    # [*:headers*] A hash of fields and their header names. Fields that aren't specified here default to their name.
+    #              When set to false, headers are hidden. Can also be an array but only for array rows.
+    # [*:max_fields*] A hash of fields and their maximum allowed lengths. Maximum length can also be a percentage of the total width
+    #                 (decimal less than one). When a field exceeds it's maximum then it's
+    #                 truncated and has a ... appended to it. Fields that aren't specified have no maximum.
+    # [*:max_width*] The maximum allowed width of all fields put together including field borders. Only valid when :resize is true.
+    #                Default is Hirb::View.width.
+    # [*:resize*] Resizes table to display all columns in allowed :max_width. Default is true. Setting this false will display the full
+    #             length of each field.
+    # [*:number*] When set to true, numbers rows by adding a :hirb_number column as the first column. Default is false.
+    # [*:change_fields*] A hash to change old field names to new field names. This can also be an array of new names but only for array rows.
+    #                    This is useful when wanting to change auto-generated keys to more user-friendly names i.e. for array rows.
+    # [*:filters*] A hash of fields and their filters, applied to every row in a field. A filter can be a proc, an instance method
+    #              applied to the field value or a Filters method. Also see the filter_classes attribute below.
+    # [*:header_filter*] A filter, like one in :filters, that is applied to all headers after the :headers option.
+    # [*:filter_any*] When set to true, any cell defaults to being filtered by its class in :filter_classes.
+    #                 Default Hirb::Helpers::Table.filter_any().
+    # [*:filter_classes*] Hash which maps classes to filters. Default is Hirb::Helpers::Table.filter_classes().
+    # [*:vertical*] When set to true, renders a vertical table using Hirb::Helpers::VerticalTable. Default is false.
+    # [*:all_fields*] When set to true, renders fields in all rows. Valid only in rows that are hashes. Default is false.
+    # [*:description*] When set to true, renders row count description at bottom. Default is true.
+    # [*:escape_special_chars*] When set to true, escapes special characters \n,\t,\r so they don't disrupt tables. Default is false for
+    #                           vertical tables and true for anything else.
+    # Examples:
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]]
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]], :max_fields=>{0=>10}, :header_filter=>:capitalize
+    #    Hirb::Helpers::Table.render [['a',1], ['b',2]], :change_fields=>%w{letters numbers}, :max_fields=>{'numbers'=>0.4}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}]
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :headers=>{:weight=>"Weight(lbs)"}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :filters=>{:age=>[:to_f]}
+    def render(rows, options={})
+      options[:vertical] ? Helpers::VerticalTable.render(rows, options) :
+      new(rows, options).render
+    rescue TooManyFieldsForWidthError
+      $stderr.puts "", "** Error: Too many fields for the current width. Configure your width " +
+        "and/or fields to avoid this error. Defaulting to a vertical table. **"
+      Helpers::VerticalTable.render(rows, options)
+    end
+
+    # A hash which maps a cell value's class to a filter. This serves to set a default filter per field if all of its
+    # values are a class in this hash. By default, Array values are comma joined and Hashes are inspected.
+    # See the :filter_any option to apply this filter per value.
+    attr_accessor :filter_classes
+    # Boolean which sets the default for :filter_any option.
+    attr_accessor :filter_any
+    # Holds last table object created
+    attr_accessor :last_table
+  end
+  self.filter_classes = { Array=>:comma_join, Hash=>:inspect }
+
+  #:stopdoc:
+  attr_accessor :width, :max_fields, :field_lengths, :fields
+  def initialize(rows, options={})
+    raise ArgumentError, "Table must be an array of hashes or array of arrays" unless rows.is_a?(Array) &&
+      (rows[0].is_a?(Hash) or rows[0].is_a?(Array) or rows.empty?)
+    @options = {:description=>true, :filters=>{}, :change_fields=>{}, :escape_special_chars=>true,
+      :filter_any=>Helpers::Table.filter_any, :resize=>true}.merge(options)
+    @fields = set_fields(rows)
+    @rows = set_rows(rows)
+    @headers = set_headers
+    if @options[:number]
+      @headers[:hirb_number] = "number"
+      @fields.unshift :hirb_number
+    end
+    Helpers::Table.last_table = self
+  end
+
+  def set_fields(rows)
+    @options[:change_fields] = array_to_indices_hash(@options[:change_fields]) if @options[:change_fields].is_a?(Array)
+    return @options[:fields].dup if @options[:fields]
+
+    fields = if rows[0].is_a?(Hash)
+      keys = @options[:all_fields] ? rows.map {|e| e.keys}.flatten.uniq : rows[0].keys
+      keys.sort {|a,b| a.to_s <=> b.to_s}
+    else
+      rows[0].is_a?(Array) ? (0..rows[0].length - 1).to_a : []
+    end
+
+    @options[:change_fields].each do |oldf, newf|
+      (index = fields.index(oldf)) && fields[index] = newf
+    end
+    fields
+  end
+
+  def set_rows(rows)
+    rows = Array(rows)
+    if rows[0].is_a?(Array)
+      rows = rows.inject([]) {|new_rows, row|
+        new_rows << array_to_indices_hash(row)
+      }
+    end
+    @options[:change_fields].each do |oldf, newf|
+      rows.each {|e| e[newf] = e.delete(oldf) if e.key?(oldf) }
+    end
+    rows = filter_values(rows)
+    rows.each_with_index {|e,i| e[:hirb_number] = (i + 1).to_s} if @options[:number]
+    deleted_callbacks = Array(@options[:delete_callbacks]).map {|e| "#{e}_callback" }
+    (methods.grep(/_callback$/).map {|e| e.to_s} - deleted_callbacks).sort.each do |meth|
+      rows = send(meth, rows, @options.dup)
+    end
+    validate_values(rows)
+    rows
+  end
+
+  def set_headers
+    headers = @fields.inject({}) {|h,e| h[e] = e.to_s; h}
+    if @options.has_key?(:headers)
+      headers = @options[:headers].is_a?(Hash) ? headers.merge(@options[:headers]) :
+        (@options[:headers].is_a?(Array) ? array_to_indices_hash(@options[:headers]) : @options[:headers])
+    end
+    if @options[:header_filter]
+      headers.each {|k,v|
+        headers[k] = call_filter(@options[:header_filter], v)
+      }
+    end
+    headers
+  end
+
+  def render
+    body = []
+    unless @rows.length == 0
+      setup_field_lengths
+      body += render_header
+      body += render_rows
+      body += render_footer
+    end
+    body << render_table_description if @options[:description]
+    body.join("\n")
+  end
+
+  def render_header
+    @headers ? render_table_header : [render_border]
+  end
+
+  def render_footer
+    [render_border]
+  end
+
+  def render_table_header
+    title_row = '| ' + @fields.map {|f|
+      format_cell(@headers[f], @field_lengths[f])
+    }.join(' | ') + ' |'
+    [render_border, title_row, render_border]
+  end
+  
+  def render_border
+    '+-' + @fields.map {|f| '-' * @field_lengths[f] }.join('-+-') + '-+'
+  end
+  
+  def format_cell(value, cell_width)
+    text = String.size(value) > cell_width ?
+      (
+      (cell_width < 5) ? String.slice(value, 0, cell_width) : String.slice(value, 0, cell_width - 3) + '...'
+      ) : value
+    String.ljust(text, cell_width)
+  end
+
+  def render_rows
+    @rows.map do |row|
+      row = '| ' + @fields.map {|f|
+        format_cell(row[f], @field_lengths[f])
+      }.join(' | ') + ' |'
+    end
+  end
+  
+  def render_table_description
+    (@rows.length == 0) ? "0 rows in set" :
+      "#{@rows.length} #{@rows.length == 1 ? 'row' : 'rows'} in set"
+  end
+  
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+    if @options[:resize]
+      raise TooManyFieldsForWidthError if @fields.size > self.actual_width.to_f / MIN_FIELD_LENGTH
+      Resizer.resize!(self)
+    else
+      enforce_field_constraints
+    end
+  end
+
+  def enforce_field_constraints
+    max_fields.each {|k,max| @field_lengths[k] = max if @field_lengths[k].to_i > max }
+  end
+
+  def max_fields
+    @max_fields ||= (@options[:max_fields] ||= {}).each {|k,v|
+      @options[:max_fields][k] = (actual_width * v.to_f.abs).floor if v.to_f.abs < 1
+    }
+  end
+
+  def actual_width
+    @actual_width ||= self.width - (@fields.size * BORDER_LENGTH + 1)
+  end
+
+  def width
+    @width ||= @options[:max_width] || View.width
+  end
+
+  # find max length for each field; start with the headers
+  def default_field_lengths
+    field_lengths = @headers ? @headers.inject({}) {|h,(k,v)| h[k] = String.size(v); h} :
+      @fields.inject({}) {|h,e| h[e] = 1; h }
+    @rows.each do |row|
+      @fields.each do |field|
+        len = String.size(row[field])
+        field_lengths[field] = len if len > field_lengths[field].to_i
+      end
+    end
+    field_lengths
+  end
+
+  def set_filter_defaults(rows)
+    @filter_classes.each do |klass, filter|
+      @fields.each {|field|
+        if rows.all? {|r| r[field].class == klass }
+          @options[:filters][field] ||= filter
+        end
+      }
+    end
+  end
+
+  def filter_values(rows)
+    @filter_classes = Helpers::Table.filter_classes.merge @options[:filter_classes] || {}
+    set_filter_defaults(rows) unless @options[:filter_any]
+    rows.map {|row|
+      @fields.inject({}) {|new_row,f|
+        (filter = @options[:filters][f]) || (@options[:filter_any] && (filter = @filter_classes[row[f].class]))
+        new_row[f] = filter ? call_filter(filter, row[f]) : row[f]
+        new_row
+      }
+    }
+  end
+
+  def call_filter(filter, val)
+    filter.is_a?(Proc) ? filter.call(val) :
+      val.respond_to?(Array(filter)[0]) ? val.send(*filter) : Filters.send(filter, val)
+  end
+
+  def validate_values(rows)
+    rows.each {|row|
+      @fields.each {|f|
+        row[f] = row[f].to_s || ''
+        row[f] = row[f].gsub(/(\t|\r|\n)/) {|e| e.dump.gsub('"','') } if @options[:escape_special_chars]
+      }
+    }
+  end
+  
+  # Converts an array to a hash mapping a numerical index to its array value.
+  def array_to_indices_hash(array)
+    array.inject({}) {|hash,e|  hash[hash.size] = e; hash }
+  end
+  #:startdoc:
+end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
new file mode 100644
index 0000000..46ba518
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
@@ -0,0 +1,10 @@
+class Hirb::Helpers::Table
+  # Contains filter methods used by :filters option. To define a custom filter, simply open this module and create a method
+  # that take one argument, the value you will be filtering.
+  module Filters
+    extend self
+    def comma_join(arr) #:nodoc:
+      arr.join(', ')
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
new file mode 100644
index 0000000..eadbc12
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
@@ -0,0 +1,82 @@
+class Hirb::Helpers::Table
+  # Resizes a table's fields to the table's max width.
+  class Resizer
+    # Modifies field_lengths to fit within width. Also enforces a table's max_fields.
+    def self.resize!(table)
+      obj = new(table)
+      obj.resize
+      obj.field_lengths
+    end
+
+    #:stopdoc:
+    attr_reader :field_lengths
+    def initialize(table)
+      @table, @width, @field_size = table, table.actual_width, table.fields.size
+      @field_lengths = table.field_lengths
+      @original_field_lengths = @field_lengths.dup
+    end
+
+    def resize
+      adjust_long_fields || default_restrict_field_lengths
+      @table.enforce_field_constraints
+      add_extra_width
+    end
+
+    # Simple algorithm which allows smaller fields to be displayed while
+    # restricting longer fields to an average_long_field
+    def adjust_long_fields
+      while (total_length = sum(@field_lengths.values)) > @width
+        average_field = total_length / @field_size.to_f
+        long_lengths = @field_lengths.values.select {|e| e > average_field }
+        return false if long_lengths.empty?
+
+        # adjusts average long field by ratio with @width
+        average_long_field = sum(long_lengths)/long_lengths.size * @width/total_length
+        @field_lengths.each {|f,length|
+          @field_lengths[f] = average_long_field if length > average_long_field
+        }
+      end
+      true
+    end
+
+    # Produces a field_lengths which meets the @width requirement
+    def default_restrict_field_lengths
+      original_total_length = sum @original_field_lengths.values
+      # set fields by their relative weight to original length
+      new_lengths = @original_field_lengths.inject({}) {|t,(k,v)|
+        t[k] = (v / original_total_length.to_f * @width).to_i; t  }
+
+      # set all fields the same if relative doesn't work
+      unless new_lengths.values.all? {|e| e > MIN_FIELD_LENGTH} && (sum(new_lengths.values) <= @width)
+        new_lengths = @field_lengths.inject({}) {|t,(k,v)| t[k] = @width / @field_size; t }
+      end
+      @field_lengths.each {|k,v| @field_lengths[k] = new_lengths[k] }
+    end
+
+    def add_extra_width
+      added_width = 0
+      extra_width = @width - sum(@field_lengths.values)
+      unmaxed_fields = @field_lengths.keys.select {|f| !remaining_width(f).zero? }
+      # order can affect which one gets the remainder so let's keep it consistent
+      unmaxed_fields = unmaxed_fields.sort_by {|e| e.to_s}
+
+      unmaxed_fields.each_with_index do |f, i|
+        extra_per_field = (extra_width - added_width) / (unmaxed_fields.size - i)
+        add_to_field = remaining_width(f) < extra_per_field ? remaining_width(f) : extra_per_field
+        added_width += add_to_field
+        @field_lengths[f] += add_to_field
+      end
+    end
+
+    def remaining_width(field)
+      (@remaining_width ||= {})[field] ||= begin
+        (@table.max_fields[field] || @original_field_lengths[field]) - @field_lengths[field]
+      end
+    end
+
+    def sum(arr)
+      arr.inject {|t,e| t += e }
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
new file mode 100644
index 0000000..2697423
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
@@ -0,0 +1,181 @@
+# Base tree class which given an array of nodes produces different types of trees.
+# The types of trees currently are:
+# * basic:
+#    0
+#      1
+#        2
+#        3
+#      4
+# 
+# * directory:
+#    0
+#    |-- 1
+#    |   |-- 2
+#    |   `-- 3
+#    `-- 4
+# 
+# * number:
+#    1. 0
+#      1. 1
+#        1. 2
+#        2. 3
+#      2. 4 
+# 
+# Tree nodes can be given as an array of arrays or an array of hashes.
+# To render the above basic tree with an array of hashes:
+#   Hirb::Helpers::Tree.render([{:value=>0, :level=>0}, {:value=>1, :level=>1}, {:value=>2, :level=>2}, 
+#     {:value=>3, :level=>2}, {:value=>4, :level=>1}])
+# Note from the hash keys that :level refers to the depth of the tree while :value refers to the text displayed
+# for a node.
+#
+# To render the above basic tree with an array of arrays:
+#   Hirb::Helpers::Tree.render([[0,0], [1,1], [2,2], [2,3], [1,4]])
+# Note that the each array pair consists of the level and the value for the node.
+class Hirb::Helpers::Tree
+  class ParentlessNodeError < StandardError; end
+
+  class <<self
+    # Main method which renders a tree.
+    # ==== Options:
+    # [:type] Type of tree. Either :basic, :directory or :number. Default is :basic.
+    # [:validate] Boolean to validate tree. Checks to see if all nodes have parents. Raises ParentlessNodeError if
+    #             an invalid node is found. Default is false.
+    # [:indent] Number of spaces to indent between levels for basic + number trees. Default is 4.
+    # [:limit] Limits the level or depth of a tree that is displayed. Root node is level 0.
+    # [:description] Displays brief description about tree ie how many nodes it has.
+    # [:multi_line_nodes] Handles multi-lined nodes by indenting their newlines. Default is false.
+    #  Examples:
+    #     Hirb::Helpers::Tree.render([[0, 'root'], [1, 'child']], :type=>:directory)
+    def render(nodes, options={})
+      new(nodes, options).render
+    end
+  end
+
+  # :stopdoc:
+  attr_accessor :nodes
+  
+  def initialize(input_nodes, options={})
+    @options = options
+    @type = options[:type] || :basic
+    if input_nodes[0].is_a?(Array)
+      @nodes = input_nodes.map {|e| Node.new(:level=>e[0], :value=>e[1]) }
+    else
+      @nodes = input_nodes.map {|e| Node.new(e)}
+    end
+    @nodes.each_with_index {|e,i| e.merge!(:tree=>self, :index=>i)}
+    @nodes.each {|e| e[:value] = e[:value].to_s }
+    validate_nodes if options[:validate]
+    self
+  end
+
+  def render
+    body = render_tree
+    body += render_description if @options[:description]
+    body
+  end
+  
+  def render_description
+    "\n\n#{@nodes.length} #{@nodes.length == 1 ? 'node' : 'nodes'} in tree"
+  end
+
+  def render_tree
+    @indent = ' ' * (@options[:indent] || 4 )
+    @nodes = @nodes.select {|e| e[:level] <= @options[:limit] } if @options[:limit]
+    case @type.to_s
+    when 'directory' then render_directory
+    when 'number'    then render_number
+    else render_basic
+    end
+  end
+
+  def render_nodes
+    value_indent = @options[:multi_line_nodes] ? @indent : nil
+    @nodes.map {|e| yield(e) + e.value(value_indent) }.join("\n")
+  end
+
+  def render_directory
+    mark_last_nodes_per_level
+    render_nodes {|e|
+      value = ''
+      unless e.root?
+        value << e.render_parent_characters
+        value << (e[:last_node] ? "`-- " : "|-- ")
+      end
+      value
+    }
+  end
+  
+  def render_number
+    counter = {}
+    @nodes.each {|e|
+      parent_level_key = "#{(e.parent ||{})[:index]}.#{e[:level]}"
+      counter[parent_level_key] ||= 0
+      counter[parent_level_key] += 1
+      e[:pre_value] = "#{counter[parent_level_key]}. "
+    }
+    render_nodes {|e| @indent * e[:level] + e[:pre_value] }
+  end
+
+  def render_basic
+    render_nodes {|e| @indent * e[:level] }
+  end
+
+  def validate_nodes
+    @nodes.each do |e|
+      raise ParentlessNodeError if (e[:level] > e.previous[:level]) && (e[:level] - e.previous[:level]) > 1
+    end
+  end
+  
+  # walks tree accumulating last nodes per unique parent+level
+  def mark_last_nodes_per_level
+    @nodes.each {|e| e.delete(:last_node)}
+    last_node_hash = @nodes.inject({}) {|h,e|
+      h["#{(e.parent ||{})[:index]}.#{e[:level]}"] = e; h
+    }
+    last_node_hash.values.uniq.each {|e| e[:last_node] = true}
+  end
+  #:startdoc:
+  class Node < ::Hash #:nodoc:
+    class MissingLevelError < StandardError; end
+    class MissingValueError < StandardError; end
+    
+    def initialize(hash)
+      super
+      raise MissingLevelError unless hash.has_key?(:level)
+      raise MissingValueError unless hash.has_key?(:value)
+      replace(hash)
+    end
+
+    def value(indent=nil)
+      indent ? self[:value].gsub("\n", "\n#{indent * self[:level]}") : self[:value]
+    end
+
+    def parent
+      self[:tree].nodes.slice(0 .. self[:index]).reverse.detect {|e| e[:level] < self[:level]}
+    end
+
+    def next
+      self[:tree].nodes[self[:index] + 1]
+    end
+
+    def previous
+      self[:tree].nodes[self[:index] - 1]
+    end
+
+    def root?; self[:level] == 0; end
+
+    # refers to characters which connect parent nodes 
+    def render_parent_characters
+      parent_chars = []
+      get_parents_character(parent_chars)
+      parent_chars.reverse.map {|level| level + ' ' * 3 }.join('')
+    end
+
+    def get_parents_character(parent_chars)
+      if self.parent
+        parent_chars << (self.parent[:last_node] ? ' ' : '|') unless self.parent.root?
+        self.parent.get_parents_character(parent_chars)
+      end
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
new file mode 100644
index 0000000..1f18f3e
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
@@ -0,0 +1,37 @@
+class Hirb::Helpers::VerticalTable < Hirb::Helpers::Table
+
+  # Renders a vertical table using the same options as Hirb::Helpers::Table.render except for the ones below
+  # and :max_fields, :vertical and :max_width which aren't used.
+  # ==== Options:
+  # [:hide_empty] Boolean which hides empty values (nil or '') from being displayed. Default is false.
+  def self.render(rows, options={})
+    new(rows, {:escape_special_chars=>false, :resize=>false}.merge(options)).render
+  end
+
+  #:stopdoc:
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+  end
+
+  def render_header; []; end
+  def render_footer; []; end
+
+  def render_rows
+    i = 0
+    longest_header = Hirb::String.size @headers.values.sort_by {|e| Hirb::String.size(e) }.last
+    stars = "*" * [(longest_header + (longest_header / 2)), 3].max
+    @rows.map do |row|
+      row = "#{stars} #{i+1}. row #{stars}\n" +
+      @fields.map {|f|
+        if !@options[:hide_empty] || (@options[:hide_empty] && !row[f].empty?)
+          "#{Hirb::String.rjust(@headers[f], longest_header)}: #{row[f]}"
+        else
+          nil
+        end
+      }.compact.join("\n")
+      i+= 1
+      row
+    end
+  end
+  #:startdoc:
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/import_object.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/import_object.rb
new file mode 100644
index 0000000..8bd0f1f
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/import_object.rb
@@ -0,0 +1,10 @@
+module Hirb
+  module ObjectMethods
+    # Takes same options as Hirb::View.render_output.
+    def view(*args)
+      Hirb::Console.render_output(*(args.unshift(self)))
+    end
+  end
+end
+
+Object.send :include, Hirb::ObjectMethods
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/menu.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/menu.rb
new file mode 100644
index 0000000..ffafd14
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/menu.rb
@@ -0,0 +1,221 @@
+module Hirb
+  # This class provides a menu using Hirb's table helpers by default to display choices.
+  # Menu choices (syntax at Hirb::Util.choose_from_array) refer to rows. However, when in
+  # two_d mode, choices refer to specific cells by appending a ':field' to a choice.
+  # A field name can be an abbreviated. Menus can also have an action mode, which turns the
+  # menu prompt into a commandline that executes the choices as arguments and uses methods as
+  # actions/commands.
+  class Menu
+    class Error < StandardError; end
+
+    # Detects valid choices and optional field/column
+    CHOSEN_REGEXP = /^(\d([^:]+)?)(?::)?(\S+)?/
+    CHOSEN_ARG = '%s'
+    DIRECTIONS = "Specify individual choices (4,7), range of choices (1-3) or all choices (*)."
+
+
+    # This method will return an array unless it's exited by simply pressing return, which returns nil.
+    # If given a block, the block will yield if and with any menu items are chosen.
+    # All options except for the ones below are passed to render the menu.
+    #
+    # ==== Options:
+    # [*:helper_class*]  Helper class to render menu. Helper class is expected to implement numbering given a :number option.
+    #                    To use a very basic menu, set this to false. Defaults to Hirb::Helpers::AutoTable.
+    # [*:prompt*]  String for menu prompt. Defaults to "Choose: ".
+    # [*:ask*] Always ask for input, even if there is only one choice. Default is true.
+    # [*:directions*] Display directions before prompt. Default is true.
+    # [*:readline*] Use readline to get user input if available. Input strings are added to readline history. Default is false.
+    # [*:two_d*] Turn menu into a 2 dimensional (2D) menu by allowing user to pick values from table cells. Default is false.
+    # [*:default_field*] Default field for a 2D menu. Defaults to first field in a table.
+    # [*:action*] Turn menu into an action menu by letting user pass menu choices as an argument to a method/command.
+    #             A menu choice's place amongst other arguments is preserved. Default is false.
+    # [*:multi_action*] Execute action menu multiple times iterating over the menu choices. Default is false.
+    # [*:action_object*] Object that takes method/command calls. Default is main.
+    # [*:command*] Default method/command to call when no command given.
+    # [*:reopen*] Reopens $stdin with given file or with /dev/tty when set to true. Use when
+    #             $stdin is already reading in piped data.
+    # Examples:
+    #     >> extend Hirb::Console
+    #     => self
+    #     >> menu [1,2,3], :prompt=> "So many choices, so little time: "
+    #     >> menu [{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:a,b], :two_d=>true)
+    def self.render(output, options={}, &block)
+      new(options).render(output, &block)
+    rescue Error=>e
+      $stderr.puts "Error: #{e.message}"
+    end
+
+    #:stopdoc:
+    def initialize(options={})
+      @options = {:helper_class=>Hirb::Helpers::AutoTable, :prompt=>"Choose: ", :ask=>true,
+        :directions=>true}.merge options
+      @options[:reopen] = '/dev/tty' if @options[:reopen] == true
+    end
+
+    def render(output, &block)
+      @output = Array(output)
+      return [] if @output.size.zero?
+      chosen = choose_from_menu
+      block.call(chosen) if block && chosen.size > 0
+      @options[:action] ? execute_action(chosen) : chosen
+    end
+
+    def get_input
+      prompt = pre_prompt + @options[:prompt]
+      prompt = DIRECTIONS+"\n"+prompt if @options[:directions]
+      $stdin.reopen @options[:reopen] if @options[:reopen]
+
+      if @options[:readline] && readline_loads?
+        get_readline_input(prompt)
+      else
+        print prompt
+        $stdin.gets.chomp.strip
+      end
+    end
+
+    def get_readline_input(prompt)
+      input = Readline.readline prompt
+      Readline::HISTORY << input
+      input
+    end
+
+    def pre_prompt
+      prompt = ''
+      prompt << "Default field: #{default_field}\n" if @options[:two_d] && default_field
+      prompt << "Default command: #{@options[:command]}\n" if @options[:action] && @options[:command]
+      prompt
+    end
+
+    def choose_from_menu
+      return unasked_choice if @output.size == 1 && !@options[:ask]
+
+      if (helper_class = Util.any_const_get(@options[:helper_class]))
+        View.render_output(@output, :class=>@options[:helper_class], :options=>@options.merge(:number=>true))
+      else
+        @output.each_with_index {|e,i| puts "#{i+1}: #{e}" }
+      end
+
+      parse_input get_input
+    end
+
+    def unasked_choice
+      return @output unless @options[:action]
+      raise(Error, "Default command and field required for unasked action menu") unless default_field && @options[:command]
+      @new_args = [@options[:command], CHOSEN_ARG]
+      map_tokens([[@output, default_field]])
+    end
+
+    def execute_action(chosen)
+      return nil if chosen.size.zero?
+      if @options[:multi_action]
+        chosen.each {|e| invoke command, add_chosen_to_args(e) }
+      else
+        invoke command, add_chosen_to_args(chosen)
+      end
+    end
+
+    def invoke(cmd, args)
+      action_object.send(cmd, *args)
+    end
+
+    def parse_input(input)
+      if (@options[:two_d] || @options[:action])
+        tokens = input_to_tokens(input)
+        map_tokens(tokens)
+      else
+        Util.choose_from_array(@output, input)
+      end
+    end
+
+    def map_tokens(tokens)
+      if return_cell_values?
+        @output[0].is_a?(Hash) ? tokens.map {|arr,f| arr.map {|e| e[f]} }.flatten :
+          tokens.map {|arr,f|
+            arr.map {|e| e.is_a?(Array) && f.is_a?(Integer) ? e[f] : e.send(f) }
+          }.flatten
+      else
+        tokens.map {|e| e[0] }.flatten
+      end
+    end
+
+    def return_cell_values?
+      @options[:two_d]
+    end
+
+    def input_to_tokens(input)
+      @new_args = []
+      tokens = (@args = split_input_args(input)).map {|word| parse_word(word) }.compact
+      cleanup_new_args
+      tokens
+    end
+
+    def parse_word(word)
+      if word[CHOSEN_REGEXP]
+        @new_args << CHOSEN_ARG
+        field = $3 ? unalias_field($3) : default_field ||
+          raise(Error, "No default field/column found. Fields must be explicitly picked.")
+        [Util.choose_from_array(@output, word), field ]
+      else
+        @new_args << word
+        nil
+      end
+    end
+
+    def cleanup_new_args
+      if @new_args.all? {|e| e == CHOSEN_ARG }
+        @new_args = [CHOSEN_ARG]
+      else
+        i = @new_args.index(CHOSEN_ARG) || raise(Error, "No rows chosen")
+        @new_args.delete(CHOSEN_ARG)
+        @new_args.insert(i, CHOSEN_ARG)
+      end
+    end
+
+    def add_chosen_to_args(items)
+      args = @new_args.dup
+      args[args.index(CHOSEN_ARG)] = items
+      args
+    end
+
+    def command
+      @command ||= begin
+        cmd = (@new_args == [CHOSEN_ARG]) ? nil : @new_args.shift
+        cmd ||= @options[:command] || raise(Error, "No command given for action menu")
+      end
+    end
+
+    def action_object
+      @options[:action_object] || eval("self", TOPLEVEL_BINDING)
+    end
+
+    def split_input_args(input)
+      input.split(/\s+/)
+    end
+
+    def default_field
+      @default_field ||= @options[:default_field] || fields[0]
+    end
+
+    # Has to be called after displaying menu
+    def fields
+      @fields ||= @options[:fields] || (@options[:ask] && table_helper_class? && Helpers::Table.last_table ?
+        Helpers::Table.last_table.fields[1..-1] : [])
+    end
+
+    def table_helper_class?
+      @options[:helper_class].is_a?(Class) && @options[:helper_class] < Helpers::Table
+    end
+
+    def unalias_field(field)
+      fields.sort_by {|e| e.to_s }.find {|e| e.to_s[/^#{field}/] } || raise(Error, "Invalid field '#{field}'")
+    end
+
+    def readline_loads?
+      require 'readline'
+      true
+    rescue LoadError
+      false
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/pager.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/pager.rb
new file mode 100644
index 0000000..8ff1250
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/pager.rb
@@ -0,0 +1,95 @@
+module Hirb
+  # This class provides class methods for paging and an object which can conditionally page given a terminal size that is exceeded.
+  class Pager
+    class<<self
+      # Pages using a configured or detected shell command.
+      def command_pager(output, options={})
+        basic_pager(output) if valid_pager_command?(options[:pager_command])
+      end
+
+      def pager_command(*commands) #:nodoc:
+        @pager_command = (!@pager_command.nil? && commands.empty?) ? @pager_command : 
+          begin
+            commands = [ENV['PAGER'], 'less', 'more', 'pager'] if commands.empty?
+            commands.compact.uniq.find {|e| Util.command_exists?(e[/\w+/]) }
+          end
+      end
+
+      # Pages with a ruby-only pager which either pages or quits.
+      def default_pager(output, options={})
+        pager = new(options[:width], options[:height])
+        while pager.activated_by?(output, options[:inspect])
+          puts pager.slice!(output, options[:inspect])
+          return unless continue_paging?
+        end
+        puts output
+        puts "=== Pager finished. ==="
+      end
+
+      #:stopdoc:
+      def valid_pager_command?(cmd)
+        cmd ? pager_command(cmd) : pager_command
+      end
+
+      private
+      def basic_pager(output)
+        pager = IO.popen(pager_command, "w")
+        begin
+          save_stdout = STDOUT.clone
+          STDOUT.reopen(pager)
+          STDOUT.puts output
+        rescue Errno::EPIPE
+        ensure
+         STDOUT.reopen(save_stdout)
+         save_stdout.close
+         pager.close
+        end
+      end
+
+      def continue_paging?
+        puts "=== Press enter/return to continue or q to quit: ==="
+        !$stdin.gets.chomp[/q/i]
+      end
+      #:startdoc:
+    end
+
+    attr_reader :width, :height
+
+    def initialize(width, height, options={})
+      resize(width, height)
+      @pager_command = options[:pager_command] if options[:pager_command]
+    end
+
+    # Pages given string using configured pager.
+    def page(string, inspect_mode)
+      if self.class.valid_pager_command?(@pager_command)
+        self.class.command_pager(string, :pager_command=>@pager_command)
+      else
+        self.class.default_pager(string, :width=>@width, :height=>@height, :inspect=>inspect_mode)
+      end
+    end
+
+    def slice!(output, inspect_mode=false) #:nodoc:
+      effective_height = @height - 2 # takes into account pager prompt
+      if inspect_mode
+        sliced_output = String.slice(output, 0, @width * effective_height)
+        output.replace String.slice(output, @width * effective_height, String.size(output))
+        sliced_output
+      else
+        # could use output.scan(/[^\n]*\n?/) instead of split
+        sliced_output = output.split("\n").slice(0, effective_height).join("\n")
+        output.replace output.split("\n").slice(effective_height..-1).join("\n")
+        sliced_output
+      end
+    end
+
+    # Determines if string should be paged based on configured width and height.
+    def activated_by?(string_to_page, inspect_mode=false)
+      inspect_mode ? (String.size(string_to_page) > @height * @width) : (string_to_page.count("\n") > @height)
+    end
+
+    def resize(width, height) #:nodoc:
+      @width, @height = View.determine_terminal_size(width, height)
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/string.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/string.rb
new file mode 100644
index 0000000..0d96585
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/string.rb
@@ -0,0 +1,44 @@
+module Hirb
+  # Provides string helpers to deal with UTF-8 and ruby 1.8.x
+  module String
+    extend self
+    # :stopdoc:
+    if RUBY_VERSION < '1.9'
+      def size(string)
+        string.scan(/./).length
+      end
+
+      def ljust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? string + " " * leftover : string
+      end
+
+      def rjust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? " " * leftover + string : string
+      end
+
+      def slice(string, start, finish)
+        string.scan(/./).slice(start, finish).join('')
+      end
+    else
+      def size(string)
+        string.length
+      end
+
+      def ljust(string, desired_length)
+        string.ljust(desired_length)
+      end
+
+      def rjust(string, desired_length)
+        string.rjust(desired_length)
+      end
+
+      def slice(*args)
+        string = args.shift
+        string.slice(*args)
+      end
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/util.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/util.rb
new file mode 100644
index 0000000..2db4b65
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/util.rb
@@ -0,0 +1,96 @@
+module Hirb
+  # Group of handy utility functions used throughout Hirb.
+  module Util
+    extend self
+    # Returns a constant like Module#const_get no matter what namespace it's nested in.
+    # Returns nil if the constant is not found.
+    def any_const_get(name)
+      return name if name.is_a?(Module)
+      begin
+        klass = Object
+        name.split('::').each {|e|
+          klass = klass.const_get(e)
+        }
+        klass
+      rescue
+         nil
+      end
+    end
+
+    # Recursively merge hash1 with hash2.
+    def recursive_hash_merge(hash1, hash2)
+      hash1.merge(hash2) {|k,o,n| (o.is_a?(Hash)) ? recursive_hash_merge(o,n) : n}
+    end
+
+    # From Rails ActiveSupport, converting undescored lowercase to camel uppercase.
+    def camelize(string)
+      string.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+    end
+
+    # Used by Hirb::Menu to select items from an array. Array counting starts at 1. Ranges of numbers are specified with a '-' or '..'.
+    # Multiple ranges can be comma delimited. Anything that isn't a valid number is ignored. All elements can be returned with a '*'.
+    # Examples:
+    #    1-3,5-6 -> [1,2,3,5,6]
+    #    *   -> all elements in array
+    #    ''  -> [] 
+    def choose_from_array(array, input, options={})
+      options = {:splitter=>","}.merge(options)
+      return array if input.strip == '*'
+      result = []
+      input.split(options[:splitter]).each do |e|
+        if e =~ /-|\.\./
+          min,max = e.split(/-|\.\./)
+          slice_min = min.to_i - 1
+          result.push(*array.slice(slice_min, max.to_i - min.to_i + 1))
+        elsif e =~ /\s*(\d+)\s*/
+          index = $1.to_i - 1
+          next if index < 0
+          result.push(array[index]) if array[index]
+        end
+      end
+      result
+    end
+
+    # Determines if a shell command exists by searching for it in ENV['PATH'].
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Returns [width, height] of terminal when detected, nil if not detected.
+    # Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
+    def detect_terminal_size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [`tput cols`.to_i, `tput lines`.to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        nil
+      end
+    rescue
+      nil
+    end
+
+    # Captures STDOUT of anything run in its block and returns it as string.
+    def capture_stdout(&block)
+      original_stdout = $stdout
+      $stdout = fake = StringIO.new
+      begin
+        yield
+      ensure
+        $stdout = original_stdout
+      end
+      fake.string
+    end
+
+    # From Rubygems, determine a user's home.
+    def find_home
+      ['HOME', 'USERPROFILE'].each {|e| return ENV[e] if ENV[e] }
+      return "#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}" if ENV['HOMEDRIVE'] && ENV['HOMEPATH']
+      File.expand_path("~")
+    rescue
+      File::ALT_SEPARATOR ? "C:/" : "/"
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/version.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/version.rb
new file mode 100644
index 0000000..58002c4
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/version.rb
@@ -0,0 +1,3 @@
+module Hirb
+  VERSION = '0.3.5'
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/view.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/view.rb
new file mode 100644
index 0000000..70a4563
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/view.rb
@@ -0,0 +1,270 @@
+module Hirb
+  # This class is responsible for managing all view-related functionality.
+  #
+  # == Create a View
+  # Let's create a simple view for Hash objects:
+  #   $ irb -rubygems
+  #   >> require 'hirb'
+  #   =>true
+  #   >> Hirb.enable
+  #   =>nil
+  #   >> require 'yaml'
+  #   =>true
+  #
+  #   # A view method is the smallest view
+  #   >> def yaml(output); output.to_yaml; end
+  #   => nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :method=>:yaml
+  #   => true
+  #
+  #   # Hashes now appear as yaml
+  #   >> {:a=>1, :b=>{:c=>3}}
+  #   ---
+  #   :a : 1
+  #   :b : 
+  #     :c : 3
+  #   => true
+  #
+  # Another way of creating a view is a Helper class:
+  #
+  #   # Create yaml view class
+  #   >> class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   =>nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :class=>Hirb::Helpers::Yaml
+  #   =>true
+  #
+  #   # Hashes appear as yaml like above ...
+  #
+  # == Configure a View
+  # To configure the above Helper class as a view, either pass Hirb.enable a hash:
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable :output=>{"Hash"=>{:class=>"Hirb::Helpers::Yaml"}}
+  #
+  # Or create a config file at config/hirb.yml or ~/.hirb.yml:
+  #   # The config file for the yaml example would look like:
+  #   # ---
+  #   # :output :
+  #   #   Hash :
+  #   #    :class : Hirb::Helpers::Yaml
+  #
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable
+  #
+  # For more about configuring Hirb, see the Config Files section in Hirb.
+  module View
+    DEFAULT_WIDTH = 120
+    DEFAULT_HEIGHT = 40
+    class<<self
+      attr_accessor :render_method
+      attr_reader :config
+
+      # This activates view functionality i.e. the formatter, pager and size detection. If irb exists, it overrides irb's output
+      # method with Hirb::View.view_output. When called multiple times, new configs are merged into the existing config.
+      # If using Wirble, you should call this after it. The view configuration can be specified in a hash via a config file,
+      # or as options to this method. In addition to the config keys mentioned in Hirb, options also take the following keys:
+      # ==== Options:
+      # * config_file: Name of config file(s) that are merged into existing config
+      # Examples:
+      #   Hirb.enable
+      #   Hirb.enable :formatter=>false
+      def enable(options={}, &block)
+        Array(options.delete(:config_file)).each {|e|
+          @new_config_file = true
+          Hirb.config_files << e
+        }
+        enable_output_method unless @output_method
+        merge_or_load_config options
+        resize(config[:width], config[:height])
+        @enabled = true
+      end
+
+      # Indicates if Hirb::View is enabled.
+      def enabled?
+        @enabled || false
+      end
+
+      # Disable's Hirb's output and revert's irb's output method if irb exists.
+      def disable
+        @enabled = false
+        disable_output_method if @output_method
+        false
+      end
+
+      # Toggles pager on or off. The pager only works while Hirb::View is enabled.
+      def toggle_pager
+        config[:pager] = !config[:pager]
+      end
+
+      # Toggles formatter on or off.
+      def toggle_formatter
+        config[:formatter] = !config[:formatter]
+      end
+
+      # Resizes the console width and height for use with the table and pager i.e. after having resized the console window. *nix users
+      # should only have to call this method. Non-*nix users should call this method with explicit width and height. If you don't know
+      # your width and height, in irb play with "a"* width to find width and puts "a\n" * height to find height.
+      def resize(width=nil, height=nil)
+        config[:width], config[:height] = determine_terminal_size(width, height)
+        pager.resize(config[:width], config[:height])
+      end
+      
+      # This is the main method of this class. When view is enabled, this method searches for a formatter it can use for the output and if
+      # successful renders it using render_method(). The options this method takes are helper config hashes as described in 
+      # Hirb::Formatter.format_output(). Returns true if successful and false if no formatting is done or if not enabled.
+      def view_output(output, options={})
+        enabled? && config[:formatter] && render_output(output, options)
+      rescue Exception=>e
+        if config[:ignore_errors]
+          $stderr.puts "Hirb Error: #{e.message}"
+          false
+        else
+          index = (obj = e.backtrace.find {|f| f =~ /^\(eval\)/}) ? e.backtrace.index(obj) : e.backtrace.length
+          $stderr.puts "Hirb Error: #{e.message}", e.backtrace.slice(0,index).map {|e| "    " + e }
+          true
+        end
+      end
+
+      # Captures STDOUT and renders it using render_method(). The main use case is to conditionally page captured stdout.
+      def capture_and_render(&block)
+        render_method.call Util.capture_stdout(&block)
+      end
+
+      # A lambda or proc which handles the final formatted object.
+      # Although this pages/puts the object by default, it could be set to do other things
+      # i.e. write the formatted object to a file.
+      def render_method
+        @render_method ||= default_render_method
+      end
+
+      # Resets render_method back to its default.
+      def reset_render_method
+        @render_method = default_render_method
+      end
+      
+      # Current console width
+      def width
+        config && config[:width] ? config[:width] : DEFAULT_WIDTH
+      end
+
+      # Current console height
+      def height
+        config && config[:height] ? config[:height] : DEFAULT_HEIGHT
+      end
+
+      # Current formatter config, storing a hash of all static views
+      def formatter_config
+        formatter.config
+      end
+
+      # Adds a view when View is enabled. See Formatter.add_view for more details.
+      def add(klass, view_config)
+        if enabled?
+          formatter.add_view(klass, view_config)
+        else
+          puts "View must be enabled to add a view"
+        end
+      end
+
+      #:stopdoc:
+      def enable_output_method
+        if defined? Ripl
+          @output_method = true
+          require 'ripl/hirb'
+        elsif defined? IRB
+          @output_method = true
+          ::IRB::Irb.class_eval do
+            alias_method :non_hirb_view_output, :output_value
+            def output_value #:nodoc:
+              Hirb::View.view_or_page_output(@context.last_value) || non_hirb_view_output
+            end
+          end
+        end
+      end
+
+      def disable_output_method
+        if defined?(IRB) && !defined? Ripl
+          ::IRB::Irb.send :alias_method, :output_value, :non_hirb_view_output
+        end
+        @output_method = nil
+      end
+
+      def view_or_page_output(str)
+        view_output(str) || page_output(str.inspect, true)
+      end
+
+      def render_output(output, options={})
+        if (formatted_output = formatter.format_output(output, options))
+          render_method.call(formatted_output)
+          true
+        else
+          false
+        end
+      end
+
+      def determine_terminal_size(width, height)
+        detected  = (width.nil? || height.nil?) ? Util.detect_terminal_size || [] : []
+        [width || detected[0] || DEFAULT_WIDTH , height || detected[1] || DEFAULT_HEIGHT]
+      end
+
+      def page_output(output, inspect_mode=false)
+        if enabled? && config[:pager] && pager.activated_by?(output, inspect_mode)
+          pager.page(output, inspect_mode)
+          true
+        else
+          false
+        end
+      end
+
+      def pager
+        @pager ||= Pager.new(config[:width], config[:height], :pager_command=>config[:pager_command])
+      end
+
+      def pager=(value); @pager = value; end
+
+      def formatter(reload=false)
+        @formatter = reload || @formatter.nil? ? Formatter.new(config[:output]) : @formatter
+      end
+
+      def formatter=(value); @formatter = value; end
+
+      def merge_or_load_config(additional_config={})
+        if @config && (@new_config_file || !additional_config.empty?)
+          Hirb.config = nil
+          load_config Util.recursive_hash_merge(@config, additional_config)
+          @new_config_file = false
+        elsif !@enabled
+          load_config(additional_config)
+        end
+      end
+
+      def load_config(additional_config={})
+        @config = Util.recursive_hash_merge default_config, additional_config
+        formatter(true)
+        true
+      end
+
+      def config_loaded?; !!@config; end
+
+      def config
+        @config
+      end
+      
+      def default_render_method
+        lambda {|output| page_output(output) || puts(output) }
+      end
+
+      def default_config
+        Util.recursive_hash_merge({:pager=>true, :formatter=>true}, Hirb.config || {})
+      end
+      #:startdoc:
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views.rb
new file mode 100644
index 0000000..330a802
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views.rb
@@ -0,0 +1,8 @@
+module Hirb
+  # Namespace for Helpers defining multiple views in a module i.e. via DynamicView.
+  module Views
+    module Single #:nodoc:
+    end
+  end
+end
+%w{rails orm mongo_db couch_db misc_db}.each {|e| require "hirb/views/#{e}" }
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
new file mode 100644
index 0000000..ad4ef11
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::CouchDb #:nodoc:
+  def default_couch(obj)
+    {:fields=>([:_id] + obj.class.properties.map {|e| e.name }) }
+  end
+
+  alias_method :couch_rest__extended_document_view, :default_couch
+  alias_method :couch_foo__base_view, :default_couch
+  alias_method :couch_potato__persistence_view, :default_couch
+end
+
+Hirb::DynamicView.add Hirb::Views::CouchDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
new file mode 100644
index 0000000..48f8d1b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
@@ -0,0 +1,15 @@
+module Hirb::Views::MiscDb #:nodoc:
+  def friendly__document_view(obj)
+    {:fields=>obj.class.attributes.keys - [:id]}
+  end
+
+  def ripple__document_view(obj)
+    {:fields=>obj.class.properties.keys}
+  end
+
+  def d_b_i__row_view(obj)
+    {:fields=>obj.column_names, :table_class=>Hirb::Helpers::Table}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::MiscDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
new file mode 100644
index 0000000..a79d35b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
@@ -0,0 +1,14 @@
+module Hirb::Views::MongoDb #:nodoc:
+  def mongoid__document_view(obj)
+    {:fields=>['_id'] + obj.class.fields.keys}
+  end
+
+  def mongo_mapper__document_view(obj)
+    fields = obj.class.column_names
+    fields.delete('_id') && fields.unshift('_id')
+    {:fields=>fields}
+  end
+  alias_method :mongo_mapper__embedded_document_view, :mongo_mapper__document_view
+end
+
+Hirb::DynamicView.add Hirb::Views::MongoDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/orm.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
new file mode 100644
index 0000000..ded4b9b
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::ORM #:nodoc:
+  def data_mapper__resource_view(obj)
+    {:fields=>obj.class.properties.map {|e| e.name }}
+  end
+
+  def sequel__model_view(obj)
+    {:fields=>obj.class.columns}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::ORM, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/rails.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
new file mode 100644
index 0000000..03105ff
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
@@ -0,0 +1,19 @@
+module Hirb::Views::Rails #:nodoc:
+  def active_record__base_view(obj)
+    {:fields=>get_active_record_fields(obj)}
+  end
+
+  def get_active_record_fields(obj)
+    fields = obj.class.column_names.map {|e| e.to_sym }
+    # if query used select
+    if obj.attributes.keys.sort != obj.class.column_names.sort
+      selected_columns = obj.attributes.keys
+      sorted_columns = obj.class.column_names.dup.delete_if {|e| !selected_columns.include?(e) }
+      sorted_columns += (selected_columns - sorted_columns)
+      fields = sorted_columns.map {|e| e.to_sym}
+    end
+    fields
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::Rails, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/lib/ripl/hirb.rb b/lib/bbcloud/vendor/hirb-0.3.5/lib/ripl/hirb.rb
new file mode 100644
index 0000000..c56a45d
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/lib/ripl/hirb.rb
@@ -0,0 +1,14 @@
+module Ripl::Hirb
+  def before_loop
+    super
+    require 'hirb'
+    Hirb.enable(Ripl.config[:hirb] || {}) unless Hirb::View.enabled?
+  end
+
+  def format_result(result)
+    return super if !Hirb::View.enabled?
+    Hirb::View.view_or_page_output(result) || super
+  end
+end
+
+Ripl::Shell.send :include, Ripl::Hirb
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/auto_table_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/auto_table_test.rb
new file mode 100644
index 0000000..8e90d9a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/auto_table_test.rb
@@ -0,0 +1,30 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "auto table" do
+  it "converts nonarrays to arrays and renders" do
+    require 'set'
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    +-------+
+    3 rows in set
+    TABLE
+    Helpers::AutoTable.render(::Set.new([1,2,3])).should == expected_table
+  end
+
+  it "renders hash" do
+    expected_table = <<-TABLE.unindent
+    +---+-------+
+    | 0 | 1     |
+    +---+-------+
+    | a | 12345 |
+    +---+-------+
+    1 row in set
+    TABLE
+    Helpers::AutoTable.render({:a=>12345}).should == expected_table
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/console_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/console_test.rb
new file mode 100644
index 0000000..b34a0ef
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/console_test.rb
@@ -0,0 +1,27 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Console" do
+  it "#table is called without Hirb enabled" do
+    extend Hirb::Console
+    reset_config
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 5     |
+    | 3     |
+    +-------+
+    2 rows in set
+    TABLE
+    capture_stdout {
+      table([5,3], :fields=>[:to_s])
+    }.should == expected_table +"\n"
+  end
+
+  it ".render_output sets config if it wasn't before" do
+    reset_config
+    View.expects(:render_output)
+    Console.render_output('blah')
+    View.config.is_a?(Hash).should == true
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/deps.rip b/lib/bbcloud/vendor/hirb-0.3.5/test/deps.rip
new file mode 100644
index 0000000..89eacd3
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/deps.rip
@@ -0,0 +1,4 @@
+bacon >=1.1.0
+mocha >=0
+mocha-on-bacon >=0
+bacon-bits >=0
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/dynamic_view_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/dynamic_view_test.rb
new file mode 100644
index 0000000..2523684
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/dynamic_view_test.rb
@@ -0,0 +1,94 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "DynamicView" do
+  def output_expects(output, expects)
+    Helpers::ObjectTable.expects(:render).with(output, expects)
+    Helpers::AutoTable.render(output)
+  end
+
+  describe "add" do
+    before_all { View.load_config }
+
+    it "raises error if no :helper option" do
+      lambda { Hirb.add_dynamic_view 'Blah', {} }.should.raise(ArgumentError).
+        message.should =~ /:helper.*required/
+    end
+
+    it "raises error if :helper option not a dynamic_view module" do
+      lambda { Hirb.add_dynamic_view('Blah', :helper=>:table) {|obj| } }.
+        should.raise(ArgumentError).message.should =~ /:helper.*must/
+    end
+
+    it "raises error if views module not a module" do
+      lambda { Hirb.add_dynamic_view 'Blah', :helper=>:auto_table }.should.raise(ArgumentError).
+        message.should =~ /must be a module/
+    end
+
+    it "adds a view with block" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "when adding views with a block, second view for same class overrides first one" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>[:blah]}
+      end
+      output_expects [Date.new], :fields=>[:blah]
+    end
+  end
+
+  it "class_to_method and method_to_class convert to each other" do
+    ["DBI::Row", "Hirb::View"].each do |e|
+      Helpers::AutoTable.method_to_class(DynamicView.class_to_method(e).downcase).should == e
+    end
+  end
+
+  it "class_to_method converts correctly" do
+    DynamicView.class_to_method("DBI::Row").should == 'd_b_i__row_view'
+  end
+
+  describe "dynamic_view" do
+    def define_view(mod_name= :Blah, &block)
+      mod = Views.const_set(mod_name, Module.new)
+      mod_block = block_given? ? block : lambda {|obj| {:fields=>obj.class::DAYNAMES}}
+      mod.send(:define_method, :date_view, mod_block)
+      Hirb.add_dynamic_view mod, :helper=>:auto_table
+    end
+
+    before_all { View.load_config }
+    before { Formatter.dynamic_config = {} }
+    after { Views.send(:remove_const, :Blah) }
+
+    it "sets a view's options" do
+      define_view
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "does override existing formatter dynamic_config" do
+      Formatter.dynamic_config["Date"] = {:class=>Helpers::Table}
+      define_view
+      Formatter.dynamic_config["Date"].should == {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+    end
+
+    it "raises a readable error when error occurs in a view" do
+      define_view {|obj| raise 'blah' }
+      lambda { Helpers::AutoTable.render([Date.new]) }.should.raise(RuntimeError).
+        message.should =~ /'Date'.*date_view.*\nblah/
+    end
+
+    it "another view can reuse an old view's options" do
+      define_view
+      define_view(:Blah2) do |obj|
+        {:fields=>obj.class::DAYNAMES + ['blah']}
+      end
+      output_expects [Date.new], :fields=>(Date::DAYNAMES + ['blah'])
+    end
+    after_all { reset_config }
+  end
+  after_all { Formatter.dynamic_config = {} }
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/formatter_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/formatter_test.rb
new file mode 100644
index 0000000..883f65e
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/formatter_test.rb
@@ -0,0 +1,176 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Formatter" do
+  def set_formatter(hash={})
+    @formatter = Formatter.new(hash)
+  end
+
+  describe "klass_config" do
+    it "recursively merges ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2], :options=>{:fields=>[:to_s]}},
+        "Object"=>{:method=>:object_output, :ancestor=>true, :options=>{:vertical=>true}},
+        "Kernel"=>{:method=>:default_output}
+      expected_result = {:method=>:object_output, :args=>[1, 2], :ancestor=>true, :options=>{:fields=>[:to_s], :vertical=>true}}
+      @formatter.klass_config(::String).should == expected_result
+    end
+
+    it "doesn't merge ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2]}, "Object"=>{:method=>:object_output},
+       "Kernel"=>{:method=>:default_output}
+      @formatter.klass_config(::String).should == {:args=>[1, 2]}
+    end
+
+    it "returns hash when nothing found" do
+      set_formatter.klass_config(::String).should == {}
+    end
+
+    describe "with dynamic_config" do
+      def set_formatter(hash={})
+        @formatter = Formatter.new(hash)
+      end
+      after { Formatter.dynamic_config = {}}
+
+      it "merges ancestor options and sets local config" do
+        Formatter.dynamic_config = {"Object"=>{:method=>:blah}, "Kernel"=>{:args=>[1,2], :ancestor=>true}}
+        set_formatter.klass_config(::String).should == {:args=>[1,2], :ancestor=>true}
+        @formatter.config['Kernel'].should == {:args=>[1,2], :ancestor=>true}
+      end
+
+      it "uses local config over dynamic_config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter "String"=>{:args=>[1,2]}
+        @formatter.klass_config(::String).should == {:args=>[1,2]}
+      end
+
+      it "uses dynamic_config and sets local config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter.klass_config(::String).should == {:method=>:blah}
+        @formatter.config['String'].should == {:method=>:blah}
+      end
+    end
+  end
+
+  describe "formatter methods:" do
+    before_all { eval "module ::Dooda; end" }
+
+    it "#add_view sets formatter config" do
+      @formatter = set_formatter
+      @formatter.add_view ::Dooda, :class=>"DoodaView"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView"}
+    end
+
+    it "#add_view overwrites existing formatter config" do
+      @formatter = set_formatter "Dooda"=>{:class=>"DoodaView"}
+      @formatter.add_view ::Dooda, :class=>"DoodaView2"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView2"}
+    end
+
+    it "#parse_console_options passes all options except for formatter options into :options" do
+      @formatter = set_formatter
+      options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :blah=>'blah'}
+      expected_options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :options=>{:blah=>'blah'}}
+      @formatter.parse_console_options(options).should == expected_options
+    end
+
+    it "#determine_output_class has exceptions for to_a" do
+      @formatter.determine_output_class(STDOUT).should == IO
+      @formatter.determine_output_class({:a=>1}).should == Hash
+    end
+  end
+
+  describe "format_output" do
+    def view_output(*args, &block); View.view_output(*args, &block); end
+    def render_method(*args); View.render_method(*args); end
+
+    def enable_with_output(value)
+      Hirb.enable :output=>value
+    end
+
+    before_all {
+      eval %[module ::Commify
+        def self.render(strings)
+          strings = Array(strings)
+          strings.map {|e| e.split('').join(',')}.join("\n")
+        end
+      end]
+      reset_config
+    }
+    before { View.formatter = nil; reset_config }
+    after { Hirb.disable }
+    
+    it "formats with method option" do
+      eval "module ::Kernel; def commify(string); string.split('').join(','); end; end"
+      enable_with_output "String"=>{:method=>:commify}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option as symbol" do
+      enable_with_output "String"=>{:class=>:auto_table}
+      Helpers::AutoTable.expects(:render)
+      view_output('dude')
+    end
+
+    it "formats arrays" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output(['dude'])
+    end
+
+    it "formats array-like objects" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      require 'set'
+      view_output Set.new(['dude'])
+    end
+
+    it "formats with options option" do
+      eval "module ::Blahify; def self.render(*args); end; end"
+      enable_with_output "String"=>{:class=>"Blahify", :options=>{:fields=>%w{a b}}}
+      Blahify.expects(:render).with('dude', :fields=>%w{a b})
+      view_output('dude')
+    end
+    
+    it "doesn't format and returns false when no format method found" do
+      Hirb.enable
+      render_method.expects(:call).never
+      view_output(Date.today).should == false
+    end
+    
+    it "formats with output_method option as method" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats with output_method option as proc" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>lambda {|e| e.chop}}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats output array with output_method option" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with("d,u,d\nm,a")
+      view_output(['dude', 'man'])
+    end
+
+    it "formats with explicit class option" do
+      enable_with_output 'String'=>{:class=>"Blahify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude', :class=>"Commify")
+    end
+    
+    it "formats with explicit options option merges with existing options" do
+      enable_with_output "String"=>{:class=>"Commify", :options=>{:fields=>%w{f1 f2}}}
+      Commify.expects(:render).with('dude', :max_width=>10, :fields=>%w{f1 f2})
+      view_output('dude', :options=>{:max_width=>10})
+    end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/hirb_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/hirb_test.rb
new file mode 100644
index 0000000..58edc95
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/hirb_test.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Hirb" do
+  before_all { Hirb.config_files = nil }
+  before { Hirb.config = nil }
+
+  it "config converts yaml when config file exists" do
+    yaml_data = {:blah=>'blah'}
+    File.stubs('exists?').returns(true)
+    Hirb.config_files = ['ok']
+    YAML::expects(:load_file).returns(yaml_data)
+    Hirb.config.should == yaml_data
+  end
+  
+  it "config defaults to hash when no config file" do
+    File.stubs('exists?').returns(false)
+    Hirb.config.should == {}
+  end
+  
+  it "config reloads if given explicit reload" do
+    Hirb.config
+    Hirb.expects(:read_config_file).returns({})
+    Hirb.config(true)
+  end
+
+  it "config reads multiple config files and merges them" do
+    Hirb.config_files = %w{one two}
+    Hirb.expects(:read_config_file).times(2).returns({:output=>{"String"=>:auto_table}}, {:output=>{"Array"=>:auto_table}})
+    Hirb.config.should == {:output=>{"Array"=>:auto_table, "String"=>:auto_table}}
+    Hirb.config_files = nil
+  end
+
+  it "config_file sets correctly when no ENV['HOME']" do
+    Hirb.config_files = nil
+    home = ENV.delete('HOME')
+    Hirb.config_files[0].class.should == String
+    ENV["HOME"] = home
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/import_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/import_test.rb
new file mode 100644
index 0000000..0a75368
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/import_test.rb
@@ -0,0 +1,9 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "import" do
+  it "require import_object extends Object" do
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == false
+    require 'hirb/import_object'
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == true
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/menu_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/menu_test.rb
new file mode 100644
index 0000000..d8f57db
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/menu_test.rb
@@ -0,0 +1,239 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Menu" do
+  before_all { View.instance_variable_set("@config", :width=>Hirb::View::DEFAULT_WIDTH) }
+
+  def menu(*args, &block)
+    # testing via menu's main use case (through console) instead of Menu.render
+    @console ||= Object.new.extend(Hirb::Console)
+    @console.menu(*args, &block)
+  end
+
+  def basic_menu(*args, &block)
+    menu_input('1')
+    capture_stdout { menu(*args, &block).should == [1] }
+  end
+
+  def menu_input(input='')
+    $stdin.expects(:gets).returns(input)
+  end
+
+  describe "menu" do
+    it "by default renders table menu" do
+      expected_menu = <<-MENU.unindent
+      +--------+-------+
+      | number | value |
+      +--------+-------+
+      | 1      | 1     |
+      | 2      | 2     |
+      | 3      | 3     |
+      +--------+-------+
+      3 rows in set
+      MENU
+      basic_menu([1,2,3]).include?(expected_menu).should == true
+    end
+
+    it "with block renders" do
+      menu_input "1,2"
+      expected_result = [1,2]
+      capture_stdout { 
+        menu([1,2,3]) {|e| e.should == expected_result }.should == expected_result
+      }
+    end
+
+    it "with block and no chosen doesn't call block" do
+      menu_input ""
+      block = lambda {|e| @called = true }
+      capture_stdout {
+        menu([1,2,3], &block).should == []
+      }
+      assert !@called
+    end
+
+    it "with valid helper_class option renders" do
+      Helpers::Table.expects(:render)
+      basic_menu [1,2,3], :helper_class=>"Hirb::Helpers::Table"
+    end
+
+    it "with invalid helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>"SomeHelper").include?(expected_menu).should == true
+    end
+
+    it "with false helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>false).include?(expected_menu).should == true
+    end
+
+    it "prints prompt option" do
+      prompt = "Input or else ..."
+      basic_menu([1,2,3], :prompt=>prompt).include?(prompt).should == true
+    end
+
+    it "converts non-array inputs to array" do
+      Helpers::AutoTable.expects(:render).with([1], anything)
+      basic_menu 1
+    end
+
+    it "with false ask option returns one choice without asking" do
+      $stdin.expects(:gets).never
+      menu([1], :ask=>false).should == [1]
+    end
+
+    it "with no items to choose from always return without asking" do
+      $stdin.expects(:gets).never
+      menu([], :ask=>false).should == []
+      menu([], :ask=>true).should == []
+    end
+
+    it "with directions option turns off directions" do
+      menu_input('blah')
+      capture_stdout { menu([1], :directions=>false) }.should.not =~ /range.*all/
+    end
+
+    it "with true reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/tty')
+      basic_menu [1], :reopen=>true
+    end
+
+    it "with string reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/blah')
+      basic_menu [1], :reopen=>'/dev/blah'
+    end
+  end
+
+  def two_d_menu(options={})
+    if options[:invokes] || options[:invoke]
+      cmd = options[:command] || 'p'
+      (options[:invokes] || [options[:invoke]]).each {|e|
+        Menu.any_instance.expects(:invoke).with(cmd, e)
+      }
+    end
+
+    capture_stdout {
+      return menu(options[:output] || [{:a=>1, :bro=>2}, {:a=>3, :bro=>4}],
+       {:two_d=>true}.merge(options))
+    }
+  end
+
+  describe "2d menu" do
+    it "with default field from last_table renders" do
+      menu_input "1"
+      two_d_menu.should == [1]
+    end
+
+    it "with default field from fields option renders" do
+      menu_input "1"
+      two_d_menu(:fields=>[:bro, :a]).should == [2]
+    end
+
+    it "with default field option renders" do
+      menu_input "1"
+      two_d_menu(:default_field=>:bro).should == [2]
+    end
+
+    it "with non-table helper class renders" do
+      menu_input "1"
+      two_d_menu(:helper_class=>false, :fields=>[:a,:bro]).should == [1]
+    end
+
+    it "with no default field prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:fields=>[]) }.should =~ /No default.*found/
+    end
+
+    it "with invalid field prints error" do
+      menu_input "1:z"
+      capture_stderr { two_d_menu }.should =~ /Invalid.*'z'/
+    end
+
+    it "with choice from abbreviated field" do
+      menu_input "2:b"
+      two_d_menu.should == [4]
+    end
+
+    it "with choices from multiple fields renders" do
+      menu_input "1 2:bro"
+      two_d_menu.should == [1,4]
+    end
+  end
+
+  describe "action menu" do
+    it "invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :invoke=>[[1,4]])
+    end
+
+    it "with 1d invokes" do
+      menu_input "p 1"
+      two_d_menu(:action=>true, :two_d=>nil, :invoke=>[[{:a=>1, :bro=>2}]])
+    end
+
+    it "with non-choice arguments invokes" do
+      menu_input "p arg1 1"
+      two_d_menu :action=>true, :invoke=>['arg1', [1]]
+    end
+
+    it "with multiple choice arguments flattens them into arg" do
+      menu_input "p arg1 1 2:bro arg2"
+      two_d_menu :action=>true, :invoke=>['arg1', [1,4], 'arg2']
+    end
+
+    it "with nothing chosen prints error" do
+      menu_input "cmd"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No rows chosen/
+    end
+
+    it "with no command given prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No command given/
+    end
+
+    it "with array menu items" do
+      menu_input "p 1"
+      two_d_menu :action=>true, :output=>[['some', 'choice'], ['and', 'another']],
+        :invokes=>[[['some']]]
+    end
+
+    it "with multi_action option invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :multi_action=>true, :invokes=>[[1], [4]])
+    end
+
+    it "with command option invokes" do
+      menu_input "1"
+      two_d_menu(:action=>true, :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with command option and empty input doesn't invoke action and exists silently" do
+      Menu.any_instance.expects(:invoke).never
+      menu_input ""
+      two_d_menu(:action=>true, :command=>'p').should == nil
+    end
+
+    it "with action_object option invokes" do
+      obj = mock(:blah=>true)
+      menu_input "blah 1"
+      two_d_menu(:action=>true, :action_object=>obj)
+    end
+
+    it "with ask false and defaults invokes" do
+      two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :default_field=>:a,
+        :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with ask false and no defaults prints error" do
+      capture_stderr {
+        two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :command=>'p')
+      }.should =~ /Default.*required/
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/object_table_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/object_table_test.rb
new file mode 100644
index 0000000..c0ef8f2
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/object_table_test.rb
@@ -0,0 +1,79 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "object table" do
+  def table(*args)
+    Helpers::ObjectTable.render(*args)
+  end
+
+  before_all {
+    @pets = [stub(:name=>'rufus', :age=>7, :to_s=>'rufus'), stub(:name=>'alf', :age=>101, :to_s=>'alf')]
+  }
+  it "renders" do
+    expected_table = <<-TABLE.unindent
+    +-------+-----+
+    | name  | age |
+    +-------+-----+
+    | rufus | 7   |
+    | alf   | 101 |
+    +-------+-----+
+    2 rows in set
+    TABLE
+    table(@pets, :fields=>[:name, :age]).should == expected_table
+  end
+  
+  it "with no options defaults to to_s field" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | rufus |
+    | alf   |
+    +-------+
+    2 rows in set
+    TABLE
+    table(@pets).should == expected_table
+  end
+
+  it "renders simple arrays" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    | 4     |
+    +-------+
+    4 rows in set
+    TABLE
+    table([1,2,3,4]).should == expected_table
+  end
+
+  it "renders simple arrays with custom header" do
+    expected_table = <<-TABLE.unindent
+    +-----+
+    | num |
+    +-----+
+    | 1   |
+    | 2   |
+    | 3   |
+    | 4   |
+    +-----+
+    4 rows in set
+    TABLE
+    table([1,2,3,4], :headers=>{:to_s=>'num'}).should == expected_table
+  end
+
+  it "with empty fields" do
+    expected_table = <<-TABLE.unindent
+    0 rows in set
+    TABLE
+    table(@pets, :fields => []).should == expected_table
+  end
+
+  it "doesn't raise error for objects that don't have :send defined" do
+    object = Object.new
+    class<<object; self; end.send :undef_method, :send
+    should.not.raise(NoMethodError) { table([object], :fields=>[:to_s]) }
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/pager_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/pager_test.rb
new file mode 100644
index 0000000..4878e12
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/pager_test.rb
@@ -0,0 +1,162 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Pager" do
+  def pager; View.pager; end
+
+  def create_pageable_string(inspect_mode=false, size={})
+    size = {:width=>pager.width, :height=>pager.height}.merge(size)
+    seed = inspect_mode ? "a" : "a\n"
+    if inspect_mode
+      seed * (size[:width] * size[:height] + 1)
+    else
+      seed * (size[:height] + 1)
+    end
+  end
+
+  it "command_pager sets pager_command when command exists" do
+    Util.expects(:command_exists?).returns(true)
+    Pager.expects(:basic_pager)
+    Pager.command_pager 'blah', :pager_command=>'less'
+  end
+
+  it "command_pager doesn't set pager_command when command doesn't exist" do
+    Util.expects(:command_exists?).returns(false)
+    Pager.expects(:basic_pager).never
+    Pager.command_pager 'blah', :pager_command=>'moreless'
+  end
+
+  describe "default_pager" do
+    before_all { reset_config; Hirb.enable :pager=>true }
+    before { View.pager = nil; Pager.stubs(:pager_command).returns(nil) }
+
+    it "pages once in normal mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string, false) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in normal mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a\n", false) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+
+    it "pages once in inspect mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string(true), true) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in inspect mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a", true) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+    after_all { Hirb.disable }
+  end
+
+  describe "pager" do
+    before_all { reset_config; Hirb.enable }
+    before { View.pager = nil; View.formatter = nil }
+
+    def irb_eval(string)
+      context_stub = stub(:last_value=>string)
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    # this mode is called within @irb.output_value
+    describe "in inspect_mode" do
+      it "activates when output is wide enough" do
+        output = create_pageable_string(true)
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "doesn't activate when output isn't wide enough" do
+        pager.expects(:page).never
+        View.expects(:render_output).returns(false)
+        irb_eval("a")
+      end
+
+      it "activates with an explicit width" do
+        View.config[:width] = 10
+        output = create_pageable_string true, :width=>10
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "activates default_pager when pager command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string(true)
+        Pager.expects(:default_pager).with(output.inspect, anything)
+        View.expects(:render_output).returns(false)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    # this mode is called within View.render_output
+    describe "in normal mode" do
+      it "activates when output is long enough" do
+        output = create_pageable_string
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "doesn't activate when output isn't long enough" do
+        output = "a\n"
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).never
+        capture_stdout { irb_eval(output) }
+      end
+
+      it "activates with an explicit height" do
+        View.config[:height] = 100
+        output = create_pageable_string false, :height=>100
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "activates default_pager when pager_command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string
+        Pager.expects(:default_pager).with(output, anything)
+        View.formatter.expects(:format_output).returns(output)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    it "activates pager_command with valid pager_command option" do
+      View.config[:pager_command] = "less"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "activates pager_command with pager_command option that has command options" do
+      View.config[:pager_command] = "less -r"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).with('less').returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "doesn't activate pager_command with invalid pager_command option" do
+      View.config[:pager_command] = "moreless"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(false)
+      Pager.expects(:default_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+  end
+  after_all { Hirb.disable }
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/resizer_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/resizer_test.rb
new file mode 100644
index 0000000..55160a7
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/resizer_test.rb
@@ -0,0 +1,62 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Resizer" do
+  def table(options)
+    @table = Helpers::Table.new [options[:field_lengths].keys.inject({}) {|t,e| t[e] = '1'; t}]
+    @table.field_lengths = options[:field_lengths]
+    @table.width = options[:width]
+    @table.max_fields = options[:max_fields] if options[:max_fields]
+    @width, @field_lengths = @table.width, @table.field_lengths
+    @table
+  end
+
+  it "resize ensures columns total doesn't exceed max width" do
+    table :field_lengths=>{:f1=>135, :f2=>45, :f3=>4, :f4=>55}, :width=>195
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+  end
+
+  it "resize sets columns by relative lengths" do
+    table :field_lengths=>{:a=>30, :b=>30, :c=>40}, :width=>60
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.uniq.size.should.not == 1
+  end
+
+  it "resize sets all columns roughly equal when adusting long fields don't work" do
+    table :field_lengths=>{:field1=>10, :field2=>15, :field3=>100}, :width=>20
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.each {|e| e.should <= 4 }
+  end
+
+  describe "add_extra_width and max_fields" do
+    def table_and_resize(options={})
+      defaults = {:field_lengths=>{:f1=>135, :f2=>30, :f3=>4, :f4=>100}, :width=>195, :max_fields=>{:f1=>80, :f4=>30} }
+      @table = table defaults.merge(options)
+      # repeated from table since instance variables aren't copied b/n contexts
+      @width, @field_lengths = @table.width, @table.field_lengths
+      Helpers::Table::Resizer.resize! @table
+    end
+
+    it "doesn't add to already maxed out field" do
+      table_and_resize
+      @field_lengths[:f3].should == 4
+    end
+
+    it "restricted before adding width" do
+      table_and_resize
+      @field_lengths[:f4].should <= 30
+    end
+
+    it "adds to restricted field" do
+      table_and_resize
+      @field_lengths[:f1].should <= 80
+    end
+
+    it "adds to unrestricted field" do
+      table_and_resize :field_lengths=>{:f1=>135, :f2=>70, :f3=>4, :f4=>100}
+      @field_lengths[:f2].should == 70
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/table_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/table_test.rb
new file mode 100644
index 0000000..1247a42
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/table_test.rb
@@ -0,0 +1,550 @@
+# encoding: UTF-8
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Table" do
+  def table(*args)
+    Helpers::Table.render(*args)
+  end
+  before_all { reset_config }
+  
+  describe "basic table" do
+    it "renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}]).should == expected_table
+    end
+    
+    it "with no headers renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 | 2 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>2}], :headers=>false).should == expected_table
+    end
+
+    it "with no headers and nil fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 |   |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>nil}], :headers=>false).should == expected_table
+    end
+
+    it "with string keys renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}]).should == expected_table
+    end
+
+    it "with array only rows renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]]).should == expected_table
+    end
+
+    it "with too many fields defaults to vertical table" do
+      rows = [Array.new(25, "A"* 10)]
+      Helpers::VerticalTable.expects(:render).with(rows, anything)
+      capture_stderr { table(rows)}.should =~ /Error/
+    end
+
+    it "with no rows renders" do
+      table([]).should == "0 rows in set"
+    end
+
+    it "with invalid rows raises an argumenterror" do
+      lambda { table(:a=>1) }.should.raise(ArgumentError).message.should =~ /Table must/
+    end
+
+    it "renders utf8" do
+      expected_table = <<-TABLE.unindent
+      +--------------------+
+      | name               |
+      +--------------------+
+      |             |
+      |        |
+      | Tata l'asticote    |
+      | toto ltoile PAOLI |
+      +--------------------+
+      4 rows in set
+      TABLE
+      table([{:name=>""}, {:name=>""}, {:name=>"Tata l'asticote"}, {:name=>"toto ltoile PAOLI"}]).should == expected_table
+    end
+
+    it "stringifies newlines and tabs and renders" do
+      expected_table = <<-TABLE.unindent
+      +-----+---+
+      | a   | b |
+      +-----+---+
+      | 1#{'\n'} | 2 |
+      | 3#{'\t'} | 4 |
+      +-----+---+
+      2 rows in set
+      TABLE
+      value = [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+      table(value).should == expected_table
+      value.should == [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+    end
+
+    it "with a field of only array values renders values comma joined" do
+      expected_table = <<-TABLE.unindent
+      +----+------+
+      | a  | b    |
+      +----+------+
+      | 1  | 1, 2 |
+      | ok | 3, 4 |
+      +----+------+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>[1,2]}, {:a=>'ok', :b=>[3,4]}]).should == expected_table
+    end
+
+    it "with filter class default doesn't override explicit filters" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | a    | 1     |
+      +------+-------+
+      1 row in set
+      TABLE
+      table([{:name=>'a', :value=>{:b=>1}}], :filters=>{:value=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with" do
+    it "fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | a |
+      +---+---+
+      | 2 | 1 |
+      | 4 | 3 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :a]).should == expected_table
+    end
+    
+    it "fields option and array only rows" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 2 |
+      +---+---+
+      | 1 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([[1,2,3]], :fields=>[0,2]).should == expected_table
+    end
+
+    it "fields and number options copies fields option and does not modify it" do
+      options = {:fields=>[:f1], :number=>true}
+      table([{:f1=>1, :f2=>2}], options)
+      options[:fields].should == [:f1]
+    end
+  
+    it "invalid fields option renders empty columns" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | c |
+      +---+---+
+      | 2 |   |
+      | 4 |   |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :c]).should == expected_table
+    end
+  
+    it "invalid field in max_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10,:c=>10}).should == expected_table
+    end
+  
+    it "max_fields option with fields less than 3 characters renders" do
+      expected_table = <<-TABLE.unindent
+      +----+---+
+      | a  | b |
+      +----+---+
+      | AA | 2 |
+      +----+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>2}, :resize=>false).should == expected_table
+    end
+  
+    it "max_fields option without resize renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10}, :resize=>false).should == expected_table
+    end
+
+    it "max_fields option with percentage renders" do
+      expected_table = <<-TABLE.unindent
+      +------------------+---+
+      | a                | b |
+      +------------------+---+
+      | AAAAAAAAAAAAA... | 2 |
+      +------------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>'0.15'}).should == expected_table
+    end
+  
+    it "max_width option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :max_width=>30).should == expected_table
+    end
+
+    it "resize option false renders full table" do
+      expected_table = <<-TABLE.unindent
+      +----------------------------------------------------+---+------------+
+      | a                                                  | b | c          |
+      +----------------------------------------------------+---+------------+
+      | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | 2 | CCCCCCCCCC |
+      +----------------------------------------------------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :resize=>false).should == expected_table
+    end
+    
+    it "global width renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      View.load_config
+      View.resize(30)
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}]).should == expected_table
+      reset_config
+    end
+
+    it "headers option and headers longer than fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---------+---------+
+      | a | field B | field C |
+      +---+---------+---------+
+      | A | 2       | C       |
+      +---+---------+---------+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2, :c=>"C"}], :headers=>{:b=>"field B", :c=>"field C"}).should == expected_table
+    end
+  
+    it "headers option and headers shortened by max_fields renders" do
+      expected_table = <<-TABLE.unindent
+      +-------+---+
+      | fi... | b |
+      +-------+---+
+      | A     | 2 |
+      +-------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2}], :headers=>{:a=>"field A"}, :max_fields=>{:a=>5}, :resize=>false).should == expected_table
+    end
+    
+    it "headers option as an array renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]], :headers=>['A', 'B']).should == expected_table
+    end
+
+    it "header_filter option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 2 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=> 2, :b=>3}], :header_filter=>:capitalize).should == expected_table
+    end
+
+    it "filters option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+
+      | 0         | 1 |
+      +-----------+---+
+      | s,o,m,e   | 2 |
+      | t,h,i,n,g | 1 |
+      +-----------+---+
+      2 rows in set
+      TABLE
+      table([['some', {:num=>2}], ['thing', {:num=>1}]], :filters=>{0=>lambda {|e| e.split("").join(",")},
+        1=>[:[], :num]}).should == expected_table
+    end
+
+    it "filters option calls Filters method and renders" do
+      module ::Hirb::Helpers::Table::Filters
+        def semicolon_join(arr); arr.join('; '); end
+      end
+
+      expected_table = <<-TABLE.unindent
+      +------+------------------------------+
+      | 0    | 1                            |
+      +------+------------------------------+
+      | some | unsightly; unreadable; array |
+      +------+------------------------------+
+      1 row in set
+      TABLE
+      table([[['some'], %w{unsightly unreadable array}]], :filters=>{1=>:semicolon_join}).should == expected_table
+    end
+
+    it "number option renders" do
+      expected_table = <<-TABLE.unindent
+      +--------+---+---+
+      | number | 0 | 1 |
+      +--------+---+---+
+      | 1      | a | b |
+      | 2      | c | d |
+      +--------+---+---+
+      2 rows in set
+      TABLE
+      table([['a','b'], ['c', 'd']], :number=>true).should == expected_table
+    end
+
+    it "description option false renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | a | b |
+      | c | d |
+      +---+---+
+      TABLE
+      table([['a','b'], ['c', 'd']], :description=>false).should == expected_table
+    end
+
+    it "vertical option renders vertical table" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table with newlines" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      and one
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>"4\nand one"}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table successively" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      options = {:vertical=>true}
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+    end
+
+    it "hide_empty and vertical options renders" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      b: 2
+      *** 2. row ***
+      a: 3
+      2 rows in set
+      TABLE
+      table([{:a=>'', :b=>2}, {:a=>3, :b=>nil}], :hide_empty=>true, :vertical=>true).should == expected_table
+    end
+
+    it "all_fields option renders all fields" do
+      expected_table = <<-TABLE.unindent
+      +---+---+---+
+      | a | b | c |
+      +---+---+---+
+      | 1 | 2 |   |
+      | 3 |   | 4 |
+      +---+---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :c=>4}], :all_fields=>true).should == expected_table
+    end
+
+    it "change_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>{0=>'name', 1=>'value'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value']).should == expected_table
+    end
+
+    it "change_fields and fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+
+      | name |
+      +------+
+      | 1    |
+      | 2    |
+      +------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>['name', 'value'], :fields=>['name']).should == expected_table
+    end
+
+    it "invalid fields in change_fields options are ignored" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([{:a=>1,:b=>2}, {:a=>2,:b=>3}], :change_fields=>{:a=>'name', :b=>'value', :c=>'time'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value','time']).should == expected_table
+    end
+
+    it "filter_any option filters any value" do
+      expected_table = <<-TABLE.unindent
+      +---------+
+      | a       |
+      +---------+
+      | {:b=>1} |
+      | 2       |
+      +---------+
+      2 rows in set
+      TABLE
+      table([{:a=>{:b=>1}}, {:a=>2}], :filter_any=>true).should == expected_table
+    end
+
+    it "filter_classes option overrides class-wide filter_classes" do
+      expected_table = <<-TABLE.unindent
+      +---+
+      | a |
+      +---+
+      | 1 |
+      +---+
+      1 row in set
+      TABLE
+      table([{:a=>{:b=>1}}], :filter_classes=>{Hash=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with callbacks" do
+    before_all {
+      Helpers::Table.send(:define_method, :and_one_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] += opt[:add] } }
+        obj
+      end
+    }
+    it "detects and runs them" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1).should == expected_table
+    end
+
+    it "doesn't run callbacks in delete_callbacks option" do
+      Helpers::Table.send(:define_method, :and_two_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] = row[k] * 2 } }
+        obj
+      end
+
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1, :delete_callbacks=>[:and_two]).should == expected_table
+
+      Helpers::Table.send(:remove_method, :and_two_callback)
+    end
+    after_all { Helpers::Table.send(:remove_method, :and_one_callback) }
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/test_helper.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/test_helper.rb
new file mode 100644
index 0000000..4706d0a
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/test_helper.rb
@@ -0,0 +1,61 @@
+require 'bacon'
+require 'bacon/bits'
+require 'mocha'
+require 'mocha-on-bacon'
+require 'hirb'
+include Hirb
+
+module TestHelpers
+  # set these to avoid invoking stty multiple times which doubles test suite running time
+  ENV["LINES"] = ENV["COLUMNS"] = "20"
+  def reset_terminal_size
+    ENV["LINES"] = ENV["COLUMNS"] = "20"
+  end
+
+  def capture_stdout(&block)
+    original_stdout = $stdout
+    $stdout = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stdout = original_stdout
+    end
+    fake.string
+  end
+
+  def capture_stderr(&block)
+    original_stderr = $stderr
+    $stderr = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stderr = original_stderr
+    end
+    fake.string
+  end
+
+  def reset_config
+    View.instance_eval "@config = nil"
+  end
+end
+
+class Bacon::Context
+  include TestHelpers
+end
+
+class String
+  def unindent(num=nil)
+    regex = num ? /^\s{#{num}}/ : /^\s*/
+    gsub(regex, '').chomp
+  end
+end
+
+# mocks IRB for View + Pager
+module ::IRB
+  class Irb
+    def initialize(context)
+      @context = context
+    end
+    def output_value; end
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/tree_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/tree_test.rb
new file mode 100644
index 0000000..cd046ef
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/tree_test.rb
@@ -0,0 +1,184 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Tree helpers:" do
+  def tree(*args)
+    Helpers::Tree.render(*args)
+  end
+  
+  describe "basic tree" do
+    it "with hash nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([{:level=>0, :value=>'0.0'}, {:level=>1, :value=>'1.1'}, {:level=>2, :value=>'2.2'},{:level=>2, :value=>'3.2'},
+         {:level=>1, :value=>'4.1'}]).should == expected_tree
+    end
+  
+    it "with array nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]]).should == expected_tree
+    end
+    
+    it "with non-string values renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0,0.0],[1,1.1],[2,2.2],[2,3.2],[1,4.1]]).should == expected_tree
+    end
+
+    it "with indent option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+        1.1
+          2.2
+          3.2
+        4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :indent=>2).should == expected_tree
+    end
+
+    it "with limit option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :limit=>1).should == expected_tree
+    end
+
+    it "with description option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      
+      5 nodes in tree
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :description=>true).should == expected_tree
+    end
+
+    it "with type directory renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :type=>:directory).should == expected_tree
+    end
+
+    it "with type directory and multiple children per level renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   |   `-- 3.3
+      |   `-- 4.2
+      |       `-- 5.3
+      `-- 6.1
+      TREE
+      tree([[0,'0.0'], [1,'1.1'], [2,'2.2'],[3,'3.3'],[2,'4.2'],[3,'5.3'],[1,'6.1']], :type=>:directory).should == expected_tree
+    end
+
+    it "with type number renders" do
+      expected_tree = <<-TREE.unindent(6)
+      1. 0
+          1. 1
+              1. 2
+              2. 3
+          2. 4
+      TREE
+      tree([[0,'0'],[1,'1'],[2,'2'],[2,'3'],[1,'4']], :type=>:number).should == expected_tree
+    end
+
+    it "with multi-line nodes option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      parent
+          +-------+
+          | value |
+          +-------+
+          | 1     |
+          | 2     |
+          | 3     |
+          +-------+
+              indented
+              stuff
+      TREE
+      node1 = "+-------+\n| value |\n+-------+\n| 1     |\n| 2     |\n| 3     |\n+-------+"
+      tree([ [0, 'parent'],[1, node1],[2, "indented\nstuff"]], :multi_line_nodes=>true).should == expected_tree
+    end
+  end
+
+  def mock_node(value, value_method)
+    children = []
+    value,children = *value if value.is_a?(Array)
+    mock(value_method=>value, :children=>children.map {|e| mock_node(e, value_method)})
+  end
+
+  describe "parent_child_tree" do
+    it "with name value renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :name)
+      Helpers::ParentChildTree.render(root, :type=>:directory).should == expected_tree
+    end
+    
+    it "with value_method option renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :blah)
+      Helpers::ParentChildTree.render(root, :type=>:directory, :value_method=>:blah).should == expected_tree
+    end
+
+    it "with children_method proc option renders" do
+      expected_tree = <<-TREE.unindent
+      1
+      |-- 2
+      |-- 3
+      |-- 4
+      `-- 5
+      TREE
+      Helpers::ParentChildTree.render(1, :type=>:directory,
+        :children_method=>lambda {|e| e == 1 ? (2..5).to_a : []}, :value_method=>:to_s).should == expected_tree
+    end
+  end
+
+  it "tree with parentless nodes renders ParentlessNodeError" do
+    lambda { tree([[0, "0.0"], [2, '1.2']], :validate=>true) }.should.raise(Helpers::Tree::ParentlessNodeError)
+  end
+  
+  it "tree with hash nodes missing level raises MissingLevelError" do
+    lambda { tree([{:value=>'ok'}]) }.should.raise(Helpers::Tree::Node::MissingLevelError)
+  end
+
+  it "tree with hash nodes missing level raises MissingValueError" do
+    lambda { tree([{:level=>0}]) }.should.raise(Helpers::Tree::Node::MissingValueError)
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/util_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/util_test.rb
new file mode 100644
index 0000000..faadd5d
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/util_test.rb
@@ -0,0 +1,59 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Util" do
+  it "camelize converts underscore lowercase to camelcase" do
+    Util.camelize('hirb/util').should == "Hirb::Util"
+    Util.camelize('hirb_hash').should == "HirbHash"
+  end
+
+  it "any_const_get returns nested class" do
+    Util.any_const_get("YAML::BaseNode").should == ::YAML::BaseNode
+  end
+
+  it "any_const_get returns nil for invalid class" do
+    Util.any_const_get("Basdfr").should == nil
+  end
+
+  it "any_const_get returns class when given class" do
+    Util.any_const_get(String).should == String
+  end
+
+  it "recursive_hash_merge merges" do
+    expected_hash = {:output=>{:fields=>["f1", "f2"], :method=>"blah"}, :key1=>"hash1", :key2=>"hash2"}
+    Util.recursive_hash_merge({:output=>{:fields=>%w{f1 f2}}, :key1=>'hash1'},
+      {:output=>{:method=>'blah'}, :key2=>'hash2'}).should == expected_hash
+  end
+
+  it "choose_from_array specifies range with -" do
+    Util.choose_from_array([1,2,3,4], '1-2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array specifies range with .." do
+    Util.choose_from_array([1,2,3,4], '1 .. 2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array chooses all with *" do
+    Util.choose_from_array([1,2,3,4], '*').should == [1,2,3,4]
+  end
+
+  it "choose_from_array ignores non-numerical input" do
+    Util.choose_from_array([1,2,3,4], 'a,2').should == [2]
+  end
+
+  it "choose_from_array ignores 0" do
+    Util.choose_from_array([1,2,3,4], '0,2').should == [2]
+  end
+
+  it "choose_from_array returns empty when empty input" do
+    Util.choose_from_array([1,2,3,4], "\n").should == []
+  end
+
+  it "choose_from_array returns empty with an invalid range" do
+    Util.choose_from_array([1,2,3,4], "5").should == []
+  end
+
+  it "capture_stdout" do
+    string = "sweetness man"
+    Util.capture_stdout { puts string }.should == string + "\n"
+  end
+end
\ No newline at end of file
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/view_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/view_test.rb
new file mode 100644
index 0000000..4d611a0
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/view_test.rb
@@ -0,0 +1,165 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "View" do
+  def formatter_config
+    View.formatter.config
+  end
+  
+  it "page_output pages when view is enabled" do
+    Hirb.enable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page)
+    View.page_output('blah').should == true
+    Hirb.disable
+  end
+
+  it "page_output doesn't page when view is disabled" do
+    Hirb.enable
+    Hirb.disable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page).never
+    View.page_output('blah').should == false
+  end
+
+  it "view_output catches unexpected errors and prints them" do
+    reset_config
+    Hirb.enable
+    View.expects(:render_output).raises('blah')
+    capture_stderr { View.view_output([1,2,3]) }.should =~ /Hirb Error: blah/
+    Hirb.disable
+  end
+
+  describe "enable" do
+    before { reset_config }
+    after { Hirb.disable }
+    it "redefines irb output_value" do
+      View.expects(:render_output).once
+      Hirb.enable
+      context_stub = stub(:last_value=>'')
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    it "is enabled?" do
+      Hirb.enable
+      View.enabled?.should == true
+    end
+
+    def output_class_config(klass)
+      { :output=>{klass=>{:class=>:auto_table}} }
+    end
+
+    it "sets formatter config" do
+      class_hash = {"Something::Base"=>{:class=>"BlahBlah"}}
+      Hirb.enable :output=>class_hash
+      View.formatter_config['Something::Base'].should == class_hash['Something::Base']
+    end
+
+    it "when called multiple times merges configs" do
+      Hirb.config = nil
+      # default config + config_file
+      Hirb.expects(:read_config_file).returns(output_class_config('Regexp'))
+      Hirb.enable output_class_config('String')
+
+      # add config file and explicit config
+      [{:config_file=>'ok'}, output_class_config('Struct')].each do |config|
+        Hirb.expects(:read_config_file).times(2).returns(
+          output_class_config('ActiveRecord::Base'), output_class_config('Array'))
+        Hirb.enable config
+      end
+
+      Hirb.config_files.include?('ok').should == true
+      output_keys = %w{ActiveRecord::Base Array Regexp String Struct}
+      View.config[:output].keys.sort.should == output_keys
+    end
+
+    it "when called multiple times without config doesn't affect config" do
+      Hirb.enable
+      old_config = View.config
+      Hirb.expects(:read_config_file).never
+      View.expects(:load_config).never
+      Hirb.enable
+      View.config.should == old_config
+    end
+
+    it "works without irb" do
+      Object.stubs(:const_defined?).with(:IRB).returns(false)
+      Hirb.enable
+      formatter_config.size.should.be > 0
+    end
+
+    it "with config_file option adds to config_file" do
+      Hirb.enable :config_file=> 'test_file'
+      Hirb.config_files.include?('test_file').should == true
+    end
+
+    it "with ignore_errors enable option" do
+      Hirb.enable :ignore_errors => true
+      View.stubs(:render_output).raises(Exception, "Ex mesg")
+      capture_stderr { View.view_output("").should == false }.should =~ /Error: Ex mesg/
+    end
+  end
+
+  describe "resize" do
+    def pager; View.pager; end
+    before { View.pager = nil; reset_config; Hirb.enable }
+    after { Hirb.disable}
+    it "changes width and height with stty" do
+      Util.expects(:command_exists?).with('stty').returns(true)
+      ENV['COLUMNS'] = ENV['LINES'] = nil # bypasses env usage
+      View.resize
+      pager.width.should.not == 10
+      pager.height.should.not == 10
+      reset_terminal_size
+    end
+
+    it "changes width and height with ENV" do
+      ENV['COLUMNS'] = ENV['LINES'] = '10' # simulates resizing
+      View.resize
+      pager.width.should == 10
+      pager.height.should == 10
+    end
+
+    it "with no environment or stty still has valid width and height" do
+      View.config[:width] = View.config[:height] = nil
+      Util.expects(:command_exists?).with('stty').returns(false)
+      ENV['COLUMNS'] = ENV['LINES'] = nil
+      View.resize
+      pager.width.is_a?(Integer).should == true
+      pager.height.is_a?(Integer).should == true
+      reset_terminal_size
+    end
+  end
+
+  it "disable points output_value back to original output_value" do
+    View.expects(:render_output).never
+    Hirb.enable
+    Hirb.disable
+    context_stub = stub(:last_value=>'')
+    ::IRB::Irb.new(context_stub).output_value
+  end
+
+  it "disable works without irb defined" do
+    Object.stubs(:const_defined?).with(:IRB).returns(false)
+    Hirb.enable
+    Hirb.disable
+    View.enabled?.should == false
+  end
+
+  it "capture_and_render" do
+    string = 'no waaaay'
+    View.render_method.expects(:call).with(string)
+    View.capture_and_render { print string }
+  end
+  
+  it "state is toggled by toggle_pager" do
+    previous_state = View.config[:pager]
+    View.toggle_pager
+    View.config[:pager].should == !previous_state
+  end
+  
+  it "state is toggled by toggle_formatter" do
+    previous_state = View.config[:formatter]
+    View.toggle_formatter
+    View.config[:formatter].should == !previous_state
+  end
+end
diff --git a/lib/bbcloud/vendor/hirb-0.3.5/test/views_test.rb b/lib/bbcloud/vendor/hirb-0.3.5/test/views_test.rb
new file mode 100644
index 0000000..1aeb641
--- /dev/null
+++ b/lib/bbcloud/vendor/hirb-0.3.5/test/views_test.rb
@@ -0,0 +1,13 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "activerecord table" do
+  it "with no select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{"name"=>'rufus', 'age'=>7}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:age, :name]}
+  end
+
+  it "with select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{'name'=>'rufus'}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:name]}
+  end
+end
\ No newline at end of file
