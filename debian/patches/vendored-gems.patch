diff --git a/vendor/excon-0.6.3/Gemfile b/vendor/excon-0.6.3/Gemfile
new file mode 100644
index 0000000..4f71f9c
--- /dev/null
+++ b/vendor/excon-0.6.3/Gemfile
@@ -0,0 +1,14 @@
+source "http://rubygems.org"
+
+gemspec
+
+group :benchmark do
+  gem 'em-http-request'
+  gem 'httparty'
+  gem 'rest-client'
+  gem 'tach'
+  gem 'typhoeus'
+  gem 'sinatra'
+  gem 'streamly_ffi'
+  gem 'curb'
+end
diff --git a/vendor/excon-0.6.3/README.rdoc b/vendor/excon-0.6.3/README.rdoc
new file mode 100644
index 0000000..ddb2d06
--- /dev/null
+++ b/vendor/excon-0.6.3/README.rdoc
@@ -0,0 +1,87 @@
+= excon
+
+Http(s) EXtended CONnections
+
+== Getting Started
+
+  sudo gem install excon
+
+Now you are ready to get started using one off requests.
+
+  require 'rubygems'
+  require 'excon'
+  Excon.get('http://geemus.com')
+
+The returned response object has #body, #headers and #status attributes. Supported one off requests are #connect, #delete, #get, #head, #options, #post, #put, and #trace
+
+You can also create a connection to reuse across multiple requests (more performant!).
+
+  connection = Excon.new('http://geemus.com')
+  connection.request(:method => 'GET')
+
+Both one off and persistent connections also support many other options, for example:
+
+  Excon.get('http://geemus.com', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  # or
+  connection.request(:method => 'GET', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+
+You can also stream responses by passing a block that will receive each chunk.
+
+  Excon.get('http://geemus.com') do |chunk, remaining_bytes, total_bytes|
+    puts chunk
+    puts "Remaining: #{remaining_bytes.to_f / total_bytes}%"
+  end
+
+These options can be combined to make pretty much any request you might need.
+
+== Proxy Support
+
+You can specify a proxy URL that Excon will use with both HTTP and HTTPS connections:
+
+  connection = Excon.new('http://geemus.com', :proxy => 'http://my.proxy:3128')
+  connection.request(:method => 'GET')
+
+The proxy URL must be fully specified, including scheme (e.g. "http://") and port.
+
+Excon will also use the environment variables "http_proxy" and "https_proxy" if they are present. "http_proxy" will be used for HTTPS connections if "https_proxy" is not set.
+
+Environment variables will take precedence over a :proxy option that has been specified in code.
+
+== HTTPS/SSL Issues
+
+By default excon will try to verify peer certificates when using ssl for https, unfortunately on some operating systems the defaults will not work. This will likely manifest itself as something like "Excon::Errors::SocketError: SSL_connect returned=1 ..."
+
+If you have the misfortune of running into this problem you have a couple options. First, if you have certificates in a location that defaults fail to locate you can set a different path to certificates:
+
+  Excon.ssl_ca_path = '/path/to/certs'
+
+or failing that, you can turn off peer verification (less secure):
+
+  Excon.ssl_verify_peer = false
+
+Either of these should allow you to work around the socket error and continue with getting your work done.
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/excon-0.6.3/Rakefile b/vendor/excon-0.6.3/Rakefile
new file mode 100644
index 0000000..dad8510
--- /dev/null
+++ b/vendor/excon-0.6.3/Rakefile
@@ -0,0 +1,143 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+require 'shindo/rake'
+Shindo::Rake.new
+
+task :default => :tests
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov tests/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/vendor/excon-0.6.3/benchmarks/class_vs_lambda.rb b/vendor/excon-0.6.3/benchmarks/class_vs_lambda.rb
new file mode 100644
index 0000000..6f902ee
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/class_vs_lambda.rb
@@ -0,0 +1,50 @@
+require 'rubygems'
+require 'tach'
+
+class Concatenator
+  def initialize(string)
+    @string = string
+  end
+
+  def call(data)
+    @string << data
+  end
+end
+
+string = "0123456789ABCDEF"
+
+Tach.meter(100_000) do
+  tach('class') do
+    s = ""
+    obj = Concatenator.new(s)
+    10.times { obj.call(string) }
+  end
+
+  tach('lambda') do
+    s = ""
+    obj = lambda {|data| s << data }
+    10.times { obj.call(string) }
+  end
+end
+
+# ruby 1.9.2p136 (2010-12-25 revision 30365) [x86_64-linux]
+#
+#  +--------+----------+
+#  | tach   | total    |
+#  +--------+----------+
+#  | class  | 1.450284 |
+#  +--------+----------+
+#  | lambda | 2.506496 |
+#  +--------+----------+
+
+# ruby 1.8.7 (2010-12-23 patchlevel 330) [x86_64-linux]
+#
+#  +--------+----------+
+#  | tach   | total    |
+#  +--------+----------+
+#  | class  | 1.373917 |
+#  +--------+----------+
+#  | lambda | 2.589384 |
+#  +--------+----------+
+  
+
diff --git a/vendor/excon-0.6.3/benchmarks/concat_vs_insert.rb b/vendor/excon-0.6.3/benchmarks/concat_vs_insert.rb
new file mode 100644
index 0000000..237a973
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/concat_vs_insert.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(1_000_000) do
+  tach('concat') do
+    path = 'path'
+    path = '/' << path
+  end
+  tach('insert') do
+    path = 'path'
+    path.insert(0, '/')
+  end
+end
+
+# +--------+----------+
+# | tach   | total    |
+# +--------+----------+
+# | insert | 0.974036 |
+# +--------+----------+
+# | concat | 0.998904 |
+# +--------+----------+
\ No newline at end of file
diff --git a/vendor/excon-0.6.3/benchmarks/concat_vs_interpolate.rb b/vendor/excon-0.6.3/benchmarks/concat_vs_interpolate.rb
new file mode 100644
index 0000000..bd2b7d9
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/concat_vs_interpolate.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+key = 'Content-Length'
+value = '100'
+Tach.meter(1_000) do
+  tach('concat') do
+    key << ': ' << value << "\r\n"
+  end
+  tach('interpolate') do
+    "#{key}: value\r\n"
+  end
+end
+
+# +-------------+----------+
+# | tach        | total    |
+# +-------------+----------+
+# | concat      | 0.000902 |
+# +-------------+----------+
+# | interpolate | 0.019667 |
+# +-------------+----------+
\ No newline at end of file
diff --git a/vendor/excon-0.6.3/benchmarks/cr_lf.rb b/vendor/excon-0.6.3/benchmarks/cr_lf.rb
new file mode 100644
index 0000000..77adc33
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/cr_lf.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+CR_LF = "\r\n"
+
+Tach.meter(1_000_000) do
+  tach('constant') do
+    '' << CR_LF
+  end
+  tach('string') do
+    '' << "\r\n"
+  end
+end
+
+# +----------+----------+
+# | tach     | total    |
+# +----------+----------+
+# | constant | 0.819885 |
+# +----------+----------+
+# | string   | 0.893602 |
+# +----------+----------+
\ No newline at end of file
diff --git a/vendor/excon-0.6.3/benchmarks/downcase-eq-eq_vs_casecmp.rb b/vendor/excon-0.6.3/benchmarks/downcase-eq-eq_vs_casecmp.rb
new file mode 100644
index 0000000..b36e993
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/downcase-eq-eq_vs_casecmp.rb
@@ -0,0 +1,169 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+comp  = "hello"
+hello = "HelLo"
+
+puts 'String#downcase == vs. String#casecmp'
+Benchmark.bmbm do |x|
+  x.report('String#downcase1') do
+    iters.times.each do
+      hello.downcase == comp
+    end
+  end
+
+  x.report('String#downcase2') do
+    iters.times.each do
+      "HelLo".downcase == "hello"
+    end
+  end
+
+  x.report('String#downcase3') do
+    iters.times.each do
+      var = "HelLo"
+      var.downcase!
+      var == "hello"
+    end
+  end
+
+  x.report('casecmp1') do
+    iters.times.each do
+      hello.casecmp(comp).zero?
+    end
+  end
+
+  x.report('casecmp1-1') do
+    iters.times.each do
+      hello.casecmp(comp) == 0
+    end
+  end
+
+  x.report('casecmp2') do
+    iters.times.each do
+      "HelLo".casecmp(comp).zero?
+    end
+  end
+
+  x.report('casecmp2-1') do
+    iters.times.each do
+      "HelLo".casecmp(comp) == 0
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby downcase-eq-eq_vs_casecmp.rb'
+
+jruby-1.5.6
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.461000   0.000000   0.461000 (  0.387000)
+String#downcase2   0.269000   0.000000   0.269000 (  0.269000)
+String#downcase3   0.224000   0.000000   0.224000 (  0.224000)
+casecmp1           0.157000   0.000000   0.157000 (  0.157000)
+casecmp1-1         0.153000   0.000000   0.153000 (  0.153000)
+casecmp2           0.163000   0.000000   0.163000 (  0.163000)
+casecmp2-1         0.163000   0.000000   0.163000 (  0.163000)
+------------------------------------------- total: 1.590000sec
+
+                       user     system      total        real
+String#downcase1   0.190000   0.000000   0.190000 (  0.191000)
+String#downcase2   0.225000   0.000000   0.225000 (  0.225000)
+String#downcase3   0.190000   0.000000   0.190000 (  0.190000)
+casecmp1           0.125000   0.000000   0.125000 (  0.125000)
+casecmp1-1         0.127000   0.000000   0.127000 (  0.127000)
+casecmp2           0.144000   0.000000   0.144000 (  0.144000)
+casecmp2-1         0.147000   0.000000   0.147000 (  0.147000)
+
+macruby-0.7.1
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   2.340000   0.040000   2.380000 (  1.765141)
+String#downcase2   5.510000   0.100000   5.610000 (  3.893249)
+String#downcase3   4.200000   0.080000   4.280000 (  3.031621)
+casecmp1           0.270000   0.000000   0.270000 (  0.267613)
+casecmp1-1         0.190000   0.000000   0.190000 (  0.188848)
+casecmp2           1.450000   0.020000   1.470000 (  1.027956)
+casecmp2-1         1.380000   0.030000   1.410000 (  0.951474)
+------------------------------------------ total: 15.610000sec
+
+                       user     system      total        real
+String#downcase1   2.350000   0.040000   2.390000 (  1.774292)
+String#downcase2   5.890000   0.120000   6.010000 (  4.214038)
+String#downcase3   4.530000   0.090000   4.620000 (  3.286059)
+casecmp1           0.270000   0.000000   0.270000 (  0.271119)
+casecmp1-1         0.190000   0.000000   0.190000 (  0.189462)
+casecmp2           1.540000   0.030000   1.570000 (  1.104751)
+casecmp2-1         1.440000   0.030000   1.470000 (  0.999689)
+
+rbx-head
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.702746   0.005229   0.707975 (  0.621969)
+String#downcase2   0.701429   0.001617   0.703046 (  0.691833)
+String#downcase3   1.042835   0.002952   1.045787 (  0.953992)
+casecmp1           0.654571   0.002239   0.656810 (  0.480158)
+casecmp1-1         0.484706   0.001105   0.485811 (  0.398601)
+casecmp2           0.564140   0.001579   0.565719 (  0.545332)
+casecmp2-1         0.554889   0.001153   0.556042 (  0.539569)
+------------------------------------------- total: 4.721190sec
+
+                       user     system      total        real
+String#downcase1   0.491199   0.001081   0.492280 (  0.493727)
+String#downcase2   0.631059   0.001018   0.632077 (  0.629885)
+String#downcase3   0.968867   0.002504   0.971371 (  0.976734)
+casecmp1           0.364496   0.000434   0.364930 (  0.365262)
+casecmp1-1         0.373140   0.000562   0.373702 (  0.374136)
+casecmp2           0.487644   0.001057   0.488701 (  0.490302)
+casecmp2-1         0.469868   0.001178   0.471046 (  0.472220)
+
+ruby-1.8.7-p330
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.780000   0.000000   0.780000 (  0.783979)
+String#downcase2   0.950000   0.000000   0.950000 (  0.954109)
+String#downcase3   0.960000   0.000000   0.960000 (  0.960554)
+casecmp1           0.440000   0.000000   0.440000 (  0.442546)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.487795)
+casecmp2           0.530000   0.000000   0.530000 (  0.535819)
+casecmp2-1         0.570000   0.000000   0.570000 (  0.574653)
+------------------------------------------- total: 4.720000sec
+
+                       user     system      total        real
+String#downcase1   0.780000   0.000000   0.780000 (  0.780692)
+String#downcase2   0.980000   0.010000   0.990000 (  0.982925)
+String#downcase3   0.960000   0.000000   0.960000 (  0.961501)
+casecmp1           0.440000   0.000000   0.440000 (  0.444528)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.487437)
+casecmp2           0.540000   0.000000   0.540000 (  0.537686)
+casecmp2-1         0.570000   0.000000   0.570000 (  0.574253)
+
+ruby-1.9.2-p136
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.750000   0.000000   0.750000 (  0.750523)
+String#downcase2   1.190000   0.000000   1.190000 (  1.193346)
+String#downcase3   1.030000   0.010000   1.040000 (  1.036435)
+casecmp1           0.640000   0.000000   0.640000 (  0.640327)
+casecmp1-1         0.480000   0.000000   0.480000 (  0.484709)  # With all this crap running, some flukes pop out
+casecmp2           0.820000   0.000000   0.820000 (  0.822223)
+casecmp2-1         0.660000   0.000000   0.660000 (  0.664190)
+------------------------------------------- total: 5.580000sec
+
+                       user     system      total        real
+String#downcase1   0.760000   0.000000   0.760000 (  0.759816)
+String#downcase2   1.150000   0.010000   1.160000 (  1.150792)
+String#downcase3   1.000000   0.000000   1.000000 (  1.005549)
+casecmp1           0.650000   0.000000   0.650000 (  0.644021)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.494456)
+casecmp2           0.820000   0.000000   0.820000 (  0.817689)
+casecmp2-1         0.680000   0.000000   0.680000 (  0.685121)
+=end
diff --git a/vendor/excon-0.6.3/benchmarks/excon.rb b/vendor/excon-0.6.3/benchmarks/excon.rb
new file mode 100644
index 0000000..5196730
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/excon.rb
@@ -0,0 +1,69 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default)
+Bundler.require(:benchmark)
+
+require 'sinatra/base'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'tach'
+
+size = 10_000
+path = '/data/' << size.to_s
+url = 'http://localhost:9292' << path
+
+times = 1_000
+
+with_server do
+
+  Tach.meter(times) do
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+    excon = Excon.new(url)
+    tach('Excon (persistent)') do
+      excon.request(:method => 'get').body
+    end
+
+  end
+end
diff --git a/vendor/excon-0.6.3/benchmarks/excon_vs.rb b/vendor/excon-0.6.3/benchmarks/excon_vs.rb
new file mode 100644
index 0000000..7d16969
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/excon_vs.rb
@@ -0,0 +1,165 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default)
+Bundler.require(:benchmark)
+
+require 'sinatra/base'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'em-http-request'
+require 'httparty'
+require 'net/http'
+require 'open-uri'
+require 'rest_client'
+require 'tach'
+require 'typhoeus'
+
+size = 10_000
+path = '/data/' << size.to_s
+url = 'http://localhost:9292' << path
+
+times = 1_000
+
+with_server do
+
+  Tach.meter(times) do
+
+    tach('curb (persistent)') do |n|
+      curb = Curl::Easy.new
+
+      n.times do
+        curb.url = url
+        curb.http_get
+        curb.body_str
+      end
+    end
+
+    tach('em-http-request') do |n|
+      EventMachine.run {
+        count = 0
+
+        n.times do
+          http = EventMachine::HttpRequest.new(url).get
+
+          http.callback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+
+          http.errback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+        end
+      }
+    end
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+    excon = Excon.new(url)
+    tach('Excon (persistent)') do
+      excon.request(:method => 'get').body
+    end
+
+    tach('HTTParty') do
+      HTTParty.get(url).body
+    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', path, 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get(path).body }
+    end
+
+    Net::HTTP.start('localhost', 9292) do |http|
+      tach('Net::HTTP (persistent)') do
+        http.get(path).body
+      end
+    end
+
+    tach('open-uri') do
+      open(url).read
+    end
+
+    tach('RestClient') do
+      RestClient.get(url)
+    end
+
+    streamly = StreamlyFFI::Connection.new
+    tach('StreamlyFFI (persistent)') do
+      streamly.get(url)
+    end
+
+    tach('Typhoeus') do
+      Typhoeus::Request.get(url).body
+    end
+
+  end
+end
+
+# +--------------------------+----------+
+# | tach                     | total    |
+# +--------------------------+----------+
+# | Excon (persistent)       | 1.529095 |
+# +--------------------------+----------+
+# | curb (persistent)        | 1.740387 |
+# +--------------------------+----------+
+# | Typhoeus                 | 1.876236 |
+# +--------------------------+----------+
+# | Excon                    | 2.001858 |
+# +--------------------------+----------+
+# | StreamlyFFI (persistent) | 2.200701 |
+# +--------------------------+----------+
+# | Net::HTTP                | 2.395704 |
+# +--------------------------+----------+
+# | Net::HTTP (persistent)   | 2.418099 |
+# +--------------------------+----------+
+# | HTTParty                 | 2.659317 |
+# +--------------------------+----------+
+# | RestClient               | 2.958159 |
+# +--------------------------+----------+
+# | open-uri                 | 2.987051 |
+# +--------------------------+----------+
+# | em-http-request          | 4.123798 |
+# +--------------------------+----------+
diff --git a/vendor/excon-0.6.3/benchmarks/for_vs_array_each.rb b/vendor/excon-0.6.3/benchmarks/for_vs_array_each.rb
new file mode 100644
index 0000000..b88f449
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/for_vs_array_each.rb
@@ -0,0 +1,27 @@
+require 'rubygems'
+require 'tach'
+
+data = ["some", "var", "goes", "in", :here, 0]
+Tach.meter(1_000_000) do
+  tach('for') do
+    for element in data
+      element == nil
+    end
+  end
+  tach('each') do
+    data.each do |element|
+      element == nil
+    end
+  end
+end
+
+# ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0]
+# 
+# +------+----------+
+# | tach | total    |
+# +------+----------+
+# | for  | 2.958672 |
+# +------+----------+
+# | each | 2.983550 |
+# +------+----------+
+# 
diff --git a/vendor/excon-0.6.3/benchmarks/for_vs_hash_each.rb b/vendor/excon-0.6.3/benchmarks/for_vs_hash_each.rb
new file mode 100644
index 0000000..c4db5ef
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/for_vs_hash_each.rb
@@ -0,0 +1,27 @@
+require 'rubygems'
+require 'tach'
+
+data = {"some" => "var", "goes" => "in", :here => 0}
+Tach.meter(1_000_000) do
+  tach('for') do
+    for key, values in data
+      key == values
+    end
+  end
+  tach('each') do
+    data.each do |key, values|
+      key == values
+    end
+  end
+end
+
+# ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0]
+# 
+# +------+----------+
+# | tach | total    |
+# +------+----------+
+# | each | 2.748909 |
+# +------+----------+
+# | for  | 2.949512 |
+# +------+----------+
+#
diff --git a/vendor/excon-0.6.3/benchmarks/has_key-vs-hash[key].rb b/vendor/excon-0.6.3/benchmarks/has_key-vs-hash[key].rb
new file mode 100755
index 0000000..95d6a3f
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/has_key-vs-hash[key].rb
@@ -0,0 +1,177 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+hash  = {
+  'some_key' => 'some_val',
+  'nil_key' => nil
+}
+
+puts 'Hash#has_key vs. Hash#[]'
+Benchmark.bmbm do |x|
+  x.report('Hash#has_key') do
+    iters.times.each do
+      hash.has_key? 'some_key'
+    end
+  end
+
+  x.report('Hash#has_key (if statement)') do
+    iters.times.each do
+      if hash.has_key?('other_key')
+        "hooray!"
+      end
+    end
+  end
+  
+  x.report('Hash#has_key (non-existant)') do
+    iters.times.each do
+      hash.has_key? 'other_key'
+    end
+  end
+
+  x.report('Hash#[]') do
+    iters.times.each do
+      hash['some_key']
+    end
+  end
+
+  x.report('Hash#[] (if statement)') do
+    iters.times.each do
+      if hash['some_key']
+        "hooray!"
+      end
+    end
+  end
+
+  x.report('Hash#[] (non-existant)') do
+    iters.times.each do
+      hash['other_key']
+    end
+  end
+  
+  x.report('Hash#has_key (if statement) explicit nil check') do
+    iters.times.each do
+      if hash.has_key?('nil_key') && !hash['nil_key'].nil?
+        "hooray!"
+      end
+    end
+  end
+  
+  
+  x.report('Hash#has_key (if statement) implicit nil check') do
+    iters.times.each do
+      if hash.has_key?('nil_key') && hash['nil_key']
+        "hooray!"
+      end
+    end
+  end
+  
+  x.report('Hash#[] (if statement with nil)') do
+    iters.times.each do
+      if hash['nil_key']
+        "hooray!"
+      end
+    end
+  end
+end
+
+=begin
+
+$ rvm exec bash -c 'echo $RUBY_VERSION && ruby has_key-vs-hash\[key\].rb'
+
+jruby-1.5.6
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.410000   0.000000   0.410000 (  0.341000)
+Hash#has_key (if statement)   0.145000   0.000000   0.145000 (  0.145000)
+Hash#has_key (non-existant)   0.116000   0.000000   0.116000 (  0.116000)
+Hash#[]                       0.189000   0.000000   0.189000 (  0.189000)
+Hash#[] (if statement)        0.176000   0.000000   0.176000 (  0.176000)
+Hash#[] (non-existant)        0.302000   0.000000   0.302000 (  0.302000)
+------------------------------------------------------ total: 1.338000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.128000   0.000000   0.128000 (  0.128000)
+Hash#has_key (if statement)   0.128000   0.000000   0.128000 (  0.128000)
+Hash#has_key (non-existant)   0.153000   0.000000   0.153000 (  0.153000)
+Hash#[]                       0.206000   0.000000   0.206000 (  0.206000)
+Hash#[] (if statement)        0.182000   0.000000   0.182000 (  0.182000)
+Hash#[] (non-existant)        0.252000   0.000000   0.252000 (  0.252000)
+
+macruby-0.7.1
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  2.530000   0.050000   2.580000 (  1.917643)
+Hash#has_key (if statement)   2.590000   0.050000   2.640000 (  1.935221)
+Hash#has_key (non-existant)   2.580000   0.050000   2.630000 (  1.964230)
+Hash#[]                       2.240000   0.040000   2.280000 (  1.640999)
+Hash#[] (if statement)        3.620000   0.070000   3.690000 (  2.530248)
+Hash#[] (non-existant)        2.060000   0.040000   2.100000 (  1.473487)
+----------------------------------------------------- total: 15.920000sec
+
+                                  user     system      total        real
+Hash#has_key                  2.230000   0.030000   2.260000 (  1.661843)
+Hash#has_key (if statement)   2.180000   0.040000   2.220000 (  1.605644)
+Hash#has_key (non-existant)   2.160000   0.040000   2.200000 (  1.582561)
+Hash#[]                       2.160000   0.030000   2.190000 (  1.581448)
+Hash#[] (if statement)        3.440000   0.070000   3.510000 (  2.393421)
+Hash#[] (non-existant)        2.330000   0.040000   2.370000 (  1.699338)
+
+rbx-head
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.660584   0.004932   0.665516 (  0.508601)
+Hash#has_key (if statement)   0.261708   0.000532   0.262240 (  0.263021)
+Hash#has_key (non-existant)   0.265908   0.000827   0.266735 (  0.259509)
+Hash#[]                       0.396607   0.001189   0.397796 (  0.372997)
+Hash#[] (if statement)        0.553003   0.001589   0.554592 (  0.543859)
+Hash#[] (non-existant)        0.323748   0.000884   0.324632 (  0.319055)
+------------------------------------------------------ total: 2.471511sec
+
+                                  user     system      total        real
+Hash#has_key                  0.332239   0.000819   0.333058 (  0.333809)
+Hash#has_key (if statement)   0.284344   0.000521   0.284865 (  0.285330)
+Hash#has_key (non-existant)   0.339695   0.001301   0.340996 (  0.324259)
+Hash#[]                       0.298555   0.000368   0.298923 (  0.299557)
+Hash#[] (if statement)        0.392755   0.000773   0.393528 (  0.395473)
+Hash#[] (non-existant)        0.277721   0.000464   0.278185 (  0.278540)
+
+ruby-1.8.7-p330
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.450000   0.000000   0.450000 (  0.450143)
+Hash#has_key (if statement)   0.440000   0.000000   0.440000 (  0.448278)
+Hash#has_key (non-existant)   0.420000   0.000000   0.420000 (  0.416959)
+Hash#[]                       0.450000   0.000000   0.450000 (  0.450727)
+Hash#[] (if statement)        0.550000   0.000000   0.550000 (  0.555043)
+Hash#[] (non-existant)        0.530000   0.000000   0.530000 (  0.527189)
+------------------------------------------------------ total: 2.840000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.440000   0.000000   0.440000 (  0.447746)
+Hash#has_key (if statement)   0.450000   0.000000   0.450000 (  0.450331)
+Hash#has_key (non-existant)   0.420000   0.000000   0.420000 (  0.419157)
+Hash#[]                       0.450000   0.000000   0.450000 (  0.454438)
+Hash#[] (if statement)        0.570000   0.000000   0.570000 (  0.563948)
+Hash#[] (non-existant)        0.520000   0.000000   0.520000 (  0.527866)
+
+ruby-1.9.2-p136
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.690000   0.000000   0.690000 (  0.691657)
+Hash#has_key (if statement)   0.630000   0.000000   0.630000 (  0.638418)
+Hash#has_key (non-existant)   0.640000   0.000000   0.640000 (  0.637510)
+Hash#[]                       0.580000   0.000000   0.580000 (  0.584500)
+Hash#[] (if statement)        0.840000   0.010000   0.850000 (  0.837541)
+Hash#[] (non-existant)        0.810000   0.000000   0.810000 (  0.811598)
+------------------------------------------------------ total: 4.200000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.690000   0.000000   0.690000 (  0.694192)
+Hash#has_key (if statement)   0.640000   0.000000   0.640000 (  0.641729)
+Hash#has_key (non-existant)   0.630000   0.000000   0.630000 (  0.634470)
+Hash#[]                       0.580000   0.000000   0.580000 (  0.587844)
+Hash#[] (if statement)        0.830000   0.000000   0.830000 (  0.832323)
+Hash#[] (non-existant)        0.790000   0.010000   0.800000 (  0.791689)
+=end
diff --git a/vendor/excon-0.6.3/benchmarks/headers_case_sensitivity.rb b/vendor/excon-0.6.3/benchmarks/headers_case_sensitivity.rb
new file mode 100644
index 0000000..85aa513
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/headers_case_sensitivity.rb
@@ -0,0 +1,83 @@
+require 'rubygems'
+require 'stringio'
+require 'tach'
+
+def all_match_socket
+  io = StringIO.new
+  io << "Connection: close\n"
+  io << "Content-Length: 000\n"
+  io << "Content-Type: text/html\n"
+  io << "Date: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Server: xxx\n"
+  io << "Transfer-Encoding: chunked\n"
+  io << "\n\n"
+  io.rewind
+  io
+end
+
+Formatador.display_line('all_match')
+Formatador.indent do
+  Tach.meter(10_000) do
+    tach('compare on read') do
+      socket, headers = all_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+        (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+        (key.casecmp('Connection') == 0) && (value.casecmp('close') == 0)
+        (key.casecmp('Content-Length') == 0)
+      end
+    end
+
+    tach('original') do
+      socket, headers = all_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+      end
+      headers.has_key?('Transfer-Encoding') && headers['Transfer-Encoding'].casecmp('chunked') == 0
+      headers.has_key?('Connection') && headers['Connection'].casecmp('close') == 0
+      headers.has_key?('Content-Length')
+    end
+  end
+end
+
+def none_match_socket
+  io = StringIO.new
+  io << "Cache-Control: max-age=0\n"
+  io << "Content-Type: text/html\n"
+  io << "Date: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Expires: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Last-Modified: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Server: xxx\n"
+  io << "\n\n"
+  io.rewind
+  io
+end
+
+Formatador.display_line('none_match')
+Formatador.indent do
+  Tach.meter(10_000) do
+    tach('compare on read') do
+      socket, headers = none_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+        (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+        (key.casecmp('Connection') == 0) && (value.casecmp('close') == 0)
+        (key.casecmp('Content-Length') == 0)
+      end
+    end
+
+    tach('original') do
+      socket, headers = none_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+      end
+      headers.has_key?('Transfer-Encoding') && headers['Transfer-Encoding'].casecmp('chunked') == 0
+      headers.has_key?('Connection') && headers['Connection'].casecmp('close') == 0
+      headers.has_key?('Content-Length')
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/excon-0.6.3/benchmarks/headers_split_vs_match.rb b/vendor/excon-0.6.3/benchmarks/headers_split_vs_match.rb
new file mode 100644
index 0000000..276c366
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/headers_split_vs_match.rb
@@ -0,0 +1,34 @@
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100"
+Tach.meter(1_000_000) do
+  tach('regex') do
+    data.match(/(.*):\s(.*)/)
+    header = [$1, $2]
+  end
+  tach('split') do
+    header = data.split(': ', 2)
+  end
+  tach('split regex') do
+    header = data.split(/:\s*/, 2)
+  end
+end
+
+#  +-------------+----------+
+#  | tach        | total    |
+#  +-------------+----------+
+#  | split regex | 5.940233 |
+#  +-------------+----------+
+#  | split       | 7.327549 |
+#  +-------------+----------+
+#  | regex       | 8.736390 |
+#  +-------------+----------+
+
+# +-------+----------+----------+
+# | tach  | average  | total    |
+# +-------+----------+----------+
+# | regex | 4.680451 | 4.680451 |
+# +-------+----------+----------+
+# | split | 4.393218 | 4.393218 |
+# +-------+----------+----------+
diff --git a/vendor/excon-0.6.3/benchmarks/implicit_block-vs-explicit_block.rb b/vendor/excon-0.6.3/benchmarks/implicit_block-vs-explicit_block.rb
new file mode 100644
index 0000000..7337b4e
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/implicit_block-vs-explicit_block.rb
@@ -0,0 +1,98 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+def do_explicit(&block)
+  var = "hello"
+  block.call(var)
+end
+
+def do_implicit
+  var = "hello"
+  yield(var)
+end
+
+puts 'explicit block vs implicit'
+Benchmark.bmbm do |x|
+  x.report('explicit') do
+    iters.times.each do
+      do_explicit {|var|
+        var << "goodbye"
+      }
+    end
+  end
+
+  x.report('implicit') do
+    iters.times.each do
+      do_implicit {|var|
+        var << "goodbye"
+      }
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby implicit_block-vs-explicit_block.rb'
+
+jruby-1.5.6
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   1.163000   0.000000   1.163000 (  1.106000)
+implicit   0.499000   0.000000   0.499000 (  0.499000)
+----------------------------------- total: 1.662000sec
+
+               user     system      total        real
+explicit   0.730000   0.000000   0.730000 (  0.730000)
+implicit   0.453000   0.000000   0.453000 (  0.453000)
+
+macruby-0.7.1
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   5.070000   0.130000   5.200000 (  3.546388)
+implicit   3.140000   0.050000   3.190000 (  2.255986)
+----------------------------------- total: 8.390000sec
+
+               user     system      total        real
+explicit   5.340000   0.140000   5.480000 (  3.774963)
+implicit   3.170000   0.060000   3.230000 (  2.279951)
+
+rbx-head
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   1.270136   0.006507   1.276643 (  1.181588)
+implicit   0.839831   0.002203   0.842034 (  0.820849)
+----------------------------------- total: 2.118677sec
+
+               user     system      total        real
+explicit   0.960593   0.001526   0.962119 (  0.966404)
+implicit   0.700361   0.001126   0.701487 (  0.703591)
+
+ruby-1.8.7-p330
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   3.970000   0.000000   3.970000 (  3.985157)
+implicit   1.560000   0.000000   1.560000 (  1.567599)
+----------------------------------- total: 5.530000sec
+
+               user     system      total        real
+explicit   3.990000   0.010000   4.000000 (  4.002637)
+implicit   1.560000   0.000000   1.560000 (  1.560901)
+
+ruby-1.9.2-p136
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   2.620000   0.010000   2.630000 (  2.633762)
+implicit   1.080000   0.000000   1.080000 (  1.076809)
+----------------------------------- total: 3.710000sec
+
+               user     system      total        real
+explicit   2.630000   0.010000   2.640000 (  2.637658)
+implicit   1.070000   0.000000   1.070000 (  1.073589)
+=end
diff --git a/vendor/excon-0.6.3/benchmarks/merging.rb b/vendor/excon-0.6.3/benchmarks/merging.rb
new file mode 100644
index 0000000..7674e3f
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/merging.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(10_000) do
+
+  tach('merge') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    override = default.merge(override)
+  end
+
+  tach('loop') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    for key, value in default
+      override[key] ||= default[key]
+    end
+    override
+  end
+
+end
diff --git a/vendor/excon-0.6.3/benchmarks/string_ranged_index.rb b/vendor/excon-0.6.3/benchmarks/string_ranged_index.rb
new file mode 100644
index 0000000..68c2fdc
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/string_ranged_index.rb
@@ -0,0 +1,87 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+string = "Test String OMG"
+
+puts 'String ranged index vs. "coordinates"'
+Benchmark.bmbm do |x|
+  x.report('ranged index') do
+    iters.times.each do
+      text = string[2..9]
+    end
+  end
+
+  x.report('coordinates') do
+    iters.times.each do
+      text = string[2, 9]
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby string_ranged_index.rb'
+
+
+jruby-1.5.6
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.419000   0.000000   0.419000 (  0.372000)
+coordinates    0.167000   0.000000   0.167000 (  0.167000)
+--------------------------------------- total: 0.586000sec
+
+                   user     system      total        real
+ranged index   0.158000   0.000000   0.158000 (  0.159000)
+coordinates    0.125000   0.000000   0.125000 (  0.125000)
+
+macruby-0.7.1
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   1.490000   0.030000   1.520000 (  1.061326)
+coordinates    1.410000   0.030000   1.440000 (  0.973640)
+--------------------------------------- total: 2.960000sec
+
+                   user     system      total        real
+ranged index   1.520000   0.030000   1.550000 (  1.081424)
+coordinates    1.480000   0.030000   1.510000 (  1.029214)
+
+rbx-head
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   1.333304   0.009398   1.342702 (  1.229629)
+coordinates    0.306087   0.000603   0.306690 (  0.303538)
+--------------------------------------- total: 1.649392sec
+
+                   user     system      total        real
+ranged index   0.923626   0.001597   0.925223 (  0.927411)
+coordinates    0.298910   0.000533   0.299443 (  0.300255)
+
+ruby-1.8.7-p330
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.730000   0.000000   0.730000 (  0.738612)
+coordinates    0.660000   0.000000   0.660000 (  0.660689)
+--------------------------------------- total: 1.390000sec
+
+                   user     system      total        real
+ranged index   0.750000   0.000000   0.750000 (  0.746172)
+coordinates    0.640000   0.000000   0.640000 (  0.640687)
+
+ruby-1.9.2-p136
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.670000   0.000000   0.670000 (  0.679046)
+coordinates    0.620000   0.000000   0.620000 (  0.622257)
+--------------------------------------- total: 1.290000sec
+
+                   user     system      total        real
+ranged index   0.680000   0.000000   0.680000 (  0.686510)
+coordinates    0.620000   0.000000   0.620000 (  0.624269)
+=end
diff --git a/vendor/excon-0.6.3/benchmarks/strip_newline.rb b/vendor/excon-0.6.3/benchmarks/strip_newline.rb
new file mode 100644
index 0000000..88a964f
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/strip_newline.rb
@@ -0,0 +1,115 @@
+# require 'benchmark'
+# 
+# COUNT = 1_000_000
+# data = "Content-Length: 100\r\n"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('chomp') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp
+#     end
+#   end
+#   bench.report('chomp!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp!
+#     end
+#   end
+#   bench.report('chop') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop
+#     end
+#   end
+#   bench.report('chop!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop!
+#     end
+#   end
+#   bench.report('strip') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip
+#     end
+#   end
+#   bench.report('strip!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip!
+#     end
+#   end
+#   bench.report('index') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data[0..-3]
+#     end
+#   end
+# end
+
+
+
+# Rehearsal ------------------------------------------------------------
+# chomp                      0.640000   0.000000   0.640000 (  0.644043)
+# chomp!                     0.530000   0.000000   0.530000 (  0.531415)
+# chop                       0.620000   0.000000   0.620000 (  0.624321)
+# chop!                      0.500000   0.000000   0.500000 (  0.509146)
+# strip                      0.640000   0.000000   0.640000 (  0.638785)
+# strip!                     0.530000   0.000000   0.530000 (  0.532196)
+# index                      0.740000   0.000000   0.740000 (  0.745742)
+# --------------------------------------------------- total: 4.200000sec
+# 
+#                                user     system      total        real
+# chomp                      0.640000   0.010000   0.650000 (  0.647287)
+# chomp!                     0.530000   0.000000   0.530000 (  0.532868)
+# chop                       0.630000   0.000000   0.630000 (  0.628236)
+# chop!                      0.520000   0.000000   0.520000 (  0.522950)
+# strip                      0.640000   0.000000   0.640000 (  0.646328)
+# strip!                     0.520000   0.000000   0.520000 (  0.532715)
+# index                      0.740000   0.010000   0.750000 (  0.771277)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100\r\n"
+Tach.meter(1_000_000) do
+  tach('chomp') do
+    data.dup.chomp
+  end
+  tach('chomp!') do
+    data.dup.chomp!
+  end
+  tach('chop') do
+    data.dup.chop
+  end
+  tach('chop!') do
+    data.dup.chop!
+  end
+  tach('strip') do
+    data.dup.strip
+  end
+  tach('strip!') do
+    data.dup.strip!
+  end
+  tach('index') do
+    data.dup[0..-3]
+  end
+end
+
+# +--------+----------+----------+
+# | tach   | average  | total    |
+# +--------+----------+----------+
+# | chomp  | 1.444547 | 1.444547 |
+# +--------+----------+----------+
+# | chomp! | 1.276813 | 1.276813 |
+# +--------+----------+----------+
+# | chop   | 1.422744 | 1.422744 |
+# +--------+----------+----------+
+# | chop!  | 1.240941 | 1.240941 |
+# +--------+----------+----------+
+# | strip  | 1.444776 | 1.444776 |
+# +--------+----------+----------+
+# | strip! | 1.266459 | 1.266459 |
+# +--------+----------+----------+
+# | index  | 1.557975 | 1.557975 |
+# +--------+----------+----------+
\ No newline at end of file
diff --git a/vendor/excon-0.6.3/benchmarks/vs_stdlib.rb b/vendor/excon-0.6.3/benchmarks/vs_stdlib.rb
new file mode 100644
index 0000000..fca9a1e
--- /dev/null
+++ b/vendor/excon-0.6.3/benchmarks/vs_stdlib.rb
@@ -0,0 +1,82 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+
+require 'sinatra/base'
+require 'tach'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'net/http'
+require 'open-uri'
+
+url = 'http://localhost:9292/data/1000'
+
+with_server do
+
+  Tach.meter(100) do
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+#    tach('Excon (persistent)') do |times|
+#      excon = Excon.new(url)
+#      times.times do
+#        excon.request(:method => 'get').body
+#      end
+#    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', '/data/1000', 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get('/data/1000').body }
+    end
+
+#    tach('Net::HTTP (persistent)') do |times|
+#      Net::HTTP.start('localhost', 9292) do |http|
+#        times.times do
+#          http.get('/data/1000').body
+#        end
+#      end
+#    end
+
+#    tach('open-uri') do
+#      open(url).read
+#    end
+
+  end
+end
diff --git a/vendor/excon-0.6.3/changelog.txt b/vendor/excon-0.6.3/changelog.txt
new file mode 100644
index 0000000..339a51b
--- /dev/null
+++ b/vendor/excon-0.6.3/changelog.txt
@@ -0,0 +1,61 @@
+0.6.2 04/11/11
+==============
+
+* fix block arguments for connection close. thanks ggoodale
+
+0.6.1 04/05/11
+==============
+
+* add support for HTTPS proxies. thanks mrowe
+* add support for http_proxy and https_proxy ENV variables. thanks mrowe
+* fix progress for requests with blocks that are chunked or connection close
+
+0.6.0 03/30/11
+==============
+
+* basic support for using proxies. thanks mattsa
+* yield remaining/total bytes to streaming block. thanks nate
+* minor optimizations/cleanup
+
+0.5.8 03/24/11
+==============
+
+* fix regression where nil values in queries were ignored in 1.9. thanks mattsa
+* fix regression causing EOFError when making many connections in one thread
+* added tests to prevent both of the former from recurring
+
+0.5.7 03/21/11
+==============
+
+* lazily connect, rather than connecting at #initialize
+* add rough first pass at stubbing
+* minor optimizations
+* ssl client certification support. thanks thommay
+* skip figuring out/setting Content-Length if one is supplied. Thanks pweldon
+* do not try to parse body for 205 and 304. Thanks seancribbs
+
+0.5.6 02/19/11
+==============
+
+* only split headers by first ':' to allow for values with ':'. Thanks mtodd!
+* check a string instance for force_encoding, not class. Thanks seancribbs!
+* add benchmarks related to for vs each for enumerable. Thanks caius!
+* fix default rake task to run tests
+
+0.5.5 02/18/11
+==============
+
+* use local variables in response parsing, prevents keeping state across requests
+
+0.5.4 02/18/11
+==============
+
+* 204 should not attempt to parse body
+
+
+0.5.3 02/17/11
+==============
+
+* header comparison for responses is now case insensitive
+* change to allow :idempotent => false to operate correctly
+* misc cleanup
diff --git a/vendor/excon-0.6.3/excon.gemspec b/vendor/excon-0.6.3/excon.gemspec
new file mode 100644
index 0000000..184dce3
--- /dev/null
+++ b/vendor/excon-0.6.3/excon.gemspec
@@ -0,0 +1,110 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'excon'
+  s.version           = '0.6.3'
+  s.date              = '2011-05-02'
+  s.rubyforge_project = 'excon'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "speed, persistence, http(s)"
+  s.description = "EXtended http(s) CONnections"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'https://github.com/geemus/excon'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+  s.add_development_dependency('open4')
+  s.add_development_dependency('rake')
+  s.add_development_dependency('shindo', '0.2.0')
+  s.add_development_dependency('sinatra')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    benchmarks/class_vs_lambda.rb
+    benchmarks/concat_vs_insert.rb
+    benchmarks/concat_vs_interpolate.rb
+    benchmarks/cr_lf.rb
+    benchmarks/downcase-eq-eq_vs_casecmp.rb
+    benchmarks/excon.rb
+    benchmarks/excon_vs.rb
+    benchmarks/for_vs_array_each.rb
+    benchmarks/for_vs_hash_each.rb
+    benchmarks/has_key-vs-hash[key].rb
+    benchmarks/headers_case_sensitivity.rb
+    benchmarks/headers_split_vs_match.rb
+    benchmarks/implicit_block-vs-explicit_block.rb
+    benchmarks/merging.rb
+    benchmarks/string_ranged_index.rb
+    benchmarks/strip_newline.rb
+    benchmarks/vs_stdlib.rb
+    changelog.txt
+    excon.gemspec
+    lib/excon.rb
+    lib/excon/connection.rb
+    lib/excon/errors.rb
+    lib/excon/response.rb
+    tests/basic_tests.rb
+    tests/header_tests.rb
+    tests/proxy_tests.rb
+    tests/query_string_tests.rb
+    tests/rackups/basic.ru
+    tests/rackups/proxy.ru
+    tests/rackups/query_string.ru
+    tests/rackups/response_header.ru
+    tests/rackups/thread_safety.ru
+    tests/stub_tests.rb
+    tests/test_helper.rb
+    tests/thread_safety_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/vendor/excon-0.6.3/lib/excon.rb b/vendor/excon-0.6.3/lib/excon.rb
new file mode 100644
index 0000000..c3a86a6
--- /dev/null
+++ b/vendor/excon-0.6.3/lib/excon.rb
@@ -0,0 +1,96 @@
+$:.unshift(File.dirname(__FILE__)) unless
+  $:.include?(File.dirname(__FILE__)) || $:.include?(File.expand_path(File.dirname(__FILE__)))
+
+require 'cgi'
+require 'openssl'
+require 'rbconfig'
+require 'socket'
+require 'uri'
+
+require 'excon/connection'
+require 'excon/errors'
+require 'excon/response'
+
+module Excon
+  unless const_defined?(:VERSION)
+    VERSION = '0.6.3'
+  end
+
+  unless const_defined?(:CHUNK_SIZE)
+    CHUNK_SIZE = 1048576 # 1 megabyte
+  end
+
+  class << self
+    # @return [String] The filesystem path to the SSL Certificate Authority
+    attr_accessor :ssl_ca_path
+
+    # @return [true, false] Whether or not to verify the peer's SSL certificate / chain
+    attr_reader :ssl_verify_peer
+
+    # setup ssl defaults based on platform
+    @ssl_verify_peer = Config::CONFIG['host_os'] !~ /mswin|win32|dos|cygwin|mingw/i
+
+    # default mocking to off
+    @mock = false
+
+    # Status of mocking
+    def mock
+      @mock
+    end
+
+    # Change the status of mocking
+    # false is the default and works as expected
+    # true returns a value from stubs or raises
+    def mock=(new_mock)
+      @mock = new_mock
+    end
+
+    # @see Connection#initialize
+    # Initializes a new keep-alive session for a given remote host
+    #   @param [String] url The destination URL
+    #   @param [Hash<Symbol, >] params One or more option params to set on the Connection instance
+    #   @return [Connection] A new Excon::Connection instance
+    def new(url, params = {})
+      Excon::Connection.new(url, params)
+    end
+
+    # Change the status of ssl peer verification
+    # @see Excon#ssl_verify_peer (attr_reader)
+    def ssl_verify_peer=(new_ssl_verify_peer)
+      @ssl_verify_peer = new_ssl_verify_peer && true || false
+    end
+
+    # push an additional stub onto the list to check for mock requests
+    #   @param [Hash<Symbol, >] request params to match against, omitted params match all
+    #   @param [Hash<Symbol, >] response params to return from matched request or block to call with params
+    def stub(request_params, response_params = nil)
+      if block_given?
+        if response_params
+          raise(ArgumentError.new("stub requires either response_params OR a block"))
+        else
+          stub = [request_params, Proc.new]
+        end
+      elsif response_params
+        stub = [request_params, response_params]
+      else
+        raise(ArgumentError.new("stub requires either response_params OR a block"))
+      end
+      stubs << stub
+      stub
+    end
+
+    # get a list of defined stubs
+    def stubs
+      @stubs ||= []
+    end
+
+    # Generic non-persistent HTTP methods
+    %w{connect delete get head options post put trace}.each do |method|
+      eval <<-DEF
+        def #{method}(url, params = {}, &block)
+          new(url).request(params.merge!(:method => :#{method}), &block)
+        end
+      DEF
+    end
+  end
+end
diff --git a/vendor/excon-0.6.3/lib/excon/connection.rb b/vendor/excon-0.6.3/lib/excon/connection.rb
new file mode 100644
index 0000000..29be12a
--- /dev/null
+++ b/vendor/excon-0.6.3/lib/excon/connection.rb
@@ -0,0 +1,292 @@
+module Excon
+  class Connection
+    attr_reader :connection, :proxy
+
+    CR_NL     = "\r\n"
+    HTTP_1_1  = " HTTP/1.1\r\n"
+    FORCE_ENC = CR_NL.respond_to?(:force_encoding)
+
+    # Initializes a new Connection instance
+    #   @param [String] url The destination URL
+    #   @param [Hash<Symbol, >] params One or more optional params
+    #     @option params [String] :body Default text to be sent over a socket. Only used if :body absent in Connection#request params
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request. Only used if params[:headers] is not supplied to Connection#request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path Default path; appears after 'scheme://host:port/'. Only used if params[:path] is not supplied to Connection#request
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query Default query; appended to the 'scheme://host:port/path/' in the form of '?key=value'. Will only be used if params[:query] is not supplied to Connection#request
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    #     @option params [String] :proxy Proxy server; e.g. 'http://myproxy.com:8888'
+    def initialize(url, params = {})
+      uri = URI.parse(url)
+      @connection = {
+        :headers  => {},
+        :host     => uri.host,
+        :mock     => Excon.mock,
+        :path     => uri.path,
+        :port     => uri.port.to_s,
+        :query    => uri.query,
+        :scheme   => uri.scheme
+      }.merge!(params)
+
+      # use proxy from the environment if present
+      if ENV.has_key?('http_proxy')
+        @proxy = setup_proxy(ENV['http_proxy'])
+      elsif params.has_key?(:proxy)
+        @proxy = setup_proxy(params[:proxy])
+      end
+
+      if https?
+        # use https_proxy if that has been specified
+        if ENV.has_key?('https_proxy')
+          @proxy = setup_proxy(ENV['https_proxy'])
+        end
+      end
+
+      if @proxy
+        @connection[:headers]['Proxy-Connection'] ||= 'Keep-Alive'
+      end
+
+      @socket_key = '' << @connection[:host] << ':' << @connection[:port]
+      reset
+    end
+
+    # Sends the supplied request to the destination host.
+    #   @yield [chunk] @see Response#self.parse
+    #   @param [Hash<Symbol, >] params One or more optional params, override defaults set in Connection.new
+    #     @option params [String] :body text to be sent over a socket
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path appears after 'scheme://host:port/'
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query appended to the 'scheme://host:port/path/' in the form of '?key=value'
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    def request(params, &block)
+      begin
+        # connection has defaults, merge in new params to override
+        params = @connection.merge(params)
+        params[:headers] = @connection[:headers].merge(params[:headers] || {})
+        params[:headers]['Host'] ||= '' << params[:host] << ':' << params[:port]
+
+        # if path is empty or doesn't start with '/', insert one
+        unless params[:path][0, 1] == '/'
+          params[:path].insert(0, '/')
+        end
+
+        if params[:mock]
+          for stub, response in Excon.stubs
+            # all specified non-headers params match and no headers were specified or all specified headers match
+            if [stub.keys - [:headers]].all? {|key| stub[key] == params[key] } &&
+              (!stub.has_key?(:headers) || stub[:headers].keys.all? {|key| stub[:headers][key] == params[:headers][key]})
+              case response
+              when Proc
+                return Excon::Response.new(response.call(params))
+              else
+                return Excon::Response.new(response)
+              end
+            end
+          end
+          # if we reach here no stubs matched
+          raise(Excon::Errors::StubNotFound.new('no stubs matched ' << params.inspect))
+        end
+
+        # start with "METHOD /path"
+        request = params[:method].to_s.upcase << ' '
+        if @proxy
+          request << params[:scheme] << '://' << params[:host] << ':' << params[:port]
+        end
+        request << params[:path]
+
+        # add query to path, if there is one
+        case params[:query]
+        when String
+          request << '?' << params[:query]
+        when Hash
+          request << '?'
+          for key, values in params[:query]
+            if values.nil?
+              request << key.to_s << '&'
+            else
+              for value in [*values]
+                request << key.to_s << '=' << CGI.escape(value.to_s) << '&'
+              end
+            end
+          end
+          request.chop! # remove trailing '&'
+        end
+
+        # finish first line with "HTTP/1.1\r\n"
+        request << HTTP_1_1
+
+        # calculate content length and set to handle non-ascii
+        unless params[:headers].has_key?('Content-Length')
+          params[:headers]['Content-Length'] = case params[:body]
+          when File
+            params[:body].binmode
+            File.size(params[:body])
+          when String
+            if FORCE_ENC
+              params[:body].force_encoding('BINARY')
+            end
+            params[:body].length
+          else
+            0
+          end
+        end
+
+        # add headers to request
+        for key, values in params[:headers]
+          for value in [*values]
+            request << key.to_s << ': ' << value.to_s << CR_NL
+          end
+        end
+
+        # add additional "\r\n" to indicate end of headers
+        request << CR_NL
+
+        # write out the request, sans body
+        socket.write(request)
+        socket.flush
+
+        # write out the body
+        if params[:body]
+          if params[:body].is_a?(String)
+            socket.write(params[:body])
+          else
+            while chunk = params[:body].read(CHUNK_SIZE)
+              socket.write(chunk)
+            end
+          end
+        end
+
+        # read the response
+        response = Excon::Response.parse(socket, params, &block)
+
+        if response.headers['Connection'] == 'close'
+          reset
+        end
+
+        response
+      rescue Excon::Errors::StubNotFound => stub_not_found
+        raise(stub_not_found)
+      rescue => socket_error
+        reset
+        raise(Excon::Errors::SocketError.new(socket_error))
+      end
+
+      if params.has_key?(:expects) && ![*params[:expects]].include?(response.status)
+        reset
+        raise(Excon::Errors.status_error(params, response))
+      else
+        response
+      end
+
+    rescue => request_error
+      if params[:idempotent] && [Excon::Errors::SocketError, Excon::Errors::HTTPStatusError].include?(request_error)
+        retries_remaining ||= 4
+        retries_remaining -= 1
+        if retries_remaining > 0
+          if params[:body].respond_to?(:pos=)
+            params[:body].pos = 0
+          end
+          retry
+        else
+          raise(request_error)
+        end
+      else
+        raise(request_error)
+      end
+    end
+
+    def reset
+      (old_socket = sockets.delete(@socket_key)) && old_socket.close
+    end
+
+  private
+    def connect
+      new_socket = open_socket
+
+      if https?
+        # create ssl context
+        ssl_context = OpenSSL::SSL::SSLContext.new
+
+        if Excon.ssl_verify_peer
+          # turn verification on
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
+
+          if Excon.ssl_ca_path
+            ssl_context.ca_path = Excon.ssl_ca_path
+          else
+            # use default cert store
+            store = OpenSSL::X509::Store.new
+            store.set_default_paths
+            ssl_context.cert_store = store
+          end
+        else
+          # turn verification off
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        end
+
+        if @connection.has_key?(:client_cert) && @connection.has_key?(:client_key)
+          ssl_context.cert = OpenSSL::X509::Certificate.new(File.read(@connection[:client_cert]))
+          ssl_context.key = OpenSSL::PKey::RSA.new(File.read(@connection[:client_key]))
+        end
+
+        new_socket = open_ssl_socket(new_socket, ssl_context)
+      end
+
+      new_socket
+    end
+
+    def open_ssl_socket(socket, ssl_context)
+
+      new_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
+      new_socket.sync_close = true
+
+      if @proxy
+        new_socket << "CONNECT " << @connection[:host] << ":" << @connection[:port] << HTTP_1_1
+        new_socket << "Host: " << @connection[:host] << ":" << @connection[:port] << CR_NL << CR_NL
+
+        # eat the proxy's connection response
+        while line = new_socket.readline.strip
+          break if line.empty?
+        end
+      end
+
+      new_socket.connect
+      # verify connection
+      new_socket.post_connection_check(@connection[:host])
+      new_socket
+    end
+
+    def open_socket
+      if @proxy
+        socket = TCPSocket.open(@proxy[:host], @proxy[:port])
+      else
+        socket = TCPSocket.open(@connection[:host], @connection[:port])
+      end
+      socket
+    end
+
+    def socket
+      sockets[@socket_key] ||= connect
+    end
+
+    def sockets
+      Thread.current[:_excon_sockets] ||= {}
+    end
+
+    def https?
+      @connection[:scheme] == 'https'
+    end
+
+    def setup_proxy(proxy)
+      uri = URI.parse(proxy)
+      unless uri.host and uri.port and uri.scheme
+        raise Excon::Errors::ProxyParseError, "Proxy is invalid"
+      end
+      {:host => uri.host, :port => uri.port, :scheme => uri.scheme}
+    end
+
+  end
+end
diff --git a/vendor/excon-0.6.3/lib/excon/errors.rb b/vendor/excon-0.6.3/lib/excon/errors.rb
new file mode 100644
index 0000000..4c851d3
--- /dev/null
+++ b/vendor/excon-0.6.3/lib/excon/errors.rb
@@ -0,0 +1,124 @@
+module Excon
+  module Errors
+
+    class Error < StandardError; end
+
+    class SocketError < Error
+      attr_reader :socket_error
+
+      def initialize(socket_error=nil)
+        if socket_error.message =~ /certificate verify failed/
+          super('Unable to verify certificate, please set `Excon.ssl_ca_path = path_to_certs` or `Excon.ssl_verify_peer = false` (less secure).')
+        else
+          super(socket_error.message)
+        end
+        set_backtrace(socket_error.backtrace)
+        @socket_error = socket_error
+      end
+    end
+
+    class ProxyParseError < Error; end
+
+    class StubNotFound < Error; end
+
+    class HTTPStatusError < Error
+      attr_reader :request, :response
+
+      def initialize(msg, request = nil, response = nil)
+        super(msg)
+        @request = request
+        @response = response
+      end
+    end
+
+    class Continue < HTTPStatusError; end                     # 100
+    class SwitchingProtocols < HTTPStatusError; end           # 101
+    class OK < HTTPStatusError; end                           # 200
+    class Created < HTTPStatusError; end                      # 201
+    class Accepted < HTTPStatusError; end                     # 202
+    class NonAuthoritativeInformation < HTTPStatusError; end  # 203
+    class NoContent < HTTPStatusError; end                    # 204
+    class ResetContent < HTTPStatusError; end                 # 205
+    class PartialContent < HTTPStatusError; end               # 206
+    class MultipleChoices < HTTPStatusError; end              # 300
+    class MovedPermanently < HTTPStatusError; end             # 301
+    class Found < HTTPStatusError; end                        # 302
+    class SeeOther < HTTPStatusError; end                     # 303
+    class NotModified < HTTPStatusError; end                  # 304
+    class UseProxy < HTTPStatusError; end                     # 305
+    class TemporaryRedirect < HTTPStatusError; end            # 307
+    class BadRequest < HTTPStatusError; end                   # 400
+    class Unauthorized < HTTPStatusError; end                 # 401
+    class PaymentRequired < HTTPStatusError; end              # 402
+    class Forbidden < HTTPStatusError; end                    # 403
+    class NotFound < HTTPStatusError; end                     # 404
+    class MethodNotAllowed < HTTPStatusError; end             # 405
+    class NotAcceptable < HTTPStatusError; end                # 406
+    class ProxyAuthenticationRequired < HTTPStatusError; end  # 407
+    class RequestTimeout < HTTPStatusError; end               # 408
+    class Conflict < HTTPStatusError; end                     # 409
+    class Gone < HTTPStatusError; end                         # 410
+    class LengthRequired < HTTPStatusError; end               # 411
+    class PreconditionFailed < HTTPStatusError; end           # 412
+    class RequestEntityTooLarge < HTTPStatusError; end        # 413
+    class RequestURITooLong < HTTPStatusError; end            # 414
+    class UnsupportedMediaType < HTTPStatusError; end         # 415
+    class RequestedRangeNotSatisfiable < HTTPStatusError; end # 416
+    class ExpectationFailed < HTTPStatusError; end            # 417
+    class UnprocessableEntity < HTTPStatusError; end          # 422
+    class InternalServerError < HTTPStatusError; end          # 500
+    class NotImplemented < HTTPStatusError; end               # 501
+    class BadGateway < HTTPStatusError; end                   # 502
+    class ServiceUnavailable < HTTPStatusError; end           # 503
+    class GatewayTimeout < HTTPStatusError; end               # 504
+
+    # Messages for nicer exceptions, from rfc2616
+    def self.status_error(request, response)
+      @errors ||= { 
+        100 => [Excon::Errors::Continue, 'Continue'],
+        101 => [Excon::Errors::SwitchingProtocols, 'Switching Protocols'],
+        200 => [Excon::Errors::OK, 'OK'],
+        201 => [Excon::Errors::Created, 'Created'],
+        202 => [Excon::Errors::Accepted, 'Accepted'],
+        203 => [Excon::Errors::NonAuthoritativeInformation, 'Non-Authoritative Information'],
+        204 => [Excon::Errors::NoContent, 'No Content'],
+        205 => [Excon::Errors::ResetContent, 'Reset Content'],
+        206 => [Excon::Errors::PartialContent, 'Partial Content'],
+        300 => [Excon::Errors::MultipleChoices, 'Multiple Choices'],
+        301 => [Excon::Errors::MovedPermanently, 'Moved Permanently'],
+        302 => [Excon::Errors::Found, 'Found'],
+        303 => [Excon::Errors::SeeOther, 'See Other'],
+        304 => [Excon::Errors::NotModified, 'Not Modified'],
+        305 => [Excon::Errors::UseProxy, 'Use Proxy'],
+        307 => [Excon::Errors::TemporaryRedirect, 'Temporary Redirect'],
+        400 => [Excon::Errors::BadRequest, 'Bad Request'],
+        401 => [Excon::Errors::Unauthorized, 'Unauthorized'],
+        402 => [Excon::Errors::PaymentRequired, 'Payment Required'],
+        403 => [Excon::Errors::Forbidden, 'Forbidden'],
+        404 => [Excon::Errors::NotFound, 'Not Found'],
+        405 => [Excon::Errors::MethodNotAllowed, 'Method Not Allowed'],
+        406 => [Excon::Errors::NotAcceptable, 'Not Acceptable'],
+        407 => [Excon::Errors::ProxyAuthenticationRequired, 'Proxy Authentication Required'],
+        408 => [Excon::Errors::RequestTimeout, 'Request Timeout'],
+        409 => [Excon::Errors::Conflict, 'Conflict'],
+        410 => [Excon::Errors::Gone, 'Gone'],
+        411 => [Excon::Errors::LengthRequired, 'Length Required'],
+        412 => [Excon::Errors::PreconditionFailed, 'Precondition Failed'],
+        413 => [Excon::Errors::RequestEntityTooLarge, 'Request Entity Too Large'],
+        414 => [Excon::Errors::RequestURITooLong, 'Request-URI Too Long'],
+        415 => [Excon::Errors::UnsupportedMediaType, 'Unsupported Media Type'],
+        416 => [Excon::Errors::RequestedRangeNotSatisfiable, 'Request Range Not Satisfiable'],
+        417 => [Excon::Errors::ExpectationFailed, 'Expectation Failed'],
+        422 => [Excon::Errors::UnprocessableEntity, 'Unprocessable Entity'],
+        500 => [Excon::Errors::InternalServerError, 'InternalServerError'],
+        501 => [Excon::Errors::NotImplemented, 'Not Implemented'],
+        502 => [Excon::Errors::BadGateway, 'Bad Gateway'],
+        503 => [Excon::Errors::ServiceUnavailable, 'Service Unavailable'],
+        504 => [Excon::Errors::GatewayTimeout, 'Gateway Timeout']
+      }
+      error, message = @errors[response.status] || [Excon::Errors::HTTPStatusError, 'Unknown']
+      error.new("Expected(#{request[:expects].inspect}) <=> Actual(#{response.status} #{message})\n  request => #{request.inspect}\n  response => #{response.inspect}", request, response)
+    end
+
+  end
+end
diff --git a/vendor/excon-0.6.3/lib/excon/response.rb b/vendor/excon-0.6.3/lib/excon/response.rb
new file mode 100644
index 0000000..ddcffc3
--- /dev/null
+++ b/vendor/excon-0.6.3/lib/excon/response.rb
@@ -0,0 +1,94 @@
+module Excon
+  class Response
+    NO_ENTITY = [204, 205, 304].freeze
+
+    attr_accessor :body, :headers, :status
+
+    def attributes
+      {
+        :body     => body,
+        :headers  => headers,
+        :status   => status
+      }
+    end
+
+    def initialize(attrs={})
+      @body    = attrs[:body]    || ''
+      @headers = attrs[:headers] || {}
+      @status  = attrs[:status]
+    end
+
+    def self.parse(socket, params={})
+      response = new(:status => socket.readline[9, 11].to_i)
+      block_given = block_given?
+
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(/:\s*/, 2)
+        response.headers[key] = ([*response.headers[key]] << value).compact.join(', ')
+        if key.casecmp('Content-Length') == 0
+          content_length = value.to_i
+        elsif (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+          transfer_encoding_chunked = true
+        elsif (key.casecmp('Connection') == 0) && (value.casecmp('close') == 0)
+          connection_close = true
+        end
+      end
+
+      unless (params[:method].to_s.casecmp('HEAD') == 0) || NO_ENTITY.include?(response.status)
+
+        # don't pass stuff into a block if there was an error
+        if params[:expects] && ![*params[:expects]].include?(response.status)
+          block_given = false
+        end
+
+        if block_given
+          if transfer_encoding_chunked
+            # 2 == "/r/n".length
+            while (chunk_size = socket.readline.chop!.to_i(16)) > 0
+              yield(socket.read(chunk_size + 2).chop!, nil, content_length)
+            end
+            socket.read(2)
+          elsif connection_close
+            remaining = socket.read
+            yield(remaining, remaining.length, content_length)
+          else
+            remaining = content_length
+            while remaining > 0
+              yield(socket.read([CHUNK_SIZE, remaining].min), [remaining - CHUNK_SIZE, 0].max, content_length)
+              remaining -= CHUNK_SIZE
+            end
+          end
+        else
+          if transfer_encoding_chunked
+            while (chunk_size = socket.readline.chop!.to_i(16)) > 0
+              response.body << socket.read(chunk_size + 2).chop! # 2 == "/r/n".length
+            end
+            socket.read(2) # 2 == "/r/n".length
+          elsif connection_close
+            response.body << socket.read
+          else
+            remaining = content_length
+            while remaining > 0
+              response.body << socket.read([CHUNK_SIZE, remaining].min)
+              remaining -= CHUNK_SIZE
+            end
+          end
+        end
+      end
+
+      response
+    end
+    
+    # Retrieve a specific header value. Header names are treated case-insensitively.
+    #   @param [String] name Header name
+    def get_header(name)
+      headers.each do |key,value|
+        if key.casecmp(name) == 0 
+          return value 
+        end
+      end
+      nil
+    end
+
+  end # class Response
+end # module Excon
diff --git a/vendor/excon-0.6.3/tests/basic_tests.rb b/vendor/excon-0.6.3/tests/basic_tests.rb
new file mode 100644
index 0000000..b29b829
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/basic_tests.rb
@@ -0,0 +1,5 @@
+with_rackup('basic.ru') do
+  Shindo.tests('Excon basics') do
+    basic_tests
+  end
+end
diff --git a/vendor/excon-0.6.3/tests/header_tests.rb b/vendor/excon-0.6.3/tests/header_tests.rb
new file mode 100644
index 0000000..cd131ed
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/header_tests.rb
@@ -0,0 +1,49 @@
+Shindo.tests('Excon response header support') do
+
+  with_rackup('response_header.ru') do
+
+    tests('Response#get_header') do
+      connection = Excon.new('http://foo.com:8080', :proxy => 'http://localhost:9292')
+      response = connection.request(:method => :get, :path => '/foo')
+
+      tests('with variable header capitalization') do
+        
+        tests('response.get_header("content-type")').returns('text/html') do
+          response.get_header("content-type")
+        end
+        
+        tests('response.get_header("custom-header")').returns('foo') do
+          response.get_header("custom-header")
+        end
+        
+        tests('response.get_header("lowercase-header")').returns('bar') do
+          response.get_header("lowercase-header")
+        end
+        
+      end
+      
+      tests('when provided key capitalization varies') do
+        
+        tests('response.get_header("CONTENT-TYPE")').returns('text/html') do
+          response.get_header("CONTENT-TYPE")
+        end
+        
+        tests('response.get_header("CoNtEnT-TyPe")').returns('text/html') do
+          response.get_header("CoNtEnT-TyPe")
+        end
+        
+      end
+      
+      tests('when header is unavailable') do
+        
+        tests('response.get_header("missing")').returns(nil) do
+          response.get_header("missing")
+        end
+        
+      end
+      
+    end
+
+  end
+
+end
diff --git a/vendor/excon-0.6.3/tests/proxy_tests.rb b/vendor/excon-0.6.3/tests/proxy_tests.rb
new file mode 100644
index 0000000..850f688
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/proxy_tests.rb
@@ -0,0 +1,136 @@
+Shindo.tests('Excon proxy support') do
+
+  tests('proxy configuration') do
+
+    tests('no proxy') do
+      connection = Excon.new('http://foo.com')
+
+      tests('connection.proxy').returns(nil) do
+        connection.proxy
+      end
+    end
+
+    tests('with fully-specified proxy: https://myproxy.net:8080') do
+      connection = Excon.new('http://foo.com', :proxy => 'https://myproxy.net:8080')
+
+      tests('connection.proxy.host').returns('myproxy.net') do
+        connection.proxy[:host]
+      end
+
+      tests('connection.proxy.port').returns(8080) do
+        connection.proxy[:port]
+      end
+
+      tests('connection.proxy.scheme').returns('https') do
+        connection.proxy[:scheme]
+      end
+    end
+
+    tests('with proxy config from the environment') do
+      ENV['http_proxy'] = 'http://myproxy:8080'
+      ENV['https_proxy'] = 'http://mysecureproxy:8081'
+
+      tests('an http connection') do
+        connection = Excon.new('http://foo.com')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      tests('an https connection') do
+        connection = Excon.new('https://secret.com')
+
+        tests('connection.proxy.host').returns('mysecureproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8081) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      tests('http proxy from the environment overrides config') do
+        connection = Excon.new('http://foo.com', :proxy => 'http://hard.coded.proxy:6666')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+      end
+
+      ENV.delete('http_proxy')
+      ENV.delete('https_proxy')
+    end
+
+    tests('with only http_proxy config from the environment') do
+      ENV['http_proxy'] = 'http://myproxy:8080'
+      ENV.delete('https_proxy')
+
+      tests('an https connection') do
+        connection = Excon.new('https://secret.com')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      ENV.delete('http_proxy')
+    end
+
+  end
+
+  with_rackup('proxy.ru') do
+
+    tests('http proxying: http://foo.com:8080') do
+      connection = Excon.new('http://foo.com:8080', :proxy => 'http://localhost:9292')
+      response = connection.request(:method => :get, :path => '/bar', :query => {:alpha => 'kappa'})
+
+      tests('response.status').returns(200) do
+        response.status
+      end
+
+      # must be absolute form for proxy requests
+      tests('sent Request URI').returns('http://foo.com:8080/bar?alpha=kappa') do
+        response.headers['Sent-Request-Uri']
+      end
+
+      tests('sent Host header').returns('foo.com:8080') do
+        response.headers['Sent-Host']
+      end
+
+      tests('sent Proxy-Connection header').returns('Keep-Alive') do
+        response.headers['Sent-Proxy-Connection']
+      end
+
+      tests('response.body (proxied content)').returns('proxied content') do
+        response.body
+      end
+    end
+
+  end
+
+end
diff --git a/vendor/excon-0.6.3/tests/query_string_tests.rb b/vendor/excon-0.6.3/tests/query_string_tests.rb
new file mode 100644
index 0000000..21a37e6
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/query_string_tests.rb
@@ -0,0 +1,58 @@
+with_rackup('query_string.ru') do
+  Shindo.tests('Excon query string variants') do
+    connection = Excon.new('http://127.0.0.1:9292')
+
+    tests(":query => {:foo => 'bar'}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar'})
+      query_string = response.body[7..-1] # query string sent
+
+      tests("query string sent").returns('foo=bar') do
+        query_string
+      end
+
+    end
+
+    tests(":query => {:foo => nil}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => nil})
+      query_string = response.body[7..-1] # query string sent
+
+      tests("query string sent").returns('foo') do
+        query_string
+      end
+
+    end
+
+    tests(":query => {:foo => 'bar', :me => nil}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar', :me => nil})
+      query_string = response.body[7..-1] # query string sent
+
+      test("query string sent includes 'foo=bar'") do
+        query_string.split('&').include?('foo=bar')
+      end
+
+      test("query string sent includes 'me'") do
+        query_string.split('&').include?('me')
+      end
+
+    end
+
+    tests(":query => {:foo => 'bar', :me => 'too'}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar', :me => 'too'})
+      query_string = response.body[7..-1] # query string sent
+
+      test("query string sent includes 'foo=bar'") do
+        query_string.split('&').include?('foo=bar')
+      end
+
+      test("query string sent includes 'me=too'") do
+        query_string.split('&').include?('me=too')
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/excon-0.6.3/tests/rackups/basic.ru b/vendor/excon-0.6.3/tests/rackups/basic.ru
new file mode 100644
index 0000000..504e1cd
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/rackups/basic.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/content-length/:value') do |value|
+    headers("Custom" => "Foo: bar")
+    'x' * value.to_i
+  end
+end
+
+run App
diff --git a/vendor/excon-0.6.3/tests/rackups/proxy.ru b/vendor/excon-0.6.3/tests/rackups/proxy.ru
new file mode 100644
index 0000000..b329ddc
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/rackups/proxy.ru
@@ -0,0 +1,14 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/bar') do
+    headers(
+      "Sent-Request-Uri" => request.env['REQUEST_URI'].to_s,
+      "Sent-Host" => request.env['HTTP_HOST'].to_s,
+      "Sent-Proxy-Connection" => request.env['HTTP_PROXY_CONNECTION'].to_s
+    )
+    'proxied content'
+  end
+end
+
+run App
diff --git a/vendor/excon-0.6.3/tests/rackups/query_string.ru b/vendor/excon-0.6.3/tests/rackups/query_string.ru
new file mode 100644
index 0000000..394063e
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/rackups/query_string.ru
@@ -0,0 +1,9 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/query') do
+    "query: " << request.query_string
+  end
+end
+
+run App
diff --git a/vendor/excon-0.6.3/tests/rackups/response_header.ru b/vendor/excon-0.6.3/tests/rackups/response_header.ru
new file mode 100644
index 0000000..22f168a
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/rackups/response_header.ru
@@ -0,0 +1,14 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/foo') do
+    headers(
+      "Content-Type" => 'text/html',
+      "CUSTOM-HEADER" => 'foo',
+      "lowercase-header" => 'bar'
+    )
+    'primary content'
+  end
+end
+
+run App
diff --git a/vendor/excon-0.6.3/tests/rackups/thread_safety.ru b/vendor/excon-0.6.3/tests/rackups/thread_safety.ru
new file mode 100644
index 0000000..8765cac
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/rackups/thread_safety.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/id/:id/wait/:wait') do |id, wait|
+    sleep(wait.to_i)
+    id.to_s
+  end
+end
+
+run App
diff --git a/vendor/excon-0.6.3/tests/stub_tests.rb b/vendor/excon-0.6.3/tests/stub_tests.rb
new file mode 100644
index 0000000..b1f6598
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/stub_tests.rb
@@ -0,0 +1,71 @@
+Shindo.tests('Excon stubs') do
+  Excon.mock = true
+
+  tests("missing stub").raises(Excon::Errors::StubNotFound) do
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+  end
+
+  tests("stub({})").raises(ArgumentError) do
+    Excon.stub({})
+  end
+
+  tests("stub({}, {}) {}").raises(ArgumentError) do
+    Excon.stub({}, {}) {}
+  end
+
+  tests("stub({:method => :get}, {:body => 'body', :status => 200})") do
+
+    Excon.stub({:method => :get}, {:body => 'body', :status => 200})
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+
+    tests('response.body').returns('body') do
+      response.body
+    end
+
+    tests('response.headers').returns({}) do
+      response.headers
+    end
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    Excon.stubs.pop
+
+  end
+
+  tests("stub({:body => 'body', :method => :get}) {|params| {:body => params[:body], :headers => params[:headers], :status => 200}}") do
+
+    Excon.stub({:body => 'body', :method => :get}) {|params| {:body => params[:body], :headers => params[:headers], :status => 200}}
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:body => 'body', :method => :get, :path => '/content-length/100')
+
+    tests('response.body').returns('body') do
+      response.body
+    end
+
+    tests('response.headers').returns({'Host' => '127.0.0.1:9292'}) do
+      response.headers
+    end
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    Excon.stubs.pop
+
+  end
+
+  Excon.mock = false
+
+  tests('mock = false') do
+    with_rackup('basic.ru') do
+      basic_tests
+    end
+  end
+
+end
diff --git a/vendor/excon-0.6.3/tests/test_helper.rb b/vendor/excon-0.6.3/tests/test_helper.rb
new file mode 100644
index 0000000..a13cf7a
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/test_helper.rb
@@ -0,0 +1,56 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default, :development)
+
+def basic_tests
+  tests('GET /content-length/100') do
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    tests("response.headers['Connection']").returns('Keep-Alive') do
+      response.headers['Connection']
+    end
+
+    tests("response.headers['Content-Length']").returns('100') do
+      response.headers['Content-Length']
+    end
+
+    tests("response.headers['Content-Type']").returns('text/html;charset=utf-8') do
+      response.headers['Content-Type']
+    end
+
+    test("Time.parse(response.headers['Date']).is_a?(Time)") do
+      Time.parse(response.headers['Date']).is_a?(Time)
+    end
+
+    test("!!(response.headers['Server'] =~ /^WEBrick/)") do
+      !!(response.headers['Server'] =~ /^WEBrick/)
+    end
+
+    tests("response.headers['Custom']").returns("Foo: bar") do
+      response.headers['Custom']
+    end
+
+    tests("response.body").returns('x' * 100) do
+      response.body
+    end
+  end
+end
+
+def rackup_path(*parts)
+  File.expand_path(File.join(File.dirname(__FILE__), 'rackups', *parts))
+end
+
+def with_rackup(name)
+  pid, w, r, e = Open4.popen4("rackup #{rackup_path(name)}")
+  until e.gets =~ /HTTPServer#start:/; end
+  yield
+ensure
+  Process.kill(9, pid)
+end
diff --git a/vendor/excon-0.6.3/tests/thread_safety_tests.rb b/vendor/excon-0.6.3/tests/thread_safety_tests.rb
new file mode 100644
index 0000000..03afb8e
--- /dev/null
+++ b/vendor/excon-0.6.3/tests/thread_safety_tests.rb
@@ -0,0 +1,26 @@
+with_rackup('thread_safety.ru') do
+  Shindo.tests('Excon thread safety') do
+    connection = Excon.new('http://127.0.0.1:9292')
+
+    long_thread = Thread.new {
+      response = connection.request(:method => 'GET', :path => '/id/1/wait/2')
+      Thread.current[:success] = response.body == '1'
+    }
+
+    short_thread = Thread.new {
+      response = connection.request(:method => 'GET', :path => '/id/2/wait/1')
+      Thread.current[:success] = response.body == '2'
+    }
+
+    long_thread.join
+    short_thread.join
+
+    test('long_thread') do
+      long_thread[:success]
+    end
+
+    test('short_thread') do
+      short_thread[:success]
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/.document b/vendor/fog-0.8.2/.document
new file mode 100644
index 0000000..2a5f665
--- /dev/null
+++ b/vendor/fog-0.8.2/.document
@@ -0,0 +1,3 @@
+README.rdoc
+lib/**/*.rb
+bin/*
diff --git a/vendor/fog-0.8.2/.gitignore b/vendor/fog-0.8.2/.gitignore
new file mode 100644
index 0000000..2af463a
--- /dev/null
+++ b/vendor/fog-0.8.2/.gitignore
@@ -0,0 +1,13 @@
+*~
+*.gem
+*.rbc
+*.sw?
+.bundle
+.DS_Store
+docs/_site/*
+coverage
+doc/*
+Gemfile.lock
+rdoc
+pkg
+spec/credentials.yml
diff --git a/vendor/fog-0.8.2/Gemfile b/vendor/fog-0.8.2/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/vendor/fog-0.8.2/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/vendor/fog-0.8.2/README.rdoc b/vendor/fog-0.8.2/README.rdoc
new file mode 100644
index 0000000..6dc2425
--- /dev/null
+++ b/vendor/fog-0.8.2/README.rdoc
@@ -0,0 +1,154 @@
+http://geemus.s3.amazonaws.com/fog.png
+
+fog is the Ruby cloud computing library, top to bottom:
+
+* Collections provide a simplified interface, making clouds easier to work with and switch between.
+* Requests allow power users to get the most out of the features of each individual cloud.
+* Mocks make testing and integrating a breeze.
+
+== Getting Started
+
+  sudo gem install fog
+
+Now type 'fog' to try stuff, confident that fog will let you know what to do. Here is an example of wading through server creation for Amazon Elastic Compute Cloud:
+
+  >> server = AWS.servers.create
+  ArgumentError: image_id is required for this operation
+
+  >> server = AWS.servers.create(:image_id => 'ami-5ee70037')
+  <Fog::AWS::EC2::Server [...]>
+
+  >> server.destroy # cleanup after yourself or regret it, trust me
+  true
+
+== Collections
+
+A high level interface to each cloud is provided through collections, such as `images` and `servers`.
+You can see a list of available collections by calling `collections` on the connection object. You can try it out using the `fog` command:
+
+  >> AWS.collections
+  [:addresses, :directories, ..., :volumes, :zones]
+
+Some collections are available across multiple providers:
+
+* compute providers have +flavors+, +images+ and +servers+
+* dns providers have +zones+ and +records+
+* storage providers have +directories+ and +files+
+
+Collections share basic CRUD type operations, such as:
+* +all+ - fetch every object of that type from the provider.
+* +create+ - initialize a new record locally and a remote resource with the provider.
+* +get+ - fetch a single object by it's identity from the provider.
+* +new+ - initialize a new record locally, but do not create a remote resource with the provider.
+
+As an example, we'll try initializing and persisting a Rackspace Cloud server:
+
+  require 'fog'
+
+  compute = Fog::Compute.new(
+    :provider           => 'Rackspace',
+    :rackspace_api_key  => key,
+    :rackspace_username => username
+  )
+
+  # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
+  server = compute.servers.create(:flavor_id => 1, :image_id => 3, :name => 'my_server')
+  server.wait_for { ready? } # give server time to boot
+
+  # DO STUFF
+
+  server.destroy # cleanup after yourself or regret it, trust me
+
+== Models
+
+Many of the collection methods return individual objects, which also provide common methods:
+* +destroy+ - will destroy the persisted object from the provider
+* +save+ - persist the object to the provider
+* +wait_for+ - takes a block and waits for either the block to return true for the object or for a timeout (defaults to 10 minutes)
+
+== Mocks
+
+As you might imagine, testing code using Fog can be slow and expensive, constantly turning on and and shutting down instances.
+Mocking allows skipping this overhead by providing an in memory representation resources as you make requests.
+Enabling mocking easy to use, before you run other commands, simply run:
+
+  Fog.mock!
+
+Then proceed as usual, if you run into unimplemented mocks fog will raise an error and as always contributions are welcome!
+
+== Requests
+
+Requests allow you to dive deeper when the models just can't cut it.
+You can see a list of available requests by calling #requests on the connection object.
+
+For instance, ec2 provides methods related to reserved instances that don't have any models (yet). Here is how you can lookup your reserved instances:
+
+  $ fog
+  >> AWS[:ec2].describe_reserved_instances
+  #<Excon::Response [...]>
+
+It will return an {excon}[http://github.com/geemus/excon] response, which has `body`, `headers` and `status`. Both return nice hashes.
+
+== Go forth and conquer
+
+Play around and use the console to explore or check out {fog.io}[http://fog.io] for more details and examples. Once you are reading to start scripting fog, here is a quick hint on how to make connections without the command line thing to help you.
+
+  # create a compute connection
+  compute = Fog::Compute.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+  # compute operations go here
+
+  # create a storage connection
+  storage = Fog::Storage.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+  # storage operations go here
+
+geemus says: "That should give you everything you need to get started, but let me know if there is anything I can do to help!"
+
+== Contributing
+
+* Find something you would like to work on. For suggestions look for the `easy`, `medium` and `hard` tags in the {issues}[http://github.com/geemus/fog/issues]
+* Fork the project and do your work in a topic branch.
+* Add shindo tests to prove your code works and run all the tests using `bundle exec rake`.
+* Rebase your branch against geemus/fog to make sure everything is up to date.
+* Commit your changes and send a pull request.
+
+== T-Shirts
+
+Wonder how you can get a lovely fog shirt? Look no further!
+
+* Blue shirts go to people who have contributed indirectly, great examples are writing blog posts or giving lightning talks.
+* Grey shirts and a follow from @fog go to people who have made it on to the {contributors list}[https://github.com/geemus/fog/contributors] by submitting code.
+* Black shirts go to people who have made it on to the {collaborators list}[https://github.com/api/v2/json/repos/show/geemus/fog/collaborators] by coercing geemus into adding them (geemus is currently the only member of this list).
+
+== Additional Resources
+
+{fog.io}[http://fog.io]
+
+== Sponsorship
+
+http://www.engineyard.com/images/logo.png
+
+All new work on fog is sponsored by {Engine Yard}[http://engineyard.com]
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/fog-0.8.2/Rakefile b/vendor/fog-0.8.2/Rakefile
new file mode 100644
index 0000000..1632f4d
--- /dev/null
+++ b/vendor/fog-0.8.2/Rakefile
@@ -0,0 +1,305 @@
+require 'rubygems'
+require 'bundler/setup'
+require 'date'
+require 'lib/fog'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+task :default => :test
+
+task :examples do
+  sh("export FOG_MOCK=false && bundle exec shindont examples")
+  # some don't provide mocks so we'll leave this out for now
+  # sh("export FOG_MOCK=true  && bundle exec shindont examples")
+end
+
+task :test do # => :examples do
+  Rake::Task[:mock_tests].invoke
+  Rake::Task[:real_tests].invoke
+end
+
+def tests(mocked)
+  Formatador.display_line
+  sh("export FOG_MOCK=#{mocked} && bundle exec spec spec")
+  Formatador.display_line
+  start = Time.now.to_i
+  threads = []
+  Thread.main[:results] = []
+  Fog.providers.each do |provider|
+    threads << Thread.new do
+      Thread.main[:results] << {
+        :provider => provider,
+        :success  => sh("export FOG_MOCK=#{mocked} && bundle exec shindont +#{provider.downcase}")
+      }
+    end
+  end
+  threads.each do |thread|
+    thread.join
+  end
+  Formatador.display_table(Thread.main[:results].sort {|x,y| x[:provider] <=> y[:provider]})
+  Formatador.display_line("[bold]FOG_MOCK=#{mocked}[/] tests completed in [bold]#{Time.now.to_i - start}[/] seconds")
+  Formatador.display_line
+end
+
+task :mock_tests do
+  tests(true)
+end
+
+task :real_tests do
+  tests(false)
+end
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rdoc/task'
+RDoc::Task.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+  Rake::Task[:docs].invoke
+  Rake::Task[:changelog].invoke
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+
+  # replace name version and date
+  replace_header(spec, :name)
+  replace_header(spec, :version)
+  replace_header(spec, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(spec, :rubyforge_project)
+
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
+
+task :changelog do
+  timestamp = Time.now.utc.strftime('%m/%d/%Y')
+  sha = `git log | head -1`.split(' ').last
+  changelog = ["#{version} #{timestamp} #{sha}"]
+  changelog << ('=' * changelog[0].length)
+  changelog << ''
+
+  last_sha = `cat changelog.txt | head -1`.split(' ').last
+  shortlog = `git shortlog #{last_sha}..HEAD`
+  changes = {}
+  committers = {}
+  for line in shortlog.split("\n")
+    if line =~ /^\S/
+      committer = line.split(' (', 2).first
+      committers[committer] = 0
+    elsif line =~ /^\s*((Merge.*)|(Release.*))?$/
+      # skip empty lines, Merge and Release commits
+    else
+      unless line[-1..-1] == '.'
+        line << '.'
+      end
+      line.gsub!(/^\s*\[([^\]]*)\] /, '')
+      tag = $1 || 'misc'
+      changes[tag] ||= []
+      changes[tag] << (line << ' thanks ' << committer)
+      committers[committer] += 1
+    end
+  end
+
+  for committer, commits in committers.to_a.sort {|x,y| y[1] <=> x[1]}
+    if ['Aaron Suggs', 'geemus', 'Wesley Beary'].include?(committer)
+      next
+    end
+    changelog << "MVP! #{committer}"
+    changelog << ''
+    break
+  end
+
+  for tag in changes.keys.sort
+    changelog << ('[' << tag << ']')
+    for commit in changes[tag]
+      changelog << ('  ' << commit)
+    end
+    changelog << ''
+  end
+
+  `echo "#{changelog.join("\n")}" | pbcopy`
+  p 'changelog copied to clipboard'
+end
+
+task :docs do
+  # build the docs locally
+  sh "jekyll docs docs/_site"
+
+  # connect to storage provider
+  Fog.credential = :geemus
+  storage = Fog::Storage.new(:provider => 'AWS')
+  directory = storage.directories.new(:key => 'fog.io')
+
+  # write web page files to versioned 'folder'
+  for file_path in Dir.glob('docs/_site/**/*')
+    next if File.directory?(file_path)
+    file_name = file_path.gsub('docs/_site/', '')
+    key = '' << version << '/' << file_name
+    Formatador.redisplay(' ' * 128)
+    Formatador.redisplay("Uploading [bold]#{key}[/]")
+    if File.extname(file_name) == '.html'
+      # rewrite links with version
+      body = File.read(file_path)
+      body.gsub!(/vX.Y.Z/, 'v' << version)
+      body.gsub!(/='\//, %{='/} << version << '/')
+      body.gsub!(/="\//, %{="/} << version << '/')
+      content_type = 'text/html'
+      directory.files.create(
+        :body         => redirecter(key),
+        :content_type => 'text/html',
+        :key          => 'latest/' << file_name,
+        :public       => true
+      )
+    else
+      body = File.open(file_path)
+      content_type = nil # leave it up to mime-types
+    end
+    directory.files.create(
+      :body         => body,
+      :content_type => content_type,
+      :key          => key,
+      :public       => true
+    )
+  end
+  Formatador.redisplay(' ' * 128)
+  Formatador.redisplay('Uploaded docs/_site')
+
+  # write rdoc files to versioned 'folder'
+  Rake::Task[:rdoc].invoke
+  for file_path in Dir.glob('rdoc/**/*')
+    next if File.directory?(file_path)
+    file_name = file_path.gsub('rdoc/', '')
+    key = '' << version << '/rdoc/' << file_name
+    Formatador.redisplay(' ' * 128)
+    Formatador.redisplay("Uploading [bold]#{key}[/]")
+    directory.files.create(
+      :body         => File.open(file_path),
+      :key          => key,
+      :public       => true
+    )
+  end
+  Formatador.redisplay(' ' * 128)
+  directory.files.create(
+    :body         => redirecter("#{version}/rdoc/index.html"),
+    :content_type => 'text/html',
+    :key          => 'latest/rdoc/index.html',
+    :public       => true
+  )
+  Formatador.redisplay('Uploaded rdoc')
+
+  # write base index with redirect to new version
+  directory.files.create(
+    :body         => redirecter(version),
+    :content_type => 'text/html',
+    :key          => 'index.html',
+    :public       => true
+  )
+
+  Formatador.display_line
+end
+
+def redirecter(path)
+  redirecter = <<-HTML
+<!doctype html>
+<head>
+<title>fog</title>
+<meta http-equiv="REFRESH" content="0;url=http://fog.io/#{path}">
+</head>
+<body>
+  <a href="http://fog.io/#{path}">redirecting to lastest (#{path})</a>
+</body>
+</html>
+HTML
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/benchs/fog_vs.rb b/vendor/fog-0.8.2/benchs/fog_vs.rb
new file mode 100644
index 0000000..464d8df
--- /dev/null
+++ b/vendor/fog-0.8.2/benchs/fog_vs.rb
@@ -0,0 +1,106 @@
+require 'rubygems'
+require 'aws/s3'
+require 'benchmark'
+require 'right_aws'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+
+data = File.open(File.expand_path('~/.fog')).read
+config = YAML.load(data)[:default]
+fog = Fog::AWS::S3.new(
+  :aws_access_key_id     => config[:aws_access_key_id],
+  :aws_secret_access_key => config[:aws_secret_access_key]
+)
+raws = RightAws::S3Interface.new(
+  config[:aws_access_key_id],
+  config[:aws_secret_access_key]
+)
+raws.logger.level = 3 # ERROR
+awss3 = AWS::S3::Base.establish_connection!(
+  :access_key_id     => config[:aws_access_key_id],
+  :secret_access_key => config[:aws_secret_access_key],
+  :persistent        => true
+)
+
+TIMES = 10
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('fog.put_bucket') do
+    TIMES.times do |x|
+      fog.put_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.create_bucket') do
+    TIMES.times do |x|
+      raws.create_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.create') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.create("awss3bench#{x}")
+    end
+  end
+
+  bench.report('fog.put_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        fog.put_object("fogbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('raws.put') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        raws.put("rawsbench#{x}", "lorem_#{y}", file)
+      end
+    end
+  end
+  bench.report('awss3::S3Object.create') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        file = File.open(File.dirname(__FILE__) + '/../spec/lorem.txt', 'r')
+        AWS::S3::S3Object.create("lorem_#{y}", file, "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_object') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        fog.delete_object("fogbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('raws.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        raws.delete("rawsbench#{x}", "lorem_#{y}")
+      end
+    end
+  end
+  bench.report('awss3::S3Object.delete') do
+    TIMES.times do |x|
+      TIMES.times do |y|
+        AWS::S3::S3Object.delete("lorem_#{y}", "awss3bench#{x}")
+      end
+    end
+  end
+
+  bench.report('fog.delete_bucket') do
+    TIMES.times do |x|
+      fog.delete_bucket("fogbench#{x}")
+    end
+  end
+  bench.report('raws.delete_bucket') do
+    TIMES.times do |x|
+      raws.delete_bucket("rawsbench#{x}")
+    end
+  end
+  bench.report('awss3::Bucket.delete') do
+    TIMES.times do |x|
+      AWS::S3::Bucket.delete("awss3bench#{x}")
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/benchs/params.rb b/vendor/fog-0.8.2/benchs/params.rb
new file mode 100644
index 0000000..25674e7
--- /dev/null
+++ b/vendor/fog-0.8.2/benchs/params.rb
@@ -0,0 +1,43 @@
+require 'benchmark'
+
+def hash(options)
+  result = "#{options.delete(:name)}"
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+def optional(name, a = nil, b = nil, c = nil)
+  result = "#{name}"
+  options = { :a => a, :b => b, :c => c }
+  for key, value in options
+    result << " #{key} => #{value} "
+  end
+  result
+end
+
+COUNT = 100_000
+data = "Content-Length: 100"
+Benchmark.bmbm(25) do |bench|
+  bench.report('hash') do
+    COUNT.times do
+      hash({:name => 'name'})
+    end
+  end
+  bench.report('optional') do
+    COUNT.times do
+      optional('name')
+    end
+  end
+  bench.report('hash_with_option') do
+    COUNT.times do
+      hash({:name => 'name', :a => 'a', :b => 'b', :c => 'c'})
+    end
+  end
+  bench.report('optional_with_option') do
+    COUNT.times do
+      optional('name', :a => 'a', :b => 'b', :c => 'c')
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/benchs/parse_vs_push.rb b/vendor/fog-0.8.2/benchs/parse_vs_push.rb
new file mode 100644
index 0000000..01bd998
--- /dev/null
+++ b/vendor/fog-0.8.2/benchs/parse_vs_push.rb
@@ -0,0 +1,69 @@
+require 'benchmark'
+require 'rubygems'
+require 'nokogiri'
+
+class Parser < Nokogiri::XML::SAX::Document
+
+  attr_reader :response
+
+  def initialize
+    reset
+  end
+
+  def reset
+    @item = {}
+    @response = { :items => [] }
+  end
+
+  def characters(string)
+    @value ||= ''
+    @value << string.strip
+  end
+
+  def start_element(name, attrs = [])
+    @value = nil
+  end
+
+  def end_element(name)
+    case name
+    when 'item'
+      @response[:items] << @item
+      @item = {}
+    when 'key'
+      @item[:key] = value
+    end
+  end
+
+  def value
+    @value.dup
+  end
+
+end
+
+data = <<-DATA
+<items>
+  <item>
+    <key>value</key>
+  </item>
+</items>
+DATA
+
+COUNT = 10_000
+
+Benchmark.bmbm(25) do |bench|
+  bench.report('parse') do
+    COUNT.times do
+      parser = Parser.new
+      Nokogiri::XML::SAX::Parser.new(parser).parse(data)
+      parser.response
+    end
+  end
+
+  bench.report('push') do
+    COUNT.times do
+      parser = Parser.new
+      Nokogiri::XML::SAX::PushParser.new(parser).write(data, true)
+      parser.response
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/bin/fog b/vendor/fog-0.8.2/bin/fog
new file mode 100755
index 0000000..5cac30f
--- /dev/null
+++ b/vendor/fog-0.8.2/bin/fog
@@ -0,0 +1,41 @@
+#!/usr/bin/env ruby
+require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib', 'fog'))
+require 'irb'
+require 'yaml'
+Fog.credential = ARGV.first ? ARGV.first.to_sym : nil
+Fog.mock! if ENV['FOG_MOCK']
+if Fog.credentials.empty?
+  Fog::Errors.missing_credentials
+end
+
+require 'fog/bin'
+
+providers = Fog.available_providers
+providers = if providers.length > 1
+  providers[0...-1].join(', ') << ' and ' << providers[-1]
+else
+  providers.first
+end
+
+if ARGV.length > 1
+
+  puts(instance_eval(ARGV[1..-1].join(' ')).to_json)
+
+else
+
+  ARGV.clear # Avoid passing args to IRB
+  IRB.setup(nil)
+  @irb = IRB::Irb.new(nil)
+  IRB.conf[:MAIN_CONTEXT] = @irb.context
+  IRB.conf[:PROMPT][:FOG] = IRB.conf[:PROMPT][:SIMPLE].dup
+  IRB.conf[:PROMPT][:FOG][:RETURN] = "%s\n"
+  @irb.context.prompt_mode = :FOG
+  @irb.context.workspace = IRB::WorkSpace.new(binding)
+
+  Formatador.display_line('Welcome to fog interactive!')
+  Formatador.display_line(":#{Fog.credential} provides #{providers}")
+  providers = Fog.providers
+
+  catch(:IRB_EXIT) { @irb.eval_input }
+
+end
diff --git a/vendor/fog-0.8.2/changelog.txt b/vendor/fog-0.8.2/changelog.txt
new file mode 100644
index 0000000..8840bcc
--- /dev/null
+++ b/vendor/fog-0.8.2/changelog.txt
@@ -0,0 +1,327 @@
+0.8.1 05/13/2011 3a452347a396f0ad1fea7f5475fb3c349b10f527
+=========================================================
+
+[aws|compute]
+  less confusing explanation comment. thanks geemus
+
+[compute|aws]
+  Fix describe_instances filtering. thanks ktheory
+  Add get_password_data request. thanks ktheory
+
+[core]
+  Add test for Fog::Parsers::Base. thanks ktheory
+  handle busted ENV['HOME']. thanks pfalcone     closes #301. thanks geemus
+  update fog.io in release task. thanks geemus
+  add hash to changelog. thanks geemus
+  work toward automating changelog. thanks geemus
+
+0.8.0 05/12/2011 27bf76d1f881bec0f900cd11d5c2a10dce4856ca
+=========================================================
+
+MVP! ktheory
+
+[aws|cloudformation] tests sleep to avoid throttling error :(
+
+[aws|elb] 
+  Add tests for create, describe, and delete. thanks ktheory
+  Fix Policies in describe_load_balancers parser. thanks ktheory
+  Stub out missing requests. thanks ktheory
+  Add configure_health_check request. thanks ktheory
+  Add support for creating and deleting listeners. thanks ktheory
+  Add requests for creating cookie policies. thanks ktheory
+  Add request ELB#delete_load_balancer_policy. thanks ktheory
+  Add request ELB#set_load_balancer_policies_of_listener. thanks ktheory
+  Create a model and collection for load_balancers. thanks ktheory
+  Create Policies collection and model. thanks ktheory
+  Create Listeners collection and model. thanks ktheory
+  Remove redundant NotFound error class. thanks ktheory
+  reorg model files for consistency
+
+[aws|iam]
+  Added server certificate tests. thanks ktheory
+  Parse server certificate UploadDate. thanks ktheory
+  Add list_server_certificates request. thanks ktheory
+  fix test description for update_login_profile
+
+[aws|rds]
+  Fix exception for missing DB security groups. thanks ktheory
+  Remove redundant NotFound class. thanks ktheory
+  Improve instance tests. thanks ktheory
+  reorg model files for consistency
+  change status waits for more consistent testing
+
+[aws|ses]
+  fix format of Destinations in send_raw_email and correct doc. thanks jhawthorne
+  Make specifying Destinations for send_raw_email work and match amazon docs. thanks jhawthorne
+  fix indent in doc. thanks jhawthorne
+
+[aws|simpledb]
+  correction for item and attribute counters in encode_batch_attributes. thanks joshounapoli
+  Fix a problem with the encoding of the tilde character. AWS needs tilde to be unescaped, or else the signature fails. CGI.escape escapes tilde; don't use it. thanks joshounapoli
+  Correction to the regular expression for unreserved characters. thanks joshounapoli
+  Test encode_batch_attributes with two attributes in one item to demonstrate an error in encode_batch_attributes. An unmocked test run will show a "400 Bad Request" response from SimpleDB. thanks joshounapoli
+
+[compute]
+  default to Ubuntu 10.04 LTS 64bit for image id
+  [aws]
+    Fix server tests. thanks ktheory
+    Fixes trailing whitespace in attributes. thanks ktheory
+    Fix & improve some tests. thanks ktheory
+    Use default AMI in tests. thanks ktheory
+    Add failing tests for keypair parsing. thanks ktheory
+    Add different availability zones for each region to the mock. thanks smerritt
+    Update docs for Compute::Real#initialize to include ap-* regions. thanks smerritt
+    change default flavor to t1.micro (so it will be 64-bit)
+    use old style, more consistent call to get single instance
+    fix console output format in tests
+  [bluebox]
+    Adding lb_applications, lb_services, lb_backends attributes to the model. thanks cparades
+    Adding in a few more tests for LB's. thanks cparades
+    Rolling back change. thanks cparades
+    Added in some data for testing. thanks cparades
+    Fixed typo in Bluebox test. thanks tokengeek
+    don't use a lb_application I don't own in tests
+  [brightbox]
+    Updated Image identifiers to match latest available Ubuntu Lucid 10.04 LTS 64bit image. thanks tokengeek
+  [ecloud]
+    1.9.2 compat, String#[] doesn't return nil as we expected. thanks dpiddy
+  [stormondemand]
+    Implement Stormondemand API. thanks seeingidog
+    cleanup
+    fixes for tests
+  [voxel]
+    Prevent voxel tests running if missing credentials. thanks tokengeek
+    minor fixes for voxel tests
+
+[core]
+  Parser does not concatenates all the strings when parsing. thanks geraud
+  Drop default_executable line from gemspec. thanks mattsa
+  Fix small logic error in Model#wait_for. thanks pvande
+  Make Model#reload more resilient against errors. thanks pvande
+  Simplify dup-ing of @attributes for models. thanks smerritt
+  Make Model#dup copy the attributes too. thanks smerritt
+  Fix typo in spec output. thanks smerritt
+  tighten excon dependency. Closes #250
+  cleanup gemspec. closes #251
+  Fixes error messaging when credentials missing
+  update parser to better handle whitespace
+
+[docs]
+  Add link to multipart upload and threads article. thanks gsandie
+  restructure toward same organization as rest of repo
+  simplify redirector to just point at directory instead of specifically index.html
+  generalize version subbing in href to catch src too
+  style cleanup for cdn/dns/storage
+  storage shouldn't be all caps
+  link to fog.io more prominently
+  fix new links to properly include version
+  replace getting started link
+  add link to learn_fog
+  remove confusion by linking to fog.io instead of wiki
+  reworking getting started guide
+  add requires
+
+[dns|aws] fix error handling for getting unknown keys
+
+[storage]
+  auto-paginate for #each     closes #268
+  [aws] 
+    Add #each_file method to directory model. thanks smerritt
+    Add documentation for #each_file method. thanks smerritt
+    Emit warning from Files#each. thanks smerritt
+    Make Files#each iterate all files, not just the first page. thanks smerritt
+    Fix docs to say files.each, not each_file. thanks smerritt
+    Issue #283: S3 get_object request doesn't really support the Range header. thanks yalon
+    fix format for multipart upload tests
+  [google]
+    fix format in bucket_tests
+  [rackspace]
+    mark get_object with block test pending when mocked
+
+0.7.2 04/05/2011
+================
+
+[aws|cloudformation]
+	enabling region parameter for AWS cloud formation requests. thanks flessa
+
+[compute]
+	[aws]
+		remove CGI escape from create_security_group. thanks coliver
+		replace remaining specs with shindo tests
+		update #keypairs reference to #key_pairs. thanks pvande
+		Emulate volume unavailability when mocking. thanks mtodd
+		Raise error on non-existent snapshot for create_volume. thanks mtodd
+		Add tag to resource data when creating a mock tag. thanks betamatt
+		Add tag filtering to mocks for snapshots, volumes, instances. thanks betamatt
+		Add delete_tags mock. thanks betamatt
+		Support tag-key, tag-value, tag:key filters. thanks betamatt
+		Correct name of dns-filter filter. thanks betamatt
+		allow key pair to write into properly chmodded files. thanks gerred
+		Making key pair names a little less potentially brittle. thanks gerred
+	[rackspace]
+		fix public_ip_address accessors
+
+[core]
+	updated base parser to not eagerly strip return data. thanks bdorry
+	don't escape ssh commands. thanks pvande
+	Deal with missing FOG_RC/HOME env vars better. thanks outerim
+	fix push parser block passed to excon > 0.6.0
+
+[docs]
+	move fog.io stuff into docs directory
+	pull in and format data from README, wiki, blog posts
+
+[storage|rackspace]
+	head_object should use HEAD. thanks nate
+	Support for serving Rackspace CDN objects via SSL. thanks minter
+	Use URI.escape instead of CGI.escape. thanks minter
+
+0.7.1 03/21/2011
+================
+
+[aws|storage] normalize headers. thanks pweldon
+
+[mock] fix reset_data to not be called in Mock#initialize
+
+[rackspace] add support for using servicenet. thanks minter
+
+[storage] provide for non file/string files. thanks pweldon
+
+0.7.0 03/14/2011
+================
+
+[aws] added ap-northeast-1 (tokyo) region options
+
+[aws|cloudformation] add basic support. thanks crazed
+
+[aws|elb] add support for configuring https
+
+[aws|iam]
+  add support for server certificates. thanks bensie
+  add support for login profiles. thanks fcheung
+
+[aws|rds]
+  support basic rds operations. thanks fcheung
+  add support for restoring servers and security groups. thanks ktheory
+
+[cdn|rackspace] use post_container to update
+
+[compute]
+  [aws]
+    fix tag.destroy. thanks eabbott
+    allow deleting all tags (instead of just specific ones)
+    fix revoke_security_group method signature
+    FLAVORS is now a constant
+		allow for modifying server monitoring. thanks gilles
+  [brightbox] thanks tokengeek
+    Added listener management (add/remove) requests for Load Balancers
+    Added new Server console activation request
+    Added activate_console method to Brightbox servers
+    Set Server#private_ip_address to be the first interface
+  [rackspace] 'official' workaround for awful caching
+  [virtualbox] rough proof of concept/initial implementation
+
+[core]
+  fix behavior of slice on collections. thanks eabbott
+  fix reset_data to be instance method on mock connection (and work)
+  [credentials]
+    handle undefined ENV['HOME']
+    Allow string keys in credentials file [issue 179]. thanks ryanlower
+
+[dns|dnsimple] fix misc bugs in models. thanks ijonas
+
+[storage]
+  use shared parse_data across providers
+  [rackspace]
+    pass through explicit content-type
+    fix bug preventing file uploads to be streamed
+
+0.6.0 02/28/2011
+================
+
+[aws|compute] fix method signature for security group requests. Thanks crazed
+
+[aws|iam]
+	fleshing out support. Thanks bdorry and coliver
+	fix get_group parser to set Arn on group/member as appropriate
+
+[bluebox|dns] added support. Thanks ggoodale
+
+[compute]
+	add basic scp support. Thanks crazed
+  consolidate ip accessors
+
+[core]
+	added changelog, covering 0.5+
+	reset credentials when changing key or path. Thanks ctennis
+
+[dnsimple|dns] added support. Thanks dje
+
+[ecloud|compute] cleaned up and reworked as basis for future ecloud work
+
+[aws|storage] add static website configuration methods
+
+[local|storage] rewrite using nested directories (NOTE: not backwards compatible)
+
+[rackspace|storage] disable cdn when deleting container
+
+[voxel|compute] added support. Thanks splaspood
+
+remove long standing deprecations
+
+
+0.5.3 02/15/11
+==============
+
+[terremark|ecloud] (thanks freeformz) 
+  initial support for Disabled monitor types 
+  InternetService#disable_monitor and #enable_ping_monitor 
+  spec fixes and tests for the new monitor functions 
+fix logic error which prevented turning off persistent connections 
+fix _dump for collections/models 
+require json for to_json of collection/model 
+add some missing parens to fix warnings
+
+
+0.5.2 02/11/11
+==============
+
+[aws|compute] fix delete AWS tags to use proper method. Thanks ody 
+[aws|storage] 
+  add sort for multi part upload fields. Thanks gavin 
+  better RRS docs. Thanks bensie 
+  Temporary redirect should not execute the block. Thanks vivienschillis
+[tests] fix mock_helper load path to allow test runs in 1.9.2. Thanks aeden
+[compute] disable password auth for current user, rather than always root
+[aws&google|storage] properly handle custom headers in mocks 
+[aws&google|storage] make signature public method 
+[aws&google] finish fixing headers in mocks 
+[core] cleanup providers/services setup 
+[README] add contributing section, recommendations for blue shirts, move providers to fog.io, cleanup resources
+implicitly add not_implemented mocks
+
+
+0.5.1 01/31/11
+==============
+
+Bug fixes. 
+[aws|iam] add signing certificate and list groups for user. thanks crazed
+[gogrid|compute] added support for password api calls. thanks lum
+[fog|time] add date header formatting that is non-localized
+
+
+0.5.0 01/27/11
+==============
+
+[aws|compute] describe reserved instances offerings 
+[aws|dns] Fix variable typo create_hosted_zone. Thanks mitchellh 
+[aws|ses] basic support. Thanks adelcambre 
+[aws|storage] Escape the path for signatures. Thanks croaker 
+[aws&google|storage] mock fixes 
+[local|storage] support file#content_type 
+[ssh] use an agent if available instead of requiring explicit keys. thanks davidx and tomstuart 
+[gogrid|compute] fix several issues. Thanks cardmagic 
+[rackspace|compute] get new auth token when one expires 
+[rackspace|storage] remove nil query params in requests 
+[terremark|ecloud] getting started on ecloud specific implementation
+
diff --git a/vendor/fog-0.8.2/docs/_config.yml b/vendor/fog-0.8.2/docs/_config.yml
new file mode 100644
index 0000000..e986d20
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/_config.yml
@@ -0,0 +1,39 @@
+safe:        false
+auto:        false
+server:      false
+server_port: 4000
+
+source:      .
+destination: ./_site
+plugins:     ./_plugins
+
+future:      true
+lsi:         false
+pygments:    false
+markdown:    maruku
+permalink:   none
+
+maruku:
+  use_tex:    false
+  use_divs:   false
+  png_engine: blahtex
+  png_dir:    images/latex
+  png_url:    /images/latex
+
+rdiscount:
+  extensions: []
+
+kramdown:
+  auto_ids: true,
+  footnote_nr: 1
+  entity_output: as_char
+  toc_levels: 1..6
+  use_coderay: false
+  
+  coderay:
+    coderay_wrap: div
+    coderay_line_numbers: inline
+    coderay_line_numbers_start: 1
+    coderay_tab_width: 4
+    coderay_bold_every: 10
+    coderay_css: style
diff --git a/vendor/fog-0.8.2/docs/_layouts/default.html b/vendor/fog-0.8.2/docs/_layouts/default.html
new file mode 100755
index 0000000..4b6a31a
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/_layouts/default.html
@@ -0,0 +1,110 @@
+<!doctype html>
+
+<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
+<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
+<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
+<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
+<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
+<head>
+  <meta charset="utf-8">
+  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
+
+  <title>fog - {{ page.title }}</title>
+  <meta name="description" content="">
+  <meta name="author" content="">
+
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+
+  <!--
+    <link rel="shortcut icon" href="/public/favicon.ico">
+    <link rel="apple-touch-icon" href="/public/apple-touch-icon.png">
+  -->
+
+  <link rel="stylesheet" href="/public/css/style.css?v=2">
+  <link rel="stylesheet" href="/public/css/fog.css?v=2">
+  <script src="/public/js/libs/modernizr-1.6.min.js"></script>
+
+</head>
+
+<body>
+
+  <div id="container">
+    <header>
+      <a href="/"><img src="/public/images/fog.png" title="fog" /></a>
+      <h1>{{ page.title }}</h1>
+      <dl>
+        <dt>version</dt><dd>vX.Y.Z</dd>
+        <dt>install</dt><dd><code>gem install fog</code></dd>
+        <dt>source</dt><dd><a href="http://github.com/geemus/fog">geemus/fog</a></dd>
+      </dl>
+    </header>
+
+    <div id="main">
+
+      {{ content }}
+
+      <h2>Services</h2>
+      <ul>
+        <li><a href="/cdn">CDN</a></li>
+        <li><a href="/compute">Compute</a></li>
+        <li><a href="/dns">DNS</a></li>
+        <li><a href="/storage">Storage</a></li>
+        {% for post in site.posts %}
+        <li><a href="{{ post.url }}">{{ post.title }}</a></li>
+        {% endfor %}
+      </ul>
+
+      <h2>About</h2>
+      <ul>
+        <li><a href="/">Home</a></li>
+        <li><a href="/about/contributing.html">Contributing</a></li>
+        <li><a href="/about/getting_started.html">Getting Started</a></li>
+        <li><a href="/about/press.html">Press</a></li>
+        <li><a href="/about/structure.html">Structure</a></li>
+        <li><a href="/about/users.html">Users</a></li>
+      </ul>
+
+    </div>
+
+    <footer>
+      sponsored by
+      <img height="20px" src="public/images/engineyard.png" title="engineyard" />
+    </footer>
+  </div> <!-- end of #container -->
+
+
+  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.js"></script>
+  <script>!window.jQuery && document.write(unescape('%3Cscript src="public/js/libs/jquery-1.4.2.js"%3E%3C/script%3E'))</script>
+
+
+  <!-- scripts concatenated and minified via ant build script-->
+  <script src="public/js/plugins.js"></script>
+  <script src="public/js/script.js"></script>
+  <!-- end concatenated and minified scripts-->
+
+
+  <!--[if lt IE 7 ]>
+    <script src="public/js/libs/dd_belatedpng.js"></script>
+    <script> DD_belatedPNG.fix('img, .png_bg'); </script>
+  <![endif]-->
+
+  <!-- yui profiler and profileviewer - remove for production -->
+  <script src="public/js/profiling/yahoo-profiling.min.js"></script>
+  <script src="public/js/profiling/config.js"></script>
+  <!-- end profiling code -->
+
+
+  <!-- change the UA-XXXXX-X to be your site's ID -->
+  <script>
+   var _gaq = [['_setAccount', 'UA-301159-7'], ['_trackPageview']];
+   (function(d, t) {
+    var g = d.createElement(t),
+        s = d.getElementsByTagName(t)[0];
+    g.async = true;
+    g.src = ('https:' == location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
+    s.parentNode.insertBefore(g, s);
+   })(document, 'script');
+  </script>
+
+</body>
+</html>
diff --git a/vendor/fog-0.8.2/docs/about/contributing.markdown b/vendor/fog-0.8.2/docs/about/contributing.markdown
new file mode 100644
index 0000000..79803ea
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/about/contributing.markdown
@@ -0,0 +1,228 @@
+---
+layout: default
+title:  Contributing
+---
+
+First off, high five for coming to visit this page.  You are my new hero.
+
+## Overview
+
+* Organize your patches by keeping all related changes together in a topic branch.
+* Rebase your branch against master before submitting a pull request (and squish any 'oops' or work in progress commits).
+* Submit changes as pull requests describing what the changes should cover and referencing issues (if any).
+* Use 'tags' in your commits to indicate the scope, so things like '\[aws|compute\] fixed something'.
+* Write and run tests.  Tests should follow through usage workflows and ought to pass both with mocking on and off.
+
+## Deep dive
+
+Now then, some of the what makes it tick and why. For simplicity let's pretend you want to implement a new service, from scratch. I will walk through the requisite pieces and important things to keep in mind as you go.
+
+But, before I dive too deep, I'll leave you with an out.  Other great ways to contribute are fixing bugs, writing documentation or helping port other projects to use fog. That way everybody wins!
+
+## The Service
+
+First and foremost you'll need to create a service, which should start from something like:
+
+    module Fog
+      class TheService < Fog::Service
+
+        requires :necessary_credential
+
+        model_path 'path/to/models'
+        collection 'name_of_collection'
+        model 'name_of_model'
+
+        request_path 'path/to/requests'
+        request 'name_of_request'
+
+        class Mock
+          include Collections
+        end
+
+        class Real
+          include Collections
+        end
+
+      end
+    end
+
+### Highlights:
+* we segregate between real and mock so it is easier to add stuff to one or the other later.
+* this is where any shared stuff will go, like making/signing requests
+
+## Requests
+
+The next thing to bite off are the requests. fog is all about making cloud services easier to use and move between, but requests are not where this happens. Requests should map closely to the actual api requests (you should be able to directly reference the api docs and vice versa). In particular, try to keep the output of any data parsing as close to the actual format as possible. This makes implementation and maintenance much easier and provides a solid foundation for models to build nice things on top of. I generally end up working on stuff to get/list details first and then filling in create/destroy pairs and other requests.
+You start with something like this:
+
+<pre>
+module Fog
+  class TheService
+
+    class Real
+
+      def request(*args)
+      end
+
+    end
+
+    class Mock
+
+      def request(*args)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+  end
+end
+</pre>
+
+### Highlights:
+* You should define the method twice, once for the real implementation and once for mocked (they should take the same arguments).
+* The mock versions should just start out by raising a not implemented error, you can come back and fill this in later.
+* The real version should make a request, probably by a method defined on the real class in the service you defined earlier.
+* Each request should either return an Excon::Response (with a parsed body where appropriate) or raise an error.
+
+## Tests
+
+Now would be a good time to write some tests to make sure what you have written works (and will continue to). I've tried a couple variations on testing in the past, but have settled on consolidated lifetime testing. These vary enough that its hard to give a single simple example, but you can see many examples in "tests/compute/requests/aws":https://github.com/geemus/fog/tree/master/tests/compute/requests/aws/.
+
+### Highlights:
+* Reuse the same objects and take them through their whole life cycle (this is much faster, and most of the time if one portion fails the others would anyway).
+* Test the format of the output to ensure parsers match expectations (check the provider's api docs) and that mocks return matching data.
+* Test common failure cases and their behavior, you'll need to know how the service acts in these cases to make better mocks.
+
+## Models
+
+You could also skip to the mocks here if you wanted, but I usually find the more time I spend working with the service the easier it is to build mocks. The models are the real pay dirt, you have slogged through low level requests that map to the provider api and now you want a nice interface. This is where models and collections come in. Collections provide access to lists of data on the provider and for creating new objects. Models represent the individual objects.
+
+If you know which object you'd like to represent you should start with the collection. When naming, please refer to the names that have been chosen for other services. I haven't standardized all nouns yet, but a few are already shared (Flavor, Image, Server)
+An example servers collection:
+
+    require 'fog/collection'
+    require 'fog/theservice/models/server'
+    module Fog
+      class TheService
+
+        class Servers < Fog::Collection
+
+          model Fog::TheService::Server
+
+          def all
+            # get list of servers
+            load(data) # data is an array of attribute hashes
+          end
+
+          def get(identity)
+            # get server matching id
+            new(data) # data is an attribute hash
+          rescue Excon::Errors::NotFound
+            nil
+          end
+
+        end
+
+      end
+    end
+
+### Highlights
+* First make an accessor in the Collections model so it will be included in Real and Mock.
+* `#model` will take a reference to the class that will be instantiated to represent individual objects.
+* `#all` should get a list of servers from the provider and pass an array of attribute hashes, one per server, to load.
+* `#get` should take an identity reference and instantiate a new model object with an attribute hash returned from the remote server, or return nil of no such object exists.
+
+Models handle remapping attributes into friendlier names and providing the rest of the interface.
+An example model:
+
+    require 'fog/model'
+    module Fog
+      module TheService
+
+        class Server << Fog::Model
+
+          identity  :id
+
+          attribute :state, 'StatusValue'
+
+          def destroy
+            requires :identity
+            connection.destroy_server(identity)
+            true
+          end
+
+          def ready?
+            state == 'running'
+          end
+
+          def save
+            requires ...
+            connection.create_server(options)
+            true
+          end
+
+        end
+
+      end
+    end
+
+### Highlights
+* `#identity` captures the id/name that the objects are identified by and takes the same arguments as attribute.
+* `#attribute` takes the name to make a variable available as and one or more aliases that parsers/requests will return this value as.
+* `#destroy` will require the identity of the model and should destroy it and return true.
+* `#ready?` should return whether the object has finished being initialized (where appropriate).
+* `#save` should take any required objects and instantiate the object on the provider's service.
+* These models just rely on underlying collections and requests, so it should not be necessary at this level to distinguish between Real and Mock methods.
+
+## Mocks
+
+Mocks provide a powerful tool for users of fog to experiment with their implementations much more quickly and without incurring costs. I usually save these for last, as implementing the requests and models provide some necessary context to finally put the mocks together. Your services mock class should have a data method that will return mocked data like so:
+
+    module Fog
+      module TheService
+
+        class Mock
+          def self.data
+            @data ||= Hash.new do |hash, key|
+              hash[key] = {}
+            end
+          end
+        end
+
+      end
+    end
+
+The keys in this hash should represent a unique identifier of the user accessing the data and the value assigned should contain any default data that a new user might have. Any implemented mock requests should then return data retrieved from here or raise an error.
+For instance:
+
+    module Fog
+      module TheService
+
+        class Mock
+
+          def destroy_server(server_identity)
+            if data = self.data[:servers].delete(server_identity)
+              response = Excon::Response.new
+              response.status = 202
+              response.body   = data
+              response
+            else
+              raise Fog::TheService::NotFound
+            end
+          end
+
+        end
+
+      end
+    end
+
+### Highlights
+* Mock requests should return the same type of data as an already parsed real response or should return the same error as a real problem.
+* By mocking at this low level, higher level functions are automatically mocked out for you.
+* The extra rigorous tests related to output formatting and error messages should help keep you honest, and each should pass in both mocked and unmocked modes.
+
+## Summary
+
+That provides a lot more detail than you will probably need right away, but hopefully you can refer back to different sections as you need them. If you have any questions send me a github message or email me (address is on my profile). You should always start development by creating your own fork. When you feel confident about your fork, send me a pull request. Be forewarned that I may edit some things before it gets to master, but I'll do my best to take care of this in a timely manner.
+
+Thanks again for your interest and let me know if there is anything else I can do to help.
diff --git a/vendor/fog-0.8.2/docs/about/getting_started.markdown b/vendor/fog-0.8.2/docs/about/getting_started.markdown
new file mode 100644
index 0000000..cb2b6b6
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/about/getting_started.markdown
@@ -0,0 +1,83 @@
+---
+layout: default
+title:  Getting Started
+---
+
+First off, install the gem:
+
+    $ gem install fog
+
+## Setting Up Local Storage
+
+We will be using Local storage in the example.  Local storage provides the same api that cloud storage services in fog do, but without the bother of needing to signup for stuff or pay extra money.
+
+First, make a local directory to hold your data.
+
+    $ mkdir ~/fog
+
+Now we can start writing our script, first off we should require fog.
+
+    require 'rubygems'
+    require 'fog'
+
+Now in order to play with our data we need to setup a storage connection.
+
+    storage = Fog::Storage.new(
+      :local_root => '~/fog',
+      :provider   => 'Local',
+    )
+
+`storage` will now contain our storage object, configured to use the Local provider from our specified directory.
+
+## Storing Data
+
+Now that you have cleared the preliminaries you are ready to start storing data. Storage providers in fog segregate files into `directories` to make it easier to organize things. So lets create a directory so we can see that in action.
+
+    directory = Fog::Storage.directories.create(
+      :key => 'data'
+    )
+
+To make sure it was created you can always check in your filesystem, but we can also check from inside fog.
+
+    storage.directories
+
+Progress! Now it is time to actually create a file inside our new directory.
+
+    file = directory.files.create(
+      :body => 'Hello World!',
+      :key  => 'hello_world.txt'
+    )
+
+We should now have our file, first we can open it up and make sure we are on the right track.
+
+    $ open ~/fog/hello_world.txt
+
+It is much more likely that you will want to see what files you have from inside fog though.
+
+    directory.files
+
+Now that we have run through all the basics, lets clean up our mess.
+
+    file.destroy
+    directory.destroy
+
+After that you should be able to check your directory list in fog or your filesystem and see you are safely back to square one.
+
+## Next Steps
+
+Using the same interface you can also practice working against a real provider (such as Amazon S3).  Rather than worrying about signing up for an account right away though, we can use mocks to simulate S3 while we practice.
+
+This time we will turn on mocking and then, just like before, we will need to make a connection.
+
+    Fog.mock!
+    storage = Fog::Storage.new(
+      :aws_access_key_id      => 'fake_access_key_id',
+      :aws_secret_access_key  => 'fake_secret_access_key',
+      :provider               => 'AWS'
+    )
+
+You may notice that we used bogus credentials, this is fine since we are just simulating things.  To use real S3 you can simply omit `Fog.mock!` and swap in your real credentials.
+
+Once you have your connection you can go through all the steps you did before, only now you will be working against a real cloud service (or at least a simulated one).
+
+Congratulations and welcome to the cloud!  Continue your journey at [fog.io](http://fog.io)
diff --git a/vendor/fog-0.8.2/docs/about/press.markdown b/vendor/fog-0.8.2/docs/about/press.markdown
new file mode 100644
index 0000000..9597a35
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/about/press.markdown
@@ -0,0 +1,37 @@
+---
+layout: default
+title:  Press
+---
+
+Mentions and blog posts from elsewhere in reverse chronological order by day (and alphasorted for same days).
+
+
+**April 7th, 2011**
+
+* [Testing multipart Uploads to S3 with Threads](http://blog.vicecity.co.uk/post/4425574978/multipart-uploads-fog-threads-win)
+
+**March 9th, 2011**
+
+* [Offsite Backups with fog](http://www.engineyard.com/blog/2011/offsite-backups-with-fog/)
+
+**March 2nd, 2011**
+
+* [Better AWS Access Control with IAM and Fog](http://blog.zerosum.org/2011/03/02/better-aws-access-control-with-iam-and-fog.html)
+* [Using Amazon's CloudFormation, cloud-init, chef and fog to automate infrastructure](http://allanfeid.com/content/using-amazons-cloudformation-cloud-init-chef-and-fog-automate-infrastructure)
+
+**January 6th, 2011**
+
+* [Happy New Year (and 0.4.0) from fog!](http://www.engineyard.com/blog/2011/happy-new-year-and-0-4-0-from-fog/)
+
+**November 30th, 2010**
+
+* [Getting Hired: fog Edition](http://www.engineyard.com/blog/2010/getting-hired-fog-edition/)
+
+**October 13, 2010**
+
+* [Engine Yard Announces Formal Support for fog to Ensure Application Portability in the Cloud](http://www.engineyard.com/company/press/2010-10-13-engine-yard-announces-formal-support-for-%E2%80%98fog%E2%80%99-to-ensure-application-portability-in-the-cloud)
+* [Wesley Beary and fog Promoted to the Engine Yard Open Source Program](http://www.engineyard.com/blog/2010/wesley-beary-and-fog-promoted-to-the-engine-yard-open-source-program/)
+
+**September 28, 2010**
+
+* [The Curious Tale of the Humble Micro](http://www.engineyard.com/blog/2010/the-curious-tale-of-the-humble-micro/)
diff --git a/vendor/fog-0.8.2/docs/about/structure.markdown b/vendor/fog-0.8.2/docs/about/structure.markdown
new file mode 100644
index 0000000..cffe8ec
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/about/structure.markdown
@@ -0,0 +1,78 @@
+---
+layout: default
+title:  Structure
+---
+
+fog is the Ruby cloud computing library, top to bottom:
+
+* Collections provide a simplified interface, making clouds easier to work with and switch between.
+* Requests allow power users to get the most out of the features of each individual cloud.
+* Mocks make testing and integrating a breeze.
+                                               
+## Collections
+
+A high level interface to each cloud is provided through collections, such as `images` and `servers`.
+You can see a list of available collections by calling `collections` on the connection object. You can try it out using the `fog` command:
+
+    >> AWS.collections
+    [:addresses, :directories, ..., :volumes, :zones]
+
+Some collections are available across multiple providers:
+
+* compute providers have `flavors`, `images` and `servers`
+* dns providers have `zones` and `records`
+* storage providers have `directories` and `files`
+
+Collections share basic CRUD type operations, such as:
+* `all` - fetch every object of that type from the provider.
+* `create` - initialize a new record locally and a remote resource with the provider.
+* `get` - fetch a single object by it's identity from the provider.
+* `new` - initialize a new record locally, but do not create a remote resource with the provider.
+
+As an example, we'll try initializing and persisting a Rackspace Cloud server:
+
+    require 'fog'
+
+    compute = Fog::Compute.new(
+      :provider           => 'Rackspace',
+      :rackspace_api_key  => key,
+      :rackspace_username => username
+    )
+
+    # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
+    server = compute.servers.create(:flavor_id => 1, :image_id => 3, :name => 'my_server')
+    server.wait_for { ready? } # give server time to boot
+
+    # DO STUFF
+
+    server.destroy # cleanup after yourself or regret it, trust me
+
+## Models
+
+Many of the collection methods return individual objects, which also provide common methods:
+* `destroy` - will destroy the persisted object from the provider
+* `save` - persist the object to the provider
+* `wait_for` - takes a block and waits for either the block to return true for the object or for a timeout (defaults to 10 minutes)
+
+## Requests
+
+Requests allow you to dive deeper when the models just can't cut it.
+You can see a list of available requests by calling #requests on the connection object.
+
+For instance, ec2 provides methods related to reserved instances that don't have any models (yet). Here is how you can lookup your reserved instances:
+
+    $ fog
+    >> AWS[:ec2].describe_reserved_instances
+    #<Excon::Response [...]>
+
+It will return an [excon](http://github.com/geemus/excon) response, which has `body`, `headers` and `status`. Both return nice hashes.
+
+## Mocks
+
+As you might imagine, testing code using Fog can be slow and expensive, constantly turning on and and shutting down instances.
+Mocking allows skipping this overhead by providing an in memory representation resources as you make requests.
+Enabling mocking easy to use, before you run other commands, simply run:
+
+    Fog.mock!
+
+Then proceed as usual, if you run into unimplemented mocks fog will raise an error and as always contributions are welcome!
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/about/users.markdown b/vendor/fog-0.8.2/docs/about/users.markdown
new file mode 100644
index 0000000..d57bd5f
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/about/users.markdown
@@ -0,0 +1,33 @@
+---
+layout: default
+title:  Users
+---
+
+Here lies a listing of projects and products that are using fog.
+
+Please feel free to add your own, just please follow these rules for consistency and readability.
+
+1. Listings should be in alphabetical order and should have a link and list of services used.
+2. Projects that are open source should link to where the source code can be found.
+3. Products that are not open source should link to where more information about the product can be found.
+
+Thanks for following these rules to keep the quality high and and the content useful!
+
+## Projects
+
+* [carrierwave](http://github.com/jnicklas/carrierwave) = AWS => Storage
+* [chef](http://github.com/opscode/chef) = AWS => Compute, Slicehost => Compute, Terremark => vCloud, Rackspace => Compute
+* [deckard](http://github.com/joewilliams/deckard) = AWS => Compute
+* [gaff](http://github.com/joewilliams/gaff) = AWS => Compute, Slicehost => Compute
+* [gemcutter](http://github.com/rubygems/gemcutter) = AWS => Storage
+* [plover](http://github.com/railsmachine/plover) = AWS => Compute
+
+## Products
+
+* [DevStructure](http://devstructure.com/) = AWS => Compute, Rackspace => Compute, Slicehost => Compute
+* [Engine Yard AppCloud](http://www.engineyard.com/cloud) = AWS => \[Compute, Storage\]
+* [iSwifter](http://iswifter.youwebinc.com/) = BlueBox => Compute
+* [OpenFeint](http://openfeint.com) = BlueBox => Compute
+* [PHPFog](https://phpfog.com) = AWS => Compute
+* [RowFeeder](https://rowfeeder.com) = Blue Box Group => Compute
+* [Viximo](http://viximo.com) = AWS => Compute
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/cdn/index.markdown b/vendor/fog-0.8.2/docs/cdn/index.markdown
new file mode 100644
index 0000000..1475aac
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/cdn/index.markdown
@@ -0,0 +1,82 @@
+---
+layout: default
+title:  CDN
+---
+
+Faster websites are better. <a href="http://www.websiteoptimization.com/speed/tweak/design-factors/">Better experience</a>, <a href="http://exp-platform.com/Documents/IEEEComputer2007OnlineExperiments.pdf">better sales</a>, <a href="http://www.stevesouders.com/blog/2009/07/27/wikia-fast-pages-retain-users/">you name it</a>. Unfortunately, making a website faster can be tough. Thankfully a content distribution network, or CDN, can give you great performance bang for your buck. A CDN helps speed things up by putting copies of your files closer to your users. It's like the difference between pizza delivery from across the street and pizza delivery from the next town over.
+
+The ease and deliciousness are the good news, but until recently CDN's were only available in the big leagues via 'my business guys will talk to your business guys' deals.  Fortunately for us, Amazon recently updated <a href="http://aws.amazon.com/cloudfront/">CloudFront</a>, their CDN service, to allow us to get these benefits with just a credit card and an API call. So now we'll see how you can spend a few minutes to save your users countless hours of load time.
+
+## Preliminaries
+
+First, make sure you have fog installed:
+
+    gem install fog
+
+Now you'll need to <a href="https://aws-portal.amazon.com/gp/aws/developer/subscription/index.html?productCode=AmazonCloudFront">sign up for Cloudfront</a>. Gather up the credentials your new credentials to initialize a connection to the service:
+
+    require 'fog'
+
+    # create a connection to the service
+    cdn = Fog::CDN.new({
+      :provider               => 'AWS',
+      :aws_access_key_id      => AWS_ACCESS_KEY_ID,
+      :aws_secret_access_key  => AWS_SECRET_ACCESS_KEY
+    }
+
+## Setting Up Your CDN
+
+Now you'll need to create a 'distribution' which represents a mapping from the CDN to your domain. For the examples we'll pretend we are working on 'http://www.example.com', but you can just switch it to your actual domain. Some <a href="http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html">other options</a> are available, but the only other one we need to fill in is OriginProtocolPolicy.  This sets what to do about http vs https. We will use 'match-viewer' which returns the same protocol as the request, but you can also choose 'http-only' which always returns http responses.
+
+    data = cdn.post_distribution({
+      'CustomOrigin' => {
+        'DNSName'               => 'www.example.com',
+        'OriginProtocolPolicy'  => 'match-viewer'
+      }
+    })
+
+    # parse the response for stuff you'll need later
+    distribution_id   = data.body['Id']
+    caller_reference  = data.body['CallerReference']
+    etag              = data.headers['ETag']
+    cdn_domain_name   = data.body['DomainName']
+
+    # wait for the updates to propogate
+    Fog.wait_for {
+      cdn.get_distribution(distribution_id).body['Status'] ## 'Deployed'
+    }
+
+## Getting Served
+
+With the domain name from the distribution in hand you should now be ready to serve content from the edge.  All you need to do is start replacing urls like `http://www.example.com/stylesheets/foo.css` with `#{cdn_domain_name}/stylesheets/foo.css`. Just because you can do something doesn't always mean you should though.  Dynamic pages are not really well suited to CDN storage, since CDN content will be the same for every user.  Fortunately some of your most used content is a great fit.  By just switching over your images, javascripts and stylesheets you can have an impact for each and every one of your users.
+
+Congrats, your site is faster! By default the urls aren't very pretty, something like `http://d1xdx2sah5udd0.cloudfront.net/stylesheets/foo.css`.  Thankfully you can use CNAME config options to utilize something like `http://assets.example.com/stylesheets/foo.css`, if you are interested in learning more about this let me know in the comments.
+
+## Cleaning Up
+
+But, just in case you need to update things I'll run through how you can make changes. In my case I just want to clean up after myself, so I'll use the distribution_id and ETag from before to disable the distribution. We need to use the ETag as well because it provides a way to refer to different versions of the same distribution and ensures we are updating the version that we think we are.
+
+    data = cdn.put_distribution_config(
+      distribution_id,
+      etag,
+      {
+        'CustomOrigin'    => {
+          'DNSName'               => 'www.example.com',
+          'OriginProtocolPolicy'  => 'match-viewer'
+        },
+        'CallerReference' => caller_reference,
+        'Enabled'         => 'false'
+      }
+    )
+
+    # parse the updated etag
+    etag = data.headers['ETag']
+
+Now you just need to wait for the update to happen like before and once its disabled we can delete it:
+
+    Fog.wait_for {
+      cdn.get_distribution(distribution_id).body['Status'] ## 'Deployed'
+    }
+    cdn.delete_distribution(distribution_id, etag)
+
+Thats it, now go forth and speed up some load times!
diff --git a/vendor/fog-0.8.2/docs/compute/index.markdown b/vendor/fog-0.8.2/docs/compute/index.markdown
new file mode 100644
index 0000000..6ab4ebb
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/compute/index.markdown
@@ -0,0 +1,104 @@
+---
+layout: default
+title:  Compute
+---
+
+Compute is the lifeblood of the cloud, but with great power comes great complication. Compute opens up huge swaths of potential, but it varies greatly in both capabilities and usage from provider to provider. Thankfully fog helps to abstract these idiosyncrasies to provide a more seamless experience.
+
+## Installing fog
+
+fog is distributed as a RubyGem:
+
+    gem install fog
+
+Or for bundler users, you can add it in your Gemfile:
+
+    gem "fog"
+
+## Using Amazon EC2 and fog
+
+Sign up for an account <a href="http://aws-portal.amazon.com/gp/aws/developer/subscription/index.html?productCode=AmazonEC2">here</a> and copy down your secret access key and access key id from <a href="http://aws-portal.amazon.com/gp/aws/developer/account/index.html?action=access-key">here</a>. We are about to get into the code samples, so be sure to fill in anything in ALL_CAPS with your own values!
+
+First, create a connection with your new account:
+
+    require 'rubygems'
+    require 'fog'
+
+    # create a connection
+    connection = Fog::Compute.new(
+      :provider                 => 'AWS',
+      :aws_secret_access_key    => YOUR_SECRET_ACCESS_KEY,
+      :aws_access_key_id        => YOUR_SECRET_ACCESS_KEY_ID
+    )
+
+With that in hand we are ready to start making EC2 calls!
+
+## Servers the EC2 way
+
+Creating a server on EC2 is very easy if you are willing to accept the defaults (the smallest server size, using Ubuntu 10.04 LTS).
+
+    server = connection.servers.create
+
+You can then list your servers to see that it now appears:
+
+    connection.servers
+
+Rather than worrying about the whole list, we can also just get the latest data for just our server:
+
+    server.reload
+
+That can get tedious quickly however, especially when servers can take several minutes to boot.  Fog has `wait_for` for cases like this and `ready?` for checking to see when a server has completed its start up.
+
+    server.wait_for { ready? }
+
+Once we are done with that we can shut it down.
+
+    server.destroy
+
+## Bootstrap: Servers the fog Way
+
+Cycling servers is great, but in order to actually ssh in we need to setup ssh keys and open ports.  But rather than worrying about the nitty gritty, we will utilize `bootstrap`.  NOTE: normally we could leave out username and use the default (root), but the default Ubuntu from Canonical uses the ubuntu username instead.
+
+    server = connection.servers.bootstrap(:private_key_path => '~/.ssh/id_rsa', :public_key_path => '~/.ssh/id_rsa.pub', :username => 'ubuntu')
+
+Bootstrap will create the server, but it will also make sure that port 22 is open for traffic and has ssh keys setup.  In order to hook everything up it will need the server to be running, so by the time it finishes it will be ready.  You can then make commands to it directly:
+
+    server.ssh('pwd')
+    server.ssh(['pwd', 'whoami'])
+
+These return an array of results, where each has stdout, stderr and status values so you can check out what your commands accomplished.  Now just shut it down to make sure you don't continue getting charged.
+
+    server.destroy
+
+## Rackspace Cloud Servers
+
+Rackspace has <a href="http://www.rackspacecloud.com/cloud_hosting_products/servers">Cloud Servers</a> and you can sign up <a href="https://www.rackspacecloud.com/signup">here</a> and get your credentials <a href="https://manage.rackspacecloud.com/APIAccess.do">here</a>.
+
+    # create a connection
+    connection = Fog::Compute.new(
+      :provider           => 'Rackspace',
+      :rackspace_username => RACKSPACE_USERNAME,
+      :rackspace_api_key  => RACKSPACE_API_KEY
+    )
+
+We will skip over learning how to do this the 'Rackspace Way' and instead jump right to using bootstrap to get their smallest Ubuntu 10.04 LTS server.
+
+    server = connection.servers.bootstrap
+
+You can run all the same ssh commands and do what you need to, then once again shutdown to ensure you are not charged once you are done.
+
+    server.destroy
+
+## Mocking out Compute
+
+You can also start any of these scripts with `Fog.mock!` or start the fog interactive tool from the command line with `FOG_MOCK=true fog` to run in mock mode. In this mode commands are run as local simulation, so no cloud resources are ever consumed and things operate much faster.
+
+## Cleaning up
+
+To cover your tracks its a good idea to check for running servers and shut them down, here is one way you might do that.
+
+    connection.servers.select {|server| server.ready? && server.destroy}
+
+## Summary
+
+Compute can be tricky, but the abstractions in fog make it much easier to get started.  With your servers up and running you can then focus on the task at hand and get some work done.  Congratulations on adding a new tool to your arsenal and let us know what we can do better.
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/dns/index.markdown b/vendor/fog-0.8.2/docs/dns/index.markdown
new file mode 100644
index 0000000..1a7c3f1
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/dns/index.markdown
@@ -0,0 +1,79 @@
+---
+layout: default
+title:  DNS
+---
+
+The power and flexibility of the cloud are amazing. But sometimes it can be a pain to chase your resources around and keep everything up to date. This is especially true of keeping track of addresses for DNS, but thankfully more and more API driven options are available, allowing you to automate your DNS to keep up with your hardware changes.
+
+## Setup
+
+First, make sure you have fog installed:
+
+    gem install fog
+
+For this first example we will use Zerigo (see below for how to use other providers). You can signup for Zerigo DNS <a href="https://www.zerigo.com/signup/dns">here</a>. Gather up your new credentials to initialize a connection to the service:
+
+    require 'rubygems'
+    require 'fog'
+
+    # create a connection to the service
+    dns = Fog::DNS.new({
+      :provider     => 'Zerigo',
+      :zerigo_email => ZERIGO_EMAIL,
+      :zerigo_token => ZERIGO_TOKEN
+    }
+
+## Getting in the Zone
+
+The first thing you need to do to prepare for your DNS excursion is create a zone for your domain.  The zone will contain all of the more specific records that you will create later.  You will just need to specify the domain, which should be your url without the 'http' or 'www' parts, and an email address.  Then you can create the zone with your DNS connection:<!--more-->
+
+    zone = @dns.zones.create(
+      :domain => 'example.com',
+      :email  => 'admin@example.com'
+    )
+
+Now that you have a zone you will need to update your registrar to let them know what DNS servers are responsible for your domain.  You can ask the zone what values to use:
+
+    zone.nameservers
+
+## Spinning Records
+
+With your new zone in hand you can add records as needed.  First and foremost you will probably want the 'www' version of your site to point to whatever your ip might be:
+
+    record = @zone.records.create(
+      :ip   => '1.2.3.4',
+      :name => 'example.com',
+      :type => 'A'
+    )
+
+Adding other records is similarly easy, for instance if we want 'www.example.com' to go to the same place, we can use a cname record:
+
+    record = @zone.records.create(
+      :ip   => 'example.com',
+      :name => 'www',
+      :type => 'CNAME'
+    )
+
+Or, similarly you might want to have your blog elsewhere:
+
+    record = @zone.records.create(
+      :ip   => '4.3.2.1',
+      :name => 'blog.example.com',
+      :type => 'A'
+    )
+
+You can add more specifics if you need to, but reasonable defaults make it just that easy.  You can also add any other kind of DNS record you might need for mail or other purposes, you can find a nice overview of record options and types <a href="http://en.wikipedia.org/wiki/Domain_Name_System#DNS_resource_records">on Wikipedia</a>.
+
+## No Zerigo? No Problem
+
+If you already have an account with another service you can just as easily use this same code with different credentials. fog currently supports <a href="http://aws.amazon.com/route53/">AWS Route 53</a>, <a href="http://bluebox.net">Blue Box</a>, <a href="http://dnsimple.com">DNSimple</a>, <a href="http://www.linode.com">Linode</a>, <a href="http://www.slicehost.com">Slicehost</a> and <a href="http://www.zerigo.com/managed-dns">Zerigo</a>; so you can have your pick.  As an example you can connect to AWS instead of Zerigo:
+
+    dns = Fog::DNS.new(
+      :provider               => 'AWS',
+      :aws_access_key_id      => AWS_ACCESS_KEY_ID,
+      :aws_secret_access_key  => AWS_SECRET_ACCESS_KEY
+    )
+
+## Go Forth and Resolve
+
+You can see an example of reusing code like this in the <a href="https://github.com/geemus/fog/blob/master/examples/dns_tests.rb">examples folder</a>. Using this makes it easier to give yourself shortcuts to your cloud servers and manage how clients and users access them as well. It is great to have this flexibility so that you can modify your cloud infrastructure as needed while keeping everything ship shape. It also provides a nice way to create custom subdomains for users and just generally round out your cloud solution.
diff --git a/vendor/fog-0.8.2/docs/index.markdown b/vendor/fog-0.8.2/docs/index.markdown
new file mode 100644
index 0000000..4376136
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/index.markdown
@@ -0,0 +1,96 @@
+---
+layout: default
+title:  The Ruby cloud services library
+---
+
+Whether you need compute, dns, storage, or a multitude of other services, fog provides an accessible entry point and facilitates cross service compatibility.
+
+Just getting started working with cloud resources? You are not alone, and having so many complicated options makes it hard to know where to start. fog delivers the knowledge of cloud experts to you, helping you to bootstrap your cloud usage and guiding you as your own expertise develops.
+
+By coding with fog from the start you avoid vendor lock-in and give yourself more flexibility to provide value. Whether you are writing a library, designing a software as a service product or just hacking on the weekend this flexibility is a huge boon.
+
+With a rapidly expanding community and codebase the advantages of fog just keep coming. Join us and together we will realize the future of cloud computing.
+
+## Getting Started
+
+    sudo gem install fog
+
+Now type 'fog' to try stuff, confident that fog will let you know what to do. Here is an example of wading through server creation for Amazon Elastic Compute Cloud:
+
+    >> server = AWS.servers.create
+    ArgumentError: image_id is required for this operation
+
+    >> server = AWS.servers.create(:image_id => 'ami-5ee70037')
+    <Fog::AWS::EC2::Server [...]>
+
+    >> server.destroy # cleanup after yourself or regret it, trust me
+    true
+
+## Go forth and conquer
+
+Play around and use the console to explore or check out the [getting started guide](/about/getting_started.html) for more details. Once you are reading to start scripting fog, here is a quick hint on how to make connections without the command line thing to help you.
+
+    # create a compute connection
+    compute = Fog::Compute.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+    # compute operations go here
+
+    # create a storage connection
+    storage = Fog::Storage.new(:provider => 'AWS', :aws_access_key_id => ACCESS_KEY_ID, :aws_secret_access_key => SECRET_ACCESS_KEY)
+    # storage operations go here
+
+geemus says: "That should give you everything you need to get started, but let me know if there is anything I can do to help!"
+
+## Contributing
+
+* Find something you would like to work on. For suggestions look for the `easy`, `medium` and `hard` tags in the [issues](http://github.com/geemus/fog/issues)
+* Fork the project and do your work in a topic branch.
+* Add shindo tests to prove your code works and run all the tests using `bundle exec rake`.
+* Rebase your branch against geemus/fog to make sure everything is up to date.
+* Commit your changes and send a pull request.
+
+## T-Shirts
+
+Wonder how you can get a lovely fog shirt? Look no further!
+
+* Blue shirts go to people who have contributed indirectly, great examples are writing blog posts or giving lightning talks.
+* Grey shirts and a follow from @fog go to people who have made it on to the [contributors list](https://github.com/geemus/fog/contributors) by submitting code.
+* Black shirts go to people who have made it on to the [collaborators list](https://github.com/api/v2/json/repos/show/geemus/fog/collaborators) by coercing geemus into adding them (geemus is currently the only member of this list).
+
+## Resources
+
+Enjoy, and let me know what I can do to continue improving fog!
+
+* Work through the [fog tutorial](https://github.com/downloads/geemus/learn_fog/learn_fog.tar.gz)
+* Read fog's [API documentation](/latest/rdoc)
+* Stay up to date by following [@fog](http://twitter.com/fog) and/or [@geemus](http://twitter.com/geemus) on Twitter.
+* Get and give help on the [#ruby-fog](irc://irc.freenode.net/ruby-fog) irc channel on Freenode
+* Follow release notes and discussions on the [mailing list](http://groups.google.com/group/ruby-fog)
+* Report bugs or find tasks to help with in the [issues](http://github.com/geemus/fog/issues)
+* Learn about [contributing](/about/contributing.html)
+* See where fog is used and let the world know how you use it [in the wild](/about/users.html)
+* Check out blog posts and other mentions in the [press](/about/press.html)
+
+## Copyright
+
+(The MIT License)
+
+Copyright (c) 2010 [geemus (Wesley Beary)](http://github.com/geemus)
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/fog-0.8.2/docs/public/crossdomain.xml b/vendor/fog-0.8.2/docs/public/crossdomain.xml
new file mode 100755
index 0000000..0d42929
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/crossdomain.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0"?>
+<!DOCTYPE cross-domain-policy SYSTEM "http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">
+<cross-domain-policy>
+  
+  
+<!-- Read this: www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html -->
+
+<!-- Most restrictive policy: -->
+	<site-control permitted-cross-domain-policies="none"/>
+	
+	
+	
+<!-- Least restrictive policy: -->
+<!--
+	<site-control permitted-cross-domain-policies="all"/>
+	<allow-access-from domain="*" to-ports="*" secure="false"/>
+	<allow-http-request-headers-from domain="*" headers="*" secure="false"/>
+-->
+<!--
+  If you host a crossdomain.xml file with allow-access-from domain=* 	 	
+  and dont understand all of the points described here, you probably 	 	
+  have a nasty security vulnerability. ~ simon willison
+-->
+
+</cross-domain-policy>
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/css/fog.css b/vendor/fog-0.8.2/docs/public/css/fog.css
new file mode 100644
index 0000000..3aed111
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/css/fog.css
@@ -0,0 +1,129 @@
+/* layout */
+body {
+  background-color: #EBF2F9;
+  line-height: 1.5em;
+  text-align: center;
+}
+
+#container {
+  margin: auto;
+  text-align: left;
+  width: 800px;
+}
+
+header {
+  background-color: #A0C0E1;
+  border-color: #70A1D2;
+  -moz-border-radius: 0 0 0.5em 0.5em;
+  border-radius: 0 0 0.5em 0.5em;
+  border-style: solid;
+  border-width: 0 1px 1px 1px;
+  color: #FFF;
+  height: 154px;
+  margin-bottom: 2em;
+  position: relative;
+  text-align: center;
+}
+
+header a, header a:active, header a:visited {
+  color: #FFF;
+}
+
+header img {
+  position: absolute;
+  left: 0;
+  top: 0;
+}
+
+header h1 {
+  font-size: 2em;
+  line-height: 154px;
+}
+
+header dl {
+  background-color: #70A1D2;
+  border-color: #70A1D2;
+  -moz-border-radius: 0 0 0.5em 0.5em;
+  border-radius: 0 0 0.5em 0.5em;
+  height: 140px; /* 154 - padding-top */
+  position: absolute;
+  padding: 14px 1.5em 0 1.5em;
+  right: 0;
+  top: 0;
+}
+
+header dl dt {
+  font-weight: bold;
+}
+
+#main {
+  background-color: #FFF;
+  -moz-border-radius: 0.5em;
+  border-radius: 0.5em;
+  color: #666;
+  border: 1px solid #70A1D2;
+  padding: 0 1em;
+  margin-bottom: 2em;
+}
+
+footer {
+  background-color: #A0C0E1;
+  border-color: #70A1D2;
+  -moz-border-radius: 0.5em 0.5em 0 0;
+  border-radius: 0.5em 0.5em 0 0;
+  border-style: solid;
+  border-width: 1px 1px 0 1px;
+  color: #FFF;
+  text-align: center;
+}
+
+footer img {
+  padding: 5px;
+  vertical-align: middle;
+}
+
+/* misc */
+
+h2 {
+  border-bottom: 2px solid #A0C0E1;
+  color: #70A1D2;
+  font-size: 1.5em;
+  margin-top: 1.33333333333333em;
+  padding: 0 0.75em 0.75em 0;
+}
+
+code, pre {
+  background-color: #EBF2F9;
+  border: 1px solid #70A1D2;
+  color: #666;
+}
+
+code {
+  padding: 0 0.2em;
+}
+
+p, ul {
+  margin-bottom: 1em;
+  margin-top: 1em;
+}
+
+pre {
+  -moz-border-radius: 0.5em;
+  border-radius: 0.5em;
+  margin: 1em;
+  white-space: pre;
+}
+
+pre code {
+  border: none;
+}
+
+@media all and (orientation:portrait) {
+}
+
+@media all and (orientation:landscape) {
+}
+
+@media screen and (max-device-width: 480px) {
+  /* html { -webkit-text-size-adjust:none; -ms-text-size-adjust:none; } */
+}
diff --git a/vendor/fog-0.8.2/docs/public/css/handheld.css b/vendor/fog-0.8.2/docs/public/css/handheld.css
new file mode 100755
index 0000000..0b8202e
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/css/handheld.css
@@ -0,0 +1,8 @@
+* {
+  float: none;       
+  background: #fff;  
+  color: #000;
+}
+
+
+body { font-size: 80%; }
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/css/style.css b/vendor/fog-0.8.2/docs/public/css/style.css
new file mode 100755
index 0000000..2690ad8
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/css/style.css
@@ -0,0 +1,129 @@
+/*  HTML5  Boilerplate  */
+
+html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,
+abbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,
+small, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li,
+fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,
+article, aside, canvas, details, figcaption, figure,  footer, header, hgroup, 
+menu, nav, section, summary, time, mark, audio, video {
+  margin:0;
+  padding:0;
+  border:0;
+  outline:0;
+  font-size:100%;
+  vertical-align:baseline;
+  background:transparent;
+}                  
+article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { 
+    display:block;
+}
+nav ul { list-style:none; }
+blockquote, q { quotes:none; }
+blockquote:before, blockquote:after,
+q:before, q:after { content:''; content:none; }
+a { margin:0; padding:0; font-size:100%; vertical-align:baseline; background:transparent; }
+ins { background-color:#ff9; color:#000; text-decoration:none; }
+mark { background-color:#ff9; color:#000; font-style:italic; font-weight:bold; }
+del { text-decoration: line-through; }
+abbr[title], dfn[title] { border-bottom:1px dotted; cursor:help; }
+table { border-collapse:collapse; border-spacing:0; }
+hr { display:block; height:1px; border:0; border-top:1px solid #ccc; margin:1em 0; padding:0; }
+input, select { vertical-align:middle; }
+
+
+body { font:13px/1.231 sans-serif; *font-size:small; } 
+select, input, textarea, button { font:99% sans-serif; }
+pre, code, kbd, samp { font-family: monospace, sans-serif; }
+
+body, select, input, textarea {   color: #444; }
+h1,h2,h3,h4,h5,h6 { font-weight: bold; }
+html { overflow-y: scroll; }
+
+a:hover, a:active { outline: none; }
+a, a:active, a:visited { color: #607890; }
+a:hover { color: #036; }
+
+ul, ol { margin-left: 1.8em; }
+ol { list-style-type: decimal; }
+
+nav ul, nav li { margin: 0; } 
+small { font-size: 85%; }
+strong, th { font-weight: bold; }
+td, td img { vertical-align: top; } 
+sub { vertical-align: sub; font-size: smaller; }
+sup { vertical-align: super; font-size: smaller; }
+pre {  padding: 15px;  white-space: pre;  white-space: pre-wrap;  white-space: pre-line;  word-wrap: break-word; }
+textarea { overflow: auto; } 
+.ie6 legend, .ie7 legend { margin-left: -7px; } 
+input[type="radio"] { vertical-align: text-bottom; }
+input[type="checkbox"] { vertical-align: bottom; }
+.ie7 input[type="checkbox"] { vertical-align: baseline; }
+.ie6 input { vertical-align: text-bottom; }
+label, input[type=button], input[type=submit], button { cursor: pointer; }
+button, input, select, textarea { margin: 0; }
+input:valid, textarea:valid   {  }
+input:invalid, textarea:invalid { border-radius: 1px;  -moz-box-shadow: 0px 0px 5px red; -webkit-box-shadow: 0px 0px 5px red;  box-shadow: 0px 0px 5px red; }
+.no-boxshadow input:invalid, 
+.no-boxshadow textarea:invalid { background-color: #f0dddd; }
+
+::-moz-selection{ background: #FF5E99; color:#fff; text-shadow: none; }
+::selection { background:#FF5E99; color:#fff; text-shadow: none; } 
+a:link { -webkit-tap-highlight-color: #FF5E99; } 
+
+button {  width: auto; overflow: visible; }
+.ie7 img { -ms-interpolation-mode: bicubic; }
+
+.ir { display: block; text-indent: -999em; overflow: hidden; background-repeat: no-repeat; text-align: left; direction: ltr; }
+.hidden { display: none; visibility: hidden; } 
+.visuallyhidden { position: absolute !important; clip: rect(1px 1px 1px 1px);  clip: rect(1px, 1px, 1px, 1px); }
+.invisible { visibility: hidden; }
+.clearfix:before, .clearfix:after {  content: "\0020"; display: block; height: 0; visibility: hidden;	 } 
+.clearfix:after { clear: both; }
+.clearfix { zoom: 1; }
+
+
+ /* Primary Styles
+    Author: 
+ */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+@media all and (orientation:portrait) { 
+  
+}
+
+@media all and (orientation:landscape) { 
+  
+}
+
+@media screen and (max-device-width: 480px) {
+  
+  
+  /* html { -webkit-text-size-adjust:none; -ms-text-size-adjust:none; } */
+}
+
+@media print {
+  * { background: transparent !important; color: #444 !important; text-shadow: none !important; }
+  a, a:visited { color: #444 !important; text-decoration: underline; }
+  a:after { content: " (" attr(href) ")"; } 
+  abbr:after { content: " (" attr(title) ")"; }
+  .ir a:after { content: ""; }  
+  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
+  thead { display: table-header-group; }  
+  tr, img { page-break-inside: avoid; }
+  @page { margin: 0.5cm; }
+  p, h2, h3 { orphans: 3; widows: 3; }
+  h2, h3{ page-break-after: avoid; }
+}
+
diff --git a/vendor/fog-0.8.2/docs/public/images/.gitignore b/vendor/fog-0.8.2/docs/public/images/.gitignore
new file mode 100755
index 0000000..a5baada
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/images/.gitignore
@@ -0,0 +1,3 @@
+*
+!.gitignore
+
diff --git a/vendor/fog-0.8.2/docs/public/js/libs/dd_belatedpng.js b/vendor/fog-0.8.2/docs/public/js/libs/dd_belatedpng.js
new file mode 100755
index 0000000..6062fb3
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/libs/dd_belatedpng.js
@@ -0,0 +1,13 @@
+/**
+* DD_belatedPNG: Adds IE6 support: PNG images for CSS background-image and HTML <IMG/>.
+* Author: Drew Diller
+* Email: drew.diller@gmail.com
+* URL: http://www.dillerdesign.com/experiment/DD_belatedPNG/
+* Version: 0.0.8a
+* Licensed under the MIT License: http://dillerdesign.com/experiment/DD_belatedPNG/#license
+*
+* Example usage:
+* DD_belatedPNG.fix('.png_bg'); // argument is a CSS selector
+* DD_belatedPNG.fixPng( someNode ); // argument is an HTMLDomElement
+**/
+var DD_belatedPNG={ns:"DD_belatedPNG",imgSize:{},delay:10,nodesFixed:0,createVmlNameSpace:function(){if(document.namespaces&&!document.namespaces[this.ns]){document.namespaces.add(this.ns,"urn:schemas-microsoft-com:vml")}},createVmlStyleSheet:function(){var b,a;b=document.createElement("style");b.setAttribute("media","screen");document.documentElement.firstChild.insertBefore(b,document.documentElement.firstChild.firstChild);if(b.styleSheet){b=b.styleSheet;b.addRule(this.ns+"\\:*","{behavior:url(#default#VML)}");b.addRule(this.ns+"\\:shape","position:absolute;");b.addRule("img."+this.ns+"_sizeFinder","behavior:none; border:none; position:absolute; z-index:-1; top:-10000px; visibility:hidden;");this.screenStyleSheet=b;a=document.createElement("style");a.setAttribute("media","print");document.documentElement.firstChild.insertBefore(a,document.documentElement.firstChild.firstChild);a=a.styleSheet;a.addRule(this.ns+"\\:*","{display: none !important;}");a.addRule("img."+this.ns+"_sizeFinder","{display: none !important;}")}},readPropertyChange:function(){var b,c,a;b=event.srcElement;if(!b.vmlInitiated){return}if(event.propertyName.search("background")!=-1||event.propertyName.search("border")!=-1){DD_belatedPNG.applyVML(b)}if(event.propertyName=="style.display"){c=(b.currentStyle.display=="none")?"none":"block";for(a in b.vml){if(b.vml.hasOwnProperty(a)){b.vml[a].shape.style.display=c}}}if(event.propertyName.search("filter")!=-1){DD_belatedPNG.vmlOpacity(b)}},vmlOpacity:function(b){if(b.currentStyle.filter.search("lpha")!=-1){var a=b.currentStyle.filter;a=parseInt(a.substring(a.lastIndexOf("=")+1,a.lastIndexOf(")")),10)/100;b.vml.color.shape.style.filter=b.currentStyle.filter;b.vml.image.fill.opacity=a}},handlePseudoHover:function(a){setTimeout(function(){DD_belatedPNG.applyVML(a)},1)},fix:function(a){if(this.screenStyleSheet){var c,b;c=a.split(",");for(b=0;b<c.length;b++){this.screenStyleSheet.addRule(c[b],"behavior:expression(DD_belatedPNG.fixPng(this))")}}},applyVML:function(a){a.runtimeStyle.cssText="";this.vmlFill(a);this.vmlOffsets(a);this.vmlOpacity(a);if(a.isImg){this.copyImageBorders(a)}},attachHandlers:function(i){var d,c,g,e,b,f;d=this;c={resize:"vmlOffsets",move:"vmlOffsets"};if(i.nodeName=="A"){e={mouseleave:"handlePseudoHover",mouseenter:"handlePseudoHover",focus:"handlePseudoHover",blur:"handlePseudoHover"};for(b in e){if(e.hasOwnProperty(b)){c[b]=e[b]}}}for(f in c){if(c.hasOwnProperty(f)){g=function(){d[c[f]](i)};i.attachEvent("on"+f,g)}}i.attachEvent("onpropertychange",this.readPropertyChange)},giveLayout:function(a){a.style.zoom=1;if(a.currentStyle.position=="static"){a.style.position="relative"}},copyImageBorders:function(b){var c,a;c={borderStyle:true,borderWidth:true,borderColor:true};for(a in c){if(c.hasOwnProperty(a)){b.vml.color.shape.style[a]=b.currentStyle[a]}}},vmlFill:function(e){if(!e.currentStyle){return}else{var d,f,g,b,a,c;d=e.currentStyle}for(b in e.vml){if(e.vml.hasOwnProperty(b)){e.vml[b].shape.style.zIndex=d.zIndex}}e.runtimeStyle.backgroundColor="";e.runtimeStyle.backgroundImage="";f=true;if(d.backgroundImage!="none"||e.isImg){if(!e.isImg){e.vmlBg=d.backgroundImage;e.vmlBg=e.vmlBg.substr(5,e.vmlBg.lastIndexOf('")')-5)}else{e.vmlBg=e.src}g=this;if(!g.imgSize[e.vmlBg]){a=document.createElement("img");g.imgSize[e.vmlBg]=a;a.className=g.ns+"_sizeFinder";a.runtimeStyle.cssText="behavior:none; position:absolute; left:-10000px; top:-10000px; border:none; margin:0; padding:0;";c=function(){this.width=this.offsetWidth;this.height=this.offsetHeight;g.vmlOffsets(e)};a.attachEvent("onload",c);a.src=e.vmlBg;a.removeAttribute("width");a.removeAttribute("height");document.body.insertBefore(a,document.body.firstChild)}e.vml.image.fill.src=e.vmlBg;f=false}e.vml.image.fill.on=!f;e.vml.image.fill.color="none";e.vml.color.shape.style.backgroundColor=d.backgroundColor;e.runtimeStyle.backgroundImage="none";e.runtimeStyle.backgroundColor="transparent"},vmlOffsets:function(d){var h,n,a,e,g,m,f,l,j,i,k;h=d.currentStyle;n={W:d.clientWidth+1,H:d.clientHeight+1,w:this.imgSize[d.vmlBg].width,h:this.imgSize[d.vmlBg].height,L:d.offsetLeft,T:d.offsetTop,bLW:d.clientLeft,bTW:d.clientTop};a=(n.L+n.bLW==1)?1:0;e=function(b,p,q,c,s,u){b.coordsize=c+","+s;b.coordorigin=u+","+u;b.path="m0,0l"+c+",0l"+c+","+s+"l0,"+s+" xe";b.style.width=c+"px";b.style.height=s+"px";b.style.left=p+"px";b.style.top=q+"px"};e(d.vml.color.shape,(n.L+(d.isImg?0:n.bLW)),(n.T+(d.isImg?0:n.bTW)),(n.W-1),(n.H-1),0);e(d.vml.image.shape,(n.L+n.bLW),(n.T+n.bTW),(n.W),(n.H),1);g={X:0,Y:0};if(d.isImg){g.X=parseInt(h.paddingLeft,10)+1;g.Y=parseInt(h.paddingTop,10)+1}else{for(j in g){if(g.hasOwnProperty(j)){this.figurePercentage(g,n,j,h["backgroundPosition"+j])}}}d.vml.image.fill.position=(g.X/n.W)+","+(g.Y/n.H);m=h.backgroundRepeat;f={T:1,R:n.W+a,B:n.H,L:1+a};l={X:{b1:"L",b2:"R",d:"W"},Y:{b1:"T",b2:"B",d:"H"}};if(m!="repeat"||d.isImg){i={T:(g.Y),R:(g.X+n.w),B:(g.Y+n.h),L:(g.X)};if(m.search("repeat-")!=-1){k=m.split("repeat-")[1].toUpperCase();i[l[k].b1]=1;i[l[k].b2]=n[l[k].d]}if(i.B>n.H){i.B=n.H}d.vml.image.shape.style.clip="rect("+i.T+"px "+(i.R+a)+"px "+i.B+"px "+(i.L+a)+"px)"}else{d.vml.image.shape.style.clip="rect("+f.T+"px "+f.R+"px "+f.B+"px "+f.L+"px)"}},figurePercentage:function(d,c,f,a){var b,e;e=true;b=(f=="X");switch(a){case"left":case"top":d[f]=0;break;case"center":d[f]=0.5;break;case"right":case"bottom":d[f]=1;break;default:if(a.search("%")!=-1){d[f]=parseInt(a,10)/100}else{e=false}}d[f]=Math.ceil(e?((c[b?"W":"H"]*d[f])-(c[b?"w":"h"]*d[f])):parseInt(a,10));if(d[f]%2===0){d[f]++}return d[f]},fixPng:function(c){c.style.behavior="none";var g,b,f,a,d;if(c.nodeName=="BODY"||c.nodeName=="TD"||c.nodeName=="TR"){return}c.isImg=false;if(c.nodeName=="IMG"){if(c.src.toLowerCase().search(/\.png$/)!=-1){c.isImg=true;c.style.visibility="hidden"}else{return}}else{if(c.currentStyle.backgroundImage.toLowerCase().search(".png")==-1){return}}g=DD_belatedPNG;c.vml={color:{},image:{}};b={shape:{},fill:{}};for(a in c.vml){if(c.vml.hasOwnProperty(a)){for(d in b){if(b.hasOwnProperty(d)){f=g.ns+":"+d;c.vml[a][d]=document.createElement(f)}}c.vml[a].shape.stroked=false;c.vml[a].shape.appendChild(c.vml[a].fill);c.parentNode.insertBefore(c.vml[a].shape,c)}}c.vml.image.shape.fillcolor="none";c.vml.image.fill.type="tile";c.vml.color.fill.on=false;g.attachHandlers(c);g.giveLayout(c);g.giveLayout(c.offsetParent);c.vmlInitiated=true;g.applyVML(c)}};try{document.execCommand("BackgroundImageCache",false,true)}catch(r){}DD_belatedPNG.createVmlNameSpace();DD_belatedPNG.createVmlStyleSheet();
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.js b/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.js
new file mode 100755
index 0000000..fff6776
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.js
@@ -0,0 +1,6240 @@
+/*!
+ * jQuery JavaScript Library v1.4.2
+ * http://jquery.com/
+ *
+ * Copyright 2010, John Resig
+ * Dual licensed under the MIT or GPL Version 2 licenses.
+ * http://jquery.org/license
+ *
+ * Includes Sizzle.js
+ * http://sizzlejs.com/
+ * Copyright 2010, The Dojo Foundation
+ * Released under the MIT, BSD, and GPL Licenses.
+ *
+ * Date: Sat Feb 13 22:33:48 2010 -0500
+ */
+(function( window, undefined ) {
+
+// Define a local copy of jQuery
+var jQuery = function( selector, context ) {
+		// The jQuery object is actually just the init constructor 'enhanced'
+		return new jQuery.fn.init( selector, context );
+	},
+
+	// Map over jQuery in case of overwrite
+	_jQuery = window.jQuery,
+
+	// Map over the $ in case of overwrite
+	_$ = window.$,
+
+	// Use the correct document accordingly with window argument (sandbox)
+	document = window.document,
+
+	// A central reference to the root jQuery(document)
+	rootjQuery,
+
+	// A simple way to check for HTML strings or ID strings
+	// (both of which we optimize for)
+	quickExpr = /^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,
+
+	// Is it a simple selector
+	isSimple = /^.[^:#\[\.,]*$/,
+
+	// Check if a string has a non-whitespace character in it
+	rnotwhite = /\S/,
+
+	// Used for trimming whitespace
+	rtrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g,
+
+	// Match a standalone tag
+	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
+
+	// Keep a UserAgent string for use with jQuery.browser
+	userAgent = navigator.userAgent,
+
+	// For matching the engine and version of the browser
+	browserMatch,
+	
+	// Has the ready events already been bound?
+	readyBound = false,
+	
+	// The functions to execute on DOM ready
+	readyList = [],
+
+	// The ready event handler
+	DOMContentLoaded,
+
+	// Save a reference to some core methods
+	toString = Object.prototype.toString,
+	hasOwnProperty = Object.prototype.hasOwnProperty,
+	push = Array.prototype.push,
+	slice = Array.prototype.slice,
+	indexOf = Array.prototype.indexOf;
+
+jQuery.fn = jQuery.prototype = {
+	init: function( selector, context ) {
+		var match, elem, ret, doc;
+
+		// Handle $(""), $(null), or $(undefined)
+		if ( !selector ) {
+			return this;
+		}
+
+		// Handle $(DOMElement)
+		if ( selector.nodeType ) {
+			this.context = this[0] = selector;
+			this.length = 1;
+			return this;
+		}
+		
+		// The body element only exists once, optimize finding it
+		if ( selector === "body" && !context ) {
+			this.context = document;
+			this[0] = document.body;
+			this.selector = "body";
+			this.length = 1;
+			return this;
+		}
+
+		// Handle HTML strings
+		if ( typeof selector === "string" ) {
+			// Are we dealing with HTML string or an ID?
+			match = quickExpr.exec( selector );
+
+			// Verify a match, and that no context was specified for #id
+			if ( match && (match[1] || !context) ) {
+
+				// HANDLE: $(html) -> $(array)
+				if ( match[1] ) {
+					doc = (context ? context.ownerDocument || context : document);
+
+					// If a single string is passed in and it's a single tag
+					// just do a createElement and skip the rest
+					ret = rsingleTag.exec( selector );
+
+					if ( ret ) {
+						if ( jQuery.isPlainObject( context ) ) {
+							selector = [ document.createElement( ret[1] ) ];
+							jQuery.fn.attr.call( selector, context, true );
+
+						} else {
+							selector = [ doc.createElement( ret[1] ) ];
+						}
+
+					} else {
+						ret = buildFragment( [ match[1] ], [ doc ] );
+						selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;
+					}
+					
+					return jQuery.merge( this, selector );
+					
+				// HANDLE: $("#id")
+				} else {
+					elem = document.getElementById( match[2] );
+
+					if ( elem ) {
+						// Handle the case where IE and Opera return items
+						// by name instead of ID
+						if ( elem.id !== match[2] ) {
+							return rootjQuery.find( selector );
+						}
+
+						// Otherwise, we inject the element directly into the jQuery object
+						this.length = 1;
+						this[0] = elem;
+					}
+
+					this.context = document;
+					this.selector = selector;
+					return this;
+				}
+
+			// HANDLE: $("TAG")
+			} else if ( !context && /^\w+$/.test( selector ) ) {
+				this.selector = selector;
+				this.context = document;
+				selector = document.getElementsByTagName( selector );
+				return jQuery.merge( this, selector );
+
+			// HANDLE: $(expr, $(...))
+			} else if ( !context || context.jquery ) {
+				return (context || rootjQuery).find( selector );
+
+			// HANDLE: $(expr, context)
+			// (which is just equivalent to: $(context).find(expr)
+			} else {
+				return jQuery( context ).find( selector );
+			}
+
+		// HANDLE: $(function)
+		// Shortcut for document ready
+		} else if ( jQuery.isFunction( selector ) ) {
+			return rootjQuery.ready( selector );
+		}
+
+		if (selector.selector !== undefined) {
+			this.selector = selector.selector;
+			this.context = selector.context;
+		}
+
+		return jQuery.makeArray( selector, this );
+	},
+
+	// Start with an empty selector
+	selector: "",
+
+	// The current version of jQuery being used
+	jquery: "1.4.2",
+
+	// The default length of a jQuery object is 0
+	length: 0,
+
+	// The number of elements contained in the matched element set
+	size: function() {
+		return this.length;
+	},
+
+	toArray: function() {
+		return slice.call( this, 0 );
+	},
+
+	// Get the Nth element in the matched element set OR
+	// Get the whole matched element set as a clean array
+	get: function( num ) {
+		return num == null ?
+
+			// Return a 'clean' array
+			this.toArray() :
+
+			// Return just the object
+			( num < 0 ? this.slice(num)[ 0 ] : this[ num ] );
+	},
+
+	// Take an array of elements and push it onto the stack
+	// (returning the new matched element set)
+	pushStack: function( elems, name, selector ) {
+		// Build a new jQuery matched element set
+		var ret = jQuery();
+
+		if ( jQuery.isArray( elems ) ) {
+			push.apply( ret, elems );
+		
+		} else {
+			jQuery.merge( ret, elems );
+		}
+
+		// Add the old object onto the stack (as a reference)
+		ret.prevObject = this;
+
+		ret.context = this.context;
+
+		if ( name === "find" ) {
+			ret.selector = this.selector + (this.selector ? " " : "") + selector;
+		} else if ( name ) {
+			ret.selector = this.selector + "." + name + "(" + selector + ")";
+		}
+
+		// Return the newly-formed element set
+		return ret;
+	},
+
+	// Execute a callback for every element in the matched set.
+	// (You can seed the arguments with an array of args, but this is
+	// only used internally.)
+	each: function( callback, args ) {
+		return jQuery.each( this, callback, args );
+	},
+	
+	ready: function( fn ) {
+		// Attach the listeners
+		jQuery.bindReady();
+
+		// If the DOM is already ready
+		if ( jQuery.isReady ) {
+			// Execute the function immediately
+			fn.call( document, jQuery );
+
+		// Otherwise, remember the function for later
+		} else if ( readyList ) {
+			// Add the function to the wait list
+			readyList.push( fn );
+		}
+
+		return this;
+	},
+	
+	eq: function( i ) {
+		return i === -1 ?
+			this.slice( i ) :
+			this.slice( i, +i + 1 );
+	},
+
+	first: function() {
+		return this.eq( 0 );
+	},
+
+	last: function() {
+		return this.eq( -1 );
+	},
+
+	slice: function() {
+		return this.pushStack( slice.apply( this, arguments ),
+			"slice", slice.call(arguments).join(",") );
+	},
+
+	map: function( callback ) {
+		return this.pushStack( jQuery.map(this, function( elem, i ) {
+			return callback.call( elem, i, elem );
+		}));
+	},
+	
+	end: function() {
+		return this.prevObject || jQuery(null);
+	},
+
+	// For internal use only.
+	// Behaves like an Array's method, not like a jQuery method.
+	push: push,
+	sort: [].sort,
+	splice: [].splice
+};
+
+// Give the init function the jQuery prototype for later instantiation
+jQuery.fn.init.prototype = jQuery.fn;
+
+jQuery.extend = jQuery.fn.extend = function() {
+	// copy reference to target object
+	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;
+
+	// Handle a deep copy situation
+	if ( typeof target === "boolean" ) {
+		deep = target;
+		target = arguments[1] || {};
+		// skip the boolean and the target
+		i = 2;
+	}
+
+	// Handle case when target is a string or something (possible in deep copy)
+	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
+		target = {};
+	}
+
+	// extend jQuery itself if only one argument is passed
+	if ( length === i ) {
+		target = this;
+		--i;
+	}
+
+	for ( ; i < length; i++ ) {
+		// Only deal with non-null/undefined values
+		if ( (options = arguments[ i ]) != null ) {
+			// Extend the base object
+			for ( name in options ) {
+				src = target[ name ];
+				copy = options[ name ];
+
+				// Prevent never-ending loop
+				if ( target === copy ) {
+					continue;
+				}
+
+				// Recurse if we're merging object literal values or arrays
+				if ( deep && copy && ( jQuery.isPlainObject(copy) || jQuery.isArray(copy) ) ) {
+					var clone = src && ( jQuery.isPlainObject(src) || jQuery.isArray(src) ) ? src
+						: jQuery.isArray(copy) ? [] : {};
+
+					// Never move original objects, clone them
+					target[ name ] = jQuery.extend( deep, clone, copy );
+
+				// Don't bring in undefined values
+				} else if ( copy !== undefined ) {
+					target[ name ] = copy;
+				}
+			}
+		}
+	}
+
+	// Return the modified object
+	return target;
+};
+
+jQuery.extend({
+	noConflict: function( deep ) {
+		window.$ = _$;
+
+		if ( deep ) {
+			window.jQuery = _jQuery;
+		}
+
+		return jQuery;
+	},
+	
+	// Is the DOM ready to be used? Set to true once it occurs.
+	isReady: false,
+	
+	// Handle when the DOM is ready
+	ready: function() {
+		// Make sure that the DOM is not already loaded
+		if ( !jQuery.isReady ) {
+			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
+			if ( !document.body ) {
+				return setTimeout( jQuery.ready, 13 );
+			}
+
+			// Remember that the DOM is ready
+			jQuery.isReady = true;
+
+			// If there are functions bound, to execute
+			if ( readyList ) {
+				// Execute all of them
+				var fn, i = 0;
+				while ( (fn = readyList[ i++ ]) ) {
+					fn.call( document, jQuery );
+				}
+
+				// Reset the list of functions
+				readyList = null;
+			}
+
+			// Trigger any bound ready events
+			if ( jQuery.fn.triggerHandler ) {
+				jQuery( document ).triggerHandler( "ready" );
+			}
+		}
+	},
+	
+	bindReady: function() {
+		if ( readyBound ) {
+			return;
+		}
+
+		readyBound = true;
+
+		// Catch cases where $(document).ready() is called after the
+		// browser event has already occurred.
+		if ( document.readyState === "complete" ) {
+			return jQuery.ready();
+		}
+
+		// Mozilla, Opera and webkit nightlies currently support this event
+		if ( document.addEventListener ) {
+			// Use the handy event callback
+			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
+			
+			// A fallback to window.onload, that will always work
+			window.addEventListener( "load", jQuery.ready, false );
+
+		// If IE event model is used
+		} else if ( document.attachEvent ) {
+			// ensure firing before onload,
+			// maybe late but safe also for iframes
+			document.attachEvent("onreadystatechange", DOMContentLoaded);
+			
+			// A fallback to window.onload, that will always work
+			window.attachEvent( "onload", jQuery.ready );
+
+			// If IE and not a frame
+			// continually check to see if the document is ready
+			var toplevel = false;
+
+			try {
+				toplevel = window.frameElement == null;
+			} catch(e) {}
+
+			if ( document.documentElement.doScroll && toplevel ) {
+				doScrollCheck();
+			}
+		}
+	},
+
+	// See test/unit/core.js for details concerning isFunction.
+	// Since version 1.3, DOM methods and functions like alert
+	// aren't supported. They return false on IE (#2968).
+	isFunction: function( obj ) {
+		return toString.call(obj) === "[object Function]";
+	},
+
+	isArray: function( obj ) {
+		return toString.call(obj) === "[object Array]";
+	},
+
+	isPlainObject: function( obj ) {
+		// Must be an Object.
+		// Because of IE, we also have to check the presence of the constructor property.
+		// Make sure that DOM nodes and window objects don't pass through, as well
+		if ( !obj || toString.call(obj) !== "[object Object]" || obj.nodeType || obj.setInterval ) {
+			return false;
+		}
+		
+		// Not own constructor property must be Object
+		if ( obj.constructor
+			&& !hasOwnProperty.call(obj, "constructor")
+			&& !hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf") ) {
+			return false;
+		}
+		
+		// Own properties are enumerated firstly, so to speed up,
+		// if last one is own, then all properties are own.
+	
+		var key;
+		for ( key in obj ) {}
+		
+		return key === undefined || hasOwnProperty.call( obj, key );
+	},
+
+	isEmptyObject: function( obj ) {
+		for ( var name in obj ) {
+			return false;
+		}
+		return true;
+	},
+	
+	error: function( msg ) {
+		throw msg;
+	},
+	
+	parseJSON: function( data ) {
+		if ( typeof data !== "string" || !data ) {
+			return null;
+		}
+
+		// Make sure leading/trailing whitespace is removed (IE can't handle it)
+		data = jQuery.trim( data );
+		
+		// Make sure the incoming data is actual JSON
+		// Logic borrowed from http://json.org/json2.js
+		if ( /^[\],:{}\s]*$/.test(data.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@")
+			.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]")
+			.replace(/(?:^|:|,)(?:\s*\[)+/g, "")) ) {
+
+			// Try to use the native JSON parser first
+			return window.JSON && window.JSON.parse ?
+				window.JSON.parse( data ) :
+				(new Function("return " + data))();
+
+		} else {
+			jQuery.error( "Invalid JSON: " + data );
+		}
+	},
+
+	noop: function() {},
+
+	// Evalulates a script in a global context
+	globalEval: function( data ) {
+		if ( data && rnotwhite.test(data) ) {
+			// Inspired by code by Andrea Giammarchi
+			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
+			var head = document.getElementsByTagName("head")[0] || document.documentElement,
+				script = document.createElement("script");
+
+			script.type = "text/javascript";
+
+			if ( jQuery.support.scriptEval ) {
+				script.appendChild( document.createTextNode( data ) );
+			} else {
+				script.text = data;
+			}
+
+			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
+			// This arises when a base node is used (#2709).
+			head.insertBefore( script, head.firstChild );
+			head.removeChild( script );
+		}
+	},
+
+	nodeName: function( elem, name ) {
+		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
+	},
+
+	// args is for internal usage only
+	each: function( object, callback, args ) {
+		var name, i = 0,
+			length = object.length,
+			isObj = length === undefined || jQuery.isFunction(object);
+
+		if ( args ) {
+			if ( isObj ) {
+				for ( name in object ) {
+					if ( callback.apply( object[ name ], args ) === false ) {
+						break;
+					}
+				}
+			} else {
+				for ( ; i < length; ) {
+					if ( callback.apply( object[ i++ ], args ) === false ) {
+						break;
+					}
+				}
+			}
+
+		// A special, fast, case for the most common use of each
+		} else {
+			if ( isObj ) {
+				for ( name in object ) {
+					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
+						break;
+					}
+				}
+			} else {
+				for ( var value = object[0];
+					i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {}
+			}
+		}
+
+		return object;
+	},
+
+	trim: function( text ) {
+		return (text || "").replace( rtrim, "" );
+	},
+
+	// results is for internal usage only
+	makeArray: function( array, results ) {
+		var ret = results || [];
+
+		if ( array != null ) {
+			// The window, strings (and functions) also have 'length'
+			// The extra typeof function check is to prevent crashes
+			// in Safari 2 (See: #3039)
+			if ( array.length == null || typeof array === "string" || jQuery.isFunction(array) || (typeof array !== "function" && array.setInterval) ) {
+				push.call( ret, array );
+			} else {
+				jQuery.merge( ret, array );
+			}
+		}
+
+		return ret;
+	},
+
+	inArray: function( elem, array ) {
+		if ( array.indexOf ) {
+			return array.indexOf( elem );
+		}
+
+		for ( var i = 0, length = array.length; i < length; i++ ) {
+			if ( array[ i ] === elem ) {
+				return i;
+			}
+		}
+
+		return -1;
+	},
+
+	merge: function( first, second ) {
+		var i = first.length, j = 0;
+
+		if ( typeof second.length === "number" ) {
+			for ( var l = second.length; j < l; j++ ) {
+				first[ i++ ] = second[ j ];
+			}
+		
+		} else {
+			while ( second[j] !== undefined ) {
+				first[ i++ ] = second[ j++ ];
+			}
+		}
+
+		first.length = i;
+
+		return first;
+	},
+
+	grep: function( elems, callback, inv ) {
+		var ret = [];
+
+		// Go through the array, only saving the items
+		// that pass the validator function
+		for ( var i = 0, length = elems.length; i < length; i++ ) {
+			if ( !inv !== !callback( elems[ i ], i ) ) {
+				ret.push( elems[ i ] );
+			}
+		}
+
+		return ret;
+	},
+
+	// arg is for internal usage only
+	map: function( elems, callback, arg ) {
+		var ret = [], value;
+
+		// Go through the array, translating each of the items to their
+		// new value (or values).
+		for ( var i = 0, length = elems.length; i < length; i++ ) {
+			value = callback( elems[ i ], i, arg );
+
+			if ( value != null ) {
+				ret[ ret.length ] = value;
+			}
+		}
+
+		return ret.concat.apply( [], ret );
+	},
+
+	// A global GUID counter for objects
+	guid: 1,
+
+	proxy: function( fn, proxy, thisObject ) {
+		if ( arguments.length === 2 ) {
+			if ( typeof proxy === "string" ) {
+				thisObject = fn;
+				fn = thisObject[ proxy ];
+				proxy = undefined;
+
+			} else if ( proxy && !jQuery.isFunction( proxy ) ) {
+				thisObject = proxy;
+				proxy = undefined;
+			}
+		}
+
+		if ( !proxy && fn ) {
+			proxy = function() {
+				return fn.apply( thisObject || this, arguments );
+			};
+		}
+
+		// Set the guid of unique handler to the same of original handler, so it can be removed
+		if ( fn ) {
+			proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
+		}
+
+		// So proxy can be declared as an argument
+		return proxy;
+	},
+
+	// Use of jQuery.browser is frowned upon.
+	// More details: http://docs.jquery.com/Utilities/jQuery.browser
+	uaMatch: function( ua ) {
+		ua = ua.toLowerCase();
+
+		var match = /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
+			/(opera)(?:.*version)?[ \/]([\w.]+)/.exec( ua ) ||
+			/(msie) ([\w.]+)/.exec( ua ) ||
+			!/compatible/.test( ua ) && /(mozilla)(?:.*? rv:([\w.]+))?/.exec( ua ) ||
+		  	[];
+
+		return { browser: match[1] || "", version: match[2] || "0" };
+	},
+
+	browser: {}
+});
+
+browserMatch = jQuery.uaMatch( userAgent );
+if ( browserMatch.browser ) {
+	jQuery.browser[ browserMatch.browser ] = true;
+	jQuery.browser.version = browserMatch.version;
+}
+
+// Deprecated, use jQuery.browser.webkit instead
+if ( jQuery.browser.webkit ) {
+	jQuery.browser.safari = true;
+}
+
+if ( indexOf ) {
+	jQuery.inArray = function( elem, array ) {
+		return indexOf.call( array, elem );
+	};
+}
+
+// All jQuery objects should point back to these
+rootjQuery = jQuery(document);
+
+// Cleanup functions for the document ready method
+if ( document.addEventListener ) {
+	DOMContentLoaded = function() {
+		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
+		jQuery.ready();
+	};
+
+} else if ( document.attachEvent ) {
+	DOMContentLoaded = function() {
+		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
+		if ( document.readyState === "complete" ) {
+			document.detachEvent( "onreadystatechange", DOMContentLoaded );
+			jQuery.ready();
+		}
+	};
+}
+
+// The DOM ready check for Internet Explorer
+function doScrollCheck() {
+	if ( jQuery.isReady ) {
+		return;
+	}
+
+	try {
+		// If IE is used, use the trick by Diego Perini
+		// http://javascript.nwbox.com/IEContentLoaded/
+		document.documentElement.doScroll("left");
+	} catch( error ) {
+		setTimeout( doScrollCheck, 1 );
+		return;
+	}
+
+	// and execute any waiting functions
+	jQuery.ready();
+}
+
+function evalScript( i, elem ) {
+	if ( elem.src ) {
+		jQuery.ajax({
+			url: elem.src,
+			async: false,
+			dataType: "script"
+		});
+	} else {
+		jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || "" );
+	}
+
+	if ( elem.parentNode ) {
+		elem.parentNode.removeChild( elem );
+	}
+}
+
+// Mutifunctional method to get and set values to a collection
+// The value/s can be optionally by executed if its a function
+function access( elems, key, value, exec, fn, pass ) {
+	var length = elems.length;
+	
+	// Setting many attributes
+	if ( typeof key === "object" ) {
+		for ( var k in key ) {
+			access( elems, k, key[k], exec, fn, value );
+		}
+		return elems;
+	}
+	
+	// Setting one attribute
+	if ( value !== undefined ) {
+		// Optionally, function values get executed if exec is true
+		exec = !pass && exec && jQuery.isFunction(value);
+		
+		for ( var i = 0; i < length; i++ ) {
+			fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
+		}
+		
+		return elems;
+	}
+	
+	// Getting an attribute
+	return length ? fn( elems[0], key ) : undefined;
+}
+
+function now() {
+	return (new Date).getTime();
+}
+(function() {
+
+	jQuery.support = {};
+
+	var root = document.documentElement,
+		script = document.createElement("script"),
+		div = document.createElement("div"),
+		id = "script" + now();
+
+	div.style.display = "none";
+	div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
+
+	var all = div.getElementsByTagName("*"),
+		a = div.getElementsByTagName("a")[0];
+
+	// Can't get basic test support
+	if ( !all || !all.length || !a ) {
+		return;
+	}
+
+	jQuery.support = {
+		// IE strips leading whitespace when .innerHTML is used
+		leadingWhitespace: div.firstChild.nodeType === 3,
+
+		// Make sure that tbody elements aren't automatically inserted
+		// IE will insert them into empty tables
+		tbody: !div.getElementsByTagName("tbody").length,
+
+		// Make sure that link elements get serialized correctly by innerHTML
+		// This requires a wrapper element in IE
+		htmlSerialize: !!div.getElementsByTagName("link").length,
+
+		// Get the style information from getAttribute
+		// (IE uses .cssText insted)
+		style: /red/.test( a.getAttribute("style") ),
+
+		// Make sure that URLs aren't manipulated
+		// (IE normalizes it by default)
+		hrefNormalized: a.getAttribute("href") === "/a",
+
+		// Make sure that element opacity exists
+		// (IE uses filter instead)
+		// Use a regex to work around a WebKit issue. See #5145
+		opacity: /^0.55$/.test( a.style.opacity ),
+
+		// Verify style float existence
+		// (IE uses styleFloat instead of cssFloat)
+		cssFloat: !!a.style.cssFloat,
+
+		// Make sure that if no value is specified for a checkbox
+		// that it defaults to "on".
+		// (WebKit defaults to "" instead)
+		checkOn: div.getElementsByTagName("input")[0].value === "on",
+
+		// Make sure that a selected-by-default option has a working selected property.
+		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
+		optSelected: document.createElement("select").appendChild( document.createElement("option") ).selected,
+
+		parentNode: div.removeChild( div.appendChild( document.createElement("div") ) ).parentNode === null,
+
+		// Will be defined later
+		deleteExpando: true,
+		checkClone: false,
+		scriptEval: false,
+		noCloneEvent: true,
+		boxModel: null
+	};
+
+	script.type = "text/javascript";
+	try {
+		script.appendChild( document.createTextNode( "window." + id + "=1;" ) );
+	} catch(e) {}
+
+	root.insertBefore( script, root.firstChild );
+
+	// Make sure that the execution of code works by injecting a script
+	// tag with appendChild/createTextNode
+	// (IE doesn't support this, fails, and uses .text instead)
+	if ( window[ id ] ) {
+		jQuery.support.scriptEval = true;
+		delete window[ id ];
+	}
+
+	// Test to see if it's possible to delete an expando from an element
+	// Fails in Internet Explorer
+	try {
+		delete script.test;
+	
+	} catch(e) {
+		jQuery.support.deleteExpando = false;
+	}
+
+	root.removeChild( script );
+
+	if ( div.attachEvent && div.fireEvent ) {
+		div.attachEvent("onclick", function click() {
+			// Cloning a node shouldn't copy over any
+			// bound event handlers (IE does this)
+			jQuery.support.noCloneEvent = false;
+			div.detachEvent("onclick", click);
+		});
+		div.cloneNode(true).fireEvent("onclick");
+	}
+
+	div = document.createElement("div");
+	div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";
+
+	var fragment = document.createDocumentFragment();
+	fragment.appendChild( div.firstChild );
+
+	// WebKit doesn't clone checked state correctly in fragments
+	jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
+
+	// Figure out if the W3C box model works as expected
+	// document.body must exist before we can do this
+	jQuery(function() {
+		var div = document.createElement("div");
+		div.style.width = div.style.paddingLeft = "1px";
+
+		document.body.appendChild( div );
+		jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;
+		document.body.removeChild( div ).style.display = 'none';
+
+		div = null;
+	});
+
+	// Technique from Juriy Zaytsev
+	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
+	var eventSupported = function( eventName ) { 
+		var el = document.createElement("div"); 
+		eventName = "on" + eventName; 
+
+		var isSupported = (eventName in el); 
+		if ( !isSupported ) { 
+			el.setAttribute(eventName, "return;"); 
+			isSupported = typeof el[eventName] === "function"; 
+		} 
+		el = null; 
+
+		return isSupported; 
+	};
+	
+	jQuery.support.submitBubbles = eventSupported("submit");
+	jQuery.support.changeBubbles = eventSupported("change");
+
+	// release memory in IE
+	root = script = div = all = a = null;
+})();
+
+jQuery.props = {
+	"for": "htmlFor",
+	"class": "className",
+	readonly: "readOnly",
+	maxlength: "maxLength",
+	cellspacing: "cellSpacing",
+	rowspan: "rowSpan",
+	colspan: "colSpan",
+	tabindex: "tabIndex",
+	usemap: "useMap",
+	frameborder: "frameBorder"
+};
+var expando = "jQuery" + now(), uuid = 0, windowData = {};
+
+jQuery.extend({
+	cache: {},
+	
+	expando:expando,
+
+	// The following elements throw uncatchable exceptions if you
+	// attempt to add expando properties to them.
+	noData: {
+		"embed": true,
+		"object": true,
+		"applet": true
+	},
+
+	data: function( elem, name, data ) {
+		if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
+			return;
+		}
+
+		elem = elem == window ?
+			windowData :
+			elem;
+
+		var id = elem[ expando ], cache = jQuery.cache, thisCache;
+
+		if ( !id && typeof name === "string" && data === undefined ) {
+			return null;
+		}
+
+		// Compute a unique ID for the element
+		if ( !id ) { 
+			id = ++uuid;
+		}
+
+		// Avoid generating a new cache unless none exists and we
+		// want to manipulate it.
+		if ( typeof name === "object" ) {
+			elem[ expando ] = id;
+			thisCache = cache[ id ] = jQuery.extend(true, {}, name);
+
+		} else if ( !cache[ id ] ) {
+			elem[ expando ] = id;
+			cache[ id ] = {};
+		}
+
+		thisCache = cache[ id ];
+
+		// Prevent overriding the named cache with undefined values
+		if ( data !== undefined ) {
+			thisCache[ name ] = data;
+		}
+
+		return typeof name === "string" ? thisCache[ name ] : thisCache;
+	},
+
+	removeData: function( elem, name ) {
+		if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
+			return;
+		}
+
+		elem = elem == window ?
+			windowData :
+			elem;
+
+		var id = elem[ expando ], cache = jQuery.cache, thisCache = cache[ id ];
+
+		// If we want to remove a specific section of the element's data
+		if ( name ) {
+			if ( thisCache ) {
+				// Remove the section of cache data
+				delete thisCache[ name ];
+
+				// If we've removed all the data, remove the element's cache
+				if ( jQuery.isEmptyObject(thisCache) ) {
+					jQuery.removeData( elem );
+				}
+			}
+
+		// Otherwise, we want to remove all of the element's data
+		} else {
+			if ( jQuery.support.deleteExpando ) {
+				delete elem[ jQuery.expando ];
+
+			} else if ( elem.removeAttribute ) {
+				elem.removeAttribute( jQuery.expando );
+			}
+
+			// Completely remove the data cache
+			delete cache[ id ];
+		}
+	}
+});
+
+jQuery.fn.extend({
+	data: function( key, value ) {
+		if ( typeof key === "undefined" && this.length ) {
+			return jQuery.data( this[0] );
+
+		} else if ( typeof key === "object" ) {
+			return this.each(function() {
+				jQuery.data( this, key );
+			});
+		}
+
+		var parts = key.split(".");
+		parts[1] = parts[1] ? "." + parts[1] : "";
+
+		if ( value === undefined ) {
+			var data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);
+
+			if ( data === undefined && this.length ) {
+				data = jQuery.data( this[0], key );
+			}
+			return data === undefined && parts[1] ?
+				this.data( parts[0] ) :
+				data;
+		} else {
+			return this.trigger("setData" + parts[1] + "!", [parts[0], value]).each(function() {
+				jQuery.data( this, key, value );
+			});
+		}
+	},
+
+	removeData: function( key ) {
+		return this.each(function() {
+			jQuery.removeData( this, key );
+		});
+	}
+});
+jQuery.extend({
+	queue: function( elem, type, data ) {
+		if ( !elem ) {
+			return;
+		}
+
+		type = (type || "fx") + "queue";
+		var q = jQuery.data( elem, type );
+
+		// Speed up dequeue by getting out quickly if this is just a lookup
+		if ( !data ) {
+			return q || [];
+		}
+
+		if ( !q || jQuery.isArray(data) ) {
+			q = jQuery.data( elem, type, jQuery.makeArray(data) );
+
+		} else {
+			q.push( data );
+		}
+
+		return q;
+	},
+
+	dequeue: function( elem, type ) {
+		type = type || "fx";
+
+		var queue = jQuery.queue( elem, type ), fn = queue.shift();
+
+		// If the fx queue is dequeued, always remove the progress sentinel
+		if ( fn === "inprogress" ) {
+			fn = queue.shift();
+		}
+
+		if ( fn ) {
+			// Add a progress sentinel to prevent the fx queue from being
+			// automatically dequeued
+			if ( type === "fx" ) {
+				queue.unshift("inprogress");
+			}
+
+			fn.call(elem, function() {
+				jQuery.dequeue(elem, type);
+			});
+		}
+	}
+});
+
+jQuery.fn.extend({
+	queue: function( type, data ) {
+		if ( typeof type !== "string" ) {
+			data = type;
+			type = "fx";
+		}
+
+		if ( data === undefined ) {
+			return jQuery.queue( this[0], type );
+		}
+		return this.each(function( i, elem ) {
+			var queue = jQuery.queue( this, type, data );
+
+			if ( type === "fx" && queue[0] !== "inprogress" ) {
+				jQuery.dequeue( this, type );
+			}
+		});
+	},
+	dequeue: function( type ) {
+		return this.each(function() {
+			jQuery.dequeue( this, type );
+		});
+	},
+
+	// Based off of the plugin by Clint Helfers, with permission.
+	// http://blindsignals.com/index.php/2009/07/jquery-delay/
+	delay: function( time, type ) {
+		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
+		type = type || "fx";
+
+		return this.queue( type, function() {
+			var elem = this;
+			setTimeout(function() {
+				jQuery.dequeue( elem, type );
+			}, time );
+		});
+	},
+
+	clearQueue: function( type ) {
+		return this.queue( type || "fx", [] );
+	}
+});
+var rclass = /[\n\t]/g,
+	rspace = /\s+/,
+	rreturn = /\r/g,
+	rspecialurl = /href|src|style/,
+	rtype = /(button|input)/i,
+	rfocusable = /(button|input|object|select|textarea)/i,
+	rclickable = /^(a|area)$/i,
+	rradiocheck = /radio|checkbox/;
+
+jQuery.fn.extend({
+	attr: function( name, value ) {
+		return access( this, name, value, true, jQuery.attr );
+	},
+
+	removeAttr: function( name, fn ) {
+		return this.each(function(){
+			jQuery.attr( this, name, "" );
+			if ( this.nodeType === 1 ) {
+				this.removeAttribute( name );
+			}
+		});
+	},
+
+	addClass: function( value ) {
+		if ( jQuery.isFunction(value) ) {
+			return this.each(function(i) {
+				var self = jQuery(this);
+				self.addClass( value.call(this, i, self.attr("class")) );
+			});
+		}
+
+		if ( value && typeof value === "string" ) {
+			var classNames = (value || "").split( rspace );
+
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				var elem = this[i];
+
+				if ( elem.nodeType === 1 ) {
+					if ( !elem.className ) {
+						elem.className = value;
+
+					} else {
+						var className = " " + elem.className + " ", setClass = elem.className;
+						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
+							if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
+								setClass += " " + classNames[c];
+							}
+						}
+						elem.className = jQuery.trim( setClass );
+					}
+				}
+			}
+		}
+
+		return this;
+	},
+
+	removeClass: function( value ) {
+		if ( jQuery.isFunction(value) ) {
+			return this.each(function(i) {
+				var self = jQuery(this);
+				self.removeClass( value.call(this, i, self.attr("class")) );
+			});
+		}
+
+		if ( (value && typeof value === "string") || value === undefined ) {
+			var classNames = (value || "").split(rspace);
+
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				var elem = this[i];
+
+				if ( elem.nodeType === 1 && elem.className ) {
+					if ( value ) {
+						var className = (" " + elem.className + " ").replace(rclass, " ");
+						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
+							className = className.replace(" " + classNames[c] + " ", " ");
+						}
+						elem.className = jQuery.trim( className );
+
+					} else {
+						elem.className = "";
+					}
+				}
+			}
+		}
+
+		return this;
+	},
+
+	toggleClass: function( value, stateVal ) {
+		var type = typeof value, isBool = typeof stateVal === "boolean";
+
+		if ( jQuery.isFunction( value ) ) {
+			return this.each(function(i) {
+				var self = jQuery(this);
+				self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
+			});
+		}
+
+		return this.each(function() {
+			if ( type === "string" ) {
+				// toggle individual class names
+				var className, i = 0, self = jQuery(this),
+					state = stateVal,
+					classNames = value.split( rspace );
+
+				while ( (className = classNames[ i++ ]) ) {
+					// check each className given, space seperated list
+					state = isBool ? state : !self.hasClass( className );
+					self[ state ? "addClass" : "removeClass" ]( className );
+				}
+
+			} else if ( type === "undefined" || type === "boolean" ) {
+				if ( this.className ) {
+					// store className if set
+					jQuery.data( this, "__className__", this.className );
+				}
+
+				// toggle whole className
+				this.className = this.className || value === false ? "" : jQuery.data( this, "__className__" ) || "";
+			}
+		});
+	},
+
+	hasClass: function( selector ) {
+		var className = " " + selector + " ";
+		for ( var i = 0, l = this.length; i < l; i++ ) {
+			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
+				return true;
+			}
+		}
+
+		return false;
+	},
+
+	val: function( value ) {
+		if ( value === undefined ) {
+			var elem = this[0];
+
+			if ( elem ) {
+				if ( jQuery.nodeName( elem, "option" ) ) {
+					return (elem.attributes.value || {}).specified ? elem.value : elem.text;
+				}
+
+				// We need to handle select boxes special
+				if ( jQuery.nodeName( elem, "select" ) ) {
+					var index = elem.selectedIndex,
+						values = [],
+						options = elem.options,
+						one = elem.type === "select-one";
+
+					// Nothing was selected
+					if ( index < 0 ) {
+						return null;
+					}
+
+					// Loop through all the selected options
+					for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
+						var option = options[ i ];
+
+						if ( option.selected ) {
+							// Get the specifc value for the option
+							value = jQuery(option).val();
+
+							// We don't need an array for one selects
+							if ( one ) {
+								return value;
+							}
+
+							// Multi-Selects return an array
+							values.push( value );
+						}
+					}
+
+					return values;
+				}
+
+				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
+				if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) {
+					return elem.getAttribute("value") === null ? "on" : elem.value;
+				}
+				
+
+				// Everything else, we just grab the value
+				return (elem.value || "").replace(rreturn, "");
+
+			}
+
+			return undefined;
+		}
+
+		var isFunction = jQuery.isFunction(value);
+
+		return this.each(function(i) {
+			var self = jQuery(this), val = value;
+
+			if ( this.nodeType !== 1 ) {
+				return;
+			}
+
+			if ( isFunction ) {
+				val = value.call(this, i, self.val());
+			}
+
+			// Typecast each time if the value is a Function and the appended
+			// value is therefore different each time.
+			if ( typeof val === "number" ) {
+				val += "";
+			}
+
+			if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) {
+				this.checked = jQuery.inArray( self.val(), val ) >= 0;
+
+			} else if ( jQuery.nodeName( this, "select" ) ) {
+				var values = jQuery.makeArray(val);
+
+				jQuery( "option", this ).each(function() {
+					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
+				});
+
+				if ( !values.length ) {
+					this.selectedIndex = -1;
+				}
+
+			} else {
+				this.value = val;
+			}
+		});
+	}
+});
+
+jQuery.extend({
+	attrFn: {
+		val: true,
+		css: true,
+		html: true,
+		text: true,
+		data: true,
+		width: true,
+		height: true,
+		offset: true
+	},
+		
+	attr: function( elem, name, value, pass ) {
+		// don't set attributes on text and comment nodes
+		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
+			return undefined;
+		}
+
+		if ( pass && name in jQuery.attrFn ) {
+			return jQuery(elem)[name](value);
+		}
+
+		var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ),
+			// Whether we are setting (or getting)
+			set = value !== undefined;
+
+		// Try to normalize/fix the name
+		name = notxml && jQuery.props[ name ] || name;
+
+		// Only do all the following if this is a node (faster for style)
+		if ( elem.nodeType === 1 ) {
+			// These attributes require special treatment
+			var special = rspecialurl.test( name );
+
+			// Safari mis-reports the default selected property of an option
+			// Accessing the parent's selectedIndex property fixes it
+			if ( name === "selected" && !jQuery.support.optSelected ) {
+				var parent = elem.parentNode;
+				if ( parent ) {
+					parent.selectedIndex;
+	
+					// Make sure that it also works with optgroups, see #5701
+					if ( parent.parentNode ) {
+						parent.parentNode.selectedIndex;
+					}
+				}
+			}
+
+			// If applicable, access the attribute via the DOM 0 way
+			if ( name in elem && notxml && !special ) {
+				if ( set ) {
+					// We can't allow the type property to be changed (since it causes problems in IE)
+					if ( name === "type" && rtype.test( elem.nodeName ) && elem.parentNode ) {
+						jQuery.error( "type property can't be changed" );
+					}
+
+					elem[ name ] = value;
+				}
+
+				// browsers index elements by id/name on forms, give priority to attributes.
+				if ( jQuery.nodeName( elem, "form" ) && elem.getAttributeNode(name) ) {
+					return elem.getAttributeNode( name ).nodeValue;
+				}
+
+				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
+				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
+				if ( name === "tabIndex" ) {
+					var attributeNode = elem.getAttributeNode( "tabIndex" );
+
+					return attributeNode && attributeNode.specified ?
+						attributeNode.value :
+						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
+							0 :
+							undefined;
+				}
+
+				return elem[ name ];
+			}
+
+			if ( !jQuery.support.style && notxml && name === "style" ) {
+				if ( set ) {
+					elem.style.cssText = "" + value;
+				}
+
+				return elem.style.cssText;
+			}
+
+			if ( set ) {
+				// convert the value to a string (all browsers do this but IE) see #1070
+				elem.setAttribute( name, "" + value );
+			}
+
+			var attr = !jQuery.support.hrefNormalized && notxml && special ?
+					// Some attributes require a special call on IE
+					elem.getAttribute( name, 2 ) :
+					elem.getAttribute( name );
+
+			// Non-existent attributes return null, we normalize to undefined
+			return attr === null ? undefined : attr;
+		}
+
+		// elem is actually elem.style ... set the style
+		// Using attr for specific style information is now deprecated. Use style instead.
+		return jQuery.style( elem, name, value );
+	}
+});
+var rnamespaces = /\.(.*)$/,
+	fcleanup = function( nm ) {
+		return nm.replace(/[^\w\s\.\|`]/g, function( ch ) {
+			return "\\" + ch;
+		});
+	};
+
+/*
+ * A number of helper functions used for managing events.
+ * Many of the ideas behind this code originated from
+ * Dean Edwards' addEvent library.
+ */
+jQuery.event = {
+
+	// Bind an event to an element
+	// Original by Dean Edwards
+	add: function( elem, types, handler, data ) {
+		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
+			return;
+		}
+
+		// For whatever reason, IE has trouble passing the window object
+		// around, causing it to be cloned in the process
+		if ( elem.setInterval && ( elem !== window && !elem.frameElement ) ) {
+			elem = window;
+		}
+
+		var handleObjIn, handleObj;
+
+		if ( handler.handler ) {
+			handleObjIn = handler;
+			handler = handleObjIn.handler;
+		}
+
+		// Make sure that the function being executed has a unique ID
+		if ( !handler.guid ) {
+			handler.guid = jQuery.guid++;
+		}
+
+		// Init the element's event structure
+		var elemData = jQuery.data( elem );
+
+		// If no elemData is found then we must be trying to bind to one of the
+		// banned noData elements
+		if ( !elemData ) {
+			return;
+		}
+
+		var events = elemData.events = elemData.events || {},
+			eventHandle = elemData.handle, eventHandle;
+
+		if ( !eventHandle ) {
+			elemData.handle = eventHandle = function() {
+				// Handle the second event of a trigger and when
+				// an event is called after a page has unloaded
+				return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
+					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
+					undefined;
+			};
+		}
+
+		// Add elem as a property of the handle function
+		// This is to prevent a memory leak with non-native events in IE.
+		eventHandle.elem = elem;
+
+		// Handle multiple events separated by a space
+		// jQuery(...).bind("mouseover mouseout", fn);
+		types = types.split(" ");
+
+		var type, i = 0, namespaces;
+
+		while ( (type = types[ i++ ]) ) {
+			handleObj = handleObjIn ?
+				jQuery.extend({}, handleObjIn) :
+				{ handler: handler, data: data };
+
+			// Namespaced event handlers
+			if ( type.indexOf(".") > -1 ) {
+				namespaces = type.split(".");
+				type = namespaces.shift();
+				handleObj.namespace = namespaces.slice(0).sort().join(".");
+
+			} else {
+				namespaces = [];
+				handleObj.namespace = "";
+			}
+
+			handleObj.type = type;
+			handleObj.guid = handler.guid;
+
+			// Get the current list of functions bound to this event
+			var handlers = events[ type ],
+				special = jQuery.event.special[ type ] || {};
+
+			// Init the event handler queue
+			if ( !handlers ) {
+				handlers = events[ type ] = [];
+
+				// Check for a special event handler
+				// Only use addEventListener/attachEvent if the special
+				// events handler returns false
+				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
+					// Bind the global event handler to the element
+					if ( elem.addEventListener ) {
+						elem.addEventListener( type, eventHandle, false );
+
+					} else if ( elem.attachEvent ) {
+						elem.attachEvent( "on" + type, eventHandle );
+					}
+				}
+			}
+			
+			if ( special.add ) { 
+				special.add.call( elem, handleObj ); 
+
+				if ( !handleObj.handler.guid ) {
+					handleObj.handler.guid = handler.guid;
+				}
+			}
+
+			// Add the function to the element's handler list
+			handlers.push( handleObj );
+
+			// Keep track of which events have been used, for global triggering
+			jQuery.event.global[ type ] = true;
+		}
+
+		// Nullify elem to prevent memory leaks in IE
+		elem = null;
+	},
+
+	global: {},
+
+	// Detach an event or set of events from an element
+	remove: function( elem, types, handler, pos ) {
+		// don't do events on text and comment nodes
+		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
+			return;
+		}
+
+		var ret, type, fn, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
+			elemData = jQuery.data( elem ),
+			events = elemData && elemData.events;
+
+		if ( !elemData || !events ) {
+			return;
+		}
+
+		// types is actually an event object here
+		if ( types && types.type ) {
+			handler = types.handler;
+			types = types.type;
+		}
+
+		// Unbind all events for the element
+		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
+			types = types || "";
+
+			for ( type in events ) {
+				jQuery.event.remove( elem, type + types );
+			}
+
+			return;
+		}
+
+		// Handle multiple events separated by a space
+		// jQuery(...).unbind("mouseover mouseout", fn);
+		types = types.split(" ");
+
+		while ( (type = types[ i++ ]) ) {
+			origType = type;
+			handleObj = null;
+			all = type.indexOf(".") < 0;
+			namespaces = [];
+
+			if ( !all ) {
+				// Namespaced event handlers
+				namespaces = type.split(".");
+				type = namespaces.shift();
+
+				namespace = new RegExp("(^|\\.)" + 
+					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)")
+			}
+
+			eventType = events[ type ];
+
+			if ( !eventType ) {
+				continue;
+			}
+
+			if ( !handler ) {
+				for ( var j = 0; j < eventType.length; j++ ) {
+					handleObj = eventType[ j ];
+
+					if ( all || namespace.test( handleObj.namespace ) ) {
+						jQuery.event.remove( elem, origType, handleObj.handler, j );
+						eventType.splice( j--, 1 );
+					}
+				}
+
+				continue;
+			}
+
+			special = jQuery.event.special[ type ] || {};
+
+			for ( var j = pos || 0; j < eventType.length; j++ ) {
+				handleObj = eventType[ j ];
+
+				if ( handler.guid === handleObj.guid ) {
+					// remove the given handler for the given type
+					if ( all || namespace.test( handleObj.namespace ) ) {
+						if ( pos == null ) {
+							eventType.splice( j--, 1 );
+						}
+
+						if ( special.remove ) {
+							special.remove.call( elem, handleObj );
+						}
+					}
+
+					if ( pos != null ) {
+						break;
+					}
+				}
+			}
+
+			// remove generic event handler if no more handlers exist
+			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
+				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
+					removeEvent( elem, type, elemData.handle );
+				}
+
+				ret = null;
+				delete events[ type ];
+			}
+		}
+
+		// Remove the expando if it's no longer used
+		if ( jQuery.isEmptyObject( events ) ) {
+			var handle = elemData.handle;
+			if ( handle ) {
+				handle.elem = null;
+			}
+
+			delete elemData.events;
+			delete elemData.handle;
+
+			if ( jQuery.isEmptyObject( elemData ) ) {
+				jQuery.removeData( elem );
+			}
+		}
+	},
+
+	// bubbling is internal
+	trigger: function( event, data, elem /*, bubbling */ ) {
+		// Event object or event type
+		var type = event.type || event,
+			bubbling = arguments[3];
+
+		if ( !bubbling ) {
+			event = typeof event === "object" ?
+				// jQuery.Event object
+				event[expando] ? event :
+				// Object literal
+				jQuery.extend( jQuery.Event(type), event ) :
+				// Just the event type (string)
+				jQuery.Event(type);
+
+			if ( type.indexOf("!") >= 0 ) {
+				event.type = type = type.slice(0, -1);
+				event.exclusive = true;
+			}
+
+			// Handle a global trigger
+			if ( !elem ) {
+				// Don't bubble custom events when global (to avoid too much overhead)
+				event.stopPropagation();
+
+				// Only trigger if we've ever bound an event for it
+				if ( jQuery.event.global[ type ] ) {
+					jQuery.each( jQuery.cache, function() {
+						if ( this.events && this.events[type] ) {
+							jQuery.event.trigger( event, data, this.handle.elem );
+						}
+					});
+				}
+			}
+
+			// Handle triggering a single element
+
+			// don't do events on text and comment nodes
+			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
+				return undefined;
+			}
+
+			// Clean up in case it is reused
+			event.result = undefined;
+			event.target = elem;
+
+			// Clone the incoming data, if any
+			data = jQuery.makeArray( data );
+			data.unshift( event );
+		}
+
+		event.currentTarget = elem;
+
+		// Trigger the event, it is assumed that "handle" is a function
+		var handle = jQuery.data( elem, "handle" );
+		if ( handle ) {
+			handle.apply( elem, data );
+		}
+
+		var parent = elem.parentNode || elem.ownerDocument;
+
+		// Trigger an inline bound script
+		try {
+			if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) {
+				if ( elem[ "on" + type ] && elem[ "on" + type ].apply( elem, data ) === false ) {
+					event.result = false;
+				}
+			}
+
+		// prevent IE from throwing an error for some elements with some event types, see #3533
+		} catch (e) {}
+
+		if ( !event.isPropagationStopped() && parent ) {
+			jQuery.event.trigger( event, data, parent, true );
+
+		} else if ( !event.isDefaultPrevented() ) {
+			var target = event.target, old,
+				isClick = jQuery.nodeName(target, "a") && type === "click",
+				special = jQuery.event.special[ type ] || {};
+
+			if ( (!special._default || special._default.call( elem, event ) === false) && 
+				!isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) {
+
+				try {
+					if ( target[ type ] ) {
+						// Make sure that we don't accidentally re-trigger the onFOO events
+						old = target[ "on" + type ];
+
+						if ( old ) {
+							target[ "on" + type ] = null;
+						}
+
+						jQuery.event.triggered = true;
+						target[ type ]();
+					}
+
+				// prevent IE from throwing an error for some elements with some event types, see #3533
+				} catch (e) {}
+
+				if ( old ) {
+					target[ "on" + type ] = old;
+				}
+
+				jQuery.event.triggered = false;
+			}
+		}
+	},
+
+	handle: function( event ) {
+		var all, handlers, namespaces, namespace, events;
+
+		event = arguments[0] = jQuery.event.fix( event || window.event );
+		event.currentTarget = this;
+
+		// Namespaced event handlers
+		all = event.type.indexOf(".") < 0 && !event.exclusive;
+
+		if ( !all ) {
+			namespaces = event.type.split(".");
+			event.type = namespaces.shift();
+			namespace = new RegExp("(^|\\.)" + namespaces.slice(0).sort().join("\\.(?:.*\\.)?") + "(\\.|$)");
+		}
+
+		var events = jQuery.data(this, "events"), handlers = events[ event.type ];
+
+		if ( events && handlers ) {
+			// Clone the handlers to prevent manipulation
+			handlers = handlers.slice(0);
+
+			for ( var j = 0, l = handlers.length; j < l; j++ ) {
+				var handleObj = handlers[ j ];
+
+				// Filter the functions by class
+				if ( all || namespace.test( handleObj.namespace ) ) {
+					// Pass in a reference to the handler function itself
+					// So that we can later remove it
+					event.handler = handleObj.handler;
+					event.data = handleObj.data;
+					event.handleObj = handleObj;
+	
+					var ret = handleObj.handler.apply( this, arguments );
+
+					if ( ret !== undefined ) {
+						event.result = ret;
+						if ( ret === false ) {
+							event.preventDefault();
+							event.stopPropagation();
+						}
+					}
+
+					if ( event.isImmediatePropagationStopped() ) {
+						break;
+					}
+				}
+			}
+		}
+
+		return event.result;
+	},
+
+	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
+
+	fix: function( event ) {
+		if ( event[ expando ] ) {
+			return event;
+		}
+
+		// store a copy of the original event object
+		// and "clone" to set read-only properties
+		var originalEvent = event;
+		event = jQuery.Event( originalEvent );
+
+		for ( var i = this.props.length, prop; i; ) {
+			prop = this.props[ --i ];
+			event[ prop ] = originalEvent[ prop ];
+		}
+
+		// Fix target property, if necessary
+		if ( !event.target ) {
+			event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either
+		}
+
+		// check if target is a textnode (safari)
+		if ( event.target.nodeType === 3 ) {
+			event.target = event.target.parentNode;
+		}
+
+		// Add relatedTarget, if necessary
+		if ( !event.relatedTarget && event.fromElement ) {
+			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
+		}
+
+		// Calculate pageX/Y if missing and clientX/Y available
+		if ( event.pageX == null && event.clientX != null ) {
+			var doc = document.documentElement, body = document.body;
+			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
+			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
+		}
+
+		// Add which for key events
+		if ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) ) {
+			event.which = event.charCode || event.keyCode;
+		}
+
+		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
+		if ( !event.metaKey && event.ctrlKey ) {
+			event.metaKey = event.ctrlKey;
+		}
+
+		// Add which for click: 1 === left; 2 === middle; 3 === right
+		// Note: button is not normalized, so don't use it
+		if ( !event.which && event.button !== undefined ) {
+			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
+		}
+
+		return event;
+	},
+
+	// Deprecated, use jQuery.guid instead
+	guid: 1E8,
+
+	// Deprecated, use jQuery.proxy instead
+	proxy: jQuery.proxy,
+
+	special: {
+		ready: {
+			// Make sure the ready event is setup
+			setup: jQuery.bindReady,
+			teardown: jQuery.noop
+		},
+
+		live: {
+			add: function( handleObj ) {
+				jQuery.event.add( this, handleObj.origType, jQuery.extend({}, handleObj, {handler: liveHandler}) ); 
+			},
+
+			remove: function( handleObj ) {
+				var remove = true,
+					type = handleObj.origType.replace(rnamespaces, "");
+				
+				jQuery.each( jQuery.data(this, "events").live || [], function() {
+					if ( type === this.origType.replace(rnamespaces, "") ) {
+						remove = false;
+						return false;
+					}
+				});
+
+				if ( remove ) {
+					jQuery.event.remove( this, handleObj.origType, liveHandler );
+				}
+			}
+
+		},
+
+		beforeunload: {
+			setup: function( data, namespaces, eventHandle ) {
+				// We only want to do this special case on windows
+				if ( this.setInterval ) {
+					this.onbeforeunload = eventHandle;
+				}
+
+				return false;
+			},
+			teardown: function( namespaces, eventHandle ) {
+				if ( this.onbeforeunload === eventHandle ) {
+					this.onbeforeunload = null;
+				}
+			}
+		}
+	}
+};
+
+var removeEvent = document.removeEventListener ?
+	function( elem, type, handle ) {
+		elem.removeEventListener( type, handle, false );
+	} : 
+	function( elem, type, handle ) {
+		elem.detachEvent( "on" + type, handle );
+	};
+
+jQuery.Event = function( src ) {
+	// Allow instantiation without the 'new' keyword
+	if ( !this.preventDefault ) {
+		return new jQuery.Event( src );
+	}
+
+	// Event object
+	if ( src && src.type ) {
+		this.originalEvent = src;
+		this.type = src.type;
+	// Event type
+	} else {
+		this.type = src;
+	}
+
+	// timeStamp is buggy for some events on Firefox(#3843)
+	// So we won't rely on the native value
+	this.timeStamp = now();
+
+	// Mark it as fixed
+	this[ expando ] = true;
+};
+
+function returnFalse() {
+	return false;
+}
+function returnTrue() {
+	return true;
+}
+
+// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
+// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
+jQuery.Event.prototype = {
+	preventDefault: function() {
+		this.isDefaultPrevented = returnTrue;
+
+		var e = this.originalEvent;
+		if ( !e ) {
+			return;
+		}
+		
+		// if preventDefault exists run it on the original event
+		if ( e.preventDefault ) {
+			e.preventDefault();
+		}
+		// otherwise set the returnValue property of the original event to false (IE)
+		e.returnValue = false;
+	},
+	stopPropagation: function() {
+		this.isPropagationStopped = returnTrue;
+
+		var e = this.originalEvent;
+		if ( !e ) {
+			return;
+		}
+		// if stopPropagation exists run it on the original event
+		if ( e.stopPropagation ) {
+			e.stopPropagation();
+		}
+		// otherwise set the cancelBubble property of the original event to true (IE)
+		e.cancelBubble = true;
+	},
+	stopImmediatePropagation: function() {
+		this.isImmediatePropagationStopped = returnTrue;
+		this.stopPropagation();
+	},
+	isDefaultPrevented: returnFalse,
+	isPropagationStopped: returnFalse,
+	isImmediatePropagationStopped: returnFalse
+};
+
+// Checks if an event happened on an element within another element
+// Used in jQuery.event.special.mouseenter and mouseleave handlers
+var withinElement = function( event ) {
+	// Check if mouse(over|out) are still within the same parent element
+	var parent = event.relatedTarget;
+
+	// Firefox sometimes assigns relatedTarget a XUL element
+	// which we cannot access the parentNode property of
+	try {
+		// Traverse up the tree
+		while ( parent && parent !== this ) {
+			parent = parent.parentNode;
+		}
+
+		if ( parent !== this ) {
+			// set the correct event type
+			event.type = event.data;
+
+			// handle event if we actually just moused on to a non sub-element
+			jQuery.event.handle.apply( this, arguments );
+		}
+
+	// assuming we've left the element since we most likely mousedover a xul element
+	} catch(e) { }
+},
+
+// In case of event delegation, we only need to rename the event.type,
+// liveHandler will take care of the rest.
+delegate = function( event ) {
+	event.type = event.data;
+	jQuery.event.handle.apply( this, arguments );
+};
+
+// Create mouseenter and mouseleave events
+jQuery.each({
+	mouseenter: "mouseover",
+	mouseleave: "mouseout"
+}, function( orig, fix ) {
+	jQuery.event.special[ orig ] = {
+		setup: function( data ) {
+			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
+		},
+		teardown: function( data ) {
+			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
+		}
+	};
+});
+
+// submit delegation
+if ( !jQuery.support.submitBubbles ) {
+
+	jQuery.event.special.submit = {
+		setup: function( data, namespaces ) {
+			if ( this.nodeName.toLowerCase() !== "form" ) {
+				jQuery.event.add(this, "click.specialSubmit", function( e ) {
+					var elem = e.target, type = elem.type;
+
+					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
+						return trigger( "submit", this, arguments );
+					}
+				});
+	 
+				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
+					var elem = e.target, type = elem.type;
+
+					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
+						return trigger( "submit", this, arguments );
+					}
+				});
+
+			} else {
+				return false;
+			}
+		},
+
+		teardown: function( namespaces ) {
+			jQuery.event.remove( this, ".specialSubmit" );
+		}
+	};
+
+}
+
+// change delegation, happens here so we have bind.
+if ( !jQuery.support.changeBubbles ) {
+
+	var formElems = /textarea|input|select/i,
+
+	changeFilters,
+
+	getVal = function( elem ) {
+		var type = elem.type, val = elem.value;
+
+		if ( type === "radio" || type === "checkbox" ) {
+			val = elem.checked;
+
+		} else if ( type === "select-multiple" ) {
+			val = elem.selectedIndex > -1 ?
+				jQuery.map( elem.options, function( elem ) {
+					return elem.selected;
+				}).join("-") :
+				"";
+
+		} else if ( elem.nodeName.toLowerCase() === "select" ) {
+			val = elem.selectedIndex;
+		}
+
+		return val;
+	},
+
+	testChange = function testChange( e ) {
+		var elem = e.target, data, val;
+
+		if ( !formElems.test( elem.nodeName ) || elem.readOnly ) {
+			return;
+		}
+
+		data = jQuery.data( elem, "_change_data" );
+		val = getVal(elem);
+
+		// the current data will be also retrieved by beforeactivate
+		if ( e.type !== "focusout" || elem.type !== "radio" ) {
+			jQuery.data( elem, "_change_data", val );
+		}
+		
+		if ( data === undefined || val === data ) {
+			return;
+		}
+
+		if ( data != null || val ) {
+			e.type = "change";
+			return jQuery.event.trigger( e, arguments[1], elem );
+		}
+	};
+
+	jQuery.event.special.change = {
+		filters: {
+			focusout: testChange, 
+
+			click: function( e ) {
+				var elem = e.target, type = elem.type;
+
+				if ( type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select" ) {
+					return testChange.call( this, e );
+				}
+			},
+
+			// Change has to be called before submit
+			// Keydown will be called before keypress, which is used in submit-event delegation
+			keydown: function( e ) {
+				var elem = e.target, type = elem.type;
+
+				if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
+					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
+					type === "select-multiple" ) {
+					return testChange.call( this, e );
+				}
+			},
+
+			// Beforeactivate happens also before the previous element is blurred
+			// with this event you can't trigger a change event, but you can store
+			// information/focus[in] is not needed anymore
+			beforeactivate: function( e ) {
+				var elem = e.target;
+				jQuery.data( elem, "_change_data", getVal(elem) );
+			}
+		},
+
+		setup: function( data, namespaces ) {
+			if ( this.type === "file" ) {
+				return false;
+			}
+
+			for ( var type in changeFilters ) {
+				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
+			}
+
+			return formElems.test( this.nodeName );
+		},
+
+		teardown: function( namespaces ) {
+			jQuery.event.remove( this, ".specialChange" );
+
+			return formElems.test( this.nodeName );
+		}
+	};
+
+	changeFilters = jQuery.event.special.change.filters;
+}
+
+function trigger( type, elem, args ) {
+	args[0].type = type;
+	return jQuery.event.handle.apply( elem, args );
+}
+
+// Create "bubbling" focus and blur events
+if ( document.addEventListener ) {
+	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
+		jQuery.event.special[ fix ] = {
+			setup: function() {
+				this.addEventListener( orig, handler, true );
+			}, 
+			teardown: function() { 
+				this.removeEventListener( orig, handler, true );
+			}
+		};
+
+		function handler( e ) { 
+			e = jQuery.event.fix( e );
+			e.type = fix;
+			return jQuery.event.handle.call( this, e );
+		}
+	});
+}
+
+jQuery.each(["bind", "one"], function( i, name ) {
+	jQuery.fn[ name ] = function( type, data, fn ) {
+		// Handle object literals
+		if ( typeof type === "object" ) {
+			for ( var key in type ) {
+				this[ name ](key, data, type[key], fn);
+			}
+			return this;
+		}
+		
+		if ( jQuery.isFunction( data ) ) {
+			fn = data;
+			data = undefined;
+		}
+
+		var handler = name === "one" ? jQuery.proxy( fn, function( event ) {
+			jQuery( this ).unbind( event, handler );
+			return fn.apply( this, arguments );
+		}) : fn;
+
+		if ( type === "unload" && name !== "one" ) {
+			this.one( type, data, fn );
+
+		} else {
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				jQuery.event.add( this[i], type, handler, data );
+			}
+		}
+
+		return this;
+	};
+});
+
+jQuery.fn.extend({
+	unbind: function( type, fn ) {
+		// Handle object literals
+		if ( typeof type === "object" && !type.preventDefault ) {
+			for ( var key in type ) {
+				this.unbind(key, type[key]);
+			}
+
+		} else {
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				jQuery.event.remove( this[i], type, fn );
+			}
+		}
+
+		return this;
+	},
+	
+	delegate: function( selector, types, data, fn ) {
+		return this.live( types, data, fn, selector );
+	},
+	
+	undelegate: function( selector, types, fn ) {
+		if ( arguments.length === 0 ) {
+				return this.unbind( "live" );
+		
+		} else {
+			return this.die( types, null, fn, selector );
+		}
+	},
+	
+	trigger: function( type, data ) {
+		return this.each(function() {
+			jQuery.event.trigger( type, data, this );
+		});
+	},
+
+	triggerHandler: function( type, data ) {
+		if ( this[0] ) {
+			var event = jQuery.Event( type );
+			event.preventDefault();
+			event.stopPropagation();
+			jQuery.event.trigger( event, data, this[0] );
+			return event.result;
+		}
+	},
+
+	toggle: function( fn ) {
+		// Save reference to arguments for access in closure
+		var args = arguments, i = 1;
+
+		// link all the functions, so any of them can unbind this click handler
+		while ( i < args.length ) {
+			jQuery.proxy( fn, args[ i++ ] );
+		}
+
+		return this.click( jQuery.proxy( fn, function( event ) {
+			// Figure out which function to execute
+			var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
+			jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );
+
+			// Make sure that clicks stop
+			event.preventDefault();
+
+			// and execute the function
+			return args[ lastToggle ].apply( this, arguments ) || false;
+		}));
+	},
+
+	hover: function( fnOver, fnOut ) {
+		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
+	}
+});
+
+var liveMap = {
+	focus: "focusin",
+	blur: "focusout",
+	mouseenter: "mouseover",
+	mouseleave: "mouseout"
+};
+
+jQuery.each(["live", "die"], function( i, name ) {
+	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
+		var type, i = 0, match, namespaces, preType,
+			selector = origSelector || this.selector,
+			context = origSelector ? this : jQuery( this.context );
+
+		if ( jQuery.isFunction( data ) ) {
+			fn = data;
+			data = undefined;
+		}
+
+		types = (types || "").split(" ");
+
+		while ( (type = types[ i++ ]) != null ) {
+			match = rnamespaces.exec( type );
+			namespaces = "";
+
+			if ( match )  {
+				namespaces = match[0];
+				type = type.replace( rnamespaces, "" );
+			}
+
+			if ( type === "hover" ) {
+				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
+				continue;
+			}
+
+			preType = type;
+
+			if ( type === "focus" || type === "blur" ) {
+				types.push( liveMap[ type ] + namespaces );
+				type = type + namespaces;
+
+			} else {
+				type = (liveMap[ type ] || type) + namespaces;
+			}
+
+			if ( name === "live" ) {
+				// bind live handler
+				context.each(function(){
+					jQuery.event.add( this, liveConvert( type, selector ),
+						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
+				});
+
+			} else {
+				// unbind live handler
+				context.unbind( liveConvert( type, selector ), fn );
+			}
+		}
+		
+		return this;
+	}
+});
+
+function liveHandler( event ) {
+	var stop, elems = [], selectors = [], args = arguments,
+		related, match, handleObj, elem, j, i, l, data,
+		events = jQuery.data( this, "events" );
+
+	// Make sure we avoid non-left-click bubbling in Firefox (#3861)
+	if ( event.liveFired === this || !events || !events.live || event.button && event.type === "click" ) {
+		return;
+	}
+
+	event.liveFired = this;
+
+	var live = events.live.slice(0);
+
+	for ( j = 0; j < live.length; j++ ) {
+		handleObj = live[j];
+
+		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
+			selectors.push( handleObj.selector );
+
+		} else {
+			live.splice( j--, 1 );
+		}
+	}
+
+	match = jQuery( event.target ).closest( selectors, event.currentTarget );
+
+	for ( i = 0, l = match.length; i < l; i++ ) {
+		for ( j = 0; j < live.length; j++ ) {
+			handleObj = live[j];
+
+			if ( match[i].selector === handleObj.selector ) {
+				elem = match[i].elem;
+				related = null;
+
+				// Those two events require additional checking
+				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
+					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];
+				}
+
+				if ( !related || related !== elem ) {
+					elems.push({ elem: elem, handleObj: handleObj });
+				}
+			}
+		}
+	}
+
+	for ( i = 0, l = elems.length; i < l; i++ ) {
+		match = elems[i];
+		event.currentTarget = match.elem;
+		event.data = match.handleObj.data;
+		event.handleObj = match.handleObj;
+
+		if ( match.handleObj.origHandler.apply( match.elem, args ) === false ) {
+			stop = false;
+			break;
+		}
+	}
+
+	return stop;
+}
+
+function liveConvert( type, selector ) {
+	return "live." + (type && type !== "*" ? type + "." : "") + selector.replace(/\./g, "`").replace(/ /g, "&");
+}
+
+jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
+	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
+	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {
+
+	// Handle event binding
+	jQuery.fn[ name ] = function( fn ) {
+		return fn ? this.bind( name, fn ) : this.trigger( name );
+	};
+
+	if ( jQuery.attrFn ) {
+		jQuery.attrFn[ name ] = true;
+	}
+});
+
+// Prevent memory leaks in IE
+// Window isn't included so as not to unbind existing unload events
+// More info:
+//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/
+if ( window.attachEvent && !window.addEventListener ) {
+	window.attachEvent("onunload", function() {
+		for ( var id in jQuery.cache ) {
+			if ( jQuery.cache[ id ].handle ) {
+				// Try/Catch is to handle iframes being unloaded, see #4280
+				try {
+					jQuery.event.remove( jQuery.cache[ id ].handle.elem );
+				} catch(e) {}
+			}
+		}
+	});
+}
+/*!
+ * Sizzle CSS Selector Engine - v1.0
+ *  Copyright 2009, The Dojo Foundation
+ *  Released under the MIT, BSD, and GPL Licenses.
+ *  More information: http://sizzlejs.com/
+ */
+(function(){
+
+var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
+	done = 0,
+	toString = Object.prototype.toString,
+	hasDuplicate = false,
+	baseHasDuplicate = true;
+
+// Here we check if the JavaScript engine is using some sort of
+// optimization where it does not always call our comparision
+// function. If that is the case, discard the hasDuplicate value.
+//   Thus far that includes Google Chrome.
+[0, 0].sort(function(){
+	baseHasDuplicate = false;
+	return 0;
+});
+
+var Sizzle = function(selector, context, results, seed) {
+	results = results || [];
+	var origContext = context = context || document;
+
+	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
+		return [];
+	}
+	
+	if ( !selector || typeof selector !== "string" ) {
+		return results;
+	}
+
+	var parts = [], m, set, checkSet, extra, prune = true, contextXML = isXML(context),
+		soFar = selector;
+	
+	// Reset the position of the chunker regexp (start from head)
+	while ( (chunker.exec(""), m = chunker.exec(soFar)) !== null ) {
+		soFar = m[3];
+		
+		parts.push( m[1] );
+		
+		if ( m[2] ) {
+			extra = m[3];
+			break;
+		}
+	}
+
+	if ( parts.length > 1 && origPOS.exec( selector ) ) {
+		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
+			set = posProcess( parts[0] + parts[1], context );
+		} else {
+			set = Expr.relative[ parts[0] ] ?
+				[ context ] :
+				Sizzle( parts.shift(), context );
+
+			while ( parts.length ) {
+				selector = parts.shift();
+
+				if ( Expr.relative[ selector ] ) {
+					selector += parts.shift();
+				}
+				
+				set = posProcess( selector, set );
+			}
+		}
+	} else {
+		// Take a shortcut and set the context if the root selector is an ID
+		// (but not if it'll be faster if the inner selector is an ID)
+		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
+				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
+			var ret = Sizzle.find( parts.shift(), context, contextXML );
+			context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0];
+		}
+
+		if ( context ) {
+			var ret = seed ?
+				{ expr: parts.pop(), set: makeArray(seed) } :
+				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
+			set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set;
+
+			if ( parts.length > 0 ) {
+				checkSet = makeArray(set);
+			} else {
+				prune = false;
+			}
+
+			while ( parts.length ) {
+				var cur = parts.pop(), pop = cur;
+
+				if ( !Expr.relative[ cur ] ) {
+					cur = "";
+				} else {
+					pop = parts.pop();
+				}
+
+				if ( pop == null ) {
+					pop = context;
+				}
+
+				Expr.relative[ cur ]( checkSet, pop, contextXML );
+			}
+		} else {
+			checkSet = parts = [];
+		}
+	}
+
+	if ( !checkSet ) {
+		checkSet = set;
+	}
+
+	if ( !checkSet ) {
+		Sizzle.error( cur || selector );
+	}
+
+	if ( toString.call(checkSet) === "[object Array]" ) {
+		if ( !prune ) {
+			results.push.apply( results, checkSet );
+		} else if ( context && context.nodeType === 1 ) {
+			for ( var i = 0; checkSet[i] != null; i++ ) {
+				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) {
+					results.push( set[i] );
+				}
+			}
+		} else {
+			for ( var i = 0; checkSet[i] != null; i++ ) {
+				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
+					results.push( set[i] );
+				}
+			}
+		}
+	} else {
+		makeArray( checkSet, results );
+	}
+
+	if ( extra ) {
+		Sizzle( extra, origContext, results, seed );
+		Sizzle.uniqueSort( results );
+	}
+
+	return results;
+};
+
+Sizzle.uniqueSort = function(results){
+	if ( sortOrder ) {
+		hasDuplicate = baseHasDuplicate;
+		results.sort(sortOrder);
+
+		if ( hasDuplicate ) {
+			for ( var i = 1; i < results.length; i++ ) {
+				if ( results[i] === results[i-1] ) {
+					results.splice(i--, 1);
+				}
+			}
+		}
+	}
+
+	return results;
+};
+
+Sizzle.matches = function(expr, set){
+	return Sizzle(expr, null, null, set);
+};
+
+Sizzle.find = function(expr, context, isXML){
+	var set, match;
+
+	if ( !expr ) {
+		return [];
+	}
+
+	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
+		var type = Expr.order[i], match;
+		
+		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
+			var left = match[1];
+			match.splice(1,1);
+
+			if ( left.substr( left.length - 1 ) !== "\\" ) {
+				match[1] = (match[1] || "").replace(/\\/g, "");
+				set = Expr.find[ type ]( match, context, isXML );
+				if ( set != null ) {
+					expr = expr.replace( Expr.match[ type ], "" );
+					break;
+				}
+			}
+		}
+	}
+
+	if ( !set ) {
+		set = context.getElementsByTagName("*");
+	}
+
+	return {set: set, expr: expr};
+};
+
+Sizzle.filter = function(expr, set, inplace, not){
+	var old = expr, result = [], curLoop = set, match, anyFound,
+		isXMLFilter = set && set[0] && isXML(set[0]);
+
+	while ( expr && set.length ) {
+		for ( var type in Expr.filter ) {
+			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
+				var filter = Expr.filter[ type ], found, item, left = match[1];
+				anyFound = false;
+
+				match.splice(1,1);
+
+				if ( left.substr( left.length - 1 ) === "\\" ) {
+					continue;
+				}
+
+				if ( curLoop === result ) {
+					result = [];
+				}
+
+				if ( Expr.preFilter[ type ] ) {
+					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
+
+					if ( !match ) {
+						anyFound = found = true;
+					} else if ( match === true ) {
+						continue;
+					}
+				}
+
+				if ( match ) {
+					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
+						if ( item ) {
+							found = filter( item, match, i, curLoop );
+							var pass = not ^ !!found;
+
+							if ( inplace && found != null ) {
+								if ( pass ) {
+									anyFound = true;
+								} else {
+									curLoop[i] = false;
+								}
+							} else if ( pass ) {
+								result.push( item );
+								anyFound = true;
+							}
+						}
+					}
+				}
+
+				if ( found !== undefined ) {
+					if ( !inplace ) {
+						curLoop = result;
+					}
+
+					expr = expr.replace( Expr.match[ type ], "" );
+
+					if ( !anyFound ) {
+						return [];
+					}
+
+					break;
+				}
+			}
+		}
+
+		// Improper expression
+		if ( expr === old ) {
+			if ( anyFound == null ) {
+				Sizzle.error( expr );
+			} else {
+				break;
+			}
+		}
+
+		old = expr;
+	}
+
+	return curLoop;
+};
+
+Sizzle.error = function( msg ) {
+	throw "Syntax error, unrecognized expression: " + msg;
+};
+
+var Expr = Sizzle.selectors = {
+	order: [ "ID", "NAME", "TAG" ],
+	match: {
+		ID: /#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
+		CLASS: /\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
+		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,
+		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
+		TAG: /^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,
+		CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,
+		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,
+		PSEUDO: /:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
+	},
+	leftMatch: {},
+	attrMap: {
+		"class": "className",
+		"for": "htmlFor"
+	},
+	attrHandle: {
+		href: function(elem){
+			return elem.getAttribute("href");
+		}
+	},
+	relative: {
+		"+": function(checkSet, part){
+			var isPartStr = typeof part === "string",
+				isTag = isPartStr && !/\W/.test(part),
+				isPartStrNotTag = isPartStr && !isTag;
+
+			if ( isTag ) {
+				part = part.toLowerCase();
+			}
+
+			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
+				if ( (elem = checkSet[i]) ) {
+					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
+
+					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
+						elem || false :
+						elem === part;
+				}
+			}
+
+			if ( isPartStrNotTag ) {
+				Sizzle.filter( part, checkSet, true );
+			}
+		},
+		">": function(checkSet, part){
+			var isPartStr = typeof part === "string";
+
+			if ( isPartStr && !/\W/.test(part) ) {
+				part = part.toLowerCase();
+
+				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+					var elem = checkSet[i];
+					if ( elem ) {
+						var parent = elem.parentNode;
+						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
+					}
+				}
+			} else {
+				for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+					var elem = checkSet[i];
+					if ( elem ) {
+						checkSet[i] = isPartStr ?
+							elem.parentNode :
+							elem.parentNode === part;
+					}
+				}
+
+				if ( isPartStr ) {
+					Sizzle.filter( part, checkSet, true );
+				}
+			}
+		},
+		"": function(checkSet, part, isXML){
+			var doneName = done++, checkFn = dirCheck;
+
+			if ( typeof part === "string" && !/\W/.test(part) ) {
+				var nodeCheck = part = part.toLowerCase();
+				checkFn = dirNodeCheck;
+			}
+
+			checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
+		},
+		"~": function(checkSet, part, isXML){
+			var doneName = done++, checkFn = dirCheck;
+
+			if ( typeof part === "string" && !/\W/.test(part) ) {
+				var nodeCheck = part = part.toLowerCase();
+				checkFn = dirNodeCheck;
+			}
+
+			checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
+		}
+	},
+	find: {
+		ID: function(match, context, isXML){
+			if ( typeof context.getElementById !== "undefined" && !isXML ) {
+				var m = context.getElementById(match[1]);
+				return m ? [m] : [];
+			}
+		},
+		NAME: function(match, context){
+			if ( typeof context.getElementsByName !== "undefined" ) {
+				var ret = [], results = context.getElementsByName(match[1]);
+
+				for ( var i = 0, l = results.length; i < l; i++ ) {
+					if ( results[i].getAttribute("name") === match[1] ) {
+						ret.push( results[i] );
+					}
+				}
+
+				return ret.length === 0 ? null : ret;
+			}
+		},
+		TAG: function(match, context){
+			return context.getElementsByTagName(match[1]);
+		}
+	},
+	preFilter: {
+		CLASS: function(match, curLoop, inplace, result, not, isXML){
+			match = " " + match[1].replace(/\\/g, "") + " ";
+
+			if ( isXML ) {
+				return match;
+			}
+
+			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
+				if ( elem ) {
+					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0) ) {
+						if ( !inplace ) {
+							result.push( elem );
+						}
+					} else if ( inplace ) {
+						curLoop[i] = false;
+					}
+				}
+			}
+
+			return false;
+		},
+		ID: function(match){
+			return match[1].replace(/\\/g, "");
+		},
+		TAG: function(match, curLoop){
+			return match[1].toLowerCase();
+		},
+		CHILD: function(match){
+			if ( match[1] === "nth" ) {
+				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
+				var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
+					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
+					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
+
+				// calculate the numbers (first)n+(last) including if they are negative
+				match[2] = (test[1] + (test[2] || 1)) - 0;
+				match[3] = test[3] - 0;
+			}
+
+			// TODO: Move to normal caching system
+			match[0] = done++;
+
+			return match;
+		},
+		ATTR: function(match, curLoop, inplace, result, not, isXML){
+			var name = match[1].replace(/\\/g, "");
+			
+			if ( !isXML && Expr.attrMap[name] ) {
+				match[1] = Expr.attrMap[name];
+			}
+
+			if ( match[2] === "~=" ) {
+				match[4] = " " + match[4] + " ";
+			}
+
+			return match;
+		},
+		PSEUDO: function(match, curLoop, inplace, result, not){
+			if ( match[1] === "not" ) {
+				// If we're dealing with a complex expression, or a simple one
+				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
+					match[3] = Sizzle(match[3], null, null, curLoop);
+				} else {
+					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
+					if ( !inplace ) {
+						result.push.apply( result, ret );
+					}
+					return false;
+				}
+			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
+				return true;
+			}
+			
+			return match;
+		},
+		POS: function(match){
+			match.unshift( true );
+			return match;
+		}
+	},
+	filters: {
+		enabled: function(elem){
+			return elem.disabled === false && elem.type !== "hidden";
+		},
+		disabled: function(elem){
+			return elem.disabled === true;
+		},
+		checked: function(elem){
+			return elem.checked === true;
+		},
+		selected: function(elem){
+			// Accessing this property makes selected-by-default
+			// options in Safari work properly
+			elem.parentNode.selectedIndex;
+			return elem.selected === true;
+		},
+		parent: function(elem){
+			return !!elem.firstChild;
+		},
+		empty: function(elem){
+			return !elem.firstChild;
+		},
+		has: function(elem, i, match){
+			return !!Sizzle( match[3], elem ).length;
+		},
+		header: function(elem){
+			return /h\d/i.test( elem.nodeName );
+		},
+		text: function(elem){
+			return "text" === elem.type;
+		},
+		radio: function(elem){
+			return "radio" === elem.type;
+		},
+		checkbox: function(elem){
+			return "checkbox" === elem.type;
+		},
+		file: function(elem){
+			return "file" === elem.type;
+		},
+		password: function(elem){
+			return "password" === elem.type;
+		},
+		submit: function(elem){
+			return "submit" === elem.type;
+		},
+		image: function(elem){
+			return "image" === elem.type;
+		},
+		reset: function(elem){
+			return "reset" === elem.type;
+		},
+		button: function(elem){
+			return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
+		},
+		input: function(elem){
+			return /input|select|textarea|button/i.test(elem.nodeName);
+		}
+	},
+	setFilters: {
+		first: function(elem, i){
+			return i === 0;
+		},
+		last: function(elem, i, match, array){
+			return i === array.length - 1;
+		},
+		even: function(elem, i){
+			return i % 2 === 0;
+		},
+		odd: function(elem, i){
+			return i % 2 === 1;
+		},
+		lt: function(elem, i, match){
+			return i < match[3] - 0;
+		},
+		gt: function(elem, i, match){
+			return i > match[3] - 0;
+		},
+		nth: function(elem, i, match){
+			return match[3] - 0 === i;
+		},
+		eq: function(elem, i, match){
+			return match[3] - 0 === i;
+		}
+	},
+	filter: {
+		PSEUDO: function(elem, match, i, array){
+			var name = match[1], filter = Expr.filters[ name ];
+
+			if ( filter ) {
+				return filter( elem, i, match, array );
+			} else if ( name === "contains" ) {
+				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;
+			} else if ( name === "not" ) {
+				var not = match[3];
+
+				for ( var i = 0, l = not.length; i < l; i++ ) {
+					if ( not[i] === elem ) {
+						return false;
+					}
+				}
+
+				return true;
+			} else {
+				Sizzle.error( "Syntax error, unrecognized expression: " + name );
+			}
+		},
+		CHILD: function(elem, match){
+			var type = match[1], node = elem;
+			switch (type) {
+				case 'only':
+				case 'first':
+					while ( (node = node.previousSibling) )	 {
+						if ( node.nodeType === 1 ) { 
+							return false; 
+						}
+					}
+					if ( type === "first" ) { 
+						return true; 
+					}
+					node = elem;
+				case 'last':
+					while ( (node = node.nextSibling) )	 {
+						if ( node.nodeType === 1 ) { 
+							return false; 
+						}
+					}
+					return true;
+				case 'nth':
+					var first = match[2], last = match[3];
+
+					if ( first === 1 && last === 0 ) {
+						return true;
+					}
+					
+					var doneName = match[0],
+						parent = elem.parentNode;
+	
+					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
+						var count = 0;
+						for ( node = parent.firstChild; node; node = node.nextSibling ) {
+							if ( node.nodeType === 1 ) {
+								node.nodeIndex = ++count;
+							}
+						} 
+						parent.sizcache = doneName;
+					}
+					
+					var diff = elem.nodeIndex - last;
+					if ( first === 0 ) {
+						return diff === 0;
+					} else {
+						return ( diff % first === 0 && diff / first >= 0 );
+					}
+			}
+		},
+		ID: function(elem, match){
+			return elem.nodeType === 1 && elem.getAttribute("id") === match;
+		},
+		TAG: function(elem, match){
+			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
+		},
+		CLASS: function(elem, match){
+			return (" " + (elem.className || elem.getAttribute("class")) + " ")
+				.indexOf( match ) > -1;
+		},
+		ATTR: function(elem, match){
+			var name = match[1],
+				result = Expr.attrHandle[ name ] ?
+					Expr.attrHandle[ name ]( elem ) :
+					elem[ name ] != null ?
+						elem[ name ] :
+						elem.getAttribute( name ),
+				value = result + "",
+				type = match[2],
+				check = match[4];
+
+			return result == null ?
+				type === "!=" :
+				type === "=" ?
+				value === check :
+				type === "*=" ?
+				value.indexOf(check) >= 0 :
+				type === "~=" ?
+				(" " + value + " ").indexOf(check) >= 0 :
+				!check ?
+				value && result !== false :
+				type === "!=" ?
+				value !== check :
+				type === "^=" ?
+				value.indexOf(check) === 0 :
+				type === "$=" ?
+				value.substr(value.length - check.length) === check :
+				type === "|=" ?
+				value === check || value.substr(0, check.length + 1) === check + "-" :
+				false;
+		},
+		POS: function(elem, match, i, array){
+			var name = match[2], filter = Expr.setFilters[ name ];
+
+			if ( filter ) {
+				return filter( elem, i, match, array );
+			}
+		}
+	}
+};
+
+var origPOS = Expr.match.POS;
+
+for ( var type in Expr.match ) {
+	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\[]*\])(?![^\(]*\))/.source );
+	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, function(all, num){
+		return "\\" + (num - 0 + 1);
+	}));
+}
+
+var makeArray = function(array, results) {
+	array = Array.prototype.slice.call( array, 0 );
+
+	if ( results ) {
+		results.push.apply( results, array );
+		return results;
+	}
+	
+	return array;
+};
+
+// Perform a simple check to determine if the browser is capable of
+// converting a NodeList to an array using builtin methods.
+// Also verifies that the returned array holds DOM nodes
+// (which is not the case in the Blackberry browser)
+try {
+	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
+
+// Provide a fallback method if it does not work
+} catch(e){
+	makeArray = function(array, results) {
+		var ret = results || [];
+
+		if ( toString.call(array) === "[object Array]" ) {
+			Array.prototype.push.apply( ret, array );
+		} else {
+			if ( typeof array.length === "number" ) {
+				for ( var i = 0, l = array.length; i < l; i++ ) {
+					ret.push( array[i] );
+				}
+			} else {
+				for ( var i = 0; array[i]; i++ ) {
+					ret.push( array[i] );
+				}
+			}
+		}
+
+		return ret;
+	};
+}
+
+var sortOrder;
+
+if ( document.documentElement.compareDocumentPosition ) {
+	sortOrder = function( a, b ) {
+		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
+			if ( a == b ) {
+				hasDuplicate = true;
+			}
+			return a.compareDocumentPosition ? -1 : 1;
+		}
+
+		var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
+		if ( ret === 0 ) {
+			hasDuplicate = true;
+		}
+		return ret;
+	};
+} else if ( "sourceIndex" in document.documentElement ) {
+	sortOrder = function( a, b ) {
+		if ( !a.sourceIndex || !b.sourceIndex ) {
+			if ( a == b ) {
+				hasDuplicate = true;
+			}
+			return a.sourceIndex ? -1 : 1;
+		}
+
+		var ret = a.sourceIndex - b.sourceIndex;
+		if ( ret === 0 ) {
+			hasDuplicate = true;
+		}
+		return ret;
+	};
+} else if ( document.createRange ) {
+	sortOrder = function( a, b ) {
+		if ( !a.ownerDocument || !b.ownerDocument ) {
+			if ( a == b ) {
+				hasDuplicate = true;
+			}
+			return a.ownerDocument ? -1 : 1;
+		}
+
+		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
+		aRange.setStart(a, 0);
+		aRange.setEnd(a, 0);
+		bRange.setStart(b, 0);
+		bRange.setEnd(b, 0);
+		var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
+		if ( ret === 0 ) {
+			hasDuplicate = true;
+		}
+		return ret;
+	};
+}
+
+// Utility function for retreiving the text value of an array of DOM nodes
+function getText( elems ) {
+	var ret = "", elem;
+
+	for ( var i = 0; elems[i]; i++ ) {
+		elem = elems[i];
+
+		// Get the text from text nodes and CDATA nodes
+		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
+			ret += elem.nodeValue;
+
+		// Traverse everything else, except comment nodes
+		} else if ( elem.nodeType !== 8 ) {
+			ret += getText( elem.childNodes );
+		}
+	}
+
+	return ret;
+}
+
+// Check to see if the browser returns elements by name when
+// querying by getElementById (and provide a workaround)
+(function(){
+	// We're going to inject a fake input element with a specified name
+	var form = document.createElement("div"),
+		id = "script" + (new Date).getTime();
+	form.innerHTML = "<a name='" + id + "'/>";
+
+	// Inject it into the root element, check its status, and remove it quickly
+	var root = document.documentElement;
+	root.insertBefore( form, root.firstChild );
+
+	// The workaround has to do additional checks after a getElementById
+	// Which slows things down for other browsers (hence the branching)
+	if ( document.getElementById( id ) ) {
+		Expr.find.ID = function(match, context, isXML){
+			if ( typeof context.getElementById !== "undefined" && !isXML ) {
+				var m = context.getElementById(match[1]);
+				return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
+			}
+		};
+
+		Expr.filter.ID = function(elem, match){
+			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
+			return elem.nodeType === 1 && node && node.nodeValue === match;
+		};
+	}
+
+	root.removeChild( form );
+	root = form = null; // release memory in IE
+})();
+
+(function(){
+	// Check to see if the browser returns only elements
+	// when doing getElementsByTagName("*")
+
+	// Create a fake element
+	var div = document.createElement("div");
+	div.appendChild( document.createComment("") );
+
+	// Make sure no comments are found
+	if ( div.getElementsByTagName("*").length > 0 ) {
+		Expr.find.TAG = function(match, context){
+			var results = context.getElementsByTagName(match[1]);
+
+			// Filter out possible comments
+			if ( match[1] === "*" ) {
+				var tmp = [];
+
+				for ( var i = 0; results[i]; i++ ) {
+					if ( results[i].nodeType === 1 ) {
+						tmp.push( results[i] );
+					}
+				}
+
+				results = tmp;
+			}
+
+			return results;
+		};
+	}
+
+	// Check to see if an attribute returns normalized href attributes
+	div.innerHTML = "<a href='#'></a>";
+	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
+			div.firstChild.getAttribute("href") !== "#" ) {
+		Expr.attrHandle.href = function(elem){
+			return elem.getAttribute("href", 2);
+		};
+	}
+
+	div = null; // release memory in IE
+})();
+
+if ( document.querySelectorAll ) {
+	(function(){
+		var oldSizzle = Sizzle, div = document.createElement("div");
+		div.innerHTML = "<p class='TEST'></p>";
+
+		// Safari can't handle uppercase or unicode characters when
+		// in quirks mode.
+		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
+			return;
+		}
+	
+		Sizzle = function(query, context, extra, seed){
+			context = context || document;
+
+			// Only use querySelectorAll on non-XML documents
+			// (ID selectors don't work in non-HTML documents)
+			if ( !seed && context.nodeType === 9 && !isXML(context) ) {
+				try {
+					return makeArray( context.querySelectorAll(query), extra );
+				} catch(e){}
+			}
+		
+			return oldSizzle(query, context, extra, seed);
+		};
+
+		for ( var prop in oldSizzle ) {
+			Sizzle[ prop ] = oldSizzle[ prop ];
+		}
+
+		div = null; // release memory in IE
+	})();
+}
+
+(function(){
+	var div = document.createElement("div");
+
+	div.innerHTML = "<div class='test e'></div><div class='test'></div>";
+
+	// Opera can't find a second classname (in 9.6)
+	// Also, make sure that getElementsByClassName actually exists
+	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
+		return;
+	}
+
+	// Safari caches class attributes, doesn't catch changes (in 3.2)
+	div.lastChild.className = "e";
+
+	if ( div.getElementsByClassName("e").length === 1 ) {
+		return;
+	}
+	
+	Expr.order.splice(1, 0, "CLASS");
+	Expr.find.CLASS = function(match, context, isXML) {
+		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
+			return context.getElementsByClassName(match[1]);
+		}
+	};
+
+	div = null; // release memory in IE
+})();
+
+function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
+	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+		var elem = checkSet[i];
+		if ( elem ) {
+			elem = elem[dir];
+			var match = false;
+
+			while ( elem ) {
+				if ( elem.sizcache === doneName ) {
+					match = checkSet[elem.sizset];
+					break;
+				}
+
+				if ( elem.nodeType === 1 && !isXML ){
+					elem.sizcache = doneName;
+					elem.sizset = i;
+				}
+
+				if ( elem.nodeName.toLowerCase() === cur ) {
+					match = elem;
+					break;
+				}
+
+				elem = elem[dir];
+			}
+
+			checkSet[i] = match;
+		}
+	}
+}
+
+function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
+	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
+		var elem = checkSet[i];
+		if ( elem ) {
+			elem = elem[dir];
+			var match = false;
+
+			while ( elem ) {
+				if ( elem.sizcache === doneName ) {
+					match = checkSet[elem.sizset];
+					break;
+				}
+
+				if ( elem.nodeType === 1 ) {
+					if ( !isXML ) {
+						elem.sizcache = doneName;
+						elem.sizset = i;
+					}
+					if ( typeof cur !== "string" ) {
+						if ( elem === cur ) {
+							match = true;
+							break;
+						}
+
+					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
+						match = elem;
+						break;
+					}
+				}
+
+				elem = elem[dir];
+			}
+
+			checkSet[i] = match;
+		}
+	}
+}
+
+var contains = document.compareDocumentPosition ? function(a, b){
+	return !!(a.compareDocumentPosition(b) & 16);
+} : function(a, b){
+	return a !== b && (a.contains ? a.contains(b) : true);
+};
+
+var isXML = function(elem){
+	// documentElement is verified for cases where it doesn't yet exist
+	// (such as loading iframes in IE - #4833) 
+	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
+	return documentElement ? documentElement.nodeName !== "HTML" : false;
+};
+
+var posProcess = function(selector, context){
+	var tmpSet = [], later = "", match,
+		root = context.nodeType ? [context] : context;
+
+	// Position selectors must be done after the filter
+	// And so must :not(positional) so we move all PSEUDOs to the end
+	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
+		later += match[0];
+		selector = selector.replace( Expr.match.PSEUDO, "" );
+	}
+
+	selector = Expr.relative[selector] ? selector + "*" : selector;
+
+	for ( var i = 0, l = root.length; i < l; i++ ) {
+		Sizzle( selector, root[i], tmpSet );
+	}
+
+	return Sizzle.filter( later, tmpSet );
+};
+
+// EXPOSE
+jQuery.find = Sizzle;
+jQuery.expr = Sizzle.selectors;
+jQuery.expr[":"] = jQuery.expr.filters;
+jQuery.unique = Sizzle.uniqueSort;
+jQuery.text = getText;
+jQuery.isXMLDoc = isXML;
+jQuery.contains = contains;
+
+return;
+
+window.Sizzle = Sizzle;
+
+})();
+var runtil = /Until$/,
+	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
+	// Note: This RegExp should be improved, or likely pulled from Sizzle
+	rmultiselector = /,/,
+	slice = Array.prototype.slice;
+
+// Implement the identical functionality for filter and not
+var winnow = function( elements, qualifier, keep ) {
+	if ( jQuery.isFunction( qualifier ) ) {
+		return jQuery.grep(elements, function( elem, i ) {
+			return !!qualifier.call( elem, i, elem ) === keep;
+		});
+
+	} else if ( qualifier.nodeType ) {
+		return jQuery.grep(elements, function( elem, i ) {
+			return (elem === qualifier) === keep;
+		});
+
+	} else if ( typeof qualifier === "string" ) {
+		var filtered = jQuery.grep(elements, function( elem ) {
+			return elem.nodeType === 1;
+		});
+
+		if ( isSimple.test( qualifier ) ) {
+			return jQuery.filter(qualifier, filtered, !keep);
+		} else {
+			qualifier = jQuery.filter( qualifier, filtered );
+		}
+	}
+
+	return jQuery.grep(elements, function( elem, i ) {
+		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
+	});
+};
+
+jQuery.fn.extend({
+	find: function( selector ) {
+		var ret = this.pushStack( "", "find", selector ), length = 0;
+
+		for ( var i = 0, l = this.length; i < l; i++ ) {
+			length = ret.length;
+			jQuery.find( selector, this[i], ret );
+
+			if ( i > 0 ) {
+				// Make sure that the results are unique
+				for ( var n = length; n < ret.length; n++ ) {
+					for ( var r = 0; r < length; r++ ) {
+						if ( ret[r] === ret[n] ) {
+							ret.splice(n--, 1);
+							break;
+						}
+					}
+				}
+			}
+		}
+
+		return ret;
+	},
+
+	has: function( target ) {
+		var targets = jQuery( target );
+		return this.filter(function() {
+			for ( var i = 0, l = targets.length; i < l; i++ ) {
+				if ( jQuery.contains( this, targets[i] ) ) {
+					return true;
+				}
+			}
+		});
+	},
+
+	not: function( selector ) {
+		return this.pushStack( winnow(this, selector, false), "not", selector);
+	},
+
+	filter: function( selector ) {
+		return this.pushStack( winnow(this, selector, true), "filter", selector );
+	},
+	
+	is: function( selector ) {
+		return !!selector && jQuery.filter( selector, this ).length > 0;
+	},
+
+	closest: function( selectors, context ) {
+		if ( jQuery.isArray( selectors ) ) {
+			var ret = [], cur = this[0], match, matches = {}, selector;
+
+			if ( cur && selectors.length ) {
+				for ( var i = 0, l = selectors.length; i < l; i++ ) {
+					selector = selectors[i];
+
+					if ( !matches[selector] ) {
+						matches[selector] = jQuery.expr.match.POS.test( selector ) ? 
+							jQuery( selector, context || this.context ) :
+							selector;
+					}
+				}
+
+				while ( cur && cur.ownerDocument && cur !== context ) {
+					for ( selector in matches ) {
+						match = matches[selector];
+
+						if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) {
+							ret.push({ selector: selector, elem: cur });
+							delete matches[selector];
+						}
+					}
+					cur = cur.parentNode;
+				}
+			}
+
+			return ret;
+		}
+
+		var pos = jQuery.expr.match.POS.test( selectors ) ? 
+			jQuery( selectors, context || this.context ) : null;
+
+		return this.map(function( i, cur ) {
+			while ( cur && cur.ownerDocument && cur !== context ) {
+				if ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selectors) ) {
+					return cur;
+				}
+				cur = cur.parentNode;
+			}
+			return null;
+		});
+	},
+	
+	// Determine the position of an element within
+	// the matched set of elements
+	index: function( elem ) {
+		if ( !elem || typeof elem === "string" ) {
+			return jQuery.inArray( this[0],
+				// If it receives a string, the selector is used
+				// If it receives nothing, the siblings are used
+				elem ? jQuery( elem ) : this.parent().children() );
+		}
+		// Locate the position of the desired element
+		return jQuery.inArray(
+			// If it receives a jQuery object, the first element is used
+			elem.jquery ? elem[0] : elem, this );
+	},
+
+	add: function( selector, context ) {
+		var set = typeof selector === "string" ?
+				jQuery( selector, context || this.context ) :
+				jQuery.makeArray( selector ),
+			all = jQuery.merge( this.get(), set );
+
+		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
+			all :
+			jQuery.unique( all ) );
+	},
+
+	andSelf: function() {
+		return this.add( this.prevObject );
+	}
+});
+
+// A painfully simple check to see if an element is disconnected
+// from a document (should be improved, where feasible).
+function isDisconnected( node ) {
+	return !node || !node.parentNode || node.parentNode.nodeType === 11;
+}
+
+jQuery.each({
+	parent: function( elem ) {
+		var parent = elem.parentNode;
+		return parent && parent.nodeType !== 11 ? parent : null;
+	},
+	parents: function( elem ) {
+		return jQuery.dir( elem, "parentNode" );
+	},
+	parentsUntil: function( elem, i, until ) {
+		return jQuery.dir( elem, "parentNode", until );
+	},
+	next: function( elem ) {
+		return jQuery.nth( elem, 2, "nextSibling" );
+	},
+	prev: function( elem ) {
+		return jQuery.nth( elem, 2, "previousSibling" );
+	},
+	nextAll: function( elem ) {
+		return jQuery.dir( elem, "nextSibling" );
+	},
+	prevAll: function( elem ) {
+		return jQuery.dir( elem, "previousSibling" );
+	},
+	nextUntil: function( elem, i, until ) {
+		return jQuery.dir( elem, "nextSibling", until );
+	},
+	prevUntil: function( elem, i, until ) {
+		return jQuery.dir( elem, "previousSibling", until );
+	},
+	siblings: function( elem ) {
+		return jQuery.sibling( elem.parentNode.firstChild, elem );
+	},
+	children: function( elem ) {
+		return jQuery.sibling( elem.firstChild );
+	},
+	contents: function( elem ) {
+		return jQuery.nodeName( elem, "iframe" ) ?
+			elem.contentDocument || elem.contentWindow.document :
+			jQuery.makeArray( elem.childNodes );
+	}
+}, function( name, fn ) {
+	jQuery.fn[ name ] = function( until, selector ) {
+		var ret = jQuery.map( this, fn, until );
+		
+		if ( !runtil.test( name ) ) {
+			selector = until;
+		}
+
+		if ( selector && typeof selector === "string" ) {
+			ret = jQuery.filter( selector, ret );
+		}
+
+		ret = this.length > 1 ? jQuery.unique( ret ) : ret;
+
+		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
+			ret = ret.reverse();
+		}
+
+		return this.pushStack( ret, name, slice.call(arguments).join(",") );
+	};
+});
+
+jQuery.extend({
+	filter: function( expr, elems, not ) {
+		if ( not ) {
+			expr = ":not(" + expr + ")";
+		}
+
+		return jQuery.find.matches(expr, elems);
+	},
+	
+	dir: function( elem, dir, until ) {
+		var matched = [], cur = elem[dir];
+		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
+			if ( cur.nodeType === 1 ) {
+				matched.push( cur );
+			}
+			cur = cur[dir];
+		}
+		return matched;
+	},
+
+	nth: function( cur, result, dir, elem ) {
+		result = result || 1;
+		var num = 0;
+
+		for ( ; cur; cur = cur[dir] ) {
+			if ( cur.nodeType === 1 && ++num === result ) {
+				break;
+			}
+		}
+
+		return cur;
+	},
+
+	sibling: function( n, elem ) {
+		var r = [];
+
+		for ( ; n; n = n.nextSibling ) {
+			if ( n.nodeType === 1 && n !== elem ) {
+				r.push( n );
+			}
+		}
+
+		return r;
+	}
+});
+var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
+	rleadingWhitespace = /^\s+/,
+	rxhtmlTag = /(<([\w:]+)[^>]*?)\/>/g,
+	rselfClosing = /^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,
+	rtagName = /<([\w:]+)/,
+	rtbody = /<tbody/i,
+	rhtml = /<|&#?\w+;/,
+	rnocache = /<script|<object|<embed|<option|<style/i,
+	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,  // checked="checked" or checked (html5)
+	fcloseTag = function( all, front, tag ) {
+		return rselfClosing.test( tag ) ?
+			all :
+			front + "></" + tag + ">";
+	},
+	wrapMap = {
+		option: [ 1, "<select multiple='multiple'>", "</select>" ],
+		legend: [ 1, "<fieldset>", "</fieldset>" ],
+		thead: [ 1, "<table>", "</table>" ],
+		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
+		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
+		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
+		area: [ 1, "<map>", "</map>" ],
+		_default: [ 0, "", "" ]
+	};
+
+wrapMap.optgroup = wrapMap.option;
+wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
+wrapMap.th = wrapMap.td;
+
+// IE can't serialize <link> and <script> tags normally
+if ( !jQuery.support.htmlSerialize ) {
+	wrapMap._default = [ 1, "div<div>", "</div>" ];
+}
+
+jQuery.fn.extend({
+	text: function( text ) {
+		if ( jQuery.isFunction(text) ) {
+			return this.each(function(i) {
+				var self = jQuery(this);
+				self.text( text.call(this, i, self.text()) );
+			});
+		}
+
+		if ( typeof text !== "object" && text !== undefined ) {
+			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
+		}
+
+		return jQuery.text( this );
+	},
+
+	wrapAll: function( html ) {
+		if ( jQuery.isFunction( html ) ) {
+			return this.each(function(i) {
+				jQuery(this).wrapAll( html.call(this, i) );
+			});
+		}
+
+		if ( this[0] ) {
+			// The elements to wrap the target around
+			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
+
+			if ( this[0].parentNode ) {
+				wrap.insertBefore( this[0] );
+			}
+
+			wrap.map(function() {
+				var elem = this;
+
+				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
+					elem = elem.firstChild;
+				}
+
+				return elem;
+			}).append(this);
+		}
+
+		return this;
+	},
+
+	wrapInner: function( html ) {
+		if ( jQuery.isFunction( html ) ) {
+			return this.each(function(i) {
+				jQuery(this).wrapInner( html.call(this, i) );
+			});
+		}
+
+		return this.each(function() {
+			var self = jQuery( this ), contents = self.contents();
+
+			if ( contents.length ) {
+				contents.wrapAll( html );
+
+			} else {
+				self.append( html );
+			}
+		});
+	},
+
+	wrap: function( html ) {
+		return this.each(function() {
+			jQuery( this ).wrapAll( html );
+		});
+	},
+
+	unwrap: function() {
+		return this.parent().each(function() {
+			if ( !jQuery.nodeName( this, "body" ) ) {
+				jQuery( this ).replaceWith( this.childNodes );
+			}
+		}).end();
+	},
+
+	append: function() {
+		return this.domManip(arguments, true, function( elem ) {
+			if ( this.nodeType === 1 ) {
+				this.appendChild( elem );
+			}
+		});
+	},
+
+	prepend: function() {
+		return this.domManip(arguments, true, function( elem ) {
+			if ( this.nodeType === 1 ) {
+				this.insertBefore( elem, this.firstChild );
+			}
+		});
+	},
+
+	before: function() {
+		if ( this[0] && this[0].parentNode ) {
+			return this.domManip(arguments, false, function( elem ) {
+				this.parentNode.insertBefore( elem, this );
+			});
+		} else if ( arguments.length ) {
+			var set = jQuery(arguments[0]);
+			set.push.apply( set, this.toArray() );
+			return this.pushStack( set, "before", arguments );
+		}
+	},
+
+	after: function() {
+		if ( this[0] && this[0].parentNode ) {
+			return this.domManip(arguments, false, function( elem ) {
+				this.parentNode.insertBefore( elem, this.nextSibling );
+			});
+		} else if ( arguments.length ) {
+			var set = this.pushStack( this, "after", arguments );
+			set.push.apply( set, jQuery(arguments[0]).toArray() );
+			return set;
+		}
+	},
+	
+	// keepData is for internal use only--do not document
+	remove: function( selector, keepData ) {
+		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
+			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
+				if ( !keepData && elem.nodeType === 1 ) {
+					jQuery.cleanData( elem.getElementsByTagName("*") );
+					jQuery.cleanData( [ elem ] );
+				}
+
+				if ( elem.parentNode ) {
+					 elem.parentNode.removeChild( elem );
+				}
+			}
+		}
+		
+		return this;
+	},
+
+	empty: function() {
+		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
+			// Remove element nodes and prevent memory leaks
+			if ( elem.nodeType === 1 ) {
+				jQuery.cleanData( elem.getElementsByTagName("*") );
+			}
+
+			// Remove any remaining nodes
+			while ( elem.firstChild ) {
+				elem.removeChild( elem.firstChild );
+			}
+		}
+		
+		return this;
+	},
+
+	clone: function( events ) {
+		// Do the clone
+		var ret = this.map(function() {
+			if ( !jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this) ) {
+				// IE copies events bound via attachEvent when
+				// using cloneNode. Calling detachEvent on the
+				// clone will also remove the events from the orignal
+				// In order to get around this, we use innerHTML.
+				// Unfortunately, this means some modifications to
+				// attributes in IE that are actually only stored
+				// as properties will not be copied (such as the
+				// the name attribute on an input).
+				var html = this.outerHTML, ownerDocument = this.ownerDocument;
+				if ( !html ) {
+					var div = ownerDocument.createElement("div");
+					div.appendChild( this.cloneNode(true) );
+					html = div.innerHTML;
+				}
+
+				return jQuery.clean([html.replace(rinlinejQuery, "")
+					// Handle the case in IE 8 where action=/test/> self-closes a tag
+					.replace(/=([^="'>\s]+\/)>/g, '="$1">')
+					.replace(rleadingWhitespace, "")], ownerDocument)[0];
+			} else {
+				return this.cloneNode(true);
+			}
+		});
+
+		// Copy the events from the original to the clone
+		if ( events === true ) {
+			cloneCopyEvent( this, ret );
+			cloneCopyEvent( this.find("*"), ret.find("*") );
+		}
+
+		// Return the cloned set
+		return ret;
+	},
+
+	html: function( value ) {
+		if ( value === undefined ) {
+			return this[0] && this[0].nodeType === 1 ?
+				this[0].innerHTML.replace(rinlinejQuery, "") :
+				null;
+
+		// See if we can take a shortcut and just use innerHTML
+		} else if ( typeof value === "string" && !rnocache.test( value ) &&
+			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
+			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {
+
+			value = value.replace(rxhtmlTag, fcloseTag);
+
+			try {
+				for ( var i = 0, l = this.length; i < l; i++ ) {
+					// Remove element nodes and prevent memory leaks
+					if ( this[i].nodeType === 1 ) {
+						jQuery.cleanData( this[i].getElementsByTagName("*") );
+						this[i].innerHTML = value;
+					}
+				}
+
+			// If using innerHTML throws an exception, use the fallback method
+			} catch(e) {
+				this.empty().append( value );
+			}
+
+		} else if ( jQuery.isFunction( value ) ) {
+			this.each(function(i){
+				var self = jQuery(this), old = self.html();
+				self.empty().append(function(){
+					return value.call( this, i, old );
+				});
+			});
+
+		} else {
+			this.empty().append( value );
+		}
+
+		return this;
+	},
+
+	replaceWith: function( value ) {
+		if ( this[0] && this[0].parentNode ) {
+			// Make sure that the elements are removed from the DOM before they are inserted
+			// this can help fix replacing a parent with child elements
+			if ( jQuery.isFunction( value ) ) {
+				return this.each(function(i) {
+					var self = jQuery(this), old = self.html();
+					self.replaceWith( value.call( this, i, old ) );
+				});
+			}
+
+			if ( typeof value !== "string" ) {
+				value = jQuery(value).detach();
+			}
+
+			return this.each(function() {
+				var next = this.nextSibling, parent = this.parentNode;
+
+				jQuery(this).remove();
+
+				if ( next ) {
+					jQuery(next).before( value );
+				} else {
+					jQuery(parent).append( value );
+				}
+			});
+		} else {
+			return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value );
+		}
+	},
+
+	detach: function( selector ) {
+		return this.remove( selector, true );
+	},
+
+	domManip: function( args, table, callback ) {
+		var results, first, value = args[0], scripts = [], fragment, parent;
+
+		// We can't cloneNode fragments that contain checked, in WebKit
+		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
+			return this.each(function() {
+				jQuery(this).domManip( args, table, callback, true );
+			});
+		}
+
+		if ( jQuery.isFunction(value) ) {
+			return this.each(function(i) {
+				var self = jQuery(this);
+				args[0] = value.call(this, i, table ? self.html() : undefined);
+				self.domManip( args, table, callback );
+			});
+		}
+
+		if ( this[0] ) {
+			parent = value && value.parentNode;
+
+			// If we're in a fragment, just use that instead of building a new one
+			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
+				results = { fragment: parent };
+
+			} else {
+				results = buildFragment( args, this, scripts );
+			}
+			
+			fragment = results.fragment;
+			
+			if ( fragment.childNodes.length === 1 ) {
+				first = fragment = fragment.firstChild;
+			} else {
+				first = fragment.firstChild;
+			}
+
+			if ( first ) {
+				table = table && jQuery.nodeName( first, "tr" );
+
+				for ( var i = 0, l = this.length; i < l; i++ ) {
+					callback.call(
+						table ?
+							root(this[i], first) :
+							this[i],
+						i > 0 || results.cacheable || this.length > 1  ?
+							fragment.cloneNode(true) :
+							fragment
+					);
+				}
+			}
+
+			if ( scripts.length ) {
+				jQuery.each( scripts, evalScript );
+			}
+		}
+
+		return this;
+
+		function root( elem, cur ) {
+			return jQuery.nodeName(elem, "table") ?
+				(elem.getElementsByTagName("tbody")[0] ||
+				elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
+				elem;
+		}
+	}
+});
+
+function cloneCopyEvent(orig, ret) {
+	var i = 0;
+
+	ret.each(function() {
+		if ( this.nodeName !== (orig[i] && orig[i].nodeName) ) {
+			return;
+		}
+
+		var oldData = jQuery.data( orig[i++] ), curData = jQuery.data( this, oldData ), events = oldData && oldData.events;
+
+		if ( events ) {
+			delete curData.handle;
+			curData.events = {};
+
+			for ( var type in events ) {
+				for ( var handler in events[ type ] ) {
+					jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data );
+				}
+			}
+		}
+	});
+}
+
+function buildFragment( args, nodes, scripts ) {
+	var fragment, cacheable, cacheresults,
+		doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);
+
+	// Only cache "small" (1/2 KB) strings that are associated with the main document
+	// Cloning options loses the selected state, so don't cache them
+	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
+	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
+	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
+		!rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {
+
+		cacheable = true;
+		cacheresults = jQuery.fragments[ args[0] ];
+		if ( cacheresults ) {
+			if ( cacheresults !== 1 ) {
+				fragment = cacheresults;
+			}
+		}
+	}
+
+	if ( !fragment ) {
+		fragment = doc.createDocumentFragment();
+		jQuery.clean( args, doc, fragment, scripts );
+	}
+
+	if ( cacheable ) {
+		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
+	}
+
+	return { fragment: fragment, cacheable: cacheable };
+}
+
+jQuery.fragments = {};
+
+jQuery.each({
+	appendTo: "append",
+	prependTo: "prepend",
+	insertBefore: "before",
+	insertAfter: "after",
+	replaceAll: "replaceWith"
+}, function( name, original ) {
+	jQuery.fn[ name ] = function( selector ) {
+		var ret = [], insert = jQuery( selector ),
+			parent = this.length === 1 && this[0].parentNode;
+		
+		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
+			insert[ original ]( this[0] );
+			return this;
+			
+		} else {
+			for ( var i = 0, l = insert.length; i < l; i++ ) {
+				var elems = (i > 0 ? this.clone(true) : this).get();
+				jQuery.fn[ original ].apply( jQuery(insert[i]), elems );
+				ret = ret.concat( elems );
+			}
+		
+			return this.pushStack( ret, name, insert.selector );
+		}
+	};
+});
+
+jQuery.extend({
+	clean: function( elems, context, fragment, scripts ) {
+		context = context || document;
+
+		// !context.createElement fails in IE with an error but returns typeof 'object'
+		if ( typeof context.createElement === "undefined" ) {
+			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
+		}
+
+		var ret = [];
+
+		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+			if ( typeof elem === "number" ) {
+				elem += "";
+			}
+
+			if ( !elem ) {
+				continue;
+			}
+
+			// Convert html string into DOM nodes
+			if ( typeof elem === "string" && !rhtml.test( elem ) ) {
+				elem = context.createTextNode( elem );
+
+			} else if ( typeof elem === "string" ) {
+				// Fix "XHTML"-style tags in all browsers
+				elem = elem.replace(rxhtmlTag, fcloseTag);
+
+				// Trim whitespace, otherwise indexOf won't work as expected
+				var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
+					wrap = wrapMap[ tag ] || wrapMap._default,
+					depth = wrap[0],
+					div = context.createElement("div");
+
+				// Go to html and back, then peel off extra wrappers
+				div.innerHTML = wrap[1] + elem + wrap[2];
+
+				// Move to the right depth
+				while ( depth-- ) {
+					div = div.lastChild;
+				}
+
+				// Remove IE's autoinserted <tbody> from table fragments
+				if ( !jQuery.support.tbody ) {
+
+					// String was a <table>, *may* have spurious <tbody>
+					var hasBody = rtbody.test(elem),
+						tbody = tag === "table" && !hasBody ?
+							div.firstChild && div.firstChild.childNodes :
+
+							// String was a bare <thead> or <tfoot>
+							wrap[1] === "<table>" && !hasBody ?
+								div.childNodes :
+								[];
+
+					for ( var j = tbody.length - 1; j >= 0 ; --j ) {
+						if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
+							tbody[ j ].parentNode.removeChild( tbody[ j ] );
+						}
+					}
+
+				}
+
+				// IE completely kills leading whitespace when innerHTML is used
+				if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
+					div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
+				}
+
+				elem = div.childNodes;
+			}
+
+			if ( elem.nodeType ) {
+				ret.push( elem );
+			} else {
+				ret = jQuery.merge( ret, elem );
+			}
+		}
+
+		if ( fragment ) {
+			for ( var i = 0; ret[i]; i++ ) {
+				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
+					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
+				
+				} else {
+					if ( ret[i].nodeType === 1 ) {
+						ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) );
+					}
+					fragment.appendChild( ret[i] );
+				}
+			}
+		}
+
+		return ret;
+	},
+	
+	cleanData: function( elems ) {
+		var data, id, cache = jQuery.cache,
+			special = jQuery.event.special,
+			deleteExpando = jQuery.support.deleteExpando;
+		
+		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
+			id = elem[ jQuery.expando ];
+			
+			if ( id ) {
+				data = cache[ id ];
+				
+				if ( data.events ) {
+					for ( var type in data.events ) {
+						if ( special[ type ] ) {
+							jQuery.event.remove( elem, type );
+
+						} else {
+							removeEvent( elem, type, data.handle );
+						}
+					}
+				}
+				
+				if ( deleteExpando ) {
+					delete elem[ jQuery.expando ];
+
+				} else if ( elem.removeAttribute ) {
+					elem.removeAttribute( jQuery.expando );
+				}
+				
+				delete cache[ id ];
+			}
+		}
+	}
+});
+// exclude the following css properties to add px
+var rexclude = /z-?index|font-?weight|opacity|zoom|line-?height/i,
+	ralpha = /alpha\([^)]*\)/,
+	ropacity = /opacity=([^)]*)/,
+	rfloat = /float/i,
+	rdashAlpha = /-([a-z])/ig,
+	rupper = /([A-Z])/g,
+	rnumpx = /^-?\d+(?:px)?$/i,
+	rnum = /^-?\d/,
+
+	cssShow = { position: "absolute", visibility: "hidden", display:"block" },
+	cssWidth = [ "Left", "Right" ],
+	cssHeight = [ "Top", "Bottom" ],
+
+	// cache check for defaultView.getComputedStyle
+	getComputedStyle = document.defaultView && document.defaultView.getComputedStyle,
+	// normalize float css property
+	styleFloat = jQuery.support.cssFloat ? "cssFloat" : "styleFloat",
+	fcamelCase = function( all, letter ) {
+		return letter.toUpperCase();
+	};
+
+jQuery.fn.css = function( name, value ) {
+	return access( this, name, value, true, function( elem, name, value ) {
+		if ( value === undefined ) {
+			return jQuery.curCSS( elem, name );
+		}
+		
+		if ( typeof value === "number" && !rexclude.test(name) ) {
+			value += "px";
+		}
+
+		jQuery.style( elem, name, value );
+	});
+};
+
+jQuery.extend({
+	style: function( elem, name, value ) {
+		// don't set styles on text and comment nodes
+		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) {
+			return undefined;
+		}
+
+		// ignore negative width and height values #1599
+		if ( (name === "width" || name === "height") && parseFloat(value) < 0 ) {
+			value = undefined;
+		}
+
+		var style = elem.style || elem, set = value !== undefined;
+
+		// IE uses filters for opacity
+		if ( !jQuery.support.opacity && name === "opacity" ) {
+			if ( set ) {
+				// IE has trouble with opacity if it does not have layout
+				// Force it by setting the zoom level
+				style.zoom = 1;
+
+				// Set the alpha filter to set the opacity
+				var opacity = parseInt( value, 10 ) + "" === "NaN" ? "" : "alpha(opacity=" + value * 100 + ")";
+				var filter = style.filter || jQuery.curCSS( elem, "filter" ) || "";
+				style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : opacity;
+			}
+
+			return style.filter && style.filter.indexOf("opacity=") >= 0 ?
+				(parseFloat( ropacity.exec(style.filter)[1] ) / 100) + "":
+				"";
+		}
+
+		// Make sure we're using the right name for getting the float value
+		if ( rfloat.test( name ) ) {
+			name = styleFloat;
+		}
+
+		name = name.replace(rdashAlpha, fcamelCase);
+
+		if ( set ) {
+			style[ name ] = value;
+		}
+
+		return style[ name ];
+	},
+
+	css: function( elem, name, force, extra ) {
+		if ( name === "width" || name === "height" ) {
+			var val, props = cssShow, which = name === "width" ? cssWidth : cssHeight;
+
+			function getWH() {
+				val = name === "width" ? elem.offsetWidth : elem.offsetHeight;
+
+				if ( extra === "border" ) {
+					return;
+				}
+
+				jQuery.each( which, function() {
+					if ( !extra ) {
+						val -= parseFloat(jQuery.curCSS( elem, "padding" + this, true)) || 0;
+					}
+
+					if ( extra === "margin" ) {
+						val += parseFloat(jQuery.curCSS( elem, "margin" + this, true)) || 0;
+					} else {
+						val -= parseFloat(jQuery.curCSS( elem, "border" + this + "Width", true)) || 0;
+					}
+				});
+			}
+
+			if ( elem.offsetWidth !== 0 ) {
+				getWH();
+			} else {
+				jQuery.swap( elem, props, getWH );
+			}
+
+			return Math.max(0, Math.round(val));
+		}
+
+		return jQuery.curCSS( elem, name, force );
+	},
+
+	curCSS: function( elem, name, force ) {
+		var ret, style = elem.style, filter;
+
+		// IE uses filters for opacity
+		if ( !jQuery.support.opacity && name === "opacity" && elem.currentStyle ) {
+			ret = ropacity.test(elem.currentStyle.filter || "") ?
+				(parseFloat(RegExp.$1) / 100) + "" :
+				"";
+
+			return ret === "" ?
+				"1" :
+				ret;
+		}
+
+		// Make sure we're using the right name for getting the float value
+		if ( rfloat.test( name ) ) {
+			name = styleFloat;
+		}
+
+		if ( !force && style && style[ name ] ) {
+			ret = style[ name ];
+
+		} else if ( getComputedStyle ) {
+
+			// Only "float" is needed here
+			if ( rfloat.test( name ) ) {
+				name = "float";
+			}
+
+			name = name.replace( rupper, "-$1" ).toLowerCase();
+
+			var defaultView = elem.ownerDocument.defaultView;
+
+			if ( !defaultView ) {
+				return null;
+			}
+
+			var computedStyle = defaultView.getComputedStyle( elem, null );
+
+			if ( computedStyle ) {
+				ret = computedStyle.getPropertyValue( name );
+			}
+
+			// We should always get a number back from opacity
+			if ( name === "opacity" && ret === "" ) {
+				ret = "1";
+			}
+
+		} else if ( elem.currentStyle ) {
+			var camelCase = name.replace(rdashAlpha, fcamelCase);
+
+			ret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ];
+
+			// From the awesome hack by Dean Edwards
+			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
+
+			// If we're not dealing with a regular pixel number
+			// but a number that has a weird ending, we need to convert it to pixels
+			if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
+				// Remember the original values
+				var left = style.left, rsLeft = elem.runtimeStyle.left;
+
+				// Put in the new values to get a computed value out
+				elem.runtimeStyle.left = elem.currentStyle.left;
+				style.left = camelCase === "fontSize" ? "1em" : (ret || 0);
+				ret = style.pixelLeft + "px";
+
+				// Revert the changed values
+				style.left = left;
+				elem.runtimeStyle.left = rsLeft;
+			}
+		}
+
+		return ret;
+	},
+
+	// A method for quickly swapping in/out CSS properties to get correct calculations
+	swap: function( elem, options, callback ) {
+		var old = {};
+
+		// Remember the old values, and insert the new ones
+		for ( var name in options ) {
+			old[ name ] = elem.style[ name ];
+			elem.style[ name ] = options[ name ];
+		}
+
+		callback.call( elem );
+
+		// Revert the old values
+		for ( var name in options ) {
+			elem.style[ name ] = old[ name ];
+		}
+	}
+});
+
+if ( jQuery.expr && jQuery.expr.filters ) {
+	jQuery.expr.filters.hidden = function( elem ) {
+		var width = elem.offsetWidth, height = elem.offsetHeight,
+			skip = elem.nodeName.toLowerCase() === "tr";
+
+		return width === 0 && height === 0 && !skip ?
+			true :
+			width > 0 && height > 0 && !skip ?
+				false :
+				jQuery.curCSS(elem, "display") === "none";
+	};
+
+	jQuery.expr.filters.visible = function( elem ) {
+		return !jQuery.expr.filters.hidden( elem );
+	};
+}
+var jsc = now(),
+	rscript = /<script(.|\s)*?\/script>/gi,
+	rselectTextarea = /select|textarea/i,
+	rinput = /color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,
+	jsre = /=\?(&|$)/,
+	rquery = /\?/,
+	rts = /(\?|&)_=.*?(&|$)/,
+	rurl = /^(\w+:)?\/\/([^\/?#]+)/,
+	r20 = /%20/g,
+
+	// Keep a copy of the old load method
+	_load = jQuery.fn.load;
+
+jQuery.fn.extend({
+	load: function( url, params, callback ) {
+		if ( typeof url !== "string" ) {
+			return _load.call( this, url );
+
+		// Don't do a request if no elements are being requested
+		} else if ( !this.length ) {
+			return this;
+		}
+
+		var off = url.indexOf(" ");
+		if ( off >= 0 ) {
+			var selector = url.slice(off, url.length);
+			url = url.slice(0, off);
+		}
+
+		// Default to a GET request
+		var type = "GET";
+
+		// If the second parameter was provided
+		if ( params ) {
+			// If it's a function
+			if ( jQuery.isFunction( params ) ) {
+				// We assume that it's the callback
+				callback = params;
+				params = null;
+
+			// Otherwise, build a param string
+			} else if ( typeof params === "object" ) {
+				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
+				type = "POST";
+			}
+		}
+
+		var self = this;
+
+		// Request the remote document
+		jQuery.ajax({
+			url: url,
+			type: type,
+			dataType: "html",
+			data: params,
+			complete: function( res, status ) {
+				// If successful, inject the HTML into all the matched elements
+				if ( status === "success" || status === "notmodified" ) {
+					// See if a selector was specified
+					self.html( selector ?
+						// Create a dummy div to hold the results
+						jQuery("<div />")
+							// inject the contents of the document in, removing the scripts
+							// to avoid any 'Permission Denied' errors in IE
+							.append(res.responseText.replace(rscript, ""))
+
+							// Locate the specified elements
+							.find(selector) :
+
+						// If not, just inject the full result
+						res.responseText );
+				}
+
+				if ( callback ) {
+					self.each( callback, [res.responseText, status, res] );
+				}
+			}
+		});
+
+		return this;
+	},
+
+	serialize: function() {
+		return jQuery.param(this.serializeArray());
+	},
+	serializeArray: function() {
+		return this.map(function() {
+			return this.elements ? jQuery.makeArray(this.elements) : this;
+		})
+		.filter(function() {
+			return this.name && !this.disabled &&
+				(this.checked || rselectTextarea.test(this.nodeName) ||
+					rinput.test(this.type));
+		})
+		.map(function( i, elem ) {
+			var val = jQuery(this).val();
+
+			return val == null ?
+				null :
+				jQuery.isArray(val) ?
+					jQuery.map( val, function( val, i ) {
+						return { name: elem.name, value: val };
+					}) :
+					{ name: elem.name, value: val };
+		}).get();
+	}
+});
+
+// Attach a bunch of functions for handling common AJAX events
+jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function( i, o ) {
+	jQuery.fn[o] = function( f ) {
+		return this.bind(o, f);
+	};
+});
+
+jQuery.extend({
+
+	get: function( url, data, callback, type ) {
+		// shift arguments if data argument was omited
+		if ( jQuery.isFunction( data ) ) {
+			type = type || callback;
+			callback = data;
+			data = null;
+		}
+
+		return jQuery.ajax({
+			type: "GET",
+			url: url,
+			data: data,
+			success: callback,
+			dataType: type
+		});
+	},
+
+	getScript: function( url, callback ) {
+		return jQuery.get(url, null, callback, "script");
+	},
+
+	getJSON: function( url, data, callback ) {
+		return jQuery.get(url, data, callback, "json");
+	},
+
+	post: function( url, data, callback, type ) {
+		// shift arguments if data argument was omited
+		if ( jQuery.isFunction( data ) ) {
+			type = type || callback;
+			callback = data;
+			data = {};
+		}
+
+		return jQuery.ajax({
+			type: "POST",
+			url: url,
+			data: data,
+			success: callback,
+			dataType: type
+		});
+	},
+
+	ajaxSetup: function( settings ) {
+		jQuery.extend( jQuery.ajaxSettings, settings );
+	},
+
+	ajaxSettings: {
+		url: location.href,
+		global: true,
+		type: "GET",
+		contentType: "application/x-www-form-urlencoded",
+		processData: true,
+		async: true,
+		/*
+		timeout: 0,
+		data: null,
+		username: null,
+		password: null,
+		traditional: false,
+		*/
+		// Create the request object; Microsoft failed to properly
+		// implement the XMLHttpRequest in IE7 (can't request local files),
+		// so we use the ActiveXObject when it is available
+		// This function can be overriden by calling jQuery.ajaxSetup
+		xhr: window.XMLHttpRequest && (window.location.protocol !== "file:" || !window.ActiveXObject) ?
+			function() {
+				return new window.XMLHttpRequest();
+			} :
+			function() {
+				try {
+					return new window.ActiveXObject("Microsoft.XMLHTTP");
+				} catch(e) {}
+			},
+		accepts: {
+			xml: "application/xml, text/xml",
+			html: "text/html",
+			script: "text/javascript, application/javascript",
+			json: "application/json, text/javascript",
+			text: "text/plain",
+			_default: "*/*"
+		}
+	},
+
+	// Last-Modified header cache for next request
+	lastModified: {},
+	etag: {},
+
+	ajax: function( origSettings ) {
+		var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings);
+		
+		var jsonp, status, data,
+			callbackContext = origSettings && origSettings.context || s,
+			type = s.type.toUpperCase();
+
+		// convert data if not already a string
+		if ( s.data && s.processData && typeof s.data !== "string" ) {
+			s.data = jQuery.param( s.data, s.traditional );
+		}
+
+		// Handle JSONP Parameter Callbacks
+		if ( s.dataType === "jsonp" ) {
+			if ( type === "GET" ) {
+				if ( !jsre.test( s.url ) ) {
+					s.url += (rquery.test( s.url ) ? "&" : "?") + (s.jsonp || "callback") + "=?";
+				}
+			} else if ( !s.data || !jsre.test(s.data) ) {
+				s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
+			}
+			s.dataType = "json";
+		}
+
+		// Build temporary JSONP function
+		if ( s.dataType === "json" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) {
+			jsonp = s.jsonpCallback || ("jsonp" + jsc++);
+
+			// Replace the =? sequence both in the query string and the data
+			if ( s.data ) {
+				s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
+			}
+
+			s.url = s.url.replace(jsre, "=" + jsonp + "$1");
+
+			// We need to make sure
+			// that a JSONP style response is executed properly
+			s.dataType = "script";
+
+			// Handle JSONP-style loading
+			window[ jsonp ] = window[ jsonp ] || function( tmp ) {
+				data = tmp;
+				success();
+				complete();
+				// Garbage collect
+				window[ jsonp ] = undefined;
+
+				try {
+					delete window[ jsonp ];
+				} catch(e) {}
+
+				if ( head ) {
+					head.removeChild( script );
+				}
+			};
+		}
+
+		if ( s.dataType === "script" && s.cache === null ) {
+			s.cache = false;
+		}
+
+		if ( s.cache === false && type === "GET" ) {
+			var ts = now();
+
+			// try replacing _= if it is there
+			var ret = s.url.replace(rts, "$1_=" + ts + "$2");
+
+			// if nothing was replaced, add timestamp to the end
+			s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
+		}
+
+		// If data is available, append data to url for get requests
+		if ( s.data && type === "GET" ) {
+			s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
+		}
+
+		// Watch for a new set of requests
+		if ( s.global && ! jQuery.active++ ) {
+			jQuery.event.trigger( "ajaxStart" );
+		}
+
+		// Matches an absolute URL, and saves the domain
+		var parts = rurl.exec( s.url ),
+			remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);
+
+		// If we're requesting a remote document
+		// and trying to load JSON or Script with a GET
+		if ( s.dataType === "script" && type === "GET" && remote ) {
+			var head = document.getElementsByTagName("head")[0] || document.documentElement;
+			var script = document.createElement("script");
+			script.src = s.url;
+			if ( s.scriptCharset ) {
+				script.charset = s.scriptCharset;
+			}
+
+			// Handle Script loading
+			if ( !jsonp ) {
+				var done = false;
+
+				// Attach handlers for all browsers
+				script.onload = script.onreadystatechange = function() {
+					if ( !done && (!this.readyState ||
+							this.readyState === "loaded" || this.readyState === "complete") ) {
+						done = true;
+						success();
+						complete();
+
+						// Handle memory leak in IE
+						script.onload = script.onreadystatechange = null;
+						if ( head && script.parentNode ) {
+							head.removeChild( script );
+						}
+					}
+				};
+			}
+
+			// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
+			// This arises when a base node is used (#2709 and #4378).
+			head.insertBefore( script, head.firstChild );
+
+			// We handle everything using the script element injection
+			return undefined;
+		}
+
+		var requestDone = false;
+
+		// Create the request object
+		var xhr = s.xhr();
+
+		if ( !xhr ) {
+			return;
+		}
+
+		// Open the socket
+		// Passing null username, generates a login popup on Opera (#2865)
+		if ( s.username ) {
+			xhr.open(type, s.url, s.async, s.username, s.password);
+		} else {
+			xhr.open(type, s.url, s.async);
+		}
+
+		// Need an extra try/catch for cross domain requests in Firefox 3
+		try {
+			// Set the correct header, if data is being sent
+			if ( s.data || origSettings && origSettings.contentType ) {
+				xhr.setRequestHeader("Content-Type", s.contentType);
+			}
+
+			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
+			if ( s.ifModified ) {
+				if ( jQuery.lastModified[s.url] ) {
+					xhr.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url]);
+				}
+
+				if ( jQuery.etag[s.url] ) {
+					xhr.setRequestHeader("If-None-Match", jQuery.etag[s.url]);
+				}
+			}
+
+			// Set header so the called script knows that it's an XMLHttpRequest
+			// Only send the header if it's not a remote XHR
+			if ( !remote ) {
+				xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
+			}
+
+			// Set the Accepts header for the server, depending on the dataType
+			xhr.setRequestHeader("Accept", s.dataType && s.accepts[ s.dataType ] ?
+				s.accepts[ s.dataType ] + ", */*" :
+				s.accepts._default );
+		} catch(e) {}
+
+		// Allow custom headers/mimetypes and early abort
+		if ( s.beforeSend && s.beforeSend.call(callbackContext, xhr, s) === false ) {
+			// Handle the global AJAX counter
+			if ( s.global && ! --jQuery.active ) {
+				jQuery.event.trigger( "ajaxStop" );
+			}
+
+			// close opended socket
+			xhr.abort();
+			return false;
+		}
+
+		if ( s.global ) {
+			trigger("ajaxSend", [xhr, s]);
+		}
+
+		// Wait for a response to come back
+		var onreadystatechange = xhr.onreadystatechange = function( isTimeout ) {
+			// The request was aborted
+			if ( !xhr || xhr.readyState === 0 || isTimeout === "abort" ) {
+				// Opera doesn't call onreadystatechange before this point
+				// so we simulate the call
+				if ( !requestDone ) {
+					complete();
+				}
+
+				requestDone = true;
+				if ( xhr ) {
+					xhr.onreadystatechange = jQuery.noop;
+				}
+
+			// The transfer is complete and the data is available, or the request timed out
+			} else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === "timeout") ) {
+				requestDone = true;
+				xhr.onreadystatechange = jQuery.noop;
+
+				status = isTimeout === "timeout" ?
+					"timeout" :
+					!jQuery.httpSuccess( xhr ) ?
+						"error" :
+						s.ifModified && jQuery.httpNotModified( xhr, s.url ) ?
+							"notmodified" :
+							"success";
+
+				var errMsg;
+
+				if ( status === "success" ) {
+					// Watch for, and catch, XML document parse errors
+					try {
+						// process the data (runs the xml through httpData regardless of callback)
+						data = jQuery.httpData( xhr, s.dataType, s );
+					} catch(err) {
+						status = "parsererror";
+						errMsg = err;
+					}
+				}
+
+				// Make sure that the request was successful or notmodified
+				if ( status === "success" || status === "notmodified" ) {
+					// JSONP handles its own success callback
+					if ( !jsonp ) {
+						success();
+					}
+				} else {
+					jQuery.handleError(s, xhr, status, errMsg);
+				}
+
+				// Fire the complete handlers
+				complete();
+
+				if ( isTimeout === "timeout" ) {
+					xhr.abort();
+				}
+
+				// Stop memory leaks
+				if ( s.async ) {
+					xhr = null;
+				}
+			}
+		};
+
+		// Override the abort handler, if we can (IE doesn't allow it, but that's OK)
+		// Opera doesn't fire onreadystatechange at all on abort
+		try {
+			var oldAbort = xhr.abort;
+			xhr.abort = function() {
+				if ( xhr ) {
+					oldAbort.call( xhr );
+				}
+
+				onreadystatechange( "abort" );
+			};
+		} catch(e) { }
+
+		// Timeout checker
+		if ( s.async && s.timeout > 0 ) {
+			setTimeout(function() {
+				// Check to see if the request is still happening
+				if ( xhr && !requestDone ) {
+					onreadystatechange( "timeout" );
+				}
+			}, s.timeout);
+		}
+
+		// Send the data
+		try {
+			xhr.send( type === "POST" || type === "PUT" || type === "DELETE" ? s.data : null );
+		} catch(e) {
+			jQuery.handleError(s, xhr, null, e);
+			// Fire the complete handlers
+			complete();
+		}
+
+		// firefox 1.5 doesn't fire statechange for sync requests
+		if ( !s.async ) {
+			onreadystatechange();
+		}
+
+		function success() {
+			// If a local callback was specified, fire it and pass it the data
+			if ( s.success ) {
+				s.success.call( callbackContext, data, status, xhr );
+			}
+
+			// Fire the global callback
+			if ( s.global ) {
+				trigger( "ajaxSuccess", [xhr, s] );
+			}
+		}
+
+		function complete() {
+			// Process result
+			if ( s.complete ) {
+				s.complete.call( callbackContext, xhr, status);
+			}
+
+			// The request was completed
+			if ( s.global ) {
+				trigger( "ajaxComplete", [xhr, s] );
+			}
+
+			// Handle the global AJAX counter
+			if ( s.global && ! --jQuery.active ) {
+				jQuery.event.trigger( "ajaxStop" );
+			}
+		}
+		
+		function trigger(type, args) {
+			(s.context ? jQuery(s.context) : jQuery.event).trigger(type, args);
+		}
+
+		// return XMLHttpRequest to allow aborting the request etc.
+		return xhr;
+	},
+
+	handleError: function( s, xhr, status, e ) {
+		// If a local callback was specified, fire it
+		if ( s.error ) {
+			s.error.call( s.context || s, xhr, status, e );
+		}
+
+		// Fire the global callback
+		if ( s.global ) {
+			(s.context ? jQuery(s.context) : jQuery.event).trigger( "ajaxError", [xhr, s, e] );
+		}
+	},
+
+	// Counter for holding the number of active queries
+	active: 0,
+
+	// Determines if an XMLHttpRequest was successful or not
+	httpSuccess: function( xhr ) {
+		try {
+			// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
+			return !xhr.status && location.protocol === "file:" ||
+				// Opera returns 0 when status is 304
+				( xhr.status >= 200 && xhr.status < 300 ) ||
+				xhr.status === 304 || xhr.status === 1223 || xhr.status === 0;
+		} catch(e) {}
+
+		return false;
+	},
+
+	// Determines if an XMLHttpRequest returns NotModified
+	httpNotModified: function( xhr, url ) {
+		var lastModified = xhr.getResponseHeader("Last-Modified"),
+			etag = xhr.getResponseHeader("Etag");
+
+		if ( lastModified ) {
+			jQuery.lastModified[url] = lastModified;
+		}
+
+		if ( etag ) {
+			jQuery.etag[url] = etag;
+		}
+
+		// Opera returns 0 when status is 304
+		return xhr.status === 304 || xhr.status === 0;
+	},
+
+	httpData: function( xhr, type, s ) {
+		var ct = xhr.getResponseHeader("content-type") || "",
+			xml = type === "xml" || !type && ct.indexOf("xml") >= 0,
+			data = xml ? xhr.responseXML : xhr.responseText;
+
+		if ( xml && data.documentElement.nodeName === "parsererror" ) {
+			jQuery.error( "parsererror" );
+		}
+
+		// Allow a pre-filtering function to sanitize the response
+		// s is checked to keep backwards compatibility
+		if ( s && s.dataFilter ) {
+			data = s.dataFilter( data, type );
+		}
+
+		// The filter can actually parse the response
+		if ( typeof data === "string" ) {
+			// Get the JavaScript object, if JSON is used.
+			if ( type === "json" || !type && ct.indexOf("json") >= 0 ) {
+				data = jQuery.parseJSON( data );
+
+			// If the type is "script", eval it in global context
+			} else if ( type === "script" || !type && ct.indexOf("javascript") >= 0 ) {
+				jQuery.globalEval( data );
+			}
+		}
+
+		return data;
+	},
+
+	// Serialize an array of form elements or a set of
+	// key/values into a query string
+	param: function( a, traditional ) {
+		var s = [];
+		
+		// Set traditional to true for jQuery <= 1.3.2 behavior.
+		if ( traditional === undefined ) {
+			traditional = jQuery.ajaxSettings.traditional;
+		}
+		
+		// If an array was passed in, assume that it is an array of form elements.
+		if ( jQuery.isArray(a) || a.jquery ) {
+			// Serialize the form elements
+			jQuery.each( a, function() {
+				add( this.name, this.value );
+			});
+			
+		} else {
+			// If traditional, encode the "old" way (the way 1.3.2 or older
+			// did it), otherwise encode params recursively.
+			for ( var prefix in a ) {
+				buildParams( prefix, a[prefix] );
+			}
+		}
+
+		// Return the resulting serialization
+		return s.join("&").replace(r20, "+");
+
+		function buildParams( prefix, obj ) {
+			if ( jQuery.isArray(obj) ) {
+				// Serialize array item.
+				jQuery.each( obj, function( i, v ) {
+					if ( traditional || /\[\]$/.test( prefix ) ) {
+						// Treat each array item as a scalar.
+						add( prefix, v );
+					} else {
+						// If array item is non-scalar (array or object), encode its
+						// numeric index to resolve deserialization ambiguity issues.
+						// Note that rack (as of 1.0.0) can't currently deserialize
+						// nested arrays properly, and attempting to do so may cause
+						// a server error. Possible fixes are to modify rack's
+						// deserialization algorithm or to provide an option or flag
+						// to force array serialization to be shallow.
+						buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v );
+					}
+				});
+					
+			} else if ( !traditional && obj != null && typeof obj === "object" ) {
+				// Serialize object item.
+				jQuery.each( obj, function( k, v ) {
+					buildParams( prefix + "[" + k + "]", v );
+				});
+					
+			} else {
+				// Serialize scalar item.
+				add( prefix, obj );
+			}
+		}
+
+		function add( key, value ) {
+			// If value is a function, invoke it and return its value
+			value = jQuery.isFunction(value) ? value() : value;
+			s[ s.length ] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
+		}
+	}
+});
+var elemdisplay = {},
+	rfxtypes = /toggle|show|hide/,
+	rfxnum = /^([+-]=)?([\d+-.]+)(.*)$/,
+	timerId,
+	fxAttrs = [
+		// height animations
+		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
+		// width animations
+		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
+		// opacity animations
+		[ "opacity" ]
+	];
+
+jQuery.fn.extend({
+	show: function( speed, callback ) {
+		if ( speed || speed === 0) {
+			return this.animate( genFx("show", 3), speed, callback);
+
+		} else {
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				var old = jQuery.data(this[i], "olddisplay");
+
+				this[i].style.display = old || "";
+
+				if ( jQuery.css(this[i], "display") === "none" ) {
+					var nodeName = this[i].nodeName, display;
+
+					if ( elemdisplay[ nodeName ] ) {
+						display = elemdisplay[ nodeName ];
+
+					} else {
+						var elem = jQuery("<" + nodeName + " />").appendTo("body");
+
+						display = elem.css("display");
+
+						if ( display === "none" ) {
+							display = "block";
+						}
+
+						elem.remove();
+
+						elemdisplay[ nodeName ] = display;
+					}
+
+					jQuery.data(this[i], "olddisplay", display);
+				}
+			}
+
+			// Set the display of the elements in a second loop
+			// to avoid the constant reflow
+			for ( var j = 0, k = this.length; j < k; j++ ) {
+				this[j].style.display = jQuery.data(this[j], "olddisplay") || "";
+			}
+
+			return this;
+		}
+	},
+
+	hide: function( speed, callback ) {
+		if ( speed || speed === 0 ) {
+			return this.animate( genFx("hide", 3), speed, callback);
+
+		} else {
+			for ( var i = 0, l = this.length; i < l; i++ ) {
+				var old = jQuery.data(this[i], "olddisplay");
+				if ( !old && old !== "none" ) {
+					jQuery.data(this[i], "olddisplay", jQuery.css(this[i], "display"));
+				}
+			}
+
+			// Set the display of the elements in a second loop
+			// to avoid the constant reflow
+			for ( var j = 0, k = this.length; j < k; j++ ) {
+				this[j].style.display = "none";
+			}
+
+			return this;
+		}
+	},
+
+	// Save the old toggle function
+	_toggle: jQuery.fn.toggle,
+
+	toggle: function( fn, fn2 ) {
+		var bool = typeof fn === "boolean";
+
+		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
+			this._toggle.apply( this, arguments );
+
+		} else if ( fn == null || bool ) {
+			this.each(function() {
+				var state = bool ? fn : jQuery(this).is(":hidden");
+				jQuery(this)[ state ? "show" : "hide" ]();
+			});
+
+		} else {
+			this.animate(genFx("toggle", 3), fn, fn2);
+		}
+
+		return this;
+	},
+
+	fadeTo: function( speed, to, callback ) {
+		return this.filter(":hidden").css("opacity", 0).show().end()
+					.animate({opacity: to}, speed, callback);
+	},
+
+	animate: function( prop, speed, easing, callback ) {
+		var optall = jQuery.speed(speed, easing, callback);
+
+		if ( jQuery.isEmptyObject( prop ) ) {
+			return this.each( optall.complete );
+		}
+
+		return this[ optall.queue === false ? "each" : "queue" ](function() {
+			var opt = jQuery.extend({}, optall), p,
+				hidden = this.nodeType === 1 && jQuery(this).is(":hidden"),
+				self = this;
+
+			for ( p in prop ) {
+				var name = p.replace(rdashAlpha, fcamelCase);
+
+				if ( p !== name ) {
+					prop[ name ] = prop[ p ];
+					delete prop[ p ];
+					p = name;
+				}
+
+				if ( prop[p] === "hide" && hidden || prop[p] === "show" && !hidden ) {
+					return opt.complete.call(this);
+				}
+
+				if ( ( p === "height" || p === "width" ) && this.style ) {
+					// Store display property
+					opt.display = jQuery.css(this, "display");
+
+					// Make sure that nothing sneaks out
+					opt.overflow = this.style.overflow;
+				}
+
+				if ( jQuery.isArray( prop[p] ) ) {
+					// Create (if needed) and add to specialEasing
+					(opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
+					prop[p] = prop[p][0];
+				}
+			}
+
+			if ( opt.overflow != null ) {
+				this.style.overflow = "hidden";
+			}
+
+			opt.curAnim = jQuery.extend({}, prop);
+
+			jQuery.each( prop, function( name, val ) {
+				var e = new jQuery.fx( self, opt, name );
+
+				if ( rfxtypes.test(val) ) {
+					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]( prop );
+
+				} else {
+					var parts = rfxnum.exec(val),
+						start = e.cur(true) || 0;
+
+					if ( parts ) {
+						var end = parseFloat( parts[2] ),
+							unit = parts[3] || "px";
+
+						// We need to compute starting value
+						if ( unit !== "px" ) {
+							self.style[ name ] = (end || 1) + unit;
+							start = ((end || 1) / e.cur(true)) * start;
+							self.style[ name ] = start + unit;
+						}
+
+						// If a +=/-= token was provided, we're doing a relative animation
+						if ( parts[1] ) {
+							end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
+						}
+
+						e.custom( start, end, unit );
+
+					} else {
+						e.custom( start, val, "" );
+					}
+				}
+			});
+
+			// For JS strict compliance
+			return true;
+		});
+	},
+
+	stop: function( clearQueue, gotoEnd ) {
+		var timers = jQuery.timers;
+
+		if ( clearQueue ) {
+			this.queue([]);
+		}
+
+		this.each(function() {
+			// go in reverse order so anything added to the queue during the loop is ignored
+			for ( var i = timers.length - 1; i >= 0; i-- ) {
+				if ( timers[i].elem === this ) {
+					if (gotoEnd) {
+						// force the next step to be the last
+						timers[i](true);
+					}
+
+					timers.splice(i, 1);
+				}
+			}
+		});
+
+		// start the next in the queue if the last step wasn't forced
+		if ( !gotoEnd ) {
+			this.dequeue();
+		}
+
+		return this;
+	}
+
+});
+
+// Generate shortcuts for custom animations
+jQuery.each({
+	slideDown: genFx("show", 1),
+	slideUp: genFx("hide", 1),
+	slideToggle: genFx("toggle", 1),
+	fadeIn: { opacity: "show" },
+	fadeOut: { opacity: "hide" }
+}, function( name, props ) {
+	jQuery.fn[ name ] = function( speed, callback ) {
+		return this.animate( props, speed, callback );
+	};
+});
+
+jQuery.extend({
+	speed: function( speed, easing, fn ) {
+		var opt = speed && typeof speed === "object" ? speed : {
+			complete: fn || !fn && easing ||
+				jQuery.isFunction( speed ) && speed,
+			duration: speed,
+			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
+		};
+
+		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
+			jQuery.fx.speeds[opt.duration] || jQuery.fx.speeds._default;
+
+		// Queueing
+		opt.old = opt.complete;
+		opt.complete = function() {
+			if ( opt.queue !== false ) {
+				jQuery(this).dequeue();
+			}
+			if ( jQuery.isFunction( opt.old ) ) {
+				opt.old.call( this );
+			}
+		};
+
+		return opt;
+	},
+
+	easing: {
+		linear: function( p, n, firstNum, diff ) {
+			return firstNum + diff * p;
+		},
+		swing: function( p, n, firstNum, diff ) {
+			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
+		}
+	},
+
+	timers: [],
+
+	fx: function( elem, options, prop ) {
+		this.options = options;
+		this.elem = elem;
+		this.prop = prop;
+
+		if ( !options.orig ) {
+			options.orig = {};
+		}
+	}
+
+});
+
+jQuery.fx.prototype = {
+	// Simple function for setting a style value
+	update: function() {
+		if ( this.options.step ) {
+			this.options.step.call( this.elem, this.now, this );
+		}
+
+		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
+
+		// Set display property to block for height/width animations
+		if ( ( this.prop === "height" || this.prop === "width" ) && this.elem.style ) {
+			this.elem.style.display = "block";
+		}
+	},
+
+	// Get the current size
+	cur: function( force ) {
+		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
+			return this.elem[ this.prop ];
+		}
+
+		var r = parseFloat(jQuery.css(this.elem, this.prop, force));
+		return r && r > -10000 ? r : parseFloat(jQuery.curCSS(this.elem, this.prop)) || 0;
+	},
+
+	// Start an animation from one number to another
+	custom: function( from, to, unit ) {
+		this.startTime = now();
+		this.start = from;
+		this.end = to;
+		this.unit = unit || this.unit || "px";
+		this.now = this.start;
+		this.pos = this.state = 0;
+
+		var self = this;
+		function t( gotoEnd ) {
+			return self.step(gotoEnd);
+		}
+
+		t.elem = this.elem;
+
+		if ( t() && jQuery.timers.push(t) && !timerId ) {
+			timerId = setInterval(jQuery.fx.tick, 13);
+		}
+	},
+
+	// Simple 'show' function
+	show: function() {
+		// Remember where we started, so that we can go back to it later
+		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
+		this.options.show = true;
+
+		// Begin the animation
+		// Make sure that we start at a small width/height to avoid any
+		// flash of content
+		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
+
+		// Start by showing the element
+		jQuery( this.elem ).show();
+	},
+
+	// Simple 'hide' function
+	hide: function() {
+		// Remember where we started, so that we can go back to it later
+		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
+		this.options.hide = true;
+
+		// Begin the animation
+		this.custom(this.cur(), 0);
+	},
+
+	// Each step of an animation
+	step: function( gotoEnd ) {
+		var t = now(), done = true;
+
+		if ( gotoEnd || t >= this.options.duration + this.startTime ) {
+			this.now = this.end;
+			this.pos = this.state = 1;
+			this.update();
+
+			this.options.curAnim[ this.prop ] = true;
+
+			for ( var i in this.options.curAnim ) {
+				if ( this.options.curAnim[i] !== true ) {
+					done = false;
+				}
+			}
+
+			if ( done ) {
+				if ( this.options.display != null ) {
+					// Reset the overflow
+					this.elem.style.overflow = this.options.overflow;
+
+					// Reset the display
+					var old = jQuery.data(this.elem, "olddisplay");
+					this.elem.style.display = old ? old : this.options.display;
+
+					if ( jQuery.css(this.elem, "display") === "none" ) {
+						this.elem.style.display = "block";
+					}
+				}
+
+				// Hide the element if the "hide" operation was done
+				if ( this.options.hide ) {
+					jQuery(this.elem).hide();
+				}
+
+				// Reset the properties, if the item has been hidden or shown
+				if ( this.options.hide || this.options.show ) {
+					for ( var p in this.options.curAnim ) {
+						jQuery.style(this.elem, p, this.options.orig[p]);
+					}
+				}
+
+				// Execute the complete function
+				this.options.complete.call( this.elem );
+			}
+
+			return false;
+
+		} else {
+			var n = t - this.startTime;
+			this.state = n / this.options.duration;
+
+			// Perform the easing function, defaults to swing
+			var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
+			var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
+			this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
+			this.now = this.start + ((this.end - this.start) * this.pos);
+
+			// Perform the next step of the animation
+			this.update();
+		}
+
+		return true;
+	}
+};
+
+jQuery.extend( jQuery.fx, {
+	tick: function() {
+		var timers = jQuery.timers;
+
+		for ( var i = 0; i < timers.length; i++ ) {
+			if ( !timers[i]() ) {
+				timers.splice(i--, 1);
+			}
+		}
+
+		if ( !timers.length ) {
+			jQuery.fx.stop();
+		}
+	},
+		
+	stop: function() {
+		clearInterval( timerId );
+		timerId = null;
+	},
+	
+	speeds: {
+		slow: 600,
+ 		fast: 200,
+ 		// Default speed
+ 		_default: 400
+	},
+
+	step: {
+		opacity: function( fx ) {
+			jQuery.style(fx.elem, "opacity", fx.now);
+		},
+
+		_default: function( fx ) {
+			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
+				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
+			} else {
+				fx.elem[ fx.prop ] = fx.now;
+			}
+		}
+	}
+});
+
+if ( jQuery.expr && jQuery.expr.filters ) {
+	jQuery.expr.filters.animated = function( elem ) {
+		return jQuery.grep(jQuery.timers, function( fn ) {
+			return elem === fn.elem;
+		}).length;
+	};
+}
+
+function genFx( type, num ) {
+	var obj = {};
+
+	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
+		obj[ this ] = type;
+	});
+
+	return obj;
+}
+if ( "getBoundingClientRect" in document.documentElement ) {
+	jQuery.fn.offset = function( options ) {
+		var elem = this[0];
+
+		if ( options ) { 
+			return this.each(function( i ) {
+				jQuery.offset.setOffset( this, options, i );
+			});
+		}
+
+		if ( !elem || !elem.ownerDocument ) {
+			return null;
+		}
+
+		if ( elem === elem.ownerDocument.body ) {
+			return jQuery.offset.bodyOffset( elem );
+		}
+
+		var box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement,
+			clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
+			top  = box.top  + (self.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop ) - clientTop,
+			left = box.left + (self.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft;
+
+		return { top: top, left: left };
+	};
+
+} else {
+	jQuery.fn.offset = function( options ) {
+		var elem = this[0];
+
+		if ( options ) { 
+			return this.each(function( i ) {
+				jQuery.offset.setOffset( this, options, i );
+			});
+		}
+
+		if ( !elem || !elem.ownerDocument ) {
+			return null;
+		}
+
+		if ( elem === elem.ownerDocument.body ) {
+			return jQuery.offset.bodyOffset( elem );
+		}
+
+		jQuery.offset.initialize();
+
+		var offsetParent = elem.offsetParent, prevOffsetParent = elem,
+			doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,
+			body = doc.body, defaultView = doc.defaultView,
+			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
+			top = elem.offsetTop, left = elem.offsetLeft;
+
+		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
+			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
+				break;
+			}
+
+			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
+			top  -= elem.scrollTop;
+			left -= elem.scrollLeft;
+
+			if ( elem === offsetParent ) {
+				top  += elem.offsetTop;
+				left += elem.offsetLeft;
+
+				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.nodeName)) ) {
+					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
+					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
+				}
+
+				prevOffsetParent = offsetParent, offsetParent = elem.offsetParent;
+			}
+
+			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
+				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
+				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
+			}
+
+			prevComputedStyle = computedStyle;
+		}
+
+		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
+			top  += body.offsetTop;
+			left += body.offsetLeft;
+		}
+
+		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
+			top  += Math.max( docElem.scrollTop, body.scrollTop );
+			left += Math.max( docElem.scrollLeft, body.scrollLeft );
+		}
+
+		return { top: top, left: left };
+	};
+}
+
+jQuery.offset = {
+	initialize: function() {
+		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.curCSS(body, "marginTop", true) ) || 0,
+			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
+
+		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );
+
+		container.innerHTML = html;
+		body.insertBefore( container, body.firstChild );
+		innerDiv = container.firstChild;
+		checkDiv = innerDiv.firstChild;
+		td = innerDiv.nextSibling.firstChild.firstChild;
+
+		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
+		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);
+
+		checkDiv.style.position = "fixed", checkDiv.style.top = "20px";
+		// safari subtracts parent border width here which is 5px
+		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
+		checkDiv.style.position = checkDiv.style.top = "";
+
+		innerDiv.style.overflow = "hidden", innerDiv.style.position = "relative";
+		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);
+
+		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);
+
+		body.removeChild( container );
+		body = container = innerDiv = checkDiv = table = td = null;
+		jQuery.offset.initialize = jQuery.noop;
+	},
+
+	bodyOffset: function( body ) {
+		var top = body.offsetTop, left = body.offsetLeft;
+
+		jQuery.offset.initialize();
+
+		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
+			top  += parseFloat( jQuery.curCSS(body, "marginTop",  true) ) || 0;
+			left += parseFloat( jQuery.curCSS(body, "marginLeft", true) ) || 0;
+		}
+
+		return { top: top, left: left };
+	},
+	
+	setOffset: function( elem, options, i ) {
+		// set position first, in-case top/left are set even on static elem
+		if ( /static/.test( jQuery.curCSS( elem, "position" ) ) ) {
+			elem.style.position = "relative";
+		}
+		var curElem   = jQuery( elem ),
+			curOffset = curElem.offset(),
+			curTop    = parseInt( jQuery.curCSS( elem, "top",  true ), 10 ) || 0,
+			curLeft   = parseInt( jQuery.curCSS( elem, "left", true ), 10 ) || 0;
+
+		if ( jQuery.isFunction( options ) ) {
+			options = options.call( elem, i, curOffset );
+		}
+
+		var props = {
+			top:  (options.top  - curOffset.top)  + curTop,
+			left: (options.left - curOffset.left) + curLeft
+		};
+		
+		if ( "using" in options ) {
+			options.using.call( elem, props );
+		} else {
+			curElem.css( props );
+		}
+	}
+};
+
+
+jQuery.fn.extend({
+	position: function() {
+		if ( !this[0] ) {
+			return null;
+		}
+
+		var elem = this[0],
+
+		// Get *real* offsetParent
+		offsetParent = this.offsetParent(),
+
+		// Get correct offsets
+		offset       = this.offset(),
+		parentOffset = /^body|html$/i.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
+
+		// Subtract element margins
+		// note: when an element has margin: auto the offsetLeft and marginLeft
+		// are the same in Safari causing offset.left to incorrectly be 0
+		offset.top  -= parseFloat( jQuery.curCSS(elem, "marginTop",  true) ) || 0;
+		offset.left -= parseFloat( jQuery.curCSS(elem, "marginLeft", true) ) || 0;
+
+		// Add offsetParent borders
+		parentOffset.top  += parseFloat( jQuery.curCSS(offsetParent[0], "borderTopWidth",  true) ) || 0;
+		parentOffset.left += parseFloat( jQuery.curCSS(offsetParent[0], "borderLeftWidth", true) ) || 0;
+
+		// Subtract the two offsets
+		return {
+			top:  offset.top  - parentOffset.top,
+			left: offset.left - parentOffset.left
+		};
+	},
+
+	offsetParent: function() {
+		return this.map(function() {
+			var offsetParent = this.offsetParent || document.body;
+			while ( offsetParent && (!/^body|html$/i.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
+				offsetParent = offsetParent.offsetParent;
+			}
+			return offsetParent;
+		});
+	}
+});
+
+
+// Create scrollLeft and scrollTop methods
+jQuery.each( ["Left", "Top"], function( i, name ) {
+	var method = "scroll" + name;
+
+	jQuery.fn[ method ] = function(val) {
+		var elem = this[0], win;
+		
+		if ( !elem ) {
+			return null;
+		}
+
+		if ( val !== undefined ) {
+			// Set the scroll offset
+			return this.each(function() {
+				win = getWindow( this );
+
+				if ( win ) {
+					win.scrollTo(
+						!i ? val : jQuery(win).scrollLeft(),
+						 i ? val : jQuery(win).scrollTop()
+					);
+
+				} else {
+					this[ method ] = val;
+				}
+			});
+		} else {
+			win = getWindow( elem );
+
+			// Return the scroll offset
+			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
+				jQuery.support.boxModel && win.document.documentElement[ method ] ||
+					win.document.body[ method ] :
+				elem[ method ];
+		}
+	};
+});
+
+function getWindow( elem ) {
+	return ("scrollTo" in elem && elem.document) ?
+		elem :
+		elem.nodeType === 9 ?
+			elem.defaultView || elem.parentWindow :
+			false;
+}
+// Create innerHeight, innerWidth, outerHeight and outerWidth methods
+jQuery.each([ "Height", "Width" ], function( i, name ) {
+
+	var type = name.toLowerCase();
+
+	// innerHeight and innerWidth
+	jQuery.fn["inner" + name] = function() {
+		return this[0] ?
+			jQuery.css( this[0], type, false, "padding" ) :
+			null;
+	};
+
+	// outerHeight and outerWidth
+	jQuery.fn["outer" + name] = function( margin ) {
+		return this[0] ?
+			jQuery.css( this[0], type, false, margin ? "margin" : "border" ) :
+			null;
+	};
+
+	jQuery.fn[ type ] = function( size ) {
+		// Get window width or height
+		var elem = this[0];
+		if ( !elem ) {
+			return size == null ? null : this;
+		}
+		
+		if ( jQuery.isFunction( size ) ) {
+			return this.each(function( i ) {
+				var self = jQuery( this );
+				self[ type ]( size.call( this, i, self[ type ]() ) );
+			});
+		}
+
+		return ("scrollTo" in elem && elem.document) ? // does it walk and quack like a window?
+			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
+			elem.document.compatMode === "CSS1Compat" && elem.document.documentElement[ "client" + name ] ||
+			elem.document.body[ "client" + name ] :
+
+			// Get document width or height
+			(elem.nodeType === 9) ? // is it a document
+				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
+				Math.max(
+					elem.documentElement["client" + name],
+					elem.body["scroll" + name], elem.documentElement["scroll" + name],
+					elem.body["offset" + name], elem.documentElement["offset" + name]
+				) :
+
+				// Get or set width or height on the element
+				size === undefined ?
+					// Get width or height on the element
+					jQuery.css( elem, type ) :
+
+					// Set the width or height on the element (default to pixels if value is unitless)
+					this.css( type, typeof size === "string" ? size : size + "px" );
+	};
+
+});
+// Expose jQuery to the global object
+window.jQuery = window.$ = jQuery;
+
+})(window);
diff --git a/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.min.js b/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.min.js
new file mode 100755
index 0000000..7c24308
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/libs/jquery-1.4.2.min.js
@@ -0,0 +1,154 @@
+/*!
+ * jQuery JavaScript Library v1.4.2
+ * http://jquery.com/
+ *
+ * Copyright 2010, John Resig
+ * Dual licensed under the MIT or GPL Version 2 licenses.
+ * http://jquery.org/license
+ *
+ * Includes Sizzle.js
+ * http://sizzlejs.com/
+ * Copyright 2010, The Dojo Foundation
+ * Released under the MIT, BSD, and GPL Licenses.
+ *
+ * Date: Sat Feb 13 22:33:48 2010 -0500
+ */
+(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
+e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
+j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\./g,"`").replace(/ /g,
+"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
+true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,
+Wa=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,Xa=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
+(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
+a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
+"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
+function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
+c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
+L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
+"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
+a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
+d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
+a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
+!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
+true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
+var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
+parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
+false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
+s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
+applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
+else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
+a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
+w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\n\t]/g,ca=/\s+/,Za=/\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
+cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
+i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
+" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
+this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
+e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
+c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
+a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\.(.*)$/,db=function(a){return a.replace(/[^\w\s\.\|`]/g,
+function(b){return"\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
+k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
+C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\.)"+c.map(o.slice(0).sort(),db).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
+null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
+e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
+f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
+if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\.)"+d.slice(0).sort().join("\\.(?:.*\\.)?")+"(\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
+fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
+d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
+"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
+a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
+isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
+{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
+if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
+e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
+"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
+d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
+!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
+toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
+u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
+function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
+if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
+e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
+t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
+g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
+for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\"){q[1]=(q[1]||"").replace(/\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
+1)!=="\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
+CLASS:/\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
+relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
+l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
+h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
+CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
+g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},
+text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
+setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
+h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
+m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
+"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\[]*\])(?![^\(]*\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\r|\n)*?)/.source+n.match[u].source.replace(/\\(\d+)/g,function(g,
+h){return"\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
+!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
+h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
+q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
+if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
+(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
+function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
+gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
+c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
+{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
+"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
+d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
+a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
+1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\d+="(?:\d+|null)"/g,V=/^\s+/,Ka=/(<([\w:]+)[^>]*?)\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\w:]+)/,ib=/<tbody/i,jb=/<|&#?\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\s*(?:[^=]|=\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
+a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
+c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
+wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
+prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
+this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
+return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\s]+\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
+""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
+this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
+u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
+1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
+return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
+""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
+c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
+c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\([^)]*\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\d+(?:px)?$/i,nb=/^-?\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
+function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
+Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
+"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
+a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
+a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\s)*?\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\?(&|$)/,ka=/\?/,wb=/(\?|&)_=.*?(&|$)/,xb=/^(\w+:)?\/\/([^\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
+"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
+serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
+function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
+global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
+e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
+"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
+false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
+false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
+c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
+d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
+g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
+1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
+"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\[\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
+if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
+this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
+"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
+animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
+j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
+this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
+"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
+c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
+this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
+this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
+e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
+c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
+function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
+this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
+k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
+f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
+a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
+c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
+d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
+f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
+"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
+e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);
diff --git a/vendor/fog-0.8.2/docs/public/js/libs/modernizr-1.6.min.js b/vendor/fog-0.8.2/docs/public/js/libs/modernizr-1.6.min.js
new file mode 100755
index 0000000..c6a800a
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/libs/modernizr-1.6.min.js
@@ -0,0 +1,30 @@
+/*
+ * Modernizr v1.6
+ * http://www.modernizr.com
+ *
+ * Developed by: 
+ * - Faruk Ates  http://farukat.es/
+ * - Paul Irish  http://paulirish.com/
+ *
+ * Copyright (c) 2009-2010
+ * Dual-licensed under the BSD or MIT licenses.
+ * http://www.modernizr.com/license/
+ */
+window.Modernizr=function(i,e,u){function s(a,b){return(""+a).indexOf(b)!==-1}function D(a,b){for(var c in a)if(j[a[c]]!==u&&(!b||b(a[c],E)))return true}function n(a,b){var c=a.charAt(0).toUpperCase()+a.substr(1);c=(a+" "+F.join(c+" ")+c).split(" ");return!!D(c,b)}function S(){f.input=function(a){for(var b=0,c=a.length;b<c;b++)L[a[b]]=!!(a[b]in h);return L}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" "));f.inputtypes=function(a){for(var b=0,c,k=a.length;b<
+k;b++){h.setAttribute("type",a[b]);if(c=h.type!=="text"){h.value=M;if(/^range$/.test(h.type)&&h.style.WebkitAppearance!==u){l.appendChild(h);c=e.defaultView;c=c.getComputedStyle&&c.getComputedStyle(h,null).WebkitAppearance!=="textfield"&&h.offsetHeight!==0;l.removeChild(h)}else/^(search|tel)$/.test(h.type)||(c=/^(url|email)$/.test(h.type)?h.checkValidity&&h.checkValidity()===false:h.value!=M)}N[a[b]]=!!c}return N}("search tel url email datetime date month week time datetime-local number range color".split(" "))}
+var f={},l=e.documentElement,E=e.createElement("modernizr"),j=E.style,h=e.createElement("input"),M=":)",O=Object.prototype.toString,q=" -webkit- -moz- -o- -ms- -khtml- ".split(" "),F="Webkit Moz O ms Khtml".split(" "),v={svg:"http://www.w3.org/2000/svg"},d={},N={},L={},P=[],w,Q=function(a){var b=document.createElement("style"),c=e.createElement("div");b.textContent=a+"{#modernizr{height:3px}}";(e.head||e.getElementsByTagName("head")[0]).appendChild(b);c.id="modernizr";l.appendChild(c);a=c.offsetHeight===
+3;b.parentNode.removeChild(b);c.parentNode.removeChild(c);return!!a},o=function(){var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return function(b,c){c=c||document.createElement(a[b]||"div");b="on"+b;var k=b in c;if(!k){c.setAttribute||(c=document.createElement("div"));if(c.setAttribute&&c.removeAttribute){c.setAttribute(b,"");k=typeof c[b]=="function";if(typeof c[b]!="undefined")c[b]=u;c.removeAttribute(b)}}return k}}(),G={}.hasOwnProperty,R;R=
+typeof G!=="undefined"&&typeof G.call!=="undefined"?function(a,b){return G.call(a,b)}:function(a,b){return b in a&&typeof a.constructor.prototype[b]==="undefined"};d.flexbox=function(){var a=e.createElement("div"),b=e.createElement("div");(function(k,g,r,x){g+=":";k.style.cssText=(g+q.join(r+";"+g)).slice(0,-g.length)+(x||"")})(a,"display","box","width:42px;padding:0;");b.style.cssText=q.join("box-flex:1;")+"width:10px;";a.appendChild(b);l.appendChild(a);var c=b.offsetWidth===42;a.removeChild(b);
+l.removeChild(a);return c};d.canvas=function(){var a=e.createElement("canvas");return!!(a.getContext&&a.getContext("2d"))};d.canvastext=function(){return!!(f.canvas&&typeof e.createElement("canvas").getContext("2d").fillText=="function")};d.webgl=function(){var a=e.createElement("canvas");try{if(a.getContext("webgl"))return true}catch(b){}try{if(a.getContext("experimental-webgl"))return true}catch(c){}return false};d.touch=function(){return"ontouchstart"in i||Q("@media ("+q.join("touch-enabled),(")+
+"modernizr)")};d.geolocation=function(){return!!navigator.geolocation};d.postmessage=function(){return!!i.postMessage};d.websqldatabase=function(){return!!i.openDatabase};d.indexedDB=function(){for(var a=-1,b=F.length;++a<b;){var c=F[a].toLowerCase();if(i[c+"_indexedDB"]||i[c+"IndexedDB"])return true}return false};d.hashchange=function(){return o("hashchange",i)&&(document.documentMode===u||document.documentMode>7)};d.history=function(){return!!(i.history&&history.pushState)};d.draganddrop=function(){return o("drag")&&
+o("dragstart")&&o("dragenter")&&o("dragover")&&o("dragleave")&&o("dragend")&&o("drop")};d.websockets=function(){return"WebSocket"in i};d.rgba=function(){j.cssText="background-color:rgba(150,255,150,.5)";return s(j.backgroundColor,"rgba")};d.hsla=function(){j.cssText="background-color:hsla(120,40%,100%,.5)";return s(j.backgroundColor,"rgba")||s(j.backgroundColor,"hsla")};d.multiplebgs=function(){j.cssText="background:url(//:),url(//:),red url(//:)";return/(url\s*\(.*?){3}/.test(j.background)};d.backgroundsize=
+function(){return n("backgroundSize")};d.borderimage=function(){return n("borderImage")};d.borderradius=function(){return n("borderRadius","",function(a){return s(a,"orderRadius")})};d.boxshadow=function(){return n("boxShadow")};d.textshadow=function(){return e.createElement("div").style.textShadow===""};d.opacity=function(){var a=q.join("opacity:.5;")+"";j.cssText=a;return s(j.opacity,"0.5")};d.cssanimations=function(){return n("animationName")};d.csscolumns=function(){return n("columnCount")};d.cssgradients=
+function(){var a=("background-image:"+q.join("gradient(linear,left top,right bottom,from(#9f9),to(white));background-image:")+q.join("linear-gradient(left top,#9f9, white);background-image:")).slice(0,-17);j.cssText=a;return s(j.backgroundImage,"gradient")};d.cssreflections=function(){return n("boxReflect")};d.csstransforms=function(){return!!D(["transformProperty","WebkitTransform","MozTransform","OTransform","msTransform"])};d.csstransforms3d=function(){var a=!!D(["perspectiveProperty","WebkitPerspective",
+"MozPerspective","OPerspective","msPerspective"]);if(a)a=Q("@media ("+q.join("transform-3d),(")+"modernizr)");return a};d.csstransitions=function(){return n("transitionProperty")};d.fontface=function(){var a,b=e.head||e.getElementsByTagName("head")[0]||l,c=e.createElement("style"),k=e.implementation||{hasFeature:function(){return false}};c.type="text/css";b.insertBefore(c,b.firstChild);a=c.sheet||c.styleSheet;b=k.hasFeature("CSS2","")?function(g){if(!(a&&g))return false;var r=false;try{a.insertRule(g,
+0);r=!/unknown/i.test(a.cssRules[0].cssText);a.deleteRule(a.cssRules.length-1)}catch(x){}return r}:function(g){if(!(a&&g))return false;a.cssText=g;return a.cssText.length!==0&&!/unknown/i.test(a.cssText)&&a.cssText.replace(/\r+|\n+/g,"").indexOf(g.split(" ")[0])===0};f._fontfaceready=function(g){g(f.fontface)};return b('@font-face { font-family: "font"; src: "font.ttf"; }')};d.video=function(){var a=e.createElement("video"),b=!!a.canPlayType;if(b){b=new Boolean(b);b.ogg=a.canPlayType('video/ogg; codecs="theora"');
+b.h264=a.canPlayType('video/mp4; codecs="avc1.42E01E"')||a.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');b.webm=a.canPlayType('video/webm; codecs="vp8, vorbis"')}return b};d.audio=function(){var a=e.createElement("audio"),b=!!a.canPlayType;if(b){b=new Boolean(b);b.ogg=a.canPlayType('audio/ogg; codecs="vorbis"');b.mp3=a.canPlayType("audio/mpeg;");b.wav=a.canPlayType('audio/wav; codecs="1"');b.m4a=a.canPlayType("audio/x-m4a;")||a.canPlayType("audio/aac;")}return b};d.localstorage=function(){try{return"localStorage"in
+i&&i.localStorage!==null}catch(a){return false}};d.sessionstorage=function(){try{return"sessionStorage"in i&&i.sessionStorage!==null}catch(a){return false}};d.webWorkers=function(){return!!i.Worker};d.applicationcache=function(){return!!i.applicationCache};d.svg=function(){return!!e.createElementNS&&!!e.createElementNS(v.svg,"svg").createSVGRect};d.inlinesvg=function(){var a=document.createElement("div");a.innerHTML="<svg/>";return(a.firstChild&&a.firstChild.namespaceURI)==v.svg};d.smil=function(){return!!e.createElementNS&&
+/SVG/.test(O.call(e.createElementNS(v.svg,"animate")))};d.svgclippaths=function(){return!!e.createElementNS&&/SVG/.test(O.call(e.createElementNS(v.svg,"clipPath")))};for(var H in d)if(R(d,H)){w=H.toLowerCase();f[w]=d[H]();P.push((f[w]?"":"no-")+w)}f.input||S();f.crosswindowmessaging=f.postmessage;f.historymanagement=f.history;f.addTest=function(a,b){a=a.toLowerCase();if(!f[a]){b=!!b();l.className+=" "+(b?"":"no-")+a;f[a]=b;return f}};j.cssText="";E=h=null;i.attachEvent&&function(){var a=e.createElement("div");
+a.innerHTML="<elem></elem>";return a.childNodes.length!==1}()&&function(a,b){function c(p){for(var m=-1;++m<r;)p.createElement(g[m])}function k(p,m){for(var I=p.length,t=-1,y,J=[];++t<I;){y=p[t];m=y.media||m;J.push(k(y.imports,m));J.push(y.cssText)}return J.join("")}var g="abbr|article|aside|audio|canvas|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video".split("|"),r=g.length,x=RegExp("<(/*)(abbr|article|aside|audio|canvas|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video)",
+"gi"),T=RegExp("\\b(abbr|article|aside|audio|canvas|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video)\\b(?!.*[;}])","gi"),z=b.createDocumentFragment(),A=b.documentElement,K=A.firstChild,B=b.createElement("style"),C=b.createElement("body");B.media="all";c(b);c(z);a.attachEvent("onbeforeprint",function(){for(var p=-1;++p<r;)for(var m=b.getElementsByTagName(g[p]),I=m.length,t=-1;++t<I;)if(m[t].className.indexOf("iepp_")<0)m[t].className+=" iepp_"+
+g[p];K.insertBefore(B,K.firstChild);B.styleSheet.cssText=k(b.styleSheets,"all").replace(T,".iepp_$1");z.appendChild(b.body);A.appendChild(C);C.innerHTML=z.firstChild.innerHTML.replace(x,"<$1bdo")});a.attachEvent("onafterprint",function(){C.innerHTML="";A.removeChild(C);K.removeChild(B);A.appendChild(z.firstChild)})}(this,document);f._enableHTML5=true;f._version="1.6";l.className=l.className.replace(/\bno-js\b/,"")+" js";l.className+=" "+P.join(" ");return f}(this,this.document);
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/js/mylibs/.gitignore b/vendor/fog-0.8.2/docs/public/js/mylibs/.gitignore
new file mode 100755
index 0000000..a5baada
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/mylibs/.gitignore
@@ -0,0 +1,3 @@
+*
+!.gitignore
+
diff --git a/vendor/fog-0.8.2/docs/public/js/plugins.js b/vendor/fog-0.8.2/docs/public/js/plugins.js
new file mode 100755
index 0000000..c1ba19f
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/plugins.js
@@ -0,0 +1,34 @@
+
+(function($){
+
+ 
+
+
+
+
+
+ 
+
+
+
+})(this.jQuery);
+
+
+
+
+window.log = function(){
+  log.history = log.history || [];   
+  log.history.push(arguments);
+  if(this.console){
+    console.log( Array.prototype.slice.call(arguments) );
+  }
+};
+(function(doc){
+  var write = doc.write;
+  doc.write = function(q){ 
+    log('document.write(): ',arguments); 
+    if (/docwriteregexwhitelist/.test(q)) write.apply(doc,arguments);  
+  };
+})(document);
+
+
diff --git a/vendor/fog-0.8.2/docs/public/js/profiling/config.js b/vendor/fog-0.8.2/docs/public/js/profiling/config.js
new file mode 100755
index 0000000..b263e9b
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/profiling/config.js
@@ -0,0 +1,59 @@
+
+
+// call PROFILE.show() to show the profileViewer
+
+var PROFILE = {
+
+  init : function(bool) {
+  
+  	// define what objects, constructors and functions you want to profile
+  	// documentation here: http://developer.yahoo.com/yui/profiler/
+  	
+  	YAHOO.tool.Profiler.registerObject("jQuery", jQuery, true);
+  	
+  	// the following would profile all methods within constructor's prototype
+    // YAHOO.tool.Profiler.registerConstructor("Person");
+  	
+    // the following would profile the global function sayHi
+    // YAHOO.tool.Profiler.registerFunction("sayHi", window); 
+    
+    // if true is passed into init(), F9 will bring up the profiler
+    if (bool){
+      $(document).keyup(function(e){
+        if (e.keyCode === 120){ 
+          PROFILE.show(); 
+          $(document).unbind('keyup',arguments.callee); 
+        }
+      })
+    }
+  },
+  
+  //When the showProfile button is clicked, use YUI Loader to get all required
+  //dependencies and then show the profile:
+  show : function() {
+  
+          
+          
+          var s = document.createElement('link');
+          s.setAttribute('rel','stylesheet');      
+          s.setAttribute('type','text/css');
+          s.setAttribute('href','js/profiling/yahoo-profiling.css');
+          document.body.appendChild(s);
+          
+	        YAHOO.util.Dom.addClass(document.body, 'yui-skin-sam');
+
+      		//instantiate ProfilerViewer with desired options:
+      		var pv = new YAHOO.widget.ProfilerViewer("", {
+      			visible: true, //expand the viewer mmediately after instantiation
+      			showChart: true,
+      		  //	base:"../../build/",
+      		  swfUrl: "js/profiling/charts.swf"
+      		});
+  	
+  }
+
+};
+
+// check some global debug variable to see if we should be profiling..
+if (true) { PROFILE.init(true) }
+
diff --git a/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.css b/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.css
new file mode 100755
index 0000000..ae1daf7
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.css
@@ -0,0 +1,7 @@
+/*
+Copyright (c) 2009, Yahoo! Inc. All rights reserved.
+Code licensed under the BSD License:
+http://developer.yahoo.net/yui/license.txt
+version: 2.7.0
+*/
+.yui-skin-sam .yui-pv{background-color:#4a4a4a;font:arial;position:relative;width:99%;z-index:1000;margin-bottom:1em;overflow:hidden;}.yui-skin-sam .yui-pv .hd{background:url(http://yui.yahooapis.com/2.7.0/build/profilerviewer/assets/skins/sam/header_background.png) repeat-x;min-height:30px;overflow:hidden;zoom:1;padding:2px 0;}.yui-skin-sam .yui-pv .hd h4{padding:8px 10px;margin:0;font:bold 14px arial;color:#fff;}.yui-skin-sam .yui-pv .hd a{background:#3f6bc3;font:bold 11px arial;color:#fff;padding:4px;margin:3px 10px 0 0;border:1px solid #3f567d;cursor:pointer;display:block;float:right;}.yui-skin-sam .yui-pv .hd span{display:none;}.yui-skin-sam .yui-pv .hd span.yui-pv-busy{height:18px;width:18px;background:url(http://yui.yahooapis.com/2.7.0/build/profilerviewer/assets/skins/sam/wait.gif) no-repeat;overflow:hidden;display:block;float:right;margin:4px 10px 0 0;}.yui-skin-sam .yui-pv .hd:after,.yui-pv .bd:after,.yui-skin-sam .yui-pv-chartlegend dl:after{content:'.';visibility:hidden;clear:left;height:0;display:block;}.yui-skin-sam .yui-pv .bd{position:relative;zoom:1;overflow-x:auto;overflow-y:hidden;}.yui-skin-sam .yui-pv .yui-pv-table{padding:0 10px;margin:5px 0 10px 0;}.yui-skin-sam .yui-pv .yui-pv-table .yui-dt-bd td{color:#eeee5c;font:12px arial;}.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-odd{background:#929292;}.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-even{background:#58637a;}.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-even td.yui-dt-asc,.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-even td.yui-dt-desc{background:#384970;}.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-odd td.yui-dt-asc,.yui-skin-sam .yui-pv .yui-pv-table tr.yui-dt-odd td.yui-dt-desc{background:#6F6E6E;}.yui-skin-sam .yui-pv .yui-pv-table .yui-dt-hd th{background-image:none;background:#2E2D2D;}.yui-skin-sam .yui-pv th.yui-dt-asc .yui-dt-liner{background:transparent url(http://yui.yahooapis.com/2.7.0/build/profilerviewer/assets/skins/sam/asc.gif) no-repeat scroll right center;}.yui-skin-sam .yui-pv th.yui-dt-desc .yui-dt-liner{background:transparent url(http://yui.yahooapis.com/2.7.0/build/profilerviewer/assets/skins/sam/desc.gif) no-repeat scroll right center;}.yui-skin-sam .yui-pv .yui-pv-table .yui-dt-hd th a{color:#fff;font:bold 12px arial;}.yui-skin-sam .yui-pv .yui-pv-table .yui-dt-hd th.yui-dt-asc,.yui-skin-sam .yui-pv .yui-pv-table .yui-dt-hd th.yui-dt-desc{background:#333;}.yui-skin-sam .yui-pv-chartcontainer{padding:0 10px;}.yui-skin-sam .yui-pv-chart{height:250px;clear:right;margin:5px 0 0 0;color:#fff;}.yui-skin-sam .yui-pv-chartlegend div{float:right;margin:0 0 0 10px;_width:250px;}.yui-skin-sam .yui-pv-chartlegend dl{border:1px solid #999;padding:.2em 0 .2em .5em;zoom:1;margin:5px 0;}.yui-skin-sam .yui-pv-chartlegend dt{float:left;display:block;height:.7em;width:.7em;padding:0;}.yui-skin-sam .yui-pv-chartlegend dd{float:left;display:block;color:#fff;margin:0 1em 0 .5em;padding:0;font:11px arial;}.yui-skin-sam .yui-pv-minimized{height:35px;}.yui-skin-sam .yui-pv-minimized .bd{top:-3000px;}.yui-skin-sam .yui-pv-minimized .hd a.yui-pv-refresh{display:none;}
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.min.js b/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.min.js
new file mode 100755
index 0000000..2947528
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/profiling/yahoo-profiling.min.js
@@ -0,0 +1,39 @@
+/*
+Copyright (c) 2009, Yahoo! Inc. All rights reserved.
+Code licensed under the BSD License:
+http://developer.yahoo.net/yui/license.txt
+version: 2.7.0
+*/
+if(typeof YAHOO=="undefined"||!YAHOO){var YAHOO={};}YAHOO.namespace=function(){var A=arguments,E=null,C,B,D;for(C=0;C<A.length;C=C+1){D=(""+A[C]).split(".");E=YAHOO;for(B=(D[0]=="YAHOO")?1:0;B<D.length;B=B+1){E[D[B]]=E[D[B]]||{};E=E[D[B]];}}return E;};YAHOO.log=function(D,A,C){var B=YAHOO.widget.Logger;if(B&&B.log){return B.log(D,A,C);}else{return false;}};YAHOO.register=function(A,E,D){var I=YAHOO.env.modules,B,H,G,F,C;if(!I[A]){I[A]={versions:[],builds:[]};}B=I[A];H=D.version;G=D.build;F=YAHOO.env.listeners;B.name=A;B.version=H;B.build=G;B.versions.push(H);B.builds.push(G);B.mainClass=E;for(C=0;C<F.length;C=C+1){F[C](B);}if(E){E.VERSION=H;E.BUILD=G;}else{YAHOO.log("mainClass is undefined for module "+A,"warn");}};YAHOO.env=YAHOO.env||{modules:[],listeners:[]};YAHOO.env.getVersion=function(A){return YAHOO.env.modules[A]||null;};YAHOO.env.ua=function(){var C={ie:0,opera:0,gecko:0,webkit:0,mobile:null,air:0,caja:0},B=navigator.userAgent,A;if((/KHTML/).test(B)){C.webkit=1;}A=B.match(/AppleWebKit\/([^\s]*)/);if(A&&A[1]){C.webkit=parseFloat(A[1]);if(/ Mobile\//.test(B)){C.mobile="Apple";}else{A=B.match(/NokiaN[^\/]*/);if(A){C.mobile=A[0];}}A=B.match(/AdobeAIR\/([^\s]*)/);if(A){C.air=A[0];}}if(!C.webkit){A=B.match(/Opera[\s\/]([^\s]*)/);if(A&&A[1]){C.opera=parseFloat(A[1]);A=B.match(/Opera Mini[^;]*/);if(A){C.mobile=A[0];}}else{A=B.match(/MSIE\s([^;]*)/);if(A&&A[1]){C.ie=parseFloat(A[1]);}else{A=B.match(/Gecko\/([^\s]*)/);if(A){C.gecko=1;A=B.match(/rv:([^\s\)]*)/);if(A&&A[1]){C.gecko=parseFloat(A[1]);}}}}}A=B.match(/Caja\/([^\s]*)/);if(A&&A[1]){C.caja=parseFloat(A[1]);}return C;}();(function(){YAHOO.namespace("util","widget","example");if("undefined"!==typeof YAHOO_config){var B=YAHOO_config.listener,A=YAHOO.env.listeners,D=true,C;if(B){for(C=0;C<A.length;C=C+1){if(A[C]==B){D=false;break;}}if(D){A.push(B);}}}})();YAHOO.lang=YAHOO.lang||{};(function(){var B=YAHOO.lang,F="[object Array]",C="[object Function]",A=Object.prototype,E=["toString","valueOf"],D={isArray:function(G){return A.toString.apply(G)===F;},isBoolean:function(G){return typeof G==="boolean";},isFunction:function(G){return A.toString.apply(G)===C;},isNull:function(G){return G===null;},isNumber:function(G){return typeof G==="number"&&isFinite(G);},isObject:function(G){return(G&&(typeof G==="object"||B.isFunction(G)))||false;},isString:function(G){return typeof G==="string";},isUndefined:function(G){return typeof G==="undefined";},_IEEnumFix:(YAHOO.env.ua.ie)?function(I,H){var G,K,J;for(G=0;G<E.length;G=G+1){K=E[G];J=H[K];if(B.isFunction(J)&&J!=A[K]){I[K]=J;}}}:function(){},extend:function(J,K,I){if(!K||!J){throw new Error("extend failed, please check that "+"all dependencies are included.");}var H=function(){},G;H.prototype=K.prototype;J.prototype=new H();J.prototype.constructor=J;J.superclass=K.prototype;if(K.prototype.constructor==A.constructor){K.prototype.constructor=K;}if(I){for(G in I){if(B.hasOwnProperty(I,G)){J.prototype[G]=I[G];}}B._IEEnumFix(J.prototype,I);}},augmentObject:function(K,J){if(!J||!K){throw new Error("Absorb failed, verify dependencies.");}var G=arguments,I,L,H=G[2];if(H&&H!==true){for(I=2;I<G.length;I=I+1){K[G[I]]=J[G[I]];}}else{for(L in J){if(H||!(L in K)){K[L]=J[L];}}B._IEEnumFix(K,J);}},augmentProto:function(J,I){if(!I||!J){throw new Error("Augment failed, verify dependencies.");}var G=[J.prototype,I.prototype],H;for(H=2;H<arguments.length;H=H+1){G.push(arguments[H]);}B.augmentObject.apply(this,G);},dump:function(G,L){var I,K,N=[],O="{...}",H="f(){...}",M=", ",J=" => ";if(!B.isObject(G)){return G+"";}else{if(G instanceof Date||("nodeType" in G&&"tagName" in G)){return G;}else{if(B.isFunction(G)){return H;}}}L=(B.isNumber(L))?L:3;if(B.isArray(G)){N.push("[");for(I=0,K=G.length;I<K;I=I+1){if(B.isObject(G[I])){N.push((L>0)?B.dump(G[I],L-1):O);}else{N.push(G[I]);}N.push(M);}if(N.length>1){N.pop();}N.push("]");}else{N.push("{");for(I in G){if(B.hasOwnProperty(G,I)){N.push(I+J);if(B.isObject(G[I])){N.push((L>0)?B.dump(G[I],L-1):O);}else{N.push(G[I]);}N.push(M);}}if(N.length>1){N.pop();}N.push("}");}return N.join("");},substitute:function(V,H,O){var L,K,J,R,S,U,Q=[],I,M="dump",P=" ",G="{",T="}",N;for(;;){L=V.lastIndexOf(G);if(L<0){break;}K=V.indexOf(T,L);if(L+1>=K){break;}I=V.substring(L+1,K);R=I;U=null;J=R.indexOf(P);if(J>-1){U=R.substring(J+1);R=R.substring(0,J);}S=H[R];if(O){S=O(R,S,U);}if(B.isObject(S)){if(B.isArray(S)){S=B.dump(S,parseInt(U,10));}else{U=U||"";N=U.indexOf(M);if(N>-1){U=U.substring(4);}if(S.toString===A.toString||N>-1){S=B.dump(S,parseInt(U,10));}else{S=S.toString();}}}else{if(!B.isString(S)&&!B.isNumber(S)){S="~-"+Q.length+"-~";Q[Q.length]=I;}}V=V.substring(0,L)+S+V.substring(K+1);}for(L=Q.length-1;L>=0;L=L-1){V=V.replace(new RegExp("~-"+L+"-~"),"{"+Q[L]+"}","g");}return V;},trim:function(G){try{return G.replace(/^\s+|\s+$/g,"");}catch(H){return G;}},merge:function(){var J={},H=arguments,G=H.length,I;for(I=0;I<G;I=I+1){B.augmentObject(J,H[I],true);}return J;},later:function(N,H,O,J,K){N=N||0;H=H||{};var I=O,M=J,L,G;if(B.isString(O)){I=H[O];}if(!I){throw new TypeError("method undefined");}if(!B.isArray(M)){M=[J];}L=function(){I.apply(H,M);};G=(K)?setInterval(L,N):setTimeout(L,N);return{interval:K,cancel:function(){if(this.interval){clearInterval(G);}else{clearTimeout(G);}}};},isValue:function(G){return(B.isObject(G)||B.isString(G)||B.isNumber(G)||B.isBoolean(G));}};B.hasOwnProperty=(A.hasOwnProperty)?function(G,H){return G&&G.hasOwnProperty(H);}:function(G,H){return !B.isUndefined(G[H])&&G.constructor.prototype[H]!==G[H];};D.augmentObject(B,D,true);YAHOO.util.Lang=B;B.augment=B.augmentProto;YAHOO.augment=B.augmentProto;YAHOO.extend=B.extend;})();YAHOO.register("yahoo",YAHOO,{version:"2.7.0",build:"1796"});YAHOO.util.Get=function(){var M={},L=0,R=0,E=false,N=YAHOO.env.ua,S=YAHOO.lang;var J=function(W,T,X){var U=X||window,Y=U.document,Z=Y.createElement(W);for(var V in T){if(T[V]&&YAHOO.lang.hasOwnProperty(T,V)){Z.setAttribute(V,T[V]);}}return Z;};var I=function(T,U,W){var V=W||"utf-8";return J("link",{"id":"yui__dyn_"+(R++),"type":"text/css","charset":V,"rel":"stylesheet","href":T},U);
+};var P=function(T,U,W){var V=W||"utf-8";return J("script",{"id":"yui__dyn_"+(R++),"type":"text/javascript","charset":V,"src":T},U);};var A=function(T,U){return{tId:T.tId,win:T.win,data:T.data,nodes:T.nodes,msg:U,purge:function(){D(this.tId);}};};var B=function(T,W){var U=M[W],V=(S.isString(T))?U.win.document.getElementById(T):T;if(!V){Q(W,"target node not found: "+T);}return V;};var Q=function(W,V){var T=M[W];if(T.onFailure){var U=T.scope||T.win;T.onFailure.call(U,A(T,V));}};var C=function(W){var T=M[W];T.finished=true;if(T.aborted){var V="transaction "+W+" was aborted";Q(W,V);return;}if(T.onSuccess){var U=T.scope||T.win;T.onSuccess.call(U,A(T));}};var O=function(V){var T=M[V];if(T.onTimeout){var U=T.scope||T;T.onTimeout.call(U,A(T));}};var G=function(V,Z){var U=M[V];if(U.timer){U.timer.cancel();}if(U.aborted){var X="transaction "+V+" was aborted";Q(V,X);return;}if(Z){U.url.shift();if(U.varName){U.varName.shift();}}else{U.url=(S.isString(U.url))?[U.url]:U.url;if(U.varName){U.varName=(S.isString(U.varName))?[U.varName]:U.varName;}}var c=U.win,b=c.document,a=b.getElementsByTagName("head")[0],W;if(U.url.length===0){if(U.type==="script"&&N.webkit&&N.webkit<420&&!U.finalpass&&!U.varName){var Y=P(null,U.win,U.charset);Y.innerHTML='YAHOO.util.Get._finalize("'+V+'");';U.nodes.push(Y);a.appendChild(Y);}else{C(V);}return;}var T=U.url[0];if(!T){U.url.shift();return G(V);}if(U.timeout){U.timer=S.later(U.timeout,U,O,V);}if(U.type==="script"){W=P(T,c,U.charset);}else{W=I(T,c,U.charset);}F(U.type,W,V,T,c,U.url.length);U.nodes.push(W);if(U.insertBefore){var e=B(U.insertBefore,V);if(e){e.parentNode.insertBefore(W,e);}}else{a.appendChild(W);}if((N.webkit||N.gecko)&&U.type==="css"){G(V,T);}};var K=function(){if(E){return;}E=true;for(var T in M){var U=M[T];if(U.autopurge&&U.finished){D(U.tId);delete M[T];}}E=false;};var D=function(a){var X=M[a];if(X){var Z=X.nodes,T=Z.length,Y=X.win.document,W=Y.getElementsByTagName("head")[0];if(X.insertBefore){var V=B(X.insertBefore,a);if(V){W=V.parentNode;}}for(var U=0;U<T;U=U+1){W.removeChild(Z[U]);}X.nodes=[];}};var H=function(U,T,V){var X="q"+(L++);V=V||{};if(L%YAHOO.util.Get.PURGE_THRESH===0){K();}M[X]=S.merge(V,{tId:X,type:U,url:T,finished:false,aborted:false,nodes:[]});var W=M[X];W.win=W.win||window;W.scope=W.scope||W.win;W.autopurge=("autopurge" in W)?W.autopurge:(U==="script")?true:false;S.later(0,W,G,X);return{tId:X};};var F=function(c,X,W,U,Y,Z,b){var a=b||G;if(N.ie){X.onreadystatechange=function(){var d=this.readyState;if("loaded"===d||"complete"===d){X.onreadystatechange=null;a(W,U);}};}else{if(N.webkit){if(c==="script"){if(N.webkit>=420){X.addEventListener("load",function(){a(W,U);});}else{var T=M[W];if(T.varName){var V=YAHOO.util.Get.POLL_FREQ;T.maxattempts=YAHOO.util.Get.TIMEOUT/V;T.attempts=0;T._cache=T.varName[0].split(".");T.timer=S.later(V,T,function(j){var f=this._cache,e=f.length,d=this.win,g;for(g=0;g<e;g=g+1){d=d[f[g]];if(!d){this.attempts++;if(this.attempts++>this.maxattempts){var h="Over retry limit, giving up";T.timer.cancel();Q(W,h);}else{}return;}}T.timer.cancel();a(W,U);},null,true);}else{S.later(YAHOO.util.Get.POLL_FREQ,null,a,[W,U]);}}}}else{X.onload=function(){a(W,U);};}}};return{POLL_FREQ:10,PURGE_THRESH:20,TIMEOUT:2000,_finalize:function(T){S.later(0,null,C,T);},abort:function(U){var V=(S.isString(U))?U:U.tId;var T=M[V];if(T){T.aborted=true;}},script:function(T,U){return H("script",T,U);},css:function(T,U){return H("css",T,U);}};}();YAHOO.register("get",YAHOO.util.Get,{version:"2.7.0",build:"1796"});(function(){var Y=YAHOO,util=Y.util,lang=Y.lang,env=Y.env,PROV="_provides",SUPER="_supersedes",REQ="expanded",AFTER="_after";var YUI={dupsAllowed:{"yahoo":true,"get":true},info:{"root":"2.7.0/build/","base":"http://yui.yahooapis.com/2.7.0/build/","comboBase":"http://yui.yahooapis.com/combo?","skin":{"defaultSkin":"sam","base":"assets/skins/","path":"skin.css","after":["reset","fonts","grids","base"],"rollup":3},dupsAllowed:["yahoo","get"],"moduleInfo":{"animation":{"type":"js","path":"animation/animation-min.js","requires":["dom","event"]},"autocomplete":{"type":"js","path":"autocomplete/autocomplete-min.js","requires":["dom","event","datasource"],"optional":["connection","animation"],"skinnable":true},"base":{"type":"css","path":"base/base-min.css","after":["reset","fonts","grids"]},"button":{"type":"js","path":"button/button-min.js","requires":["element"],"optional":["menu"],"skinnable":true},"calendar":{"type":"js","path":"calendar/calendar-min.js","requires":["event","dom"],"skinnable":true},"carousel":{"type":"js","path":"carousel/carousel-min.js","requires":["element"],"optional":["animation"],"skinnable":true},"charts":{"type":"js","path":"charts/charts-min.js","requires":["element","json","datasource"]},"colorpicker":{"type":"js","path":"colorpicker/colorpicker-min.js","requires":["slider","element"],"optional":["animation"],"skinnable":true},"connection":{"type":"js","path":"connection/connection-min.js","requires":["event"]},"container":{"type":"js","path":"container/container-min.js","requires":["dom","event"],"optional":["dragdrop","animation","connection"],"supersedes":["containercore"],"skinnable":true},"containercore":{"type":"js","path":"container/container_core-min.js","requires":["dom","event"],"pkg":"container"},"cookie":{"type":"js","path":"cookie/cookie-min.js","requires":["yahoo"]},"datasource":{"type":"js","path":"datasource/datasource-min.js","requires":["event"],"optional":["connection"]},"datatable":{"type":"js","path":"datatable/datatable-min.js","requires":["element","datasource"],"optional":["calendar","dragdrop","paginator"],"skinnable":true},"dom":{"type":"js","path":"dom/dom-min.js","requires":["yahoo"]},"dragdrop":{"type":"js","path":"dragdrop/dragdrop-min.js","requires":["dom","event"]},"editor":{"type":"js","path":"editor/editor-min.js","requires":["menu","element","button"],"optional":["animation","dragdrop"],"supersedes":["simpleeditor"],"skinnable":true},"element":{"type":"js","path":"element/element-min.js","requires":["dom","event"]},"event":{"type":"js","path":"event/event-min.js","requires":["yahoo"]},"fonts":{"type":"css","path":"fonts/fonts-min.css"},"get":{"type":"js","path":"get/get-min.js","requires":["yahoo"]},"grids":{"type":"css","path":"grids/grids-min.css","requires":["fonts"],"optional":["reset"]},"history":{"type":"js","path":"history/history-min.js","requires":["event"]},"imagecropper":{"type":"js","path":"imagecropper/imagecropper-min.js","requires":["dom","event","dragdrop","element","resize"],"skinnable":true},"imageloader":{"type":"js","path":"imageloader/imageloader-min.js","requires":["event","dom"]},"json":{"type":"js","path":"json/json-min.js","requires":["yahoo"]},"layout":{"type":"js","path":"layout/layout-min.js","requires":["dom","event","element"],"optional":["animation","dragdrop","resize","selector"],"skinnable":true},"logger":{"type":"js","path":"logger/logger-min.js","requires":["event","dom"],"optional":["dragdrop"],"skinnable":true},"menu":{"type":"js","path":"menu/menu-min.js","requires":["containercore"],"skinnable":true},"paginator":{"type":"js","path":"paginator/paginator-min.js","requires":["element"],"skinnable":true},"profiler":{"type":"js","path":"profiler/profiler-min.js","requires":["yahoo"]},"profilerviewer":{"type":"js","path":"profilerviewer/profilerviewer-min.js","requires":["profiler","yuiloader","element"],"skinnable":true},"reset":{"type":"css","path":"reset/reset-min.css"},"reset-fonts-grids":{"type":"css","path":"reset-fonts-grids/reset-fonts-grids.css","supersedes":["reset","fonts","grids","reset-fonts"],"rollup":4},"reset-fonts":{"type":"css","path":"reset-fonts/reset-fonts.css","supersedes":["reset","fonts"],"rollup":2},"resize":{"type":"js","path":"resize/resize-min.js","requires":["dom","event","dragdrop","element"],"optional":["animation"],"skinnable":true},"selector":{"type":"js","path":"selector/selector-min.js","requires":["yahoo","dom"]},"simpleeditor":{"type":"js","path":"editor/simpleeditor-min.js","requires":["element"],"optional":["containercore","menu","button","animation","dragdrop"],"skinnable":true,"pkg":"editor"},"slider":{"type":"js","path":"slider/slider-min.js","requires":["dragdrop"],"optional":["animation"],"skinnable":true},"stylesheet":{"type":"js","path":"stylesheet/stylesheet-min.js","requires":["yahoo"]},"tabview":{"type":"js","path":"tabview/tabview-min.js","requires":["element"],"optional":["connection"],"skinnable":true},"treeview":{"type":"js","path":"treeview/treeview-min.js","requires":["event","dom"],"optional":["json"],"skinnable":true},"uploader":{"type":"js","path":"uploader/uploader.js","requires":["element"]},"utilities":{"type":"js","path":"utilities/utilities.js","supersedes":["yahoo","event","dragdrop","animation","dom","connection","element","yahoo-dom-event","get","yuiloader","yuiloader-dom-event"],"rollup":8},"yahoo":{"type":"js","path":"yahoo/yahoo-min.js"},"yahoo-dom-event":{"type":"js","path":"yahoo-dom-event/yahoo-dom-event.js","supersedes":["yahoo","event","dom"],"rollup":3},"yuiloader":{"type":"js","path":"yuiloader/yuiloader-min.js","supersedes":["yahoo","get"]},"yuiloader-dom-event":{"type":"js","path":"yuiloader-dom-event/yuiloader-dom-event.js","supersedes":["yahoo","dom","event","get","yuiloader","yahoo-dom-event"],"rollup":5},"yuitest":{"type":"js","path":"yuitest/yuitest-min.js","requires":["logger"],"skinnable":true}}},ObjectUtil:{appendArray:function(o,a){if(a){for(var i=0;
+i<a.length;i=i+1){o[a[i]]=true;}}},keys:function(o,ordered){var a=[],i;for(i in o){if(lang.hasOwnProperty(o,i)){a.push(i);}}return a;}},ArrayUtil:{appendArray:function(a1,a2){Array.prototype.push.apply(a1,a2);},indexOf:function(a,val){for(var i=0;i<a.length;i=i+1){if(a[i]===val){return i;}}return -1;},toObject:function(a){var o={};for(var i=0;i<a.length;i=i+1){o[a[i]]=true;}return o;},uniq:function(a){return YUI.ObjectUtil.keys(YUI.ArrayUtil.toObject(a));}}};YAHOO.util.YUILoader=function(o){this._internalCallback=null;this._useYahooListener=false;this.onSuccess=null;this.onFailure=Y.log;this.onProgress=null;this.onTimeout=null;this.scope=this;this.data=null;this.insertBefore=null;this.charset=null;this.varName=null;this.base=YUI.info.base;this.comboBase=YUI.info.comboBase;this.combine=false;this.root=YUI.info.root;this.timeout=0;this.ignore=null;this.force=null;this.allowRollup=true;this.filter=null;this.required={};this.moduleInfo=lang.merge(YUI.info.moduleInfo);this.rollups=null;this.loadOptional=false;this.sorted=[];this.loaded={};this.dirty=true;this.inserted={};var self=this;env.listeners.push(function(m){if(self._useYahooListener){self.loadNext(m.name);}});this.skin=lang.merge(YUI.info.skin);this._config(o);};Y.util.YUILoader.prototype={FILTERS:{RAW:{"searchExp":"-min\\.js","replaceStr":".js"},DEBUG:{"searchExp":"-min\\.js","replaceStr":"-debug.js"}},SKIN_PREFIX:"skin-",_config:function(o){if(o){for(var i in o){if(lang.hasOwnProperty(o,i)){if(i=="require"){this.require(o[i]);}else{this[i]=o[i];}}}}var f=this.filter;if(lang.isString(f)){f=f.toUpperCase();if(f==="DEBUG"){this.require("logger");}if(!Y.widget.LogWriter){Y.widget.LogWriter=function(){return Y;};}this.filter=this.FILTERS[f];}},addModule:function(o){if(!o||!o.name||!o.type||(!o.path&&!o.fullpath)){return false;}o.ext=("ext" in o)?o.ext:true;o.requires=o.requires||[];this.moduleInfo[o.name]=o;this.dirty=true;return true;},require:function(what){var a=(typeof what==="string")?arguments:what;this.dirty=true;YUI.ObjectUtil.appendArray(this.required,a);},_addSkin:function(skin,mod){var name=this.formatSkin(skin),info=this.moduleInfo,sinf=this.skin,ext=info[mod]&&info[mod].ext;if(!info[name]){this.addModule({"name":name,"type":"css","path":sinf.base+skin+"/"+sinf.path,"after":sinf.after,"rollup":sinf.rollup,"ext":ext});}if(mod){name=this.formatSkin(skin,mod);if(!info[name]){var mdef=info[mod],pkg=mdef.pkg||mod;this.addModule({"name":name,"type":"css","after":sinf.after,"path":pkg+"/"+sinf.base+skin+"/"+mod+".css","ext":ext});}}return name;},getRequires:function(mod){if(!mod){return[];}if(!this.dirty&&mod.expanded){return mod.expanded;}mod.requires=mod.requires||[];var i,d=[],r=mod.requires,o=mod.optional,info=this.moduleInfo,m;for(i=0;i<r.length;i=i+1){d.push(r[i]);m=info[r[i]];YUI.ArrayUtil.appendArray(d,this.getRequires(m));}if(o&&this.loadOptional){for(i=0;i<o.length;i=i+1){d.push(o[i]);YUI.ArrayUtil.appendArray(d,this.getRequires(info[o[i]]));}}mod.expanded=YUI.ArrayUtil.uniq(d);return mod.expanded;},getProvides:function(name,notMe){var addMe=!(notMe),ckey=(addMe)?PROV:SUPER,m=this.moduleInfo[name],o={};if(!m){return o;}if(m[ckey]){return m[ckey];}var s=m.supersedes,done={},me=this;var add=function(mm){if(!done[mm]){done[mm]=true;lang.augmentObject(o,me.getProvides(mm));}};if(s){for(var i=0;i<s.length;i=i+1){add(s[i]);}}m[SUPER]=o;m[PROV]=lang.merge(o);m[PROV][name]=true;return m[ckey];},calculate:function(o){if(o||this.dirty){this._config(o);this._setup();this._explode();if(this.allowRollup){this._rollup();}this._reduce();this._sort();this.dirty=false;}},_setup:function(){var info=this.moduleInfo,name,i,j;for(name in info){if(lang.hasOwnProperty(info,name)){var m=info[name];if(m&&m.skinnable){var o=this.skin.overrides,smod;if(o&&o[name]){for(i=0;i<o[name].length;i=i+1){smod=this._addSkin(o[name][i],name);}}else{smod=this._addSkin(this.skin.defaultSkin,name);}m.requires.push(smod);}}}var l=lang.merge(this.inserted);if(!this._sandbox){l=lang.merge(l,env.modules);}if(this.ignore){YUI.ObjectUtil.appendArray(l,this.ignore);}if(this.force){for(i=0;i<this.force.length;i=i+1){if(this.force[i] in l){delete l[this.force[i]];}}}for(j in l){if(lang.hasOwnProperty(l,j)){lang.augmentObject(l,this.getProvides(j));}}this.loaded=l;},_explode:function(){var r=this.required,i,mod;for(i in r){if(lang.hasOwnProperty(r,i)){mod=this.moduleInfo[i];if(mod){var req=this.getRequires(mod);if(req){YUI.ObjectUtil.appendArray(r,req);}}}}},_skin:function(){},formatSkin:function(skin,mod){var s=this.SKIN_PREFIX+skin;if(mod){s=s+"-"+mod;}return s;},parseSkin:function(mod){if(mod.indexOf(this.SKIN_PREFIX)===0){var a=mod.split("-");return{skin:a[1],module:a[2]};}return null;},_rollup:function(){var i,j,m,s,rollups={},r=this.required,roll,info=this.moduleInfo;if(this.dirty||!this.rollups){for(i in info){if(lang.hasOwnProperty(info,i)){m=info[i];if(m&&m.rollup){rollups[i]=m;}}}this.rollups=rollups;}for(;;){var rolled=false;for(i in rollups){if(!r[i]&&!this.loaded[i]){m=info[i];s=m.supersedes;roll=false;if(!m.rollup){continue;}var skin=(m.ext)?false:this.parseSkin(i),c=0;if(skin){for(j in r){if(lang.hasOwnProperty(r,j)){if(i!==j&&this.parseSkin(j)){c++;roll=(c>=m.rollup);if(roll){break;}}}}}else{for(j=0;j<s.length;j=j+1){if(this.loaded[s[j]]&&(!YUI.dupsAllowed[s[j]])){roll=false;break;}else{if(r[s[j]]){c++;roll=(c>=m.rollup);if(roll){break;}}}}}if(roll){r[i]=true;rolled=true;this.getRequires(m);}}}if(!rolled){break;}}},_reduce:function(){var i,j,s,m,r=this.required;for(i in r){if(i in this.loaded){delete r[i];}else{var skinDef=this.parseSkin(i);if(skinDef){if(!skinDef.module){var skin_pre=this.SKIN_PREFIX+skinDef.skin;for(j in r){if(lang.hasOwnProperty(r,j)){m=this.moduleInfo[j];var ext=m&&m.ext;if(!ext&&j!==i&&j.indexOf(skin_pre)>-1){delete r[j];}}}}}else{m=this.moduleInfo[i];s=m&&m.supersedes;if(s){for(j=0;j<s.length;j=j+1){if(s[j] in r){delete r[s[j]];}}}}}}},_onFailure:function(msg){YAHOO.log("Failure","info","loader");var f=this.onFailure;if(f){f.call(this.scope,{msg:"failure: "+msg,data:this.data,success:false});
+}},_onTimeout:function(){YAHOO.log("Timeout","info","loader");var f=this.onTimeout;if(f){f.call(this.scope,{msg:"timeout",data:this.data,success:false});}},_sort:function(){var s=[],info=this.moduleInfo,loaded=this.loaded,checkOptional=!this.loadOptional,me=this;var requires=function(aa,bb){var mm=info[aa];if(loaded[bb]||!mm){return false;}var ii,rr=mm.expanded,after=mm.after,other=info[bb],optional=mm.optional;if(rr&&YUI.ArrayUtil.indexOf(rr,bb)>-1){return true;}if(after&&YUI.ArrayUtil.indexOf(after,bb)>-1){return true;}if(checkOptional&&optional&&YUI.ArrayUtil.indexOf(optional,bb)>-1){return true;}var ss=info[bb]&&info[bb].supersedes;if(ss){for(ii=0;ii<ss.length;ii=ii+1){if(requires(aa,ss[ii])){return true;}}}if(mm.ext&&mm.type=="css"&&!other.ext&&other.type=="css"){return true;}return false;};for(var i in this.required){if(lang.hasOwnProperty(this.required,i)){s.push(i);}}var p=0;for(;;){var l=s.length,a,b,j,k,moved=false;for(j=p;j<l;j=j+1){a=s[j];for(k=j+1;k<l;k=k+1){if(requires(a,s[k])){b=s.splice(k,1);s.splice(j,0,b[0]);moved=true;break;}}if(moved){break;}else{p=p+1;}}if(!moved){break;}}this.sorted=s;},toString:function(){var o={type:"YUILoader",base:this.base,filter:this.filter,required:this.required,loaded:this.loaded,inserted:this.inserted};lang.dump(o,1);},_combine:function(){this._combining=[];var self=this,s=this.sorted,len=s.length,js=this.comboBase,css=this.comboBase,target,startLen=js.length,i,m,type=this.loadType;YAHOO.log("type "+type);for(i=0;i<len;i=i+1){m=this.moduleInfo[s[i]];if(m&&!m.ext&&(!type||type===m.type)){target=this.root+m.path;target+="&";if(m.type=="js"){js+=target;}else{css+=target;}this._combining.push(s[i]);}}if(this._combining.length){YAHOO.log("Attempting to combine: "+this._combining,"info","loader");var callback=function(o){var c=this._combining,len=c.length,i,m;for(i=0;i<len;i=i+1){this.inserted[c[i]]=true;}this.loadNext(o.data);},loadScript=function(){if(js.length>startLen){YAHOO.util.Get.script(self._filter(js),{data:self._loading,onSuccess:callback,onFailure:self._onFailure,onTimeout:self._onTimeout,insertBefore:self.insertBefore,charset:self.charset,timeout:self.timeout,scope:self});}};if(css.length>startLen){YAHOO.util.Get.css(this._filter(css),{data:this._loading,onSuccess:loadScript,onFailure:this._onFailure,onTimeout:this._onTimeout,insertBefore:this.insertBefore,charset:this.charset,timeout:this.timeout,scope:self});}else{loadScript();}return;}else{this.loadNext(this._loading);}},insert:function(o,type){this.calculate(o);this._loading=true;this.loadType=type;if(this.combine){return this._combine();}if(!type){var self=this;this._internalCallback=function(){self._internalCallback=null;self.insert(null,"js");};this.insert(null,"css");return;}this.loadNext();},sandbox:function(o,type){this._config(o);if(!this.onSuccess){throw new Error("You must supply an onSuccess handler for your sandbox");}this._sandbox=true;var self=this;if(!type||type!=="js"){this._internalCallback=function(){self._internalCallback=null;self.sandbox(null,"js");};this.insert(null,"css");return;}if(!util.Connect){var ld=new YAHOO.util.YUILoader();ld.insert({base:this.base,filter:this.filter,require:"connection",insertBefore:this.insertBefore,charset:this.charset,onSuccess:function(){this.sandbox(null,"js");},scope:this},"js");return;}this._scriptText=[];this._loadCount=0;this._stopCount=this.sorted.length;this._xhr=[];this.calculate();var s=this.sorted,l=s.length,i,m,url;for(i=0;i<l;i=i+1){m=this.moduleInfo[s[i]];if(!m){this._onFailure("undefined module "+m);for(var j=0;j<this._xhr.length;j=j+1){this._xhr[j].abort();}return;}if(m.type!=="js"){this._loadCount++;continue;}url=m.fullpath;url=(url)?this._filter(url):this._url(m.path);var xhrData={success:function(o){var idx=o.argument[0],name=o.argument[2];this._scriptText[idx]=o.responseText;if(this.onProgress){this.onProgress.call(this.scope,{name:name,scriptText:o.responseText,xhrResponse:o,data:this.data});}this._loadCount++;if(this._loadCount>=this._stopCount){var v=this.varName||"YAHOO";var t="(function() {\n";var b="\nreturn "+v+";\n})();";var ref=eval(t+this._scriptText.join("\n")+b);this._pushEvents(ref);if(ref){this.onSuccess.call(this.scope,{reference:ref,data:this.data});}else{this._onFailure.call(this.varName+" reference failure");}}},failure:function(o){this.onFailure.call(this.scope,{msg:"XHR failure",xhrResponse:o,data:this.data});},scope:this,argument:[i,url,s[i]]};this._xhr.push(util.Connect.asyncRequest("GET",url,xhrData));}},loadNext:function(mname){if(!this._loading){return;}if(mname){if(mname!==this._loading){return;}this.inserted[mname]=true;if(this.onProgress){this.onProgress.call(this.scope,{name:mname,data:this.data});}}var s=this.sorted,len=s.length,i,m;for(i=0;i<len;i=i+1){if(s[i] in this.inserted){continue;}if(s[i]===this._loading){return;}m=this.moduleInfo[s[i]];if(!m){this.onFailure.call(this.scope,{msg:"undefined module "+m,data:this.data});return;}if(!this.loadType||this.loadType===m.type){this._loading=s[i];var fn=(m.type==="css")?util.Get.css:util.Get.script,url=m.fullpath,self=this,c=function(o){self.loadNext(o.data);};url=(url)?this._filter(url):this._url(m.path);if(env.ua.webkit&&env.ua.webkit<420&&m.type==="js"&&!m.varName){c=null;this._useYahooListener=true;}fn(url,{data:s[i],onSuccess:c,onFailure:this._onFailure,onTimeout:this._onTimeout,insertBefore:this.insertBefore,charset:this.charset,timeout:this.timeout,varName:m.varName,scope:self});return;}}this._loading=null;if(this._internalCallback){var f=this._internalCallback;this._internalCallback=null;f.call(this);}else{if(this.onSuccess){this._pushEvents();this.onSuccess.call(this.scope,{data:this.data});}}},_pushEvents:function(ref){var r=ref||YAHOO;if(r.util&&r.util.Event){r.util.Event._load();}},_filter:function(str){var f=this.filter;return(f)?str.replace(new RegExp(f.searchExp,"g"),f.replaceStr):str;},_url:function(path){return this._filter((this.base||"")+path);}};})();YAHOO.register("yuiloader",YAHOO.util.YUILoader,{version:"2.7.0",build:"1796"});
+(function(){YAHOO.env._id_counter=YAHOO.env._id_counter||0;var E=YAHOO.util,L=YAHOO.lang,m=YAHOO.env.ua,A=YAHOO.lang.trim,d={},h={},N=/^t(?:able|d|h)$/i,X=/color$/i,K=window.document,W=K.documentElement,e="ownerDocument",n="defaultView",v="documentElement",t="compatMode",b="offsetLeft",P="offsetTop",u="offsetParent",Z="parentNode",l="nodeType",C="tagName",O="scrollLeft",i="scrollTop",Q="getBoundingClientRect",w="getComputedStyle",a="currentStyle",M="CSS1Compat",c="BackCompat",g="class",F="className",J="",B=" ",s="(?:^|\\s)",k="(?= |$)",U="g",p="position",f="fixed",V="relative",j="left",o="top",r="medium",q="borderLeftWidth",R="borderTopWidth",D=m.opera,I=m.webkit,H=m.gecko,T=m.ie;E.Dom={CUSTOM_ATTRIBUTES:(!W.hasAttribute)?{"for":"htmlFor","class":F}:{"htmlFor":"for","className":g},get:function(y){var AA,Y,z,x,G;if(y){if(y[l]||y.item){return y;}if(typeof y==="string"){AA=y;y=K.getElementById(y);if(y&&y.id===AA){return y;}else{if(y&&K.all){y=null;Y=K.all[AA];for(x=0,G=Y.length;x<G;++x){if(Y[x].id===AA){return Y[x];}}}}return y;}if(y.DOM_EVENTS){y=y.get("element");}if("length" in y){z=[];for(x=0,G=y.length;x<G;++x){z[z.length]=E.Dom.get(y[x]);}return z;}return y;}return null;},getComputedStyle:function(G,Y){if(window[w]){return G[e][n][w](G,null)[Y];}else{if(G[a]){return E.Dom.IE_ComputedStyle.get(G,Y);}}},getStyle:function(G,Y){return E.Dom.batch(G,E.Dom._getStyle,Y);},_getStyle:function(){if(window[w]){return function(G,y){y=(y==="float")?y="cssFloat":E.Dom._toCamel(y);var x=G.style[y],Y;if(!x){Y=G[e][n][w](G,null);if(Y){x=Y[y];}}return x;};}else{if(W[a]){return function(G,y){var x;switch(y){case"opacity":x=100;try{x=G.filters["DXImageTransform.Microsoft.Alpha"].opacity;}catch(z){try{x=G.filters("alpha").opacity;}catch(Y){}}return x/100;case"float":y="styleFloat";default:y=E.Dom._toCamel(y);x=G[a]?G[a][y]:null;return(G.style[y]||x);}};}}}(),setStyle:function(G,Y,x){E.Dom.batch(G,E.Dom._setStyle,{prop:Y,val:x});},_setStyle:function(){if(T){return function(Y,G){var x=E.Dom._toCamel(G.prop),y=G.val;if(Y){switch(x){case"opacity":if(L.isString(Y.style.filter)){Y.style.filter="alpha(opacity="+y*100+")";if(!Y[a]||!Y[a].hasLayout){Y.style.zoom=1;}}break;case"float":x="styleFloat";default:Y.style[x]=y;}}else{}};}else{return function(Y,G){var x=E.Dom._toCamel(G.prop),y=G.val;if(Y){if(x=="float"){x="cssFloat";}Y.style[x]=y;}else{}};}}(),getXY:function(G){return E.Dom.batch(G,E.Dom._getXY);},_canPosition:function(G){return(E.Dom._getStyle(G,"display")!=="none"&&E.Dom._inDoc(G));},_getXY:function(){if(K[v][Q]){return function(y){var z,Y,AA,AF,AE,AD,AC,G,x,AB=Math.floor,AG=false;if(E.Dom._canPosition(y)){AA=y[Q]();AF=y[e];z=E.Dom.getDocumentScrollLeft(AF);Y=E.Dom.getDocumentScrollTop(AF);AG=[AB(AA[j]),AB(AA[o])];if(T&&m.ie<8){AE=2;AD=2;AC=AF[t];G=S(AF[v],q);x=S(AF[v],R);if(m.ie===6){if(AC!==c){AE=0;AD=0;}}if((AC==c)){if(G!==r){AE=parseInt(G,10);}if(x!==r){AD=parseInt(x,10);}}AG[0]-=AE;AG[1]-=AD;}if((Y||z)){AG[0]+=z;AG[1]+=Y;}AG[0]=AB(AG[0]);AG[1]=AB(AG[1]);}else{}return AG;};}else{return function(y){var x,Y,AA,AB,AC,z=false,G=y;if(E.Dom._canPosition(y)){z=[y[b],y[P]];x=E.Dom.getDocumentScrollLeft(y[e]);Y=E.Dom.getDocumentScrollTop(y[e]);AC=((H||m.webkit>519)?true:false);while((G=G[u])){z[0]+=G[b];z[1]+=G[P];if(AC){z=E.Dom._calcBorders(G,z);}}if(E.Dom._getStyle(y,p)!==f){G=y;while((G=G[Z])&&G[C]){AA=G[i];AB=G[O];if(H&&(E.Dom._getStyle(G,"overflow")!=="visible")){z=E.Dom._calcBorders(G,z);}if(AA||AB){z[0]-=AB;z[1]-=AA;}}z[0]+=x;z[1]+=Y;}else{if(D){z[0]-=x;z[1]-=Y;}else{if(I||H){z[0]+=x;z[1]+=Y;}}}z[0]=Math.floor(z[0]);z[1]=Math.floor(z[1]);}else{}return z;};}}(),getX:function(G){var Y=function(x){return E.Dom.getXY(x)[0];};return E.Dom.batch(G,Y,E.Dom,true);},getY:function(G){var Y=function(x){return E.Dom.getXY(x)[1];};return E.Dom.batch(G,Y,E.Dom,true);},setXY:function(G,x,Y){E.Dom.batch(G,E.Dom._setXY,{pos:x,noRetry:Y});},_setXY:function(G,z){var AA=E.Dom._getStyle(G,p),y=E.Dom.setStyle,AD=z.pos,Y=z.noRetry,AB=[parseInt(E.Dom.getComputedStyle(G,j),10),parseInt(E.Dom.getComputedStyle(G,o),10)],AC,x;if(AA=="static"){AA=V;y(G,p,AA);}AC=E.Dom._getXY(G);if(!AD||AC===false){return false;}if(isNaN(AB[0])){AB[0]=(AA==V)?0:G[b];}if(isNaN(AB[1])){AB[1]=(AA==V)?0:G[P];}if(AD[0]!==null){y(G,j,AD[0]-AC[0]+AB[0]+"px");}if(AD[1]!==null){y(G,o,AD[1]-AC[1]+AB[1]+"px");}if(!Y){x=E.Dom._getXY(G);if((AD[0]!==null&&x[0]!=AD[0])||(AD[1]!==null&&x[1]!=AD[1])){E.Dom._setXY(G,{pos:AD,noRetry:true});}}},setX:function(Y,G){E.Dom.setXY(Y,[G,null]);},setY:function(G,Y){E.Dom.setXY(G,[null,Y]);},getRegion:function(G){var Y=function(x){var y=false;if(E.Dom._canPosition(x)){y=E.Region.getRegion(x);}else{}return y;};return E.Dom.batch(G,Y,E.Dom,true);},getClientWidth:function(){return E.Dom.getViewportWidth();},getClientHeight:function(){return E.Dom.getViewportHeight();},getElementsByClassName:function(AB,AF,AC,AE,x,AD){AB=L.trim(AB);AF=AF||"*";AC=(AC)?E.Dom.get(AC):null||K;if(!AC){return[];}var Y=[],G=AC.getElementsByTagName(AF),z=E.Dom.hasClass;for(var y=0,AA=G.length;y<AA;++y){if(z(G[y],AB)){Y[Y.length]=G[y];}}if(AE){E.Dom.batch(Y,AE,x,AD);}return Y;},hasClass:function(Y,G){return E.Dom.batch(Y,E.Dom._hasClass,G);},_hasClass:function(x,Y){var G=false,y;if(x&&Y){y=E.Dom.getAttribute(x,F)||J;if(Y.exec){G=Y.test(y);}else{G=Y&&(B+y+B).indexOf(B+Y+B)>-1;}}else{}return G;},addClass:function(Y,G){return E.Dom.batch(Y,E.Dom._addClass,G);},_addClass:function(x,Y){var G=false,y;if(x&&Y){y=E.Dom.getAttribute(x,F)||J;if(!E.Dom._hasClass(x,Y)){E.Dom.setAttribute(x,F,A(y+B+Y));G=true;}}else{}return G;},removeClass:function(Y,G){return E.Dom.batch(Y,E.Dom._removeClass,G);},_removeClass:function(y,x){var Y=false,AA,z,G;if(y&&x){AA=E.Dom.getAttribute(y,F)||J;E.Dom.setAttribute(y,F,AA.replace(E.Dom._getClassRegex(x),J));z=E.Dom.getAttribute(y,F);if(AA!==z){E.Dom.setAttribute(y,F,A(z));Y=true;if(E.Dom.getAttribute(y,F)===""){G=(y.hasAttribute&&y.hasAttribute(g))?g:F;y.removeAttribute(G);}}}else{}return Y;},replaceClass:function(x,Y,G){return E.Dom.batch(x,E.Dom._replaceClass,{from:Y,to:G});
+},_replaceClass:function(y,x){var Y,AB,AA,G=false,z;if(y&&x){AB=x.from;AA=x.to;if(!AA){G=false;}else{if(!AB){G=E.Dom._addClass(y,x.to);}else{if(AB!==AA){z=E.Dom.getAttribute(y,F)||J;Y=(B+z.replace(E.Dom._getClassRegex(AB),B+AA)).split(E.Dom._getClassRegex(AA));Y.splice(1,0,B+AA);E.Dom.setAttribute(y,F,A(Y.join(J)));G=true;}}}}else{}return G;},generateId:function(G,x){x=x||"yui-gen";var Y=function(y){if(y&&y.id){return y.id;}var z=x+YAHOO.env._id_counter++;if(y){if(y[e].getElementById(z)){return E.Dom.generateId(y,z+x);}y.id=z;}return z;};return E.Dom.batch(G,Y,E.Dom,true)||Y.apply(E.Dom,arguments);},isAncestor:function(Y,x){Y=E.Dom.get(Y);x=E.Dom.get(x);var G=false;if((Y&&x)&&(Y[l]&&x[l])){if(Y.contains&&Y!==x){G=Y.contains(x);}else{if(Y.compareDocumentPosition){G=!!(Y.compareDocumentPosition(x)&16);}}}else{}return G;},inDocument:function(G,Y){return E.Dom._inDoc(E.Dom.get(G),Y);},_inDoc:function(Y,x){var G=false;if(Y&&Y[C]){x=x||Y[e];G=E.Dom.isAncestor(x[v],Y);}else{}return G;},getElementsBy:function(Y,AF,AB,AD,y,AC,AE){AF=AF||"*";AB=(AB)?E.Dom.get(AB):null||K;if(!AB){return[];}var x=[],G=AB.getElementsByTagName(AF);for(var z=0,AA=G.length;z<AA;++z){if(Y(G[z])){if(AE){x=G[z];break;}else{x[x.length]=G[z];}}}if(AD){E.Dom.batch(x,AD,y,AC);}return x;},getElementBy:function(x,G,Y){return E.Dom.getElementsBy(x,G,Y,null,null,null,true);},batch:function(x,AB,AA,z){var y=[],Y=(z)?AA:window;x=(x&&(x[C]||x.item))?x:E.Dom.get(x);if(x&&AB){if(x[C]||x.length===undefined){return AB.call(Y,x,AA);}for(var G=0;G<x.length;++G){y[y.length]=AB.call(Y,x[G],AA);}}else{return false;}return y;},getDocumentHeight:function(){var Y=(K[t]!=M||I)?K.body.scrollHeight:W.scrollHeight,G=Math.max(Y,E.Dom.getViewportHeight());return G;},getDocumentWidth:function(){var Y=(K[t]!=M||I)?K.body.scrollWidth:W.scrollWidth,G=Math.max(Y,E.Dom.getViewportWidth());return G;},getViewportHeight:function(){var G=self.innerHeight,Y=K[t];if((Y||T)&&!D){G=(Y==M)?W.clientHeight:K.body.clientHeight;}return G;},getViewportWidth:function(){var G=self.innerWidth,Y=K[t];if(Y||T){G=(Y==M)?W.clientWidth:K.body.clientWidth;}return G;},getAncestorBy:function(G,Y){while((G=G[Z])){if(E.Dom._testElement(G,Y)){return G;}}return null;},getAncestorByClassName:function(Y,G){Y=E.Dom.get(Y);if(!Y){return null;}var x=function(y){return E.Dom.hasClass(y,G);};return E.Dom.getAncestorBy(Y,x);},getAncestorByTagName:function(Y,G){Y=E.Dom.get(Y);if(!Y){return null;}var x=function(y){return y[C]&&y[C].toUpperCase()==G.toUpperCase();};return E.Dom.getAncestorBy(Y,x);},getPreviousSiblingBy:function(G,Y){while(G){G=G.previousSibling;if(E.Dom._testElement(G,Y)){return G;}}return null;},getPreviousSibling:function(G){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getPreviousSiblingBy(G);},getNextSiblingBy:function(G,Y){while(G){G=G.nextSibling;if(E.Dom._testElement(G,Y)){return G;}}return null;},getNextSibling:function(G){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getNextSiblingBy(G);},getFirstChildBy:function(G,x){var Y=(E.Dom._testElement(G.firstChild,x))?G.firstChild:null;return Y||E.Dom.getNextSiblingBy(G.firstChild,x);},getFirstChild:function(G,Y){G=E.Dom.get(G);if(!G){return null;}return E.Dom.getFirstChildBy(G);},getLastChildBy:function(G,x){if(!G){return null;}var Y=(E.Dom._testElement(G.lastChild,x))?G.lastChild:null;return Y||E.Dom.getPreviousSiblingBy(G.lastChild,x);},getLastChild:function(G){G=E.Dom.get(G);return E.Dom.getLastChildBy(G);},getChildrenBy:function(Y,y){var x=E.Dom.getFirstChildBy(Y,y),G=x?[x]:[];E.Dom.getNextSiblingBy(x,function(z){if(!y||y(z)){G[G.length]=z;}return false;});return G;},getChildren:function(G){G=E.Dom.get(G);if(!G){}return E.Dom.getChildrenBy(G);},getDocumentScrollLeft:function(G){G=G||K;return Math.max(G[v].scrollLeft,G.body.scrollLeft);},getDocumentScrollTop:function(G){G=G||K;return Math.max(G[v].scrollTop,G.body.scrollTop);},insertBefore:function(Y,G){Y=E.Dom.get(Y);G=E.Dom.get(G);if(!Y||!G||!G[Z]){return null;}return G[Z].insertBefore(Y,G);},insertAfter:function(Y,G){Y=E.Dom.get(Y);G=E.Dom.get(G);if(!Y||!G||!G[Z]){return null;}if(G.nextSibling){return G[Z].insertBefore(Y,G.nextSibling);}else{return G[Z].appendChild(Y);}},getClientRegion:function(){var x=E.Dom.getDocumentScrollTop(),Y=E.Dom.getDocumentScrollLeft(),y=E.Dom.getViewportWidth()+Y,G=E.Dom.getViewportHeight()+x;return new E.Region(x,y,G,Y);},setAttribute:function(Y,G,x){G=E.Dom.CUSTOM_ATTRIBUTES[G]||G;Y.setAttribute(G,x);},getAttribute:function(Y,G){G=E.Dom.CUSTOM_ATTRIBUTES[G]||G;return Y.getAttribute(G);},_toCamel:function(Y){var x=d;function G(y,z){return z.toUpperCase();}return x[Y]||(x[Y]=Y.indexOf("-")===-1?Y:Y.replace(/-([a-z])/gi,G));},_getClassRegex:function(Y){var G;if(Y!==undefined){if(Y.exec){G=Y;}else{G=h[Y];if(!G){Y=Y.replace(E.Dom._patterns.CLASS_RE_TOKENS,"\\$1");G=h[Y]=new RegExp(s+Y+k,U);}}}return G;},_patterns:{ROOT_TAG:/^body|html$/i,CLASS_RE_TOKENS:/([\.\(\)\^\$\*\+\?\|\[\]\{\}])/g},_testElement:function(G,Y){return G&&G[l]==1&&(!Y||Y(G));},_calcBorders:function(x,y){var Y=parseInt(E.Dom[w](x,R),10)||0,G=parseInt(E.Dom[w](x,q),10)||0;if(H){if(N.test(x[C])){Y=0;G=0;}}y[0]+=G;y[1]+=Y;return y;}};var S=E.Dom[w];if(m.opera){E.Dom[w]=function(Y,G){var x=S(Y,G);if(X.test(G)){x=E.Dom.Color.toRGB(x);}return x;};}if(m.webkit){E.Dom[w]=function(Y,G){var x=S(Y,G);if(x==="rgba(0, 0, 0, 0)"){x="transparent";}return x;};}})();YAHOO.util.Region=function(C,D,A,B){this.top=C;this.y=C;this[1]=C;this.right=D;this.bottom=A;this.left=B;this.x=B;this[0]=B;this.width=this.right-this.left;this.height=this.bottom-this.top;};YAHOO.util.Region.prototype.contains=function(A){return(A.left>=this.left&&A.right<=this.right&&A.top>=this.top&&A.bottom<=this.bottom);};YAHOO.util.Region.prototype.getArea=function(){return((this.bottom-this.top)*(this.right-this.left));};YAHOO.util.Region.prototype.intersect=function(E){var C=Math.max(this.top,E.top),D=Math.min(this.right,E.right),A=Math.min(this.bottom,E.bottom),B=Math.max(this.left,E.left);if(A>=C&&D>=B){return new YAHOO.util.Region(C,D,A,B);
+}else{return null;}};YAHOO.util.Region.prototype.union=function(E){var C=Math.min(this.top,E.top),D=Math.max(this.right,E.right),A=Math.max(this.bottom,E.bottom),B=Math.min(this.left,E.left);return new YAHOO.util.Region(C,D,A,B);};YAHOO.util.Region.prototype.toString=function(){return("Region {"+"top: "+this.top+", right: "+this.right+", bottom: "+this.bottom+", left: "+this.left+", height: "+this.height+", width: "+this.width+"}");};YAHOO.util.Region.getRegion=function(D){var F=YAHOO.util.Dom.getXY(D),C=F[1],E=F[0]+D.offsetWidth,A=F[1]+D.offsetHeight,B=F[0];return new YAHOO.util.Region(C,E,A,B);};YAHOO.util.Point=function(A,B){if(YAHOO.lang.isArray(A)){B=A[1];A=A[0];}YAHOO.util.Point.superclass.constructor.call(this,B,A,B,A);};YAHOO.extend(YAHOO.util.Point,YAHOO.util.Region);(function(){var B=YAHOO.util,A="clientTop",F="clientLeft",J="parentNode",K="right",W="hasLayout",I="px",U="opacity",L="auto",D="borderLeftWidth",G="borderTopWidth",P="borderRightWidth",V="borderBottomWidth",S="visible",Q="transparent",N="height",E="width",H="style",T="currentStyle",R=/^width|height$/,O=/^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,M={get:function(X,Z){var Y="",a=X[T][Z];if(Z===U){Y=B.Dom.getStyle(X,U);}else{if(!a||(a.indexOf&&a.indexOf(I)>-1)){Y=a;}else{if(B.Dom.IE_COMPUTED[Z]){Y=B.Dom.IE_COMPUTED[Z](X,Z);}else{if(O.test(a)){Y=B.Dom.IE.ComputedStyle.getPixel(X,Z);}else{Y=a;}}}}return Y;},getOffset:function(Z,e){var b=Z[T][e],X=e.charAt(0).toUpperCase()+e.substr(1),c="offset"+X,Y="pixel"+X,a="",d;if(b==L){d=Z[c];if(d===undefined){a=0;}a=d;if(R.test(e)){Z[H][e]=d;if(Z[c]>d){a=d-(Z[c]-d);}Z[H][e]=L;}}else{if(!Z[H][Y]&&!Z[H][e]){Z[H][e]=b;}a=Z[H][Y];}return a+I;},getBorderWidth:function(X,Z){var Y=null;if(!X[T][W]){X[H].zoom=1;}switch(Z){case G:Y=X[A];break;case V:Y=X.offsetHeight-X.clientHeight-X[A];break;case D:Y=X[F];break;case P:Y=X.offsetWidth-X.clientWidth-X[F];break;}return Y+I;},getPixel:function(Y,X){var a=null,b=Y[T][K],Z=Y[T][X];Y[H][K]=Z;a=Y[H].pixelRight;Y[H][K]=b;return a+I;},getMargin:function(Y,X){var Z;if(Y[T][X]==L){Z=0+I;}else{Z=B.Dom.IE.ComputedStyle.getPixel(Y,X);}return Z;},getVisibility:function(Y,X){var Z;while((Z=Y[T])&&Z[X]=="inherit"){Y=Y[J];}return(Z)?Z[X]:S;},getColor:function(Y,X){return B.Dom.Color.toRGB(Y[T][X])||Q;},getBorderColor:function(Y,X){var Z=Y[T],a=Z[X]||Z.color;return B.Dom.Color.toRGB(B.Dom.Color.toHex(a));}},C={};C.top=C.right=C.bottom=C.left=C[E]=C[N]=M.getOffset;C.color=M.getColor;C[G]=C[P]=C[V]=C[D]=M.getBorderWidth;C.marginTop=C.marginRight=C.marginBottom=C.marginLeft=M.getMargin;C.visibility=M.getVisibility;C.borderColor=C.borderTopColor=C.borderRightColor=C.borderBottomColor=C.borderLeftColor=M.getBorderColor;B.Dom.IE_COMPUTED=C;B.Dom.IE_ComputedStyle=M;})();(function(){var C="toString",A=parseInt,B=RegExp,D=YAHOO.util;D.Dom.Color={KEYWORDS:{black:"000",silver:"c0c0c0",gray:"808080",white:"fff",maroon:"800000",red:"f00",purple:"800080",fuchsia:"f0f",green:"008000",lime:"0f0",olive:"808000",yellow:"ff0",navy:"000080",blue:"00f",teal:"008080",aqua:"0ff"},re_RGB:/^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,re_hex:/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,re_hex3:/([0-9A-F])/gi,toRGB:function(E){if(!D.Dom.Color.re_RGB.test(E)){E=D.Dom.Color.toHex(E);}if(D.Dom.Color.re_hex.exec(E)){E="rgb("+[A(B.$1,16),A(B.$2,16),A(B.$3,16)].join(", ")+")";}return E;},toHex:function(H){H=D.Dom.Color.KEYWORDS[H]||H;if(D.Dom.Color.re_RGB.exec(H)){var G=(B.$1.length===1)?"0"+B.$1:Number(B.$1),F=(B.$2.length===1)?"0"+B.$2:Number(B.$2),E=(B.$3.length===1)?"0"+B.$3:Number(B.$3);H=[G[C](16),F[C](16),E[C](16)].join("");}if(H.length<6){H=H.replace(D.Dom.Color.re_hex3,"$1$1");}if(H!=="transparent"&&H.indexOf("#")<0){H="#"+H;}return H.toLowerCase();}};}());YAHOO.register("dom",YAHOO.util.Dom,{version:"2.7.0",build:"1796"});YAHOO.util.CustomEvent=function(D,C,B,A){this.type=D;this.scope=C||window;this.silent=B;this.signature=A||YAHOO.util.CustomEvent.LIST;this.subscribers=[];if(!this.silent){}var E="_YUICEOnSubscribe";if(D!==E){this.subscribeEvent=new YAHOO.util.CustomEvent(E,this,true);}this.lastError=null;};YAHOO.util.CustomEvent.LIST=0;YAHOO.util.CustomEvent.FLAT=1;YAHOO.util.CustomEvent.prototype={subscribe:function(A,B,C){if(!A){throw new Error("Invalid callback for subscriber to '"+this.type+"'");}if(this.subscribeEvent){this.subscribeEvent.fire(A,B,C);}this.subscribers.push(new YAHOO.util.Subscriber(A,B,C));},unsubscribe:function(D,F){if(!D){return this.unsubscribeAll();}var E=false;for(var B=0,A=this.subscribers.length;B<A;++B){var C=this.subscribers[B];if(C&&C.contains(D,F)){this._delete(B);E=true;}}return E;},fire:function(){this.lastError=null;var K=[],E=this.subscribers.length;if(!E&&this.silent){return true;}var I=[].slice.call(arguments,0),G=true,D,J=false;if(!this.silent){}var C=this.subscribers.slice(),A=YAHOO.util.Event.throwErrors;for(D=0;D<E;++D){var M=C[D];if(!M){J=true;}else{if(!this.silent){}var L=M.getScope(this.scope);if(this.signature==YAHOO.util.CustomEvent.FLAT){var B=null;if(I.length>0){B=I[0];}try{G=M.fn.call(L,B,M.obj);}catch(F){this.lastError=F;if(A){throw F;}}}else{try{G=M.fn.call(L,this.type,I,M.obj);}catch(H){this.lastError=H;if(A){throw H;}}}if(false===G){if(!this.silent){}break;}}}return(G!==false);},unsubscribeAll:function(){var A=this.subscribers.length,B;for(B=A-1;B>-1;B--){this._delete(B);}this.subscribers=[];return A;},_delete:function(A){var B=this.subscribers[A];if(B){delete B.fn;delete B.obj;}this.subscribers.splice(A,1);},toString:function(){return"CustomEvent: "+"'"+this.type+"', "+"context: "+this.scope;}};YAHOO.util.Subscriber=function(A,B,C){this.fn=A;this.obj=YAHOO.lang.isUndefined(B)?null:B;this.overrideContext=C;};YAHOO.util.Subscriber.prototype.getScope=function(A){if(this.overrideContext){if(this.overrideContext===true){return this.obj;}else{return this.overrideContext;}}return A;};YAHOO.util.Subscriber.prototype.contains=function(A,B){if(B){return(this.fn==A&&this.obj==B);}else{return(this.fn==A);}};YAHOO.util.Subscriber.prototype.toString=function(){return"Subscriber { obj: "+this.obj+", overrideContext: "+(this.overrideContext||"no")+" }";};if(!YAHOO.util.Event){YAHOO.util.Event=function(){var H=false;var I=[];var J=[];var G=[];var E=[];var C=0;var F=[];var B=[];var A=0;var D={63232:38,63233:40,63234:37,63235:39,63276:33,63277:34,25:9};var K=YAHOO.env.ua.ie?"focusin":"focus";var L=YAHOO.env.ua.ie?"focusout":"blur";return{POLL_RETRYS:2000,POLL_INTERVAL:20,EL:0,TYPE:1,FN:2,WFN:3,UNLOAD_OBJ:3,ADJ_SCOPE:4,OBJ:5,OVERRIDE:6,lastError:null,isSafari:YAHOO.env.ua.webkit,webkit:YAHOO.env.ua.webkit,isIE:YAHOO.env.ua.ie,_interval:null,_dri:null,DOMReady:false,throwErrors:false,startInterval:function(){if(!this._interval){var M=this;var N=function(){M._tryPreloadAttach();};this._interval=setInterval(N,this.POLL_INTERVAL);}},onAvailable:function(S,O,Q,R,P){var M=(YAHOO.lang.isString(S))?[S]:S;for(var N=0;N<M.length;N=N+1){F.push({id:M[N],fn:O,obj:Q,overrideContext:R,checkReady:P});}C=this.POLL_RETRYS;this.startInterval();},onContentReady:function(P,M,N,O){this.onAvailable(P,M,N,O,true);},onDOMReady:function(M,N,O){if(this.DOMReady){setTimeout(function(){var P=window;if(O){if(O===true){P=N;}else{P=O;}}M.call(P,"DOMReady",[],N);},0);}else{this.DOMReadyEvent.subscribe(M,N,O);}},_addListener:function(O,M,Y,S,W,b){if(!Y||!Y.call){return false;}if(this._isValidCollection(O)){var Z=true;for(var T=0,V=O.length;T<V;++T){Z=this.on(O[T],M,Y,S,W)&&Z;}return Z;}else{if(YAHOO.lang.isString(O)){var R=this.getEl(O);if(R){O=R;}else{this.onAvailable(O,function(){YAHOO.util.Event.on(O,M,Y,S,W);});return true;}}}if(!O){return false;}if("unload"==M&&S!==this){J[J.length]=[O,M,Y,S,W];return true;}var N=O;if(W){if(W===true){N=S;}else{N=W;}}var P=function(c){return Y.call(N,YAHOO.util.Event.getEvent(c,O),S);};var a=[O,M,Y,P,N,S,W];var U=I.length;I[U]=a;if(this.useLegacyEvent(O,M)){var Q=this.getLegacyIndex(O,M);if(Q==-1||O!=G[Q][0]){Q=G.length;B[O.id+M]=Q;G[Q]=[O,M,O["on"+M]];E[Q]=[];O["on"+M]=function(c){YAHOO.util.Event.fireLegacyEvent(YAHOO.util.Event.getEvent(c),Q);};}E[Q].push(a);}else{try{this._simpleAdd(O,M,P,b);}catch(X){this.lastError=X;this.removeListener(O,M,Y);return false;}}return true;},addListener:function(N,Q,M,O,P){return this._addListener(N,Q,M,O,P,false);},addFocusListener:function(N,M,O,P){return this._addListener(N,K,M,O,P,true);},removeFocusListener:function(N,M){return this.removeListener(N,K,M);},addBlurListener:function(N,M,O,P){return this._addListener(N,L,M,O,P,true);},removeBlurListener:function(N,M){return this.removeListener(N,L,M);},fireLegacyEvent:function(R,P){var T=true,M,V,U,N,S;V=E[P].slice();for(var O=0,Q=V.length;O<Q;++O){U=V[O];if(U&&U[this.WFN]){N=U[this.ADJ_SCOPE];S=U[this.WFN].call(N,R);T=(T&&S);}}M=G[P];if(M&&M[2]){M[2](R);}return T;},getLegacyIndex:function(N,O){var M=this.generateId(N)+O;if(typeof B[M]=="undefined"){return -1;}else{return B[M];}},useLegacyEvent:function(M,N){return(this.webkit&&this.webkit<419&&("click"==N||"dblclick"==N));},removeListener:function(N,M,V){var Q,T,X;if(typeof N=="string"){N=this.getEl(N);}else{if(this._isValidCollection(N)){var W=true;for(Q=N.length-1;Q>-1;Q--){W=(this.removeListener(N[Q],M,V)&&W);}return W;}}if(!V||!V.call){return this.purgeElement(N,false,M);}if("unload"==M){for(Q=J.length-1;Q>-1;Q--){X=J[Q];if(X&&X[0]==N&&X[1]==M&&X[2]==V){J.splice(Q,1);return true;}}return false;}var R=null;var S=arguments[3];if("undefined"===typeof S){S=this._getCacheIndex(N,M,V);}if(S>=0){R=I[S];}if(!N||!R){return false;}if(this.useLegacyEvent(N,M)){var P=this.getLegacyIndex(N,M);var O=E[P];if(O){for(Q=0,T=O.length;Q<T;++Q){X=O[Q];if(X&&X[this.EL]==N&&X[this.TYPE]==M&&X[this.FN]==V){O.splice(Q,1);break;}}}}else{try{this._simpleRemove(N,M,R[this.WFN],false);}catch(U){this.lastError=U;return false;}}delete I[S][this.WFN];delete I[S][this.FN];
+I.splice(S,1);return true;},getTarget:function(O,N){var M=O.target||O.srcElement;return this.resolveTextNode(M);},resolveTextNode:function(N){try{if(N&&3==N.nodeType){return N.parentNode;}}catch(M){}return N;},getPageX:function(N){var M=N.pageX;if(!M&&0!==M){M=N.clientX||0;if(this.isIE){M+=this._getScrollLeft();}}return M;},getPageY:function(M){var N=M.pageY;if(!N&&0!==N){N=M.clientY||0;if(this.isIE){N+=this._getScrollTop();}}return N;},getXY:function(M){return[this.getPageX(M),this.getPageY(M)];},getRelatedTarget:function(N){var M=N.relatedTarget;if(!M){if(N.type=="mouseout"){M=N.toElement;}else{if(N.type=="mouseover"){M=N.fromElement;}}}return this.resolveTextNode(M);},getTime:function(O){if(!O.time){var N=new Date().getTime();try{O.time=N;}catch(M){this.lastError=M;return N;}}return O.time;},stopEvent:function(M){this.stopPropagation(M);this.preventDefault(M);},stopPropagation:function(M){if(M.stopPropagation){M.stopPropagation();}else{M.cancelBubble=true;}},preventDefault:function(M){if(M.preventDefault){M.preventDefault();}else{M.returnValue=false;}},getEvent:function(O,M){var N=O||window.event;if(!N){var P=this.getEvent.caller;while(P){N=P.arguments[0];if(N&&Event==N.constructor){break;}P=P.caller;}}return N;},getCharCode:function(N){var M=N.keyCode||N.charCode||0;if(YAHOO.env.ua.webkit&&(M in D)){M=D[M];}return M;},_getCacheIndex:function(Q,R,P){for(var O=0,N=I.length;O<N;O=O+1){var M=I[O];if(M&&M[this.FN]==P&&M[this.EL]==Q&&M[this.TYPE]==R){return O;}}return -1;},generateId:function(M){var N=M.id;if(!N){N="yuievtautoid-"+A;++A;M.id=N;}return N;},_isValidCollection:function(N){try{return(N&&typeof N!=="string"&&N.length&&!N.tagName&&!N.alert&&typeof N[0]!=="undefined");}catch(M){return false;}},elCache:{},getEl:function(M){return(typeof M==="string")?document.getElementById(M):M;},clearCache:function(){},DOMReadyEvent:new YAHOO.util.CustomEvent("DOMReady",this),_load:function(N){if(!H){H=true;var M=YAHOO.util.Event;M._ready();M._tryPreloadAttach();}},_ready:function(N){var M=YAHOO.util.Event;if(!M.DOMReady){M.DOMReady=true;M.DOMReadyEvent.fire();M._simpleRemove(document,"DOMContentLoaded",M._ready);}},_tryPreloadAttach:function(){if(F.length===0){C=0;if(this._interval){clearInterval(this._interval);this._interval=null;}return;}if(this.locked){return;}if(this.isIE){if(!this.DOMReady){this.startInterval();return;}}this.locked=true;var S=!H;if(!S){S=(C>0&&F.length>0);}var R=[];var T=function(V,W){var U=V;if(W.overrideContext){if(W.overrideContext===true){U=W.obj;}else{U=W.overrideContext;}}W.fn.call(U,W.obj);};var N,M,Q,P,O=[];for(N=0,M=F.length;N<M;N=N+1){Q=F[N];if(Q){P=this.getEl(Q.id);if(P){if(Q.checkReady){if(H||P.nextSibling||!S){O.push(Q);F[N]=null;}}else{T(P,Q);F[N]=null;}}else{R.push(Q);}}}for(N=0,M=O.length;N<M;N=N+1){Q=O[N];T(this.getEl(Q.id),Q);}C--;if(S){for(N=F.length-1;N>-1;N--){Q=F[N];if(!Q||!Q.id){F.splice(N,1);}}this.startInterval();}else{if(this._interval){clearInterval(this._interval);this._interval=null;}}this.locked=false;},purgeElement:function(Q,R,T){var O=(YAHOO.lang.isString(Q))?this.getEl(Q):Q;var S=this.getListeners(O,T),P,M;if(S){for(P=S.length-1;P>-1;P--){var N=S[P];this.removeListener(O,N.type,N.fn);}}if(R&&O&&O.childNodes){for(P=0,M=O.childNodes.length;P<M;++P){this.purgeElement(O.childNodes[P],R,T);}}},getListeners:function(O,M){var R=[],N;if(!M){N=[I,J];}else{if(M==="unload"){N=[J];}else{N=[I];}}var T=(YAHOO.lang.isString(O))?this.getEl(O):O;for(var Q=0;Q<N.length;Q=Q+1){var V=N[Q];if(V){for(var S=0,U=V.length;S<U;++S){var P=V[S];if(P&&P[this.EL]===T&&(!M||M===P[this.TYPE])){R.push({type:P[this.TYPE],fn:P[this.FN],obj:P[this.OBJ],adjust:P[this.OVERRIDE],scope:P[this.ADJ_SCOPE],index:S});}}}}return(R.length)?R:null;},_unload:function(T){var N=YAHOO.util.Event,Q,P,O,S,R,U=J.slice(),M;for(Q=0,S=J.length;Q<S;++Q){O=U[Q];if(O){M=window;if(O[N.ADJ_SCOPE]){if(O[N.ADJ_SCOPE]===true){M=O[N.UNLOAD_OBJ];}else{M=O[N.ADJ_SCOPE];}}O[N.FN].call(M,N.getEvent(T,O[N.EL]),O[N.UNLOAD_OBJ]);U[Q]=null;}}O=null;M=null;J=null;if(I){for(P=I.length-1;P>-1;P--){O=I[P];if(O){N.removeListener(O[N.EL],O[N.TYPE],O[N.FN],P);}}O=null;}G=null;N._simpleRemove(window,"unload",N._unload);},_getScrollLeft:function(){return this._getScroll()[1];},_getScrollTop:function(){return this._getScroll()[0];},_getScroll:function(){var M=document.documentElement,N=document.body;if(M&&(M.scrollTop||M.scrollLeft)){return[M.scrollTop,M.scrollLeft];}else{if(N){return[N.scrollTop,N.scrollLeft];}else{return[0,0];}}},regCE:function(){},_simpleAdd:function(){if(window.addEventListener){return function(O,P,N,M){O.addEventListener(P,N,(M));};}else{if(window.attachEvent){return function(O,P,N,M){O.attachEvent("on"+P,N);};}else{return function(){};}}}(),_simpleRemove:function(){if(window.removeEventListener){return function(O,P,N,M){O.removeEventListener(P,N,(M));};}else{if(window.detachEvent){return function(N,O,M){N.detachEvent("on"+O,M);};}else{return function(){};}}}()};}();(function(){var EU=YAHOO.util.Event;EU.on=EU.addListener;EU.onFocus=EU.addFocusListener;EU.onBlur=EU.addBlurListener;
+/* DOMReady: based on work by: Dean Edwards/John Resig/Matthias Miller */
+if(EU.isIE){YAHOO.util.Event.onDOMReady(YAHOO.util.Event._tryPreloadAttach,YAHOO.util.Event,true);var n=document.createElement("p");EU._dri=setInterval(function(){try{n.doScroll("left");clearInterval(EU._dri);EU._dri=null;EU._ready();n=null;}catch(ex){}},EU.POLL_INTERVAL);}else{if(EU.webkit&&EU.webkit<525){EU._dri=setInterval(function(){var rs=document.readyState;if("loaded"==rs||"complete"==rs){clearInterval(EU._dri);EU._dri=null;EU._ready();}},EU.POLL_INTERVAL);}else{EU._simpleAdd(document,"DOMContentLoaded",EU._ready);}}EU._simpleAdd(window,"load",EU._load);EU._simpleAdd(window,"unload",EU._unload);EU._tryPreloadAttach();})();}YAHOO.util.EventProvider=function(){};YAHOO.util.EventProvider.prototype={__yui_events:null,__yui_subscribers:null,subscribe:function(A,C,F,E){this.__yui_events=this.__yui_events||{};var D=this.__yui_events[A];if(D){D.subscribe(C,F,E);
+}else{this.__yui_subscribers=this.__yui_subscribers||{};var B=this.__yui_subscribers;if(!B[A]){B[A]=[];}B[A].push({fn:C,obj:F,overrideContext:E});}},unsubscribe:function(C,E,G){this.__yui_events=this.__yui_events||{};var A=this.__yui_events;if(C){var F=A[C];if(F){return F.unsubscribe(E,G);}}else{var B=true;for(var D in A){if(YAHOO.lang.hasOwnProperty(A,D)){B=B&&A[D].unsubscribe(E,G);}}return B;}return false;},unsubscribeAll:function(A){return this.unsubscribe(A);},createEvent:function(G,D){this.__yui_events=this.__yui_events||{};var A=D||{};var I=this.__yui_events;if(I[G]){}else{var H=A.scope||this;var E=(A.silent);var B=new YAHOO.util.CustomEvent(G,H,E,YAHOO.util.CustomEvent.FLAT);I[G]=B;if(A.onSubscribeCallback){B.subscribeEvent.subscribe(A.onSubscribeCallback);}this.__yui_subscribers=this.__yui_subscribers||{};var F=this.__yui_subscribers[G];if(F){for(var C=0;C<F.length;++C){B.subscribe(F[C].fn,F[C].obj,F[C].overrideContext);}}}return I[G];},fireEvent:function(E,D,A,C){this.__yui_events=this.__yui_events||{};var G=this.__yui_events[E];if(!G){return null;}var B=[];for(var F=1;F<arguments.length;++F){B.push(arguments[F]);}return G.fire.apply(G,B);},hasEvent:function(A){if(this.__yui_events){if(this.__yui_events[A]){return true;}}return false;}};(function(){var A=YAHOO.util.Event,C=YAHOO.lang;YAHOO.util.KeyListener=function(D,I,E,F){if(!D){}else{if(!I){}else{if(!E){}}}if(!F){F=YAHOO.util.KeyListener.KEYDOWN;}var G=new YAHOO.util.CustomEvent("keyPressed");this.enabledEvent=new YAHOO.util.CustomEvent("enabled");this.disabledEvent=new YAHOO.util.CustomEvent("disabled");if(C.isString(D)){D=document.getElementById(D);}if(C.isFunction(E)){G.subscribe(E);}else{G.subscribe(E.fn,E.scope,E.correctScope);}function H(O,N){if(!I.shift){I.shift=false;}if(!I.alt){I.alt=false;}if(!I.ctrl){I.ctrl=false;}if(O.shiftKey==I.shift&&O.altKey==I.alt&&O.ctrlKey==I.ctrl){var J,M=I.keys,L;if(YAHOO.lang.isArray(M)){for(var K=0;K<M.length;K++){J=M[K];L=A.getCharCode(O);if(J==L){G.fire(L,O);break;}}}else{L=A.getCharCode(O);if(M==L){G.fire(L,O);}}}}this.enable=function(){if(!this.enabled){A.on(D,F,H);this.enabledEvent.fire(I);}this.enabled=true;};this.disable=function(){if(this.enabled){A.removeListener(D,F,H);this.disabledEvent.fire(I);}this.enabled=false;};this.toString=function(){return"KeyListener ["+I.keys+"] "+D.tagName+(D.id?"["+D.id+"]":"");};};var B=YAHOO.util.KeyListener;B.KEYDOWN="keydown";B.KEYUP="keyup";B.KEY={ALT:18,BACK_SPACE:8,CAPS_LOCK:20,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,META:224,NUM_LOCK:144,PAGE_DOWN:34,PAGE_UP:33,PAUSE:19,PRINTSCREEN:44,RIGHT:39,SCROLL_LOCK:145,SHIFT:16,SPACE:32,TAB:9,UP:38};})();YAHOO.register("event",YAHOO.util.Event,{version:"2.7.0",build:"1796"});YAHOO.register("yuiloader-dom-event", YAHOO, {version: "2.7.0", build: "1796"});
+/*
+Copyright (c) 2009, Yahoo! Inc. All rights reserved.
+Code licensed under the BSD License:
+http://developer.yahoo.net/yui/license.txt
+version: 2.7.0
+*/
+YAHOO.namespace("tool");YAHOO.tool.Profiler={_container:new Object(),_report:new Object(),_saveData:function(B,C){var A=this._report[B];A.calls++;A.points.push(C);if(A.calls>1){A.avg=((A.avg*(A.calls-1))+C)/A.calls;A.min=Math.min(A.min,C);A.max=Math.max(A.max,C);}else{A.avg=C;A.min=C;A.max=C;}},getAverage:function(A){return this._report[A].avg;},getCallCount:function(A){return this._report[A].calls;},getMax:function(A){return this._report[A].max;},getMin:function(A){return this._report[A].min;},getFunctionReport:function(A){return this._report[A];},getFullReport:function(C){C=C||function(){return true;};if(YAHOO.lang.isFunction(C)){var A={};for(var B in this._report){if(C(this._report[B])){A[B]=this._report[B];}}return A;}},registerConstructor:function(B,A){this.registerFunction(B,A,true);},registerFunction:function(name,owner,registerPrototype){var funcName=(name.indexOf(".")>-1?name.substring(name.lastIndexOf(".")+1):name);if(!YAHOO.lang.isObject(owner)){owner=eval(name.substring(0,name.lastIndexOf(".")));}var method=owner[funcName];var prototype=method.prototype;if(YAHOO.lang.isFunction(method)&&!method.__yuiProfiled){this._container[name]=method;owner[funcName]=function(){var start=new Date();var retval=method.apply(this,arguments);var stop=new Date();YAHOO.tool.Profiler._saveData(name,stop-start);return retval;};YAHOO.lang.augmentObject(owner[funcName],method);owner[funcName].__yuiProfiled=true;owner[funcName].prototype=prototype;this._container[name].__yuiOwner=owner;this._container[name].__yuiFuncName=funcName;if(registerPrototype){this.registerObject(name+".prototype",prototype);}this._report[name]={calls:0,max:0,min:0,avg:0,points:[]};}return method;},registerObject:function(name,object,recurse){object=(YAHOO.lang.isObject(object)?object:eval(name));this._container[name]=object;for(var prop in object){if(typeof object[prop]=="function"){if(prop!="constructor"&&prop!="superclass"){this.registerFunction(name+"."+prop,object);}}else{if(typeof object[prop]=="object"&&recurse){this.registerObject(name+"."+prop,object[prop],recurse);}}}},unregisterConstructor:function(A){if(YAHOO.lang.isFunction(this._container[A])){this.unregisterFunction(A,true);}},unregisterFunction:function(B,C){if(YAHOO.lang.isFunction(this._container[B])){if(C){this.unregisterObject(B+".prototype",this._container[B].prototype);}var A=this._container[B].__yuiOwner;var D=this._container[B].__yuiFuncName;delete this._container[B].__yuiOwner;delete this._container[B].__yuiFuncName;A[D]=this._container[B];delete this._container[B];delete this._report[B];}},unregisterObject:function(B,C){if(YAHOO.lang.isObject(this._container[B])){var A=this._container[B];for(var D in A){if(typeof A[D]=="function"){this.unregisterFunction(B+"."+D);}else{if(typeof A[D]=="object"&&C){this.unregisterObject(B+"."+D,C);}}}delete this._container[B];}}};YAHOO.register("profiler",YAHOO.tool.Profiler,{version:"2.7.0",build:"1796"});/*
+Copyright (c) 2009, Yahoo! Inc. All rights reserved.
+Code licensed under the BSD License:
+http://developer.yahoo.net/yui/license.txt
+version: 2.7.0
+*/
+YAHOO.util.Attribute=function(B,A){if(A){this.owner=A;this.configure(B,true);}};YAHOO.util.Attribute.prototype={name:undefined,value:null,owner:null,readOnly:false,writeOnce:false,_initialConfig:null,_written:false,method:null,setter:null,getter:null,validator:null,getValue:function(){var A=this.value;if(this.getter){A=this.getter.call(this.owner,this.name);}return A;},setValue:function(F,B){var E,A=this.owner,C=this.name;var D={type:C,prevValue:this.getValue(),newValue:F};if(this.readOnly||(this.writeOnce&&this._written)){return false;}if(this.validator&&!this.validator.call(A,F)){return false;}if(!B){E=A.fireBeforeChangeEvent(D);if(E===false){return false;}}if(this.setter){F=this.setter.call(A,F,this.name);if(F===undefined){}}if(this.method){this.method.call(A,F,this.name);}this.value=F;this._written=true;D.type=C;if(!B){this.owner.fireChangeEvent(D);}return true;},configure:function(B,C){B=B||{};if(C){this._written=false;}this._initialConfig=this._initialConfig||{};for(var A in B){if(B.hasOwnProperty(A)){this[A]=B[A];if(C){this._initialConfig[A]=B[A];}}}},resetValue:function(){return this.setValue(this._initialConfig.value);},resetConfig:function(){this.configure(this._initialConfig,true);},refresh:function(A){this.setValue(this.value,A);}};(function(){var A=YAHOO.util.Lang;YAHOO.util.AttributeProvider=function(){};YAHOO.util.AttributeProvider.prototype={_configs:null,get:function(C){this._configs=this._configs||{};var B=this._configs[C];if(!B||!this._configs.hasOwnProperty(C)){return null;}return B.getValue();},set:function(D,E,B){this._configs=this._configs||{};var C=this._configs[D];if(!C){return false;}return C.setValue(E,B);},getAttributeKeys:function(){this._configs=this._configs;var C=[],B;for(B in this._configs){if(A.hasOwnProperty(this._configs,B)&&!A.isUndefined(this._configs[B])){C[C.length]=B;}}return C;},setAttributes:function(D,B){for(var C in D){if(A.hasOwnProperty(D,C)){this.set(C,D[C],B);}}},resetValue:function(C,B){this._configs=this._configs||{};if(this._configs[C]){this.set(C,this._configs[C]._initialConfig.value,B);return true;}return false;},refresh:function(E,C){this._configs=this._configs||{};var F=this._configs;E=((A.isString(E))?[E]:E)||this.getAttributeKeys();for(var D=0,B=E.length;D<B;++D){if(F.hasOwnProperty(E[D])){this._configs[E[D]].refresh(C);}}},register:function(B,C){this.setAttributeConfig(B,C);},getAttributeConfig:function(C){this._configs=this._configs||{};var B=this._configs[C]||{};var D={};for(C in B){if(A.hasOwnProperty(B,C)){D[C]=B[C];}}return D;},setAttributeConfig:function(B,C,D){this._configs=this._configs||{};C=C||{};if(!this._configs[B]){C.name=B;this._configs[B]=this.createAttribute(C);}else{this._configs[B].configure(C,D);}},configureAttribute:function(B,C,D){this.setAttributeConfig(B,C,D);},resetAttributeConfig:function(B){this._configs=this._configs||{};this._configs[B].resetConfig();},subscribe:function(B,C){this._events=this._events||{};if(!(B in this._events)){this._events[B]=this.createEvent(B);}YAHOO.util.EventProvider.prototype.subscribe.apply(this,arguments);},on:function(){this.subscribe.apply(this,arguments);},addListener:function(){this.subscribe.apply(this,arguments);},fireBeforeChangeEvent:function(C){var B="before";B+=C.type.charAt(0).toUpperCase()+C.type.substr(1)+"Change";C.type=B;return this.fireEvent(C.type,C);},fireChangeEvent:function(B){B.type+="Change";return this.fireEvent(B.type,B);},createAttribute:function(B){return new YAHOO.util.Attribute(B,this);}};YAHOO.augment(YAHOO.util.AttributeProvider,YAHOO.util.EventProvider);})();(function(){var B=YAHOO.util.Dom,C=YAHOO.util.AttributeProvider;var A=function(D,E){this.init.apply(this,arguments);};A.DOM_EVENTS={"click":true,"dblclick":true,"keydown":true,"keypress":true,"keyup":true,"mousedown":true,"mousemove":true,"mouseout":true,"mouseover":true,"mouseup":true,"focus":true,"blur":true,"submit":true,"change":true};A.prototype={DOM_EVENTS:null,DEFAULT_HTML_SETTER:function(F,D){var E=this.get("element");if(E){E[D]=F;}},DEFAULT_HTML_GETTER:function(D){var E=this.get("element"),F;if(E){F=E[D];}return F;},appendChild:function(D){D=D.get?D.get("element"):D;return this.get("element").appendChild(D);},getElementsByTagName:function(D){return this.get("element").getElementsByTagName(D);},hasChildNodes:function(){return this.get("element").hasChildNodes();},insertBefore:function(D,E){D=D.get?D.get("element"):D;E=(E&&E.get)?E.get("element"):E;return this.get("element").insertBefore(D,E);},removeChild:function(D){D=D.get?D.get("element"):D;return this.get("element").removeChild(D);},replaceChild:function(D,E){D=D.get?D.get("element"):D;E=E.get?E.get("element"):E;return this.get("element").replaceChild(D,E);},initAttributes:function(D){},addListener:function(H,G,I,F){var E=this.get("element")||this.get("id");F=F||this;var D=this;if(!this._events[H]){if(E&&this.DOM_EVENTS[H]){YAHOO.util.Event.addListener(E,H,function(J){if(J.srcElement&&!J.target){J.target=J.srcElement;}D.fireEvent(H,J);},I,F);}this.createEvent(H,this);}return YAHOO.util.EventProvider.prototype.subscribe.apply(this,arguments);},on:function(){return this.addListener.apply(this,arguments);},subscribe:function(){return this.addListener.apply(this,arguments);},removeListener:function(E,D){return this.unsubscribe.apply(this,arguments);},addClass:function(D){B.addClass(this.get("element"),D);},getElementsByClassName:function(E,D){return B.getElementsByClassName(E,D,this.get("element"));},hasClass:function(D){return B.hasClass(this.get("element"),D);},removeClass:function(D){return B.removeClass(this.get("element"),D);},replaceClass:function(E,D){return B.replaceClass(this.get("element"),E,D);},setStyle:function(E,D){return B.setStyle(this.get("element"),E,D);},getStyle:function(D){return B.getStyle(this.get("element"),D);},fireQueue:function(){var E=this._queue;for(var F=0,D=E.length;F<D;++F){this[E[F][0]].apply(this,E[F][1]);}},appendTo:function(E,F){E=(E.get)?E.get("element"):B.get(E);this.fireEvent("beforeAppendTo",{type:"beforeAppendTo",target:E});
+F=(F&&F.get)?F.get("element"):B.get(F);var D=this.get("element");if(!D){return false;}if(!E){return false;}if(D.parent!=E){if(F){E.insertBefore(D,F);}else{E.appendChild(D);}}this.fireEvent("appendTo",{type:"appendTo",target:E});return D;},get:function(D){var F=this._configs||{},E=F.element;if(E&&!F[D]&&!YAHOO.lang.isUndefined(E.value[D])){this._setHTMLAttrConfig(D);}return C.prototype.get.call(this,D);},setAttributes:function(J,G){var E={},H=this._configOrder;for(var I=0,D=H.length;I<D;++I){if(J[H[I]]!==undefined){E[H[I]]=true;this.set(H[I],J[H[I]],G);}}for(var F in J){if(J.hasOwnProperty(F)&&!E[F]){this.set(F,J[F],G);}}},set:function(E,G,D){var F=this.get("element");if(!F){this._queue[this._queue.length]=["set",arguments];if(this._configs[E]){this._configs[E].value=G;}return;}if(!this._configs[E]&&!YAHOO.lang.isUndefined(F[E])){this._setHTMLAttrConfig(E);}return C.prototype.set.apply(this,arguments);},setAttributeConfig:function(D,E,F){this._configOrder.push(D);C.prototype.setAttributeConfig.apply(this,arguments);},createEvent:function(E,D){this._events[E]=true;return C.prototype.createEvent.apply(this,arguments);},init:function(E,D){this._initElement(E,D);},destroy:function(){var D=this.get("element");YAHOO.util.Event.purgeElement(D,true);this.unsubscribeAll();if(D&&D.parentNode){D.parentNode.removeChild(D);}this._queue=[];this._events={};this._configs={};this._configOrder=[];},_initElement:function(F,E){this._queue=this._queue||[];this._events=this._events||{};this._configs=this._configs||{};this._configOrder=[];E=E||{};E.element=E.element||F||null;var H=false;var D=A.DOM_EVENTS;this.DOM_EVENTS=this.DOM_EVENTS||{};for(var G in D){if(D.hasOwnProperty(G)){this.DOM_EVENTS[G]=D[G];}}if(typeof E.element==="string"){this._setHTMLAttrConfig("id",{value:E.element});}if(B.get(E.element)){H=true;this._initHTMLElement(E);this._initContent(E);}YAHOO.util.Event.onAvailable(E.element,function(){if(!H){this._initHTMLElement(E);}this.fireEvent("available",{type:"available",target:B.get(E.element)});},this,true);YAHOO.util.Event.onContentReady(E.element,function(){if(!H){this._initContent(E);}this.fireEvent("contentReady",{type:"contentReady",target:B.get(E.element)});},this,true);},_initHTMLElement:function(D){this.setAttributeConfig("element",{value:B.get(D.element),readOnly:true});},_initContent:function(D){this.initAttributes(D);this.setAttributes(D,true);this.fireQueue();},_setHTMLAttrConfig:function(D,F){var E=this.get("element");F=F||{};F.name=D;F.setter=F.setter||this.DEFAULT_HTML_SETTER;F.getter=F.getter||this.DEFAULT_HTML_GETTER;F.value=F.value||E[D];this._configs[D]=new YAHOO.util.Attribute(F,this);}};YAHOO.augment(A,C);YAHOO.util.Element=A;})();YAHOO.register("element",YAHOO.util.Element,{version:"2.7.0",build:"1796"});/*
+Copyright (c) 2009, Yahoo! Inc. All rights reserved.
+Code licensed under the BSD License:
+http://developer.yahoo.net/yui/license.txt
+version: 2.7.0
+*/
+(function(){YAHOO.widget.ProfilerViewer=function(H,G){G=G||{};if(arguments.length==1&&!YAHOO.lang.isString(H)&&!H.nodeName){G=H;H=G.element||null;}if(!H&&!G.element){H=this._createProfilerViewerElement();}YAHOO.widget.ProfilerViewer.superclass.constructor.call(this,H,G);this._init();};YAHOO.extend(YAHOO.widget.ProfilerViewer,YAHOO.util.Element);YAHOO.lang.augmentObject(YAHOO.widget.ProfilerViewer,{CLASS:"yui-pv",CLASS_DASHBOARD:"yui-pv-dashboard",CLASS_REFRESH:"yui-pv-refresh",CLASS_BUSY:"yui-pv-busy",CLASS_CHART_CONTAINER:"yui-pv-chartcontainer",CLASS_CHART:"yui-pv-chart",CLASS_CHART_LEGEND:"yui-pv-chartlegend",CLASS_TABLE:"yui-pv-table",STRINGS:{title:"YUI Profiler (beta)",buttons:{viewprofiler:"View Profiler Data",hideprofiler:"Hide Profiler Report",showchart:"Show Chart",hidechart:"Hide Chart",refreshdata:"Refresh Data"},colHeads:{fn:["Function/Method",null],calls:["Calls",40],avg:["Average",80],min:["Shortest",70],max:["Longest",70],total:["Total Time",70],pct:["Percent",70]},millisecondsAbbrev:"ms",initMessage:"initialiazing chart...",installFlashMessage:"Unable to load Flash content. The YUI Charts Control requires Flash Player 9.0.45 or higher. You can download the latest version of Flash Player from the <a href='http://www.adobe.com/go/getflashplayer'>Adobe Flash Player Download Center</a>."},timeAxisLabelFunction:function(H){var G=(H===Math.floor(H))?H:(Math.round(H*1000))/1000;return(G+" "+YAHOO.widget.ProfilerViewer.STRINGS.millisecondsAbbrev);},percentAxisLabelFunction:function(H){var G=(H===Math.floor(H))?H:(Math.round(H*100))/100;return(G+"%");}},true);var C=YAHOO.util.Dom;var A=YAHOO.util.Event;var B=YAHOO.tool.Profiler;var E=YAHOO.widget.ProfilerViewer;var D=E.prototype;D.refreshData=function(){this.fireEvent("dataRefreshEvent");};D.getHeadEl=function(){return(this._headEl)?C.get(this._headEl):false;};D.getBodyEl=function(){return(this._bodyEl)?C.get(this._bodyEl):false;};D.getChartEl=function(){return(this._chartEl)?C.get(this._chartEl):false;};D.getTableEl=function(){return(this._tableEl)?C.get(this._tableEl):false;};D.getDataTable=function(){return this._dataTable;};D.getChart=function(){return this._chart;};D._rendered=false;D._headEl=null;D._bodyEl=null;D._toggleVisibleEl=null;D._busyEl=null;D._busy=false;D._tableEl=null;D._dataTable=null;D._chartEl=null;D._chartLegendEl=null;D._chartElHeight=250;D._chart=null;D._chartInitialized=false;D._init=function(){this.createEvent("dataRefreshEvent");this.createEvent("renderEvent");this.on("dataRefreshEvent",this._refreshDataTable,this,true);this._initLauncherDOM();if(this.get("showChart")){this.on("sortedByChange",this._refreshChart);}};D._createProfilerViewerElement=function(){var G=document.createElement("div");document.body.insertBefore(G,document.body.firstChild);C.addClass(G,this.SKIN_CLASS);C.addClass(G,E.CLASS);return G;};D.toString=function(){return"ProfilerViewer "+(this.get("id")||this.get("tagName"));};D._toggleVisible=function(){var G=(this.get("visible"))?false:true;this.set("visible",G);};D._show=function(){if(!this._busy){this._setBusyState(true);if(!this._rendered){var G=new YAHOO.util.YUILoader();if(this.get("base")){G.base=this.get("base");}var H=["datatable"];if(this.get("showChart")){H.push("charts");}G.insert({require:H,onSuccess:function(){this._render();},scope:this});}else{var I=this.get("element");C.removeClass(I,"yui-pv-minimized");this._toggleVisibleEl.innerHTML=E.STRINGS.buttons.hideprofiler;C.addClass(I,"yui-pv-null");C.removeClass(I,"yui-pv-null");this.refreshData();}}};D._hide=function(){this._toggleVisibleEl.innerHTML=E.STRINGS.buttons.viewprofiler;C.addClass(this.get("element"),"yui-pv-minimized");};D._render=function(){C.removeClass(this.get("element"),"yui-pv-minimized");this._initViewerDOM();this._initDataTable();if(this.get("showChart")){this._initChartDOM();this._initChart();}this._rendered=true;this._toggleVisibleEl.innerHTML=E.STRINGS.buttons.hideprofiler;this.fireEvent("renderEvent");};D._initLauncherDOM=function(){var I=this.get("element");C.addClass(I,E.CLASS);C.addClass(I,"yui-pv-minimized");this._headEl=document.createElement("div");C.addClass(this._headEl,"hd");var H=E.STRINGS.buttons;var G=(this.get("visible"))?H.hideprofiler:H.viewprofiler;this._toggleVisibleEl=this._createButton(G,this._headEl);this._refreshEl=this._createButton(H.refreshdata,this._headEl);C.addClass(this._refreshEl,E.CLASS_REFRESH);this._busyEl=document.createElement("span");this._headEl.appendChild(this._busyEl);var J=document.createElement("h4");J.innerHTML=E.STRINGS.title;this._headEl.appendChild(J);I.appendChild(this._headEl);A.on(this._toggleVisibleEl,"click",this._toggleVisible,this,true);A.on(this._refreshEl,"click",function(){if(!this._busy){this._setBusyState(true);this.fireEvent("dataRefreshEvent");}},this,true);};D._initViewerDOM=function(){var G=this.get("element");this._bodyEl=document.createElement("div");C.addClass(this._bodyEl,"bd");this._tableEl=document.createElement("div");C.addClass(this._tableEl,E.CLASS_TABLE);this._bodyEl.appendChild(this._tableEl);G.appendChild(this._bodyEl);};D._initChartDOM=function(){this._chartContainer=document.createElement("div");C.addClass(this._chartContainer,E.CLASS_CHART_CONTAINER);var H=document.createElement("div");C.addClass(H,E.CLASS_CHART_LEGEND);var G=document.createElement("div");this._chartLegendEl=document.createElement("dl");this._chartLegendEl.innerHTML="<dd>"+E.STRINGS.initMessage+"</dd>";this._chartEl=document.createElement("div");C.addClass(this._chartEl,E.CLASS_CHART);var I=document.createElement("p");I.innerHTML=E.STRINGS.installFlashMessage;this._chartEl.appendChild(I);this._chartContainer.appendChild(H);H.appendChild(G);G.appendChild(this._chartLegendEl);this._chartContainer.appendChild(this._chartEl);this._bodyEl.insertBefore(this._chartContainer,this._tableEl);};D._createButton=function(I,J,H){var G=document.createElement("a");G.innerHTML=G.title=I;if(J){if(!H){J.appendChild(G);}else{J.insertBefore(G,J.firstChild);}}return G;};D._setBusyState=function(G){if(G){C.addClass(this._busyEl,E.CLASS_BUSY);
+this._busy=true;}else{C.removeClass(this._busyEl,E.CLASS_BUSY);this._busy=false;}};D._genSortFunction=function(H,G){var J=H;var I=G;return function(L,K){if(I==YAHOO.widget.DataTable.CLASS_ASC){return L[J]-K[J];}else{return((L[J]-K[J])*-1);}};};var F=function(G){var I=0;for(var H=0;H<G.length;I+=G[H++]){}return I;};D._getProfilerData=function(){var L=B.getFullReport();var N=[];var H=0;for(name in L){if(YAHOO.lang.hasOwnProperty(L,name)){var G=L[name];var I={};I.fn=name;I.points=G.points.slice();I.calls=G.calls;I.min=G.min;I.max=G.max;I.avg=G.avg;I.total=F(I.points);I.points=G.points;var P=this.get("filter");if((!P)||(P(I))){N.push(I);H+=I.total;}}}for(var M=0,K=N.length;M<K;M++){N[M].pct=(H)?(N[M].total*100)/H:0;}var O=this.get("sortedBy");var Q=O.key;var J=O.dir;N.sort(this._genSortFunction(Q,J));return N;};D._initDataTable=function(){var P=this;this._dataSource=new YAHOO.util.DataSource(function(){return P._getProfilerData.call(P);},{responseType:YAHOO.util.DataSource.TYPE_JSARRAY,maxCacheEntries:0});var H=this._dataSource;H.responseSchema={fields:["fn","avg","calls","max","min","total","pct","points"]};var O=function(S,R,T,U){var Q=(U===Math.floor(U))?U:(Math.round(U*1000))/1000;S.innerHTML=Q+" "+E.STRINGS.millisecondsAbbrev;};var N=function(S,R,T,U){var Q=(U===Math.floor(U))?U:(Math.round(U*100))/100;S.innerHTML=Q+"%";};var M=YAHOO.widget.DataTable.CLASS_ASC;var J=YAHOO.widget.DataTable.CLASS_DESC;var K=E.STRINGS.colHeads;var I=O;var L=[{key:"fn",sortable:true,label:K.fn[0],sortOptions:{defaultDir:M},resizeable:(YAHOO.util.DragDrop)?true:false,minWidth:K.fn[1]},{key:"calls",sortable:true,label:K.calls[0],sortOptions:{defaultDir:J},width:K.calls[1]},{key:"avg",sortable:true,label:K.avg[0],sortOptions:{defaultDir:J},formatter:I,width:K.avg[1]},{key:"min",sortable:true,label:K.min[0],sortOptions:{defaultDir:M},formatter:I,width:K.min[1]},{key:"max",sortable:true,label:K.max[0],sortOptions:{defaultDir:J},formatter:I,width:K.max[1]},{key:"total",sortable:true,label:K.total[0],sortOptions:{defaultDir:J},formatter:I,width:K.total[1]},{key:"pct",sortable:true,label:K.pct[0],sortOptions:{defaultDir:J},formatter:N,width:K.pct[1]}];this._dataTable=new YAHOO.widget.DataTable(this._tableEl,L,H,{scrollable:true,height:this.get("tableHeight"),initialRequest:null,sortedBy:{key:"total",dir:YAHOO.widget.DataTable.CLASS_DESC}});var G=this._dataTable;G.subscribe("sortedByChange",this._sortedByChange,this,true);G.subscribe("renderEvent",this._dataTableRenderHandler,this,true);G.subscribe("initEvent",this._dataTableRenderHandler,this,true);A.on(this._tableEl.getElementsByTagName("th"),"click",this._thClickHandler,this,true);};D._sortedByChange=function(G){if(G.newValue&&G.newValue.key){this.set("sortedBy",{key:G.newValue.key,dir:G.newValue.dir});}};D._dataTableRenderHandler=function(G){this._setBusyState(false);};D._thClickHandler=function(G){this._setBusyState(true);};D._refreshDataTable=function(G){var H=this._dataTable;H.getDataSource().sendRequest("",H.onDataReturnInitializeTable,H);};D._refreshChart=function(){switch(this.get("sortedBy").key){case"fn":this._chart.set("dataSource",this._chart.get("dataSource"));return;case"calls":this._chart.set("xAxis",this._chartAxisDefinitionPlain);break;case"pct":this._chart.set("xAxis",this._chartAxisDefinitionPercent);break;default:this._chart.set("xAxis",this._chartAxisDefinitionTime);break;}this._drawChartLegend();this._chart.set("series",this._getSeriesDef(this.get("sortedBy").key));};D._getChartData=function(){var H=this._dataTable.getRecordSet().getRecords(0,this.get("maxChartFunctions"));var G=[];for(var J=0,I=H.length;J<I;J++){G.push(H[J].getData());}return G;};D._getSeriesDef=function(K){var J=this.get("chartSeriesDefinitions")[K];var G=[];for(var I=0,H=J.group.length;I<H;I++){var L=this.get("chartSeriesDefinitions")[J.group[I]];G.push({displayName:L.displayName,xField:L.xField,style:{color:L.style.color,size:L.style.size}});}return G;};D._initChart=function(){this._sizeChartCanvas();YAHOO.widget.Chart.SWFURL=this.get("swfUrl");var G=this;var H=new YAHOO.util.DataSource(function(){return G._getChartData.call(G);},{responseType:YAHOO.util.DataSource.TYPE_JSARRAY,maxCacheEntries:0});H.responseSchema={fields:["fn","avg","calls","max","min","total","pct"]};H.subscribe("responseEvent",this._sizeChartCanvas,this,true);this._chartAxisDefinitionTime=new YAHOO.widget.NumericAxis();this._chartAxisDefinitionTime.labelFunction="YAHOO.widget.ProfilerViewer.timeAxisLabelFunction";this._chartAxisDefinitionPercent=new YAHOO.widget.NumericAxis();this._chartAxisDefinitionPercent.labelFunction="YAHOO.widget.ProfilerViewer.percentAxisLabelFunction";this._chartAxisDefinitionPlain=new YAHOO.widget.NumericAxis();this._chart=new YAHOO.widget.BarChart(this._chartEl,H,{yField:"fn",series:this._getSeriesDef(this.get("sortedBy").key),style:this.get("chartStyle"),xAxis:this._chartAxisDefinitionTime});this._drawChartLegend();this._chartInitialized=true;this._dataTable.unsubscribe("initEvent",this._initChart,this);this._dataTable.subscribe("initEvent",this._refreshChart,this,true);};D._drawChartLegend=function(){var M=this.get("chartSeriesDefinitions");var I=M[this.get("sortedBy").key];var H=this._chartLegendEl;H.innerHTML="";for(var K=0,J=I.group.length;K<J;K++){var N=M[I.group[K]];var L=document.createElement("dt");C.setStyle(L,"backgroundColor","#"+N.style.color);var G=document.createElement("dd");G.innerHTML=N.displayName;H.appendChild(L);H.appendChild(G);}};D._sizeChartCanvas=function(I){var G=(I)?I.response.length:this.get("maxChartFunctions");var H=(G*36)+34;if(H!=parseInt(this._chartElHeight,10)){this._chartElHeight=H;C.setStyle(this._chartEl,"height",H+"px");}};D.initAttributes=function(G){YAHOO.widget.ProfilerViewer.superclass.initAttributes.call(this,G);this.setAttributeConfig("base",{value:G.base});this.setAttributeConfig("tableHeight",{value:G.tableHeight||"15em",method:function(H){if(this._dataTable){this._dataTable.set("height",H);}}});this.setAttributeConfig("sortedBy",{value:G.sortedBy||{key:"total",dir:"yui-dt-desc"}});
+this.setAttributeConfig("filter",{value:G.filter||null,validator:YAHOO.lang.isFunction});this.setAttributeConfig("swfUrl",{value:G.swfUrl||"http://yui.yahooapis.com/2.5.0/build/charts/assets/charts.swf"});this.setAttributeConfig("maxChartFunctions",{value:G.maxChartFunctions||6,method:function(H){if(this._rendered){this._sizeChartCanvas();}},validator:YAHOO.lang.isNumber});this.setAttributeConfig("chartStyle",{value:G.chartStyle||{font:{name:"Arial",color:15658588,size:12},background:{color:"6e6e63"}},method:function(){if(this._rendered&&this.get("showChart")){this._refreshChart();}}});this.setAttributeConfig("chartSeriesDefinitions",{value:G.chartSeriesDefinitions||{total:{displayName:E.STRINGS.colHeads.total[0],xField:"total",style:{color:"4d95dd",size:20},group:["total"]},calls:{displayName:E.STRINGS.colHeads.calls[0],xField:"calls",style:{color:"edff9f",size:20},group:["calls"]},avg:{displayName:E.STRINGS.colHeads.avg[0],xField:"avg",style:{color:"209daf",size:9},group:["avg","min","max"]},min:{displayName:E.STRINGS.colHeads.min[0],xField:"min",style:{color:"b6ecf4",size:9},group:["avg","min","max"]},max:{displayName:E.STRINGS.colHeads.max[0],xField:"max",style:{color:"29c7de",size:9},group:["avg","min","max"]},pct:{displayName:E.STRINGS.colHeads.pct[0],xField:"pct",style:{color:"C96EDB",size:20},group:["pct"]}},method:function(){if(this._rendered&&this.get("showChart")){this._refreshChart();}}});this.setAttributeConfig("visible",{value:G.visible||false,validator:YAHOO.lang.isBoolean,method:function(H){if(H){this._show();}else{if(this._rendered){this._hide();}}}});this.setAttributeConfig("showChart",{value:G.showChart||true,validator:YAHOO.lang.isBoolean,writeOnce:true});YAHOO.widget.ProfilerViewer.superclass.initAttributes.call(this,G);};})();YAHOO.register("profilerviewer",YAHOO.widget.ProfilerViewer,{version:"2.7.0",build:"1796"});
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/docs/public/js/script.js b/vendor/fog-0.8.2/docs/public/js/script.js
new file mode 100755
index 0000000..750842e
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/js/script.js
@@ -0,0 +1,26 @@
+/* Author: 
+
+*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/vendor/fog-0.8.2/docs/public/robots.txt b/vendor/fog-0.8.2/docs/public/robots.txt
new file mode 100755
index 0000000..d310d07
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/public/robots.txt
@@ -0,0 +1,5 @@
+# www.robotstxt.org/
+# www.google.com/support/webmasters/bin/answer.py?hl=en&answer=156449
+
+User-agent: *
+
diff --git a/vendor/fog-0.8.2/docs/storage/index.markdown b/vendor/fog-0.8.2/docs/storage/index.markdown
new file mode 100644
index 0000000..a084292
--- /dev/null
+++ b/vendor/fog-0.8.2/docs/storage/index.markdown
@@ -0,0 +1,200 @@
+---
+layout: default
+title:  Storage
+---
+
+Having Ruby experience makes you hirable; but how can you stand out? You need to demonstrate your abilities. What better way than using Ruby and "the cloud" to store and serve your resume!
+
+In this blog post you will learn to use <a href="http://github.com/geemus/fog">fog</a> - the cloud computing library - to upload your resume to Amazon's <a href="http://aws.amazon.com/s3/">Simple Storage Service</a> (S3), Rackspace's <a href="http://www.rackspacecloud.com/cloud_hosting_products/files">CloudFiles</a> or Google's <a href="http://code.google.com/apis/storage/">Storage for Developers</a>.
+
+Here's my out of date resume stored on <a href="http://geemus.s3.amazonaws.com/resume.html">S3</a>, <a href="http://c0023559.cdn2.cloudfiles.rackspacecloud.com/resume.html">CloudFiles</a> and <a href="https://geemus.commondatastorage.googleapis.com/resume.html">Google Storage</a>; programmatically stored in the cloud using this tutorial. NOTE: my boss would like me to add that I'm not currently looking for a new gig ;)
+
+Check out those cloud-specific URLs! You could put all three in your job application, add the Ruby source for how you did it, and have your choice of Ruby jobs for being so awesome!
+
+How? The all-clouds-in-one library of choice is <a href="https://github.com/geemus/fog">fog</a>.
+
+## Installing fog
+
+fog is distributed as a RubyGem:
+
+    gem install fog
+
+Or add it in your application's Gemfile:
+
+    gem "fog"
+
+## Using Amazon S3 and fog
+
+Sign up for an account <a href="http://aws-portal.amazon.com/gp/aws/developer/subscription/index.html?productCode=AmazonS3">here</a> and copy down your secret access key and access key id from <a href="http://aws-portal.amazon.com/gp/aws/developer/account/index.html?action=access-key">here</a>. We are about to get into the code samples, so be sure to fill in anything in ALL_CAPS with your own values!
+
+First, create a connection with your new account:
+
+    require 'rubygems'
+    require 'fog'
+
+    # create a connection
+    connection = Fog::Storage.new(
+      :provider                 => 'AWS',
+      :aws_secret_access_key    => YOUR_SECRET_ACCESS_KEY,
+      :aws_access_key_id        => YOUR_SECRET_ACCESS_KEY_ID
+    )
+
+    # First, a place to contain the glorious details
+    directory = connection.directories.create(
+      :key    => "fog-demo-#{Time.now.to_i}", # globally unique name
+      :public => true
+    )
+
+    # list directories
+    p connection.directories
+
+    # upload that resume
+    file = directory.files.create(
+      :key    => 'resume.html',
+      :body   => File.open("/path/to/my/resume.html"),
+      :public => true
+    )
+
+If you are anything like me, you will continually tweak your resume. Pushing updates is easy:
+
+    file.body = File.open("/path/to/my/resume.html")
+    file.save
+
+As you can see, cloud storage files in fog are a lot like an ActiveRecord model. Attributes that can be changed and a `#save` method that creates or updates the stored file in the cloud.
+
+But if it took you longer to realize the mistake you might not still have file around, but you've got options.
+
+directory = connection.directories.get("proclamations1234567890")
+
+    # get the resume file
+    file = directory.files.get('resume.html')
+    file.body = File.open("/path/to/my/resume.html")
+    file.save
+
+    # also, create(attributes) is just new(attributes).save, so you can also do:
+    file = directory.files.new(
+      :key    => 'resume.html',
+      :body   => 'improvements',
+      :public => true
+    )
+    file.save
+
+## Backing up your files
+
+Now you've got a bunch of files in S3: your resume, some code samples,
+and maybe some pictures of your cat doing funny stuff. Since this is
+all of vital importance, you need to back it up.
+
+   # copy each file to local disk
+   directory.files.each do |s3_file|
+     File.open(s3_file.key, 'w') do |local_file|
+       local_file.write(s3_file.body)
+     end
+   end
+
+One caveat: it's way more efficient to do this:
+
+  # do two things per file
+  directory.files.each do |file|
+    do_one_thing(file)
+    do_another_thing(file)
+  end
+
+than it is to do this:
+
+  # do two things per file
+  directory.files.each do |file|
+    do_one_thing(file)
+  end.each do |file|
+    do_another_thing(file)
+  end
+
+The reason is that the list of files might be large. Really
+large. Eat-all-your-RAM-and-ask-for-more large. Therefore, every time
+you say `files.each`, fog makes a fresh set of API calls to Amazon to
+list the available files (Amazon's API returns a page at a time, so
+fog works a page at a time in order to keep its memory requirements sane).
+
+## Sending it out
+
+Alright, so you (eventually) become satisfied enough to send it off, what is the URL endpoint to your resume?
+
+    puts file.public_url
+
+Pop that link in an email and you should be ready to cruise job ads and send your resume far and wide (Engine Yard is <a href="http://www.engineyard.com/company/careers/wanted-head-in-the-clouds-engineer">hiring</a>, so check us out!). Now you are set, unless you are interviewing for Google, or Rackspace... Both of these companies have their own cloud storage services, so using Amazon S3 might not be the foot in the door you hoped for.
+
+More clouds? How much extra stuff will you have to do for these services!?! Hardly anything needs to change, you just have to pass slightly different credentials in, but I'm getting ahead of myself.
+
+## Google Storage for Developers
+
+Sign up <a href="http://gs-signup-redirect.appspot.com/">here</a> and get your credentials <a href="https://sandbox.google.com/storage/m/">here</a>.
+
+    connection = Fog::Storage.new(
+      :provider                         => 'Google',
+      :google_storage_secret_access_key => YOUR_SECRET_ACCESS_KEY,
+      :google_storage_access_key_id     => YOUR_SECRET_ACCESS_KEY_ID
+    )
+
+## Rackspace CloudFiles
+
+Rackspace has <a href="http://www.rackspacecloud.com/cloud_hosting_products/files">Cloud Files</a> and you can sign up <a href="https://www.rackspacecloud.com/signup">here</a> and get your credentials <a href="https://manage.rackspacecloud.com/APIAccess.do">here</a>.
+
+    connection = Fog::Storage.new(
+      :provider           => 'Rackspace',
+      :rackspace_username => RACKSPACE_USERNAME,
+      :rackspace_api_key  => RACKSPACE_API_KEY
+    )
+
+Then create, save, destroy as per fog-for-AWS. The `:public => true` option when creating directories (see above) is important for Rackspace; your folder and files won't be shared to Rackspace's CDN and hence your users without it.  Similarly the `:public =&gt; true` on files is important for AWS and Google or they will be private.
+
+## Local Storage
+
+While you are working out the kinks you might not want to do everything live though, ditto for while you are running tests, so you have a couple options to try before you buy.  First, you can use a local provider to store things in a directory on your machine.
+
+    connection = Fog::Storage.new(
+      :provider   => 'Local',
+      :local_root => '~/fog'
+    )
+
+## Mocking out Cloud Storage
+
+Of course when you are testing or developing you can always just use the mocks (at least for AWS and Google, Rackspace still needs mocks implemented if you are looking for somewhere to contribute).  They emulate the behavior of the external systems without actually using them.  It is as simple as:
+
+    Fog.mock!
+    connection = Fog::Storage.new(config_hash)
+
+## Cleaning up
+
+Fog takes care of the rest so you can focus on your cover letter. And with the awesome cover letter and cloud delivered resume you are probably a shoe-in. So all that is left is to cleanup that leftover job hunt residue.
+
+    file.destroy
+    directory.destroy
+
+## Checking if a file already exists
+
+Sometimes you might want to find out some information about a file without retrieving the whole file. You can do that using 'head'.
+
+    #returns nil if the file doesn't exist
+    unless directory.files.head('resume.html')
+       #do something, like creating the file
+    end
+    
+    #returns a hash with the following data:
+    # 'key' - Key for the object
+    # 'Content-Length' - Size of object contents
+    # 'Content-Type' - MIME type of object
+    # 'ETag' - Etag of object
+    # 'Last-Modified' - Last modified timestamp for object
+    puts directory.files.head('resume.html')
+
+## Summary
+
+All done. Try out all the different options and let me know if you have any bugs or issues.  I also wrote up a more <a href="https://gist.github.com/710869">consolidated example as a script</a> that you can use for reference.
+
+Bonus, note the `Fog.mock!` command. In your tests you can easily mock out calls to cloud providers.
+
+Please let me know in the comments if you got a new Ruby job because you hosted your CV on 3 different Cloud Stores without getting your hands dirty.
+
+Have questions or comments?  Hop into <a href="irc://irc.freenode.net/">#ruby-fog</a> on freenode, ping <a href="http://twitter.com/fog">@fog</a> or <a href="http://twitter.com/geemus">@geemus</a>.
+
+And please always remember that I accept high fives and contributions!
diff --git a/vendor/fog-0.8.2/examples/dns_tests.rb b/vendor/fog-0.8.2/examples/dns_tests.rb
new file mode 100644
index 0000000..7308d54
--- /dev/null
+++ b/vendor/fog-0.8.2/examples/dns_tests.rb
@@ -0,0 +1,78 @@
+require 'rubygems'
+require 'shindo'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require File.join(File.dirname(__FILE__), '..', 'tests', 'helper')
+
+Shindo.tests('dns tests', 'dns') do
+
+  # iterate over all the providers
+  Fog.providers.each do |provider|
+
+    provider = eval(provider) # convert from string to object
+
+    # skip if provider does not have storage
+    next unless provider.respond_to?(:services) && provider.services.include?(:dns)
+
+    tests(provider, provider.to_s.downcase) do
+
+      # use shortcuts to instantiate connection
+      @dns = Fog::DNS.new(:provider => provider.to_s)
+
+      # create a zone
+      #   domain should be the hostname
+      #   email is only required for linode, but included for consistency
+      tests('@zone = @dns.zones.create').succeeds do
+        @zone = @dns.zones.create(
+          :domain => 'fogdnsexamples.com',
+          :email => 'tests@fogdnsexamples.com'
+        )
+      end
+
+      # create a record in the zone
+      #   ip is the address to route to
+      #   name is the name for the record
+      #   type is the type of record to create
+      tests('@record = @zone.records.create').succeeds do
+        @record = @zone.records.create(
+          :ip => '1.2.3.4',
+          :name => 'www.fogdnsexamples.com',
+          :type => 'A'
+        )
+      end
+
+      # list zones
+      tests('@zones = @dns.zones').succeeds do
+        @zones = @dns.zones
+      end
+
+      # get a zone
+      tests('@dns.zones.get(@zone.identity)').succeeds do
+        @dns.zones.get(@zone.identity)
+      end
+
+      # list records
+      tests('@records = @zone.records').succeeds do
+        @records = @zone.records
+      end
+
+      # get a record
+      tests('@zone.records.get(@record.identity)').succeeds do
+        @zone.records.get(@record.identity)
+      end
+
+      # destroy the record
+      tests('@record.destroy').succeeds do
+        @record.destroy
+      end
+
+      # destroy the zone
+      tests('@zone.destroy').succeeds do
+        @zone.destroy
+      end
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/examples/storage_tests.rb b/vendor/fog-0.8.2/examples/storage_tests.rb
new file mode 100755
index 0000000..86f2a1e
--- /dev/null
+++ b/vendor/fog-0.8.2/examples/storage_tests.rb
@@ -0,0 +1,105 @@
+require 'rubygems'
+require 'shindo'
+
+require File.join(File.dirname(__FILE__), '..', 'lib', 'fog')
+require File.join(File.dirname(__FILE__), '..', 'tests', 'helper')
+
+Shindo.tests('storage tests', 'storage') do
+
+  # iterate over all the providers
+  Fog.providers.each do |provider|
+
+    provider = eval(provider) # convert from string to object
+
+    # skip if provider does not have storage
+    next unless provider.respond_to?(:services) && provider.services.include?(:storage)
+
+    tests(provider, provider.to_s.downcase) do
+
+      # use shortcuts to instantiate connection
+      @storage = Fog::Storage.new(:provider => provider.to_s)
+
+      # for compatibility public is simply true or false
+      [false, true].each do |publicity|
+
+        tests(":public => #{publicity}") do
+
+          # create a directory
+          #   key should be a unique string
+          #   public should be a boolean
+          tests('@directory = @storage.directories.create').succeeds do
+            @directory = @storage.directories.create(
+              :key    => "fogstoragedirectory#{Time.now.to_i}",
+              :public => publicity
+            )
+          end
+
+          # list directories
+          tests('@directories = @storage.directories').succeeds do
+            @directories = @storage.directories
+          end
+
+          # get a directory
+          tests('@storage.directories.get(@directory.identity)').succeeds do
+            @storage.directories.get(@directory.identity)
+          end
+
+          # create a file in the directory
+          #   key can be any string
+          #   body can be a string or a file as File.open(path)
+          #   public should be a boolean and match the directory
+          tests('@file = @directory.files.create').succeeds do
+            @file = @directory.files.create(
+              :body   => 'fog_storage_object_body',
+              :key    => 'fogstorageobject',
+              :public => publicity
+            )
+          end
+
+          # list files
+          tests('@files = @directory.files').succeeds do
+            @files = @directory.files
+          end
+
+          # get a file
+          tests('@directory.files.get(@file.identity)').succeeds do
+            @directory.files.get(@file.identity)
+          end
+
+          # test the publicity of files
+          # Local is unable to inherently serve files, so we can skip it
+          unless provider == Local
+            # if the file is public it should have a url
+            test('!!@file.public_url == publicity') do
+              pending if Fog.mocking?
+              !!@file.public_url == publicity
+            end
+
+            # if it is public ensure that public url is usable
+            if publicity
+              tests('Excon.get(@file.public_url).body').returns('fog_storage_object_body') do
+                pending if Fog.mocking?
+                Excon.get(@file.public_url).body
+              end
+            end
+          end
+
+          # destroy the file
+          tests('@file.destroy').succeeds do
+            @file.destroy
+          end
+
+          # destroy the directory
+          tests('@directory.destroy').succeeds do
+            @directory.destroy
+          end
+
+        end
+
+      end
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/fog.gemspec b/vendor/fog-0.8.2/fog.gemspec
new file mode 100644
index 0000000..47c651e
--- /dev/null
+++ b/vendor/fog-0.8.2/fog.gemspec
@@ -0,0 +1,59 @@
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'fog'
+  s.version           = '0.8.2'
+  s.date              = '2011-05-26'
+  s.rubyforge_project = 'fog'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "brings clouds to you"
+  s.description = "The Ruby cloud services library."
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/fog'
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  s.executables = ["fog"]
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  s.add_dependency('builder')
+  s.add_dependency('excon', '~>0.6.1')
+  s.add_dependency('formatador', '>=0.1.3')
+  s.add_dependency('json')
+  s.add_dependency('mime-types')
+  s.add_dependency('net-ssh', '>=2.1.3')
+  s.add_dependency('nokogiri', '>=1.4.4')
+  s.add_dependency('ruby-hmac')
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('jekyll')
+  s.add_development_dependency('rake')
+  s.add_development_dependency('rdoc')
+  s.add_development_dependency('rspec', '1.3.1')
+  s.add_development_dependency('shindo', '0.3.4')
+  s.add_development_dependency('virtualbox', '0.8.3')
+
+  s.files = `git ls-files`.split("\n")
+  s.test_files = `git ls-files -- {spec,tests}/*`.split("\n")
+end
diff --git a/vendor/fog-0.8.2/lib/fog.rb b/vendor/fog-0.8.2/lib/fog.rb
new file mode 100644
index 0000000..3c6e5b5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog.rb
@@ -0,0 +1,18 @@
+require File.join(File.dirname(__FILE__), 'fog', 'core')
+
+module Fog
+
+  unless const_defined?(:VERSION)
+    VERSION = '0.8.2'
+  end
+
+end
+
+# FIXME: these should go away (force usage of Fog::[Compute, CDN, DNS, Storage]  etc)
+require 'fog/providers'
+require 'fog/terremark'
+
+require 'fog/compute'
+require 'fog/cdn'
+require 'fog/dns'
+require 'fog/storage'
diff --git a/vendor/fog-0.8.2/lib/fog/aws/cloud_formation.rb b/vendor/fog-0.8.2/lib/fog/aws/cloud_formation.rb
new file mode 100644
index 0000000..4a68ceb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/cloud_formation.rb
@@ -0,0 +1,124 @@
+module Fog
+  module AWS
+    class CloudFormation < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :persistent, :region
+
+      request_path 'fog/aws/requests/cloud_formation'
+      request :create_stack
+      request :delete_stack
+      request :describe_stack_events
+      request :describe_stack_resources
+      request :describe_stacks
+      request :get_template
+      request :validate_template
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to CloudFormation
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   cf = CloudFormation.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * CloudFormation object with connection to AWS.
+        def initialize(options={})
+          require 'fog/core/parser'
+          require 'json'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-northeast-1'
+            'cloudformation.ap-northeast-1.amazonaws.com'
+          when 'ap-southeast-1'
+            'cloudformation.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'cloudformation.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'cloudformation.us-east-1.amazonaws.com'
+          when 'us-west-1'
+            'cloudformation.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-05-15'
+            }
+          )
+
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :idempotent => idempotent,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::HTTPStatusError => error
+            if match = error.message.match(/<Code>(.*)<\/Code><Message>(.*)<\/Message>/)
+              raise case match[1].split('.').last
+              when 'NotFound'
+                Fog::AWS::Compute::NotFound.slurp(error, match[2])
+              else
+                Fog::AWS::Compute::Error.slurp(error, "#{match[1]} => #{match[2]}")
+              end
+            else
+              raise error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/elb.rb b/vendor/fog-0.8.2/lib/fog/aws/elb.rb
new file mode 100644
index 0000000..1da7b28
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/elb.rb
@@ -0,0 +1,146 @@
+module Fog
+  module AWS
+    class ELB < Fog::Service
+
+      class IdentifierTaken < Fog::Errors::Error; end
+      class InvalidInstance < Fog::Errors::Error; end
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :region, :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/elb'
+      request :configure_health_check
+      request :create_app_cookie_stickiness_policy
+      request :create_lb_cookie_stickiness_policy
+      request :create_load_balancer
+      request :create_load_balancer_listeners
+      request :delete_load_balancer
+      request :delete_load_balancer_listeners
+      request :delete_load_balancer_policy
+      request :deregister_instances_from_load_balancer
+      request :describe_instance_health
+      request :describe_load_balancers
+      request :disable_availability_zones_for_load_balancer
+      request :enable_availability_zones_for_load_balancer
+      request :register_instances_with_load_balancer
+      #request :set_load_balancer_listener_ssl_certificate
+      request :set_load_balancer_policies_of_listener
+
+      model_path 'fog/aws/models/elb'
+      model      :load_balancer
+      collection :load_balancers
+      model      :policy
+      collection :policies
+      model      :listener
+      collection :listeners
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to ELB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   elb = ELB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1'i, 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * ELB object with connection to AWS.
+        def initialize(options={})
+          require 'fog/core/parser'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-northeast-1'
+            'elasticloadbalancing.ap-northeast-1.amazonaws.com'
+          when 'ap-southeast-1'
+            'elasticloadbalancing.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'elasticloadbalancing.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'elasticloadbalancing.us-east-1.amazonaws.com'
+          when 'us-west-1'
+            'elasticloadbalancing.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-07-01'
+          }
+          )
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :idempotent => idempotent,
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::HTTPStatusError => error
+            if match = error.message.match(/<Code>(.*)<\/Code>/m)
+              case match[1]
+              when 'LoadBalancerNotFound'
+                raise Fog::AWS::ELB::NotFound
+              when 'DuplicateLoadBalancerName'
+                raise Fog::AWS::ELB::IdentifierTaken
+              when 'InvalidInstance'
+                raise Fog::AWS::ELB::InvalidInstance
+              else
+                raise
+              end
+            else
+              raise
+            end
+          end
+
+          response
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/iam.rb b/vendor/fog-0.8.2/lib/fog/aws/iam.rb
new file mode 100644
index 0000000..1fd85a1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/iam.rb
@@ -0,0 +1,124 @@
+module Fog
+  module AWS
+    class IAM < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/iam'
+      request :add_user_to_group
+      request :create_access_key
+      request :create_group
+      request :create_user
+      request :create_login_profile
+      request :delete_access_key
+      request :delete_group
+      request :delete_group_policy
+      request :delete_login_profile
+      request :delete_server_certificate
+      request :delete_signing_certificate
+      request :delete_user
+      request :delete_user_policy
+      request :get_login_profile
+      request :get_user
+      request :get_user_policy
+      request :get_group
+      request :list_access_keys
+      request :list_groups
+      request :list_groups_for_user
+      request :list_group_policies
+      request :list_server_certificates
+      request :list_signing_certificates
+      request :list_user_policies
+      request :list_users
+      request :put_group_policy
+      request :put_user_policy
+      request :remove_user_from_group
+      request :update_access_key
+      request :update_group
+      request :update_login_profile
+      request :update_user
+      request :update_signing_certificate
+      request :upload_server_certificate
+      request :upload_signing_certificate
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to IAM
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   iam = IAM.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * IAM object with connection to AWS.
+        def initialize(options={})
+          require 'fog/core/parser'
+          require 'json'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @host       = options[:host]      || 'iam.amazonaws.com'
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-05-08'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :idempotent => idempotent,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+            :host       => @host,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/listener.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/listener.rb
new file mode 100644
index 0000000..915b4e8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/listener.rb
@@ -0,0 +1,51 @@
+require 'fog/core/model'
+module Fog
+  module AWS
+    class ELB
+      class Listener < Fog::Model
+
+        attribute :policy_names,  :aliases => 'PolicyNames'
+        attribute :instance_port, :aliases => 'InstancePort'
+        attribute :lb_port,       :aliases => 'LoadBalancerPort'
+        attribute :protocol,      :aliases => 'Protocol'
+        attribute :ssl_id,        :aliases => 'SSLCertificateId'
+
+        def save
+          requires :load_balancer, :instance_port, :lb_port, :protocol
+          connection.create_load_balancer_listeners(load_balancer.id, [to_params])
+          reload
+        end
+
+        def destroy
+          requires :load_balancer, :lb_port
+          connection.delete_load_balancer_listeners(load_balancer.id, [lb_port])
+          reload
+        end
+
+        # Return the policy associated with this load balancer
+        def policy
+          load_balancer.policies.get(policy_names.first)
+        end
+
+        def reload
+          load_balancer.reload
+        end
+
+        def load_balancer
+          collection.load_balancer
+        end
+
+        def to_params
+          {
+            'InstancePort'     => instance_port,
+            'LoadBalancerPort' => lb_port,
+            'Protocol'         => protocol,
+            'SSLCertificateId' => ssl_id
+          }
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/listeners.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/listeners.rb
new file mode 100644
index 0000000..908c189
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/listeners.rb
@@ -0,0 +1,32 @@
+require 'fog/aws/models/elb/listener'
+module Fog
+  module AWS
+    class ELB
+      class Listeners < Fog::Collection
+
+        model Fog::AWS::ELB::Listener
+
+        attr_accessor :data, :load_balancer
+
+        def all
+          load(munged_data)
+        end
+
+        def get(lb_port)
+          all.detect{|listener| listener.lb_port == lb_port}
+        end
+
+        private
+        # Munge an array of ListernerDescription hashes like:
+        # {'Listener' => listener, 'PolicyNames' => []}
+        # to an array of listeners withi a PolicyNames key
+        def munged_data
+          data.map {|description|
+            description['Listener'].merge('PolicyNames' => description['PolicyNames'])
+          }
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancer.rb
new file mode 100644
index 0000000..c36c38c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancer.rb
@@ -0,0 +1,129 @@
+require 'fog/core/model'
+module Fog
+  module AWS
+    class ELB
+
+      class LoadBalancer < Fog::Model
+
+        identity  :id,                    :aliases => 'LoadBalancerName'
+        attribute :created_at,            :aliases => 'CreatedTime'
+        attribute :health_check,          :aliases => 'HealthCheck'
+        attribute :dns_name,              :aliases => 'DNSName'
+        attribute :availability_zones,    :aliases => 'AvailabilityZones'
+        attribute :instances,             :aliases => 'Instances'
+
+        def initialize(attributes={})
+          attributes[:availability_zones] ||= %w(us-east-1a us-east-1b us-east-1c us-east-1d)
+          attributes['ListenerDescriptions'] ||= [{
+            'Listener' => {'LoadBalancerPort' => 80, 'InstancePort' => 80, 'Protocol' => 'http'},
+            'PolicyNames' => []
+          }]
+          attributes['Policies'] ||= {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => []}
+          super
+        end
+
+        def register_instances(instances)
+          requires :id
+          data = connection.register_instances_with_load_balancer(instances, id).body['RegisterInstancesWithLoadBalancerResult']
+          data['Instances'].map!{|h| h['InstanceId']}
+          merge_attributes(data)
+        end
+
+        def deregister_instances(instances)
+          requires :id
+          data = connection.deregister_instances_from_load_balancer(instances, id).body['DeregisterInstancesFromLoadBalancerResult']
+          data['Instances'].map!{|h| h['InstanceId']}
+          merge_attributes(data)
+        end
+
+        def enable_availability_zones(zones)
+          requires :id
+          data = connection.enable_availability_zones_for_load_balancer(zones, id).body['EnableAvailabilityZonesForLoadBalancerResult']
+          merge_attributes(data)
+        end
+
+        def disable_availability_zones(zones)
+          requires :id
+          data = connection.disable_availability_zones_for_load_balancer(zones, id).body['DisableAvailabilityZonesForLoadBalancerResult']
+          merge_attributes(data)
+        end
+
+        def instance_health
+          requires :id
+          @instance_health ||= connection.describe_instance_health(id).body['DescribeInstanceHealthResult']['InstanceStates']
+        end
+
+        def instances_in_service
+          instance_health.select{|hash| hash['State'] == 'InService'}.map{|hash| hash['InstanceId']}
+        end
+
+        def instances_out_of_service
+          instance_health.select{|hash| hash['State'] == 'OutOfService'}.map{|hash| hash['InstanceId']}
+        end
+
+        def configure_health_check(health_check)
+          requires :id
+          data = connection.configure_health_check(id, health_check).body['ConfigureHealthCheckResult']['HealthCheck']
+          merge_attributes(:health_check => data)
+        end
+
+        def listeners
+          Fog::AWS::ELB::Listeners.new({
+            :data => attributes['ListenerDescriptions'],
+            :connection => connection,
+            :load_balancer => self
+          })
+        end
+
+        def policies
+          Fog::AWS::ELB::Policies.new({
+            :data => attributes['Policies'],
+            :connection => connection,
+            :load_balancer => self
+          })
+        end
+
+        def set_listener_policy(port, policy_name)
+          requires :id
+          policy_name = [policy_name].flatten
+          connection.set_load_balancer_policies_of_listener(id, port, policy_name)
+          reload
+        end
+
+        def unset_listener_policy(port)
+          set_listener_policy(port, [])
+        end
+
+        def ready?
+          # ELB requests are synchronous
+          true
+        end
+
+        def save
+          requires :id
+          requires :listeners
+          requires :availability_zones
+
+          connection.create_load_balancer(availability_zones, id, listeners.map{|l| l.to_params})
+
+          # reload instead of merge attributes b/c some attrs (like HealthCheck)
+          # may be set, but only the DNS name is returned in the create_load_balance
+          # API call
+          reload
+        end
+
+        def reload
+          super
+          @instance_health = nil
+          self
+        end
+
+        def destroy
+          requires :id
+          connection.delete_load_balancer(id)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancers.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancers.rb
new file mode 100644
index 0000000..922d321
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/load_balancers.rb
@@ -0,0 +1,28 @@
+require 'fog/aws/models/elb/load_balancer'
+module Fog
+  module AWS
+    class ELB
+      class LoadBalancers < Fog::Collection
+        model Fog::AWS::ELB::LoadBalancer
+
+        # Creates a new load balancer
+        def initialize(attributes={})
+          super
+        end
+
+        def all
+          data = connection.describe_load_balancers.body['DescribeLoadBalancersResult']['LoadBalancerDescriptions']
+          load(data)
+        end
+
+        def get(identity)
+          data = connection.describe_load_balancers(identity).body['DescribeLoadBalancersResult']['LoadBalancerDescriptions'].first
+          new(data)
+        rescue Fog::AWS::ELB::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/policies.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/policies.rb
new file mode 100644
index 0000000..081934e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/policies.rb
@@ -0,0 +1,40 @@
+require 'fog/aws/models/elb/policy'
+module Fog
+  module AWS
+    class ELB
+      class Policies < Fog::Collection
+
+        model Fog::AWS::ELB::Policy
+
+        attr_accessor :data, :load_balancer
+
+        def all
+          load(munged_data)
+        end
+
+        def get(id)
+          all.detect{|policy| id == policy.id}
+        end
+
+        private
+        # Munge a hash like:
+        # {'LBCookieStickinessPolicies' => [policies...],
+        # 'AppCookieStickinessPolicies' => [policies...]}
+        # to a single array of policies with a cookie_stickiness value
+        def munged_data
+          munged_data = []
+          data['LBCookieStickinessPolicies'].each do |policy|
+            munged_data << policy.merge(:cookie_stickiness => :lb)
+          end
+           data['AppCookieStickinessPolicies'].each do |policy|
+            munged_data << policy.merge(:cookie_stickiness => :app)
+          end
+           munged_data
+        end
+
+      end
+
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/elb/policy.rb b/vendor/fog-0.8.2/lib/fog/aws/models/elb/policy.rb
new file mode 100644
index 0000000..9ba10c1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/elb/policy.rb
@@ -0,0 +1,52 @@
+require 'fog/core/model'
+module Fog
+  module AWS
+    class ELB
+
+      class Policy < Fog::Model
+        identity :id, :aliases => 'PolicyName'
+
+        attribute :cookie,     :aliases => 'CookieName'
+        attribute :expiration, :aliases => 'CookieExpirationPeriod'
+
+        attr_accessor :cookie_stickiness # Either :app or :lb
+
+        def save
+          requires :id, :load_balancer, :cookie_stickiness
+          connection_method = nil
+          args = [load_balancer.id, id]
+          case cookie_stickiness
+          when :app
+            requires :cookie
+            method = :create_app_cookie_stickiness_policy
+            args << cookie
+          when :lb
+            method = :create_lb_cookie_stickiness_policy
+            args << expiration if expiration
+          else
+            raise ArgumentError.new('cookie_stickiness must be :app or :lb')
+          end
+
+          connection.send(method, *args)
+          reload
+        end
+
+        def destroy
+          requires :id, :load_balancer
+          connection.delete_load_balancer_policy(load_balancer.id, id)
+          reload
+        end
+
+        def reload
+          load_balancer.reload
+        end
+
+        def load_balancer
+          collection.load_balancer
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter.rb
new file mode 100644
index 0000000..3e31492
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter.rb
@@ -0,0 +1,21 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class RDS
+      
+      class Parameter < Fog::Model
+
+        attribute  :name, :aliases => ['ParameterName']
+        attribute  :data_type, :aliases => 'DataType'
+        attribute  :description, :aliases => 'Description'
+        attribute  :allowed_values, :aliases => 'AllowedValues'
+        attribute  :source, :aliases => 'Source'
+        attribute  :modifiable, :aliases => 'IsModifiable'
+        attribute  :apply_type, :aliases => 'ApplyType'
+        attribute  :value, :aliases => 'ParameterValue'
+        
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_group.rb
new file mode 100644
index 0000000..d584535
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_group.rb
@@ -0,0 +1,36 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class RDS
+      
+      class ParameterGroup < Fog::Model
+
+        identity  :id, :aliases => ['DBParameterGroupName', :name]
+        attribute  :family, :aliases => 'DBParameterGroupFamily'
+        attribute  :description, :aliases => 'Description'
+        
+        def save
+          requires :family
+          requires :description
+          requires :id
+          connection.create_db_parameter_group(id, family, description)
+        end
+        
+        def modify(changes)
+          connection.modify_db_parameter_group id, changes.collect {|c| {'ParameterName' => c[:name], 'ParameterValue' => c[:value], 'ApplyMethod' => c[:apply_method]}}
+        end
+        
+        def destroy
+          requires :id
+          connection.delete_db_parameter_group(id)
+          true
+        end
+        
+        def parameters(filters={})
+          connection.parameters({:group => self}.merge(filters))
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_groups.rb
new file mode 100644
index 0000000..2ac75bb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameter_groups.rb
@@ -0,0 +1,27 @@
+require 'fog/core/collection'
+require 'fog/aws/models/rds/parameter_group'
+
+module Fog
+  module AWS
+    class RDS
+
+      class ParameterGroups < Fog::Collection
+
+        model Fog::AWS::RDS::ParameterGroup
+
+        def all
+          data = connection.describe_db_parameter_groups.body['DescribeDBParameterGroupsResult']['DBParameterGroups']
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identity)
+          data = connection.describe_db_parameter_groups(identity).body['DescribeDBParameterGroupsResult']['DBParameterGroups'].first
+          new(data) # data is an attribute hash
+        rescue Fog::AWS::RDS::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameters.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameters.rb
new file mode 100644
index 0000000..18e69d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/parameters.rb
@@ -0,0 +1,37 @@
+require 'fog/core/collection'
+require 'fog/aws/models/rds/parameter'
+
+module Fog
+  module AWS
+    class RDS
+
+      class Parameters < Fog::Collection
+        attribute :group
+        attribute :filters
+        model Fog::AWS::RDS::Parameter
+
+        def initialize(attributes)
+          self.filters ||= {}
+          if attributes[:source]
+            filters[:source] = attributes[:source]
+          end
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          result = []
+          marker = nil
+          finished = false
+          while !finished
+            data = connection.describe_db_parameters(group.id, filters.merge(:marker => marker)).body
+            result.concat(data['DescribeDBParametersResult']['Parameters'])
+            marker = data['DescribeDBParametersResult']['Marker']
+            finished = marker.nil?
+          end
+          load(result) # data is an array of attribute hashes
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_group.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_group.rb
new file mode 100644
index 0000000..0b84662
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_group.rb
@@ -0,0 +1,73 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class RDS
+
+      class SecurityGroup < Fog::Model
+
+        identity   :id, :aliases => ['DBSecurityGroupName']
+        attribute  :description, :aliases => 'DBSecurityGroupDescription'
+        attribute  :ec2_security_groups, :aliases => 'EC2SecurityGroups', :type => :array
+        attribute  :ip_ranges, :aliases => 'IPRanges', :type => :array
+        attribute  :owner_id, :aliases => 'OwnerId'
+
+        def ready?
+          (ec2_security_groups + ip_ranges).all?{|ingress| ingress['Status'] == 'authorized'}
+        end
+
+        def destroy
+          requires :id
+          connection.delete_db_security_group(id)
+          true
+        end
+
+        def save
+          requires :id
+          requires :description
+
+          data = connection.create_db_security_group(id, description).body['CreateDBSecurityGroupResult']['DBSecurityGroup']
+          merge_attributes(data)
+          true
+        end
+
+        # group_owner_id defaults to the current owner_id
+        def authorize_ec2_security_group(group_name, group_owner_id=owner_id)
+          authorize_ingress({
+            'EC2SecurityGroupName' => group_name,
+            'EC2SecurityGroupOwnerId' => group_owner_id
+          })
+        end
+
+        def authorize_cidrip(cidrip)
+          authorize_ingress({'CIDRIP' => cidrip})
+        end
+
+        def authorize_ingress(opts)
+          data = connection.authorize_db_security_group_ingress(id, opts).body['AuthorizeDBSecurityGroupIngressResult']['DBSecurityGroup']
+          merge_attributes(data)
+        end
+
+        # group_owner_id defaults to the current owner_id
+        def revoke_ec2_security_group(group_name, group_owner_id=owner_id)
+          revoke_ingress({
+            'EC2SecurityGroupName' => group_name,
+            'EC2SecurityGroupOwnerId' => group_owner_id
+          })
+        end
+
+        def revoke_cidrip(cidrip)
+          revoke_ingress({'CIDRIP' => cidrip})
+        end
+
+        def revoke_ingress(opts)
+          data = connection.revoke_db_security_group_ingress(id, opts).body['RevokeDBSecurityGroupIngressResult']['DBSecurityGroup']
+          merge_attributes(data)
+        end
+
+
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_groups.rb
new file mode 100644
index 0000000..dd5220e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/security_groups.rb
@@ -0,0 +1,43 @@
+require 'fog/core/collection'
+require 'fog/aws/models/rds/security_group'
+
+module Fog
+  module AWS
+    class RDS
+
+      class SecurityGroups < Fog::Collection
+        attribute :server
+        attribute :filters
+        model Fog::AWS::RDS::SecurityGroup
+
+        def initialize(attributes={})
+          self.filters ||= {}
+          if attributes[:server]
+            filters[:identifier] = attributes[:server].id
+          end
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_db_security_groups(filters).body['DescribeDBSecurityGroupsResult']['DBSecurityGroups']
+          load(data) # data is an array of attribute hashes
+        end
+
+        # Example:
+        # get('my_db_security_group') # => model for my_db_security_group
+        def get(identity)
+          data = connection.describe_db_security_groups(identity).body['DescribeDBSecurityGroupsResult']['DBSecurityGroups'].first
+          new(data) # data is an attribute hash
+        rescue Fog::AWS::RDS::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          super
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/server.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/server.rb
new file mode 100644
index 0000000..f514643
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/server.rb
@@ -0,0 +1,105 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class RDS
+
+      class Server < Fog::Model
+
+        identity  :id, :aliases => 'DBInstanceIdentifier'
+        attribute :engine, :aliases => 'Engine'
+        attribute :engine_version, :aliases => 'EngineVersion'
+        attribute :state, :aliases => 'DBInstanceStatus'
+        attribute :allocated_storage, :aliases => 'AllocatedStorage', :type => :integer
+        attribute :availability_zone , :aliases => 'AvailabilityZone'
+        attribute :flavor_id, :aliases => 'DBInstanceClass'
+        attribute :endpoint, :aliases => 'Endpoint'
+        attribute :read_replica_source, :aliases => 'ReadReplicaSourceDBInstanceIdentifier'
+        attribute :read_replica_identifiers, :aliases => 'ReadReplicaDBInstanceIdentifiers', :type => :array
+        attribute :master_username, :aliases => 'MasterUsername'
+        attribute :multi_az, :aliases => 'MultiAZ'
+        attribute :created_at, :aliases => 'InstanceCreateTime', :type => :time
+        attribute :last_restorable_time, :aliases => 'LatestRestorableTime', :type => :time
+        attribute :auto_minor_version_upgrade, :aliases => 'AutoMinorVersionUpgrade'
+        attribute :pending_modified_values, :aliases => 'PendingModifiedValues'
+        attribute :preferred_backup_window, :aliases => 'PreferredBackupWindow'
+        attribute :preferred_maintenance_window, :aliases => 'PreferredMaintenanceWindow'
+        attribute :db_name, :aliases => 'DBName'
+        attribute :db_security_groups, :aliases => 'DBSecurityGroups'
+        attribute :db_parameter_groups, :aliases => 'DBParameterGroups'
+        attribute :backup_retention_period, :aliases => 'BackupRetentionPeriod', :type => :integer
+
+        attr_accessor :password, :parameter_group_name, :security_group_names, :port
+        
+        def initialize(attributes={})
+          self.flavor_id ||= 'db.m1.small'
+          super
+        end
+
+        def create_read_replica(replica_id, options={})
+          connection.create_db_instance_read_replica(replica_id, id, options)
+          connection.servers.get(replica_id)
+        end
+        
+        def ready?
+          state == 'available'
+        end
+   
+        def destroy(snapshot_identifier)
+          requires :id
+          connection.delete_db_instance(id, snapshot_identifier, snapshot_identifier.nil?)
+          true
+        end
+
+        def reboot
+          connection.reboot_db_instance(id)
+          true
+        end
+        
+        def snapshots
+          requires :id
+          connection.snapshots(:server => self)
+        end
+        
+        def modify(immediately, options)
+          data = connection.modify_db_instance(id, immediately, options)
+          merge_attributes(data.body['ModifyDBInstanceResult']['DBInstance'])
+          true  
+        end
+        
+        def save
+          requires :engine
+          requires :allocated_storage
+          requires :master_username
+          requires :password
+          options = {
+            'AllocatedStorage'              => allocated_storage,
+            'AutoMinorVersionUpgrade'       => auto_minor_version_upgrade,
+            'BackupRetentionPeriod'         => backup_retention_period,
+            'DBName'                        => db_name,
+            'DBParameterGroupName'          => parameter_group_name,
+            'DBSecurityGroups'              => security_group_names,
+            'DBInstanceIdentifier'          => id,
+            'AvailabilityZone'              => availability_zone,
+            'DBInstanceClass'               => flavor_id,
+            'Port'                          => port,
+            'Engine'                        => engine,
+            'EngineVersion'                 => engine_version,
+            'MasterUsername'                => master_username,
+            'MasterUserPassword'            => password,
+            'PreferredMaintenanceWindow'    => preferred_maintenance_window,
+            'PreferredBackupWindow'         => preferred_backup_window,
+            'MultiAZ'                       => multi_az
+          }
+          options.delete_if {|key, value| value.nil?}
+
+
+          data = connection.create_db_instance(id, options)
+          merge_attributes(data.body['CreateDBInstanceResult']['DBInstance'])
+          true
+        end
+        
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/servers.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/servers.rb
new file mode 100644
index 0000000..d291e9d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/servers.rb
@@ -0,0 +1,27 @@
+require 'fog/core/collection'
+require 'fog/aws/models/rds/server'
+
+module Fog
+  module AWS
+    class RDS
+
+      class Servers < Fog::Collection
+
+        model Fog::AWS::RDS::Server
+
+        def all
+          data = connection.describe_db_instances.body['DescribeDBInstancesResult']['DBInstances']
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identity)
+          data = connection.describe_db_instances(identity).body['DescribeDBInstancesResult']['DBInstances'].first
+          new(data) # data is an attribute hash
+        rescue Fog::AWS::RDS::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshot.rb
new file mode 100644
index 0000000..c91df09
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshot.rb
@@ -0,0 +1,49 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class RDS
+
+      class Snapshot < Fog::Model
+
+        identity  :id, :aliases => ['DBSnapshotIdentifier', :name]
+        attribute  :instance_id, :aliases => 'DBInstanceIdentifier'
+        attribute  :created_at, :aliases => 'SnapshotCreateTime', :type => :time
+        attribute  :instance_created_at, :aliases => 'InstanceCreateTime', :type => :time
+        attribute  :engine, :aliases => 'Engine'
+        attribute  :engine_version, :aliases => 'EngineVersion'
+        attribute  :master_username, :aliases => 'MasterUsername'
+        attribute  :state, :aliases => 'Status'
+        attribute  :port, :aliases => 'Port', :type => :integer
+        attribute  :allocated_storage, :aliases => 'AllocatedStorage', :type => :integer
+        attribute  :availability_zone, :aliases => 'AvailabilityZone'
+
+        def ready?
+          state == 'available'
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_db_snapshot(id)
+          true
+        end
+
+        def save
+          requires :instance_id
+          requires :id
+
+          data = connection.create_db_snapshot(instance_id, id).body['CreateDBSnapshotResult']['DBSnapshot']
+          merge_attributes(data)
+          true
+        end
+
+        def server
+          requires :instance_id
+          connection.servers.get(instance_id)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshots.rb b/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshots.rb
new file mode 100644
index 0000000..7a53e3a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/models/rds/snapshots.rb
@@ -0,0 +1,45 @@
+require 'fog/core/collection'
+require 'fog/aws/models/rds/snapshot'
+
+module Fog
+  module AWS
+    class RDS
+
+      class Snapshots < Fog::Collection
+        attribute :server
+        attribute :filters
+        model Fog::AWS::RDS::Snapshot
+
+        def initialize(attributes)
+          self.filters ||= {}
+          if attributes[:server]
+            filters[:identifier] = attributes[:server].id
+          end
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_db_snapshots(filters).body['DescribeDBSnapshotsResult']['DBSnapshots']
+          load(data) # data is an array of attribute hashes
+        end
+
+        def get(identity)
+          data = connection.describe_db_snapshots(:snapshot_id => identity).body['DescribeDBSnapshotsResult']['DBSnapshots'].first
+          new(data) # data is an attribute hash
+        rescue Fog::AWS::RDS::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :instance_id => server.id }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/basic.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/basic.rb
new file mode 100644
index 0000000..b73b5d4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/basic.rb
@@ -0,0 +1,12 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class Basic < Fog::Parsers::Base
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/create_stack.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/create_stack.rb
new file mode 100644
index 0000000..0023214
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/create_stack.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class CreateStack < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'RequestId', 'StackId'
+              @response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_events.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_events.rb
new file mode 100644
index 0000000..0348f6f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_events.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class DescribeStackEvents < Fog::Parsers::Base
+
+          def reset
+            @event = {}
+            @response = { 'StackEvents' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'EventId', 'LogicalResourceId', 'PhysicalResourceId', 'ResourceProperties', 'ResourceStatus', 'ResourceStatusReason', 'ResourceType', 'StackId', 'StackName'
+              @event[name] = value
+            when 'member'
+              @response['StackEvents'] << @event
+              @event = {}
+            when 'RequestId'
+              @response[name] = value
+            when 'Timestamp'
+              @event[name] = Time.parse(value)
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_resources.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_resources.rb
new file mode 100644
index 0000000..8b91366
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stack_resources.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class DescribeStackResources < Fog::Parsers::Base
+
+          def reset
+            @resource = {}
+            @response = { 'StackResources' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'StackId', 'StackName', 'LogicalResourceId', 'PhysicalResourceId', 'ResourceType', 'ResourceStatus'
+              @resource[name] = value
+            when 'member'
+              @response['StackResources'] << @resource
+              @resource = {}
+            when 'RequestId'
+              @response[name] = value
+            when 'Timestamp'
+              @resource[name] = Time.parse(value)
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stacks.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stacks.rb
new file mode 100644
index 0000000..18f9c3f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/describe_stacks.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class DescribeStacks < Fog::Parsers::Base
+
+          def reset
+            @stack = { 'Outputs' => [], 'Parameters' => [] }
+            @output = {}
+            @parameter = {}
+            @response = { 'Stacks' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Outputs'
+              @in_outputs = true
+            when 'Parameters'
+              @in_parameters = true
+            end
+          end
+
+          def end_element(name)
+            if @in_outputs
+              case name
+              when 'OutputKey', 'OutputValue'
+                @output[name] = value
+              when 'member'
+                @stack['Outputs'] << @output
+                @output = {}
+              when 'Outputs'
+                @in_outputs = false
+              end
+            elsif @in_parameters
+              case name
+              when 'ParameterKey', 'ParameterValue'
+                @parameter[name] = value
+              when 'member'
+                @stack['Parameters'] << @parameter
+                @parameter = {}
+              when 'Parameters'
+                @in_parameters = false
+              end
+            else
+              case name
+              when 'member'
+                @response['Stacks'] << @stack
+                @stack = { 'Outputs' => [], 'Parameters' => [] }
+              when 'RequestId'
+                @response[name] = value
+              when 'CreationTime'
+                @stack[name] = Time.parse(value)
+              when 'DisableRollback'
+                case value
+                when 'false'
+                  @stack[name] = false
+                when 'true'
+                  @stack[name] = true
+                end
+              when 'StackName', 'StackId', 'StackStatus'
+                @stack[name] = value
+              end
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/get_template.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/get_template.rb
new file mode 100644
index 0000000..55830ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/get_template.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class GetTemplate < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'RequestId', 'TemplateBody'
+              @response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/validate_template.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/validate_template.rb
new file mode 100644
index 0000000..0db4722
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/cloud_formation/validate_template.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module AWS
+      module CloudFormation
+
+        class ValidateTemplate < Fog::Parsers::Base
+
+          def reset
+            @parameter = {}
+            @response = { 'Parameters' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Parameters'
+              @in_parameters = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DefaultValue', 'ParameterKey'
+              @parameter[name] = value
+            when 'Description'
+              if @in_parameters
+                @parameter[name] = value
+              else
+                @response[name] = value
+              end
+            when 'RequestId'
+              @response[name] = value
+            when 'member'
+              @response['Parameters'] << @parameter
+              @parameter = {}
+            when 'NoEcho'
+              case value
+              when 'false'
+                @parameter[name] = false
+              when 'true'
+                @parameter[name] = true
+              end
+            when 'Parameters'
+              @in_parameters = false
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/configure_health_check.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/configure_health_check.rb
new file mode 100644
index 0000000..b2934fd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/configure_health_check.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class ConfigureHealthCheck < Fog::Parsers::Base
+
+          def reset
+            @health_check = {}
+            @response = { 'ConfigureHealthCheckResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'Target'
+              @health_check[name] = value
+            when 'Interval', 'Timeout', 'UnhealthyThreshold', 'HealthyThreshold'
+              @health_check[name] = value.to_i
+
+            when 'HealthCheck'
+              @response['ConfigureHealthCheckResult'][name] = @health_check
+
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/create_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/create_load_balancer.rb
new file mode 100644
index 0000000..27aa211
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/create_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class CreateLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CreateLoadBalancerResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DNSName'
+              @response['CreateLoadBalancerResult'][name] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/delete_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..a7aa650
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/delete_load_balancer.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeleteLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeleteLoadBalancerResult' => nil, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..170ca53
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DeregisterInstancesFromLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DeregisterInstancesFromLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['DeregisterInstancesFromLoadBalancerResult']['Instances'] << {name => value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_instance_health.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_instance_health.rb
new file mode 100644
index 0000000..4c01831
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_instance_health.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeInstanceHealth < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DescribeInstanceHealthResult' => { 'InstanceStates' => [] }, 'ResponseMetadata' => {} }
+            @instance_state = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'State', 'InstanceId', 'ReasonCode'
+              @instance_state[name] = value
+            when 'member'
+              @response['DescribeInstanceHealthResult']['InstanceStates'] << @instance_state
+              @instance_state = {}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_load_balancers.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..1025b29
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/describe_load_balancers.rb
@@ -0,0 +1,121 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DescribeLoadBalancers < Fog::Parsers::Base
+
+          def reset
+            reset_load_balancer
+            reset_listener_description
+            reset_policy
+            @results = { 'LoadBalancerDescriptions' => [] }
+            @response = { 'DescribeLoadBalancersResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def reset_load_balancer
+            @load_balancer = { 'ListenerDescriptions' => [], 'Instances' => [], 'AvailabilityZones' => [], 'Policies' => {'AppCookieStickinessPolicies' => [], 'LBCookieStickinessPolicies' => [] }, 'HealthCheck' => {} }
+          end
+
+          def reset_listener_description
+            @listener_description = { 'PolicyNames' => [], 'Listener' => {} }
+          end
+
+          def reset_policy
+            @policy = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'ListenerDescriptions'
+              @in_listeners = true
+            when 'Instances'
+              @in_instances = true
+            when 'AvailabilityZones'
+              @in_availability_zones = true
+            when 'PolicyNames'
+              @in_policy_names = true
+            when 'Policies'
+              @in_policies = true
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = true
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              if @in_policy_names
+                @listener_description['PolicyNames'] << value
+              elsif @in_availability_zones
+                @load_balancer['AvailabilityZones'] << value
+              elsif @in_listeners
+                @load_balancer['ListenerDescriptions'] << @listener_description
+                reset_listener_description
+              elsif @in_app_cookies
+                @load_balancer['Policies']['AppCookieStickinessPolicies'] << @policy
+                reset_policy
+              elsif @in_lb_cookies
+                @load_balancer['Policies']['LBCookieStickinessPolicies'] << @policy
+                reset_policy
+              elsif !@in_instances && !@in_policies
+                @results['LoadBalancerDescriptions'] << @load_balancer
+                reset_load_balancer
+              end
+
+            when 'LoadBalancerName', 'DNSName'
+              @load_balancer[name] = value
+            when 'CreatedTime'
+              @load_balancer[name] = Time.parse(value)
+
+            when 'ListenerDescriptions'
+              @in_listeners = false
+            when 'PolicyNames'
+              @in_policy_names = false
+            when 'Protocol'
+              @listener_description['Listener'][name] = value
+            when 'LoadBalancerPort', 'InstancePort'
+              @listener_description['Listener'][name] = value.to_i
+
+            when 'Instances'
+              @in_instances = false
+            when 'InstanceId'
+              @load_balancer['Instances'] << value
+
+            when 'AvailabilityZones'
+              @in_availability_zones = false
+
+            when 'Policies'
+              @in_policies = false
+            when 'AppCookieStickinessPolicies'
+              @in_app_cookies = false
+            when 'LBCookieStickinessPolicies'
+              @in_lb_cookies = false
+
+            when 'Interval', 'HealthyThreshold', 'Timeout', 'UnhealthyThreshold'
+              @load_balancer['HealthCheck'][name] = value.to_i
+            when 'Target'
+              @load_balancer['HealthCheck'][name] = value
+
+            when 'PolicyName', 'CookieName'
+              @policy[name] = value
+            when 'CookieExpirationPeriod'
+              @policy[name] = value.to_i
+
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+
+            when 'DescribeLoadBalancersResponse'
+              @response['DescribeLoadBalancersResult'] = @results
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..a50f697
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class DisableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DisableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['DisableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/empty.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/empty.rb
new file mode 100644
index 0000000..7f344b2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/empty.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class Empty < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..17e2ff9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class EnableAvailabilityZonesForLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'EnableAvailabilityZonesForLoadBalancerResult' => { 'AvailabilityZones' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['EnableAvailabilityZonesForLoadBalancerResult']['AvailabilityZones'] << value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..083e539
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module ELB
+
+        class RegisterInstancesWithLoadBalancer < Fog::Parsers::Base
+
+          def reset
+            @response = { 'RegisterInstancesWithLoadBalancerResult' => { 'Instances' => [] }, 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'InstanceId'
+              @response['RegisterInstancesWithLoadBalancerResult']['Instances'] << {name => value}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/basic.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/basic.rb
new file mode 100644
index 0000000..28049bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/basic.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class Basic < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_access_key.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_access_key.rb
new file mode 100644
index 0000000..bcf277b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_access_key.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateAccessKey < Fog::Parsers::Base
+
+          def reset
+            @response = { 'AccessKey' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessKeyId', 'UserName', 'SecretAccessKey', 'Status'
+              @response['AccessKey'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_group.rb
new file mode 100644
index 0000000..a75172d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_group.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateGroup < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Group' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'GroupId', 'GroupName', 'Path'
+              @response['Group'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_user.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_user.rb
new file mode 100644
index 0000000..8afa024
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/create_user.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class CreateUser < Fog::Parsers::Base
+
+          def reset
+            @response = { 'User' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @response['User'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_group.rb
new file mode 100644
index 0000000..de5320b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_group.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class GetGroup < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_GetGroup.html
+
+          def reset
+            @user = {}
+            @response = { 'Group' => {}, 'Users' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Group'
+              @in_group = true
+            when 'Users'
+              @in_users = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn'
+              if @in_group
+                @response['Group'][name] = value
+              elsif @in_users
+                @user[name] = value
+              end
+            when 'Group'
+              @in_group = false
+            when 'GroupName', 'GroupId'
+              @response['Group'][name] = value
+            when 'Users'
+              @in_users = false
+            when 'UserId', 'UserName', 'Path'
+              @user[name] = value
+            when 'member'
+              @response['Users'] << @user              
+              @user = {}
+            when 'IsTruncated'	
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'              
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user.rb
new file mode 100644
index 0000000..0c3f029
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class GetUser < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_GetUser.html
+
+          def reset
+            @response = { 'User' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @response['User'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user_policy.rb
new file mode 100644
index 0000000..d6a9213
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/get_user_policy.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class GetUserPolicy < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_GetUserPolicy.html
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'UserName', 'PolicyName', 'PolicyDocument'
+              @response[name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_access_keys.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_access_keys.rb
new file mode 100644
index 0000000..2d56449
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_access_keys.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListAccessKeys < Fog::Parsers::Base
+
+          def reset
+            @access_key = {}
+            @response = { 'AccessKeys' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessKeyId', 'Status', 'Username'
+              @access_key[name] = value
+            when 'member'
+              @response['AccessKeys'] << @access_key
+              @access_key = {}
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups.rb
new file mode 100644
index 0000000..b98d11b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListGroups < Fog::Parsers::Base
+
+          def reset
+            @group = {}
+            @response = { 'Groups' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'GroupId', 'GroupName', 'Path'
+              @group[name] = value
+            when 'member'
+              @response['Groups'] << @group
+              @group = {}
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups_for_user.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups_for_user.rb
new file mode 100644
index 0000000..6a0e15b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_groups_for_user.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListGroupsForUser < Fog::Parsers::Base
+
+          def reset
+            @group_for_user = {}
+            @response = { 'GroupsForUser' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Path', 'GroupName', 'GroupId', 'Arn'
+              @group_for_user[name] = value
+            when 'member'
+              @response['GroupsForUser'] << @group_for_user
+              @group_for_user = {}
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_policies.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_policies.rb
new file mode 100644
index 0000000..b59d6d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_policies.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListPolicies < Fog::Parsers::Base
+
+          def reset
+            @response = { 'PolicyNames' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['PolicyNames'] << value
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_server_certificates.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_server_certificates.rb
new file mode 100644
index 0000000..a9c899e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_server_certificates.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListServerCertificates < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Certificates' => [] }
+            reset_certificate
+          end
+
+          def reset_certificate
+            @certificate = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'Path', 'ServerCertificateId', 'ServerCertificateName'
+              @certificate[name] = value
+            when 'UploadDate'
+              @certificate[name] = Time.parse(value)
+            when 'member'
+              @response['Certificates'] << @certificate
+              reset_certificate
+            when 'IsTrunctated'
+              @response[name] = !!value
+            when 'Marker'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_signing_certificates.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_signing_certificates.rb
new file mode 100644
index 0000000..e5c6939
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_signing_certificates.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListSigningCertificates < Fog::Parsers::Base
+          
+          def reset
+            @signing_certificate = {}
+            @response = { 'SigningCertificates' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'UserName', 'CertificateId', 'CertificateBody', 'Status'
+              @signing_certificate[name] = value
+            when 'member'
+              @response['SigningCertificates'] << @signing_certificate
+              @signing_certificate = {}
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_users.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_users.rb
new file mode 100644
index 0000000..d0d9e0b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/list_users.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class ListUsers < Fog::Parsers::Base
+
+          def reset
+            @user = {}
+            @response = { 'Users' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @user[name] = value
+            when 'member'
+              @response['Users'] << @user
+              @user = {}
+            when 'IsTruncated'
+              response[name] = (value == 'true')
+            when 'Marker', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/login_profile.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/login_profile.rb
new file mode 100644
index 0000000..dddf89c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/login_profile.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class LoginProfile < Fog::Parsers::Base
+
+          def reset
+            @response = { 'LoginProfile' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'UserName'
+              @response['LoginProfile']['UserName'] = value
+            when 'CreateDate'
+              @response['LoginProfile']['CreateDate'] = Time.parse(value)
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_group.rb
new file mode 100644
index 0000000..3232db3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_group.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class UpdateGroup < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UpdateGroup.html
+          def reset
+            @response = { 'Group' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'GroupId', 'GroupName', 'Path'
+              @response['Group'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_user.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_user.rb
new file mode 100644
index 0000000..a4e4c6d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/update_user.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class UpdateUser < Fog::Parsers::Base
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UpdateUser.html
+        
+          def reset
+            @response = { 'User' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'UserId', 'UserName', 'Path'
+              @response['User'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_server_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_server_certificate.rb
new file mode 100644
index 0000000..2fa6be1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_server_certificate.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class UploadServerCertificate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Certificate' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Arn', 'Path', 'ServerCertificateId', 'ServerCertificateName'
+              @response['Certificate'][name] = value
+            when 'UploadDate'
+              @response['Certificate'][name] = Time.parse(value)
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_signing_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_signing_certificate.rb
new file mode 100644
index 0000000..4f473f7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/iam/upload_signing_certificate.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module IAM
+
+        class UploadSigningCertificate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Certificate' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'CertificateId', 'UserName', 'CertificateBody', 'Status'
+              @response['Certificate'][name] = value
+            when 'RequestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/authorize_db_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/authorize_db_security_group_ingress.rb
new file mode 100644
index 0000000..7b2d2ff
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/authorize_db_security_group_ingress.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/security_group_parser'
+
+        class AuthorizeDBSecurityGroupIngress < Fog::Parsers::AWS::RDS::SecurityGroupParser
+
+          def reset
+            @response = { 'AuthorizeDBSecurityGroupIngressResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSecurityGroup' then
+              @response['AuthorizeDBSecurityGroupIngressResult']['DBSecurityGroup'] = @security_group
+              @security_group = fresh_security_group
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance.rb
new file mode 100644
index 0000000..ab24407
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+        
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class CreateDBInstance < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'CreateDBInstanceResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super            
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['CreateDBInstanceResult']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance_read_replica.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance_read_replica.rb
new file mode 100644
index 0000000..95c9593
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_instance_read_replica.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+        
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class CreateDBInstanceReadReplica < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'CreateDBInstanceReadReplicaResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super            
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['CreateDBInstanceReadReplicaResult']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_parameter_group.rb
new file mode 100644
index 0000000..12cdba5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_parameter_group.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class CreateDbParameterGroup < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CreateDBParameterGroupResult' => {}, 'ResponseMetadata' => {} }
+            @db_parameter_group = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBParameterGroupFamily'
+              @db_parameter_group['DBParameterGroupFamily'] = value
+            when 'Description'
+              @db_parameter_group['Description'] = value
+            when 'DBParameterGroupName'
+              @db_parameter_group['DBParameterGroupName'] = value
+            when 'DBParameterGroup'
+              @response['CreateDBParameterGroupResult']['DBParameterGroup']= @db_parameter_group
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_security_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_security_group.rb
new file mode 100644
index 0000000..5933896
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_security_group.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/security_group_parser'
+
+        class CreateDBSecurityGroup < Fog::Parsers::AWS::RDS::SecurityGroupParser
+
+          def reset
+            @response = { 'CreateDBSecurityGroupResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSecurityGroup' then
+              @response['CreateDBSecurityGroupResult']['DBSecurityGroup'] = @security_group
+              @security_group = fresh_security_group
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_snapshot.rb
new file mode 100644
index 0000000..416cc4b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/create_db_snapshot.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+        require 'fog/aws/parsers/rds/snapshot_parser'
+        
+        class CreateDBSnapshot < Fog::Parsers::AWS::RDS::SnapshotParser
+
+          def reset
+            @response = { 'CreateDBSnapshotResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSnapshot' then 
+              @response['CreateDBSnapshotResult']['DBSnapshot'] = @db_snapshot
+              @db_snapshot = fresh_snapshot
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/db_parser.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/db_parser.rb
new file mode 100644
index 0000000..125acf2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/db_parser.rb
@@ -0,0 +1,123 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class DbParser < Fog::Parsers::Base
+
+          def reset
+            @db_instance = fresh_instance
+            
+          end
+          
+          def fresh_instance
+            {'PendingModifiedValues' => [], 'DBSecurityGroups' => [], 'ReadReplicaDBInstanceIdentifiers' => [], 'Endpoint' => {}}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'PendingModifiedValues'
+              @in_pending_modified_values = true
+              @pending_modified_values = {}
+            when 'DBSecurityGroups'
+              @in_db_security_groups = true
+              @db_security_groups = []
+            when 'DBSecurityGroup'
+              @db_security_group = {}
+            when 'Endpoint'
+              @in_endpoint = true
+              @endpoint = {}
+            when 'DBParameterGroup'
+              @db_parameter_group = {}
+            when 'DBParameterGroups'
+              @in_db_parameter_groups = true
+              @db_parameter_groups = []
+            end
+            
+          end
+
+          def end_element(name)
+            case name
+              
+            when 'LatestRestorableTime', 'InstanceCreateTime'
+              @db_instance[name] = Time.parse value
+            when 'Engine', 
+              'DBInstanceStatus', 'DBInstanceIdentifier', 'EngineVersion', 
+              'PreferredBackupWindow', 'PreferredMaintenanceWindow', 
+              'AvailabilityZone', 'MasterUsername', 'DBName'
+              @db_instance[name] = value
+            when 'MultiAZ', 'AutoMinorVersionUpgrade'
+              if value == 'false'
+                @db_instance[name] = false
+              else
+                @db_instance[name] = true
+              end
+            when 'DBParameterGroups'
+              @in_db_parameter_groups = false
+              @db_instance['DBParameterGroups'] = @db_parameter_groups
+            when 'DBParameterGroup'
+              @db_parameter_groups << @db_parameter_group
+              @db_parameter_group = {}
+            when 'ParameterApplyStatus', 'DBParameterGroupName'
+              if @in_db_parameter_groups
+                @db_parameter_group[name] = value
+              end
+            
+            when 'BackupRetentionPeriod'
+              if @in_pending_modified_values
+                @pending_modified_values[name] = value.to_i
+              else
+                @db_instance[name] = value.to_i
+              end
+            when 'DBInstanceClass', 'EngineVersion', 'MasterUserPassword', 'MultiAZ'
+              if @in_pending_modified_values
+                @pending_modified_values[name] = value
+              else
+                @db_instance[name] = value
+              end
+            when 'DBSecurityGroups'
+              @in_db_security_groups = false
+              @db_instance['DBSecurityGroups'] = @db_security_groups
+            when 'Status', 'DBSecurityGroupName'
+              if @in_db_security_groups
+                @db_security_group[name]=value
+              end
+            when 'DBSecurityGroup'
+              @db_security_groups << @db_security_group
+              @db_security_group = {}
+            
+            when 'AllocatedStorage'
+              if @in_pending_modified_values
+                @pending_modified_values[name] = value.to_i
+              else
+                @db_instance[name] = value.to_i
+              end
+            when 'Address'
+              @endpoint[name] = value
+            when 'Port'
+              if @in_pending_modified_values
+                @pending_modified_values[name] = value.to_i
+              elsif @in_endpoint
+                @endpoint[name] = value.to_i
+              end
+      
+            when 'PendingModifiedValues'
+              @in_pending_modified_values = false
+              @db_instance['PendingModifiedValues'] = @pending_modified_values
+            when 'Endpoint'
+              @in_endpoint = false
+              @db_instance['Endpoint'] = @endpoint
+            when 'ReadReplicaDBInstanceIdentifier'
+              @db_instance['ReadReplicaDBInstanceIdentifiers'] << value
+            when 'ReadReplicaSourceDBInstanceIdentifier'
+              @db_instance['ReadReplicaSourceDBInstanceIdentifier'] = value
+            when 'DBInstance'
+              @db_instance = fresh_instance
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_instance.rb
new file mode 100644
index 0000000..64910f4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_instance.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class DeleteDBInstance < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'DeleteDBInstanceResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super            
+          end
+
+          def end_element(name)
+            case name
+              
+            when 'DBInstance'
+              @response['DeleteDBInstanceResult']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_parameter_group.rb
new file mode 100644
index 0000000..98cf233
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_parameter_group.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class DeleteDbParameterGroup < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+            @db_parameter_group = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_security_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_security_group.rb
new file mode 100644
index 0000000..282c7d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_security_group.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+        require 'fog/aws/parsers/rds/snapshot_parser'
+
+        class DeleteDBSecurityGroup < Fog::Parsers::AWS::RDS::SnapshotParser
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_snapshot.rb
new file mode 100644
index 0000000..3d12c38
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/delete_db_snapshot.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/snapshot_parser'
+        
+        class DeleteDBSnapshot < Fog::Parsers::AWS::RDS::SnapshotParser
+
+          def reset
+            @response = { 'DeleteDBSnapshotResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            when 'DBSnapshot'
+              @response['DeleteDBSnapshotResult']['DBSnapshot'] = @db_snapshot
+              @db_snapshot = fresh_snapshot
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_instances.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_instances.rb
new file mode 100644
index 0000000..6ec17e1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_instances.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class DescribeDBInstances < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'DescribeDBInstancesResult' => {'DBInstances' => []}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['DescribeDBInstancesResult']['DBInstances'] << @db_instance
+              @db_instance = fresh_instance
+            when 'Marker'
+              @response['DescribeDBInstancesResult']['Marker'] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameter_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameter_groups.rb
new file mode 100644
index 0000000..6dcc387
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameter_groups.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class DescribeDBParameterGroups < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DescribeDBParameterGroupsResult' => {'DBParameterGroups' => []}, 'ResponseMetadata' => {} }
+            @db_parameter_group = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBParameterGroupFamily' then @db_parameter_group['DBParameterGroupFamily'] = value
+            when 'Description' then @db_parameter_group['Description'] = value
+            when 'DBParameterGroupName' then @db_parameter_group['DBParameterGroupName'] = value
+            when 'DBParameterGroup' then 
+              @response['DescribeDBParameterGroupsResult']['DBParameterGroups'] << @db_parameter_group
+              @db_parameter_group = {}              
+            when 'Marker'
+              @response['DescribeDBParameterGroupsResult']['Marker'] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameters.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameters.rb
new file mode 100644
index 0000000..370d046
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_parameters.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class DescribeDBParameters < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DescribeDBParametersResult' =>{}, 'ResponseMetadata' => {} }
+            @parameter = {}
+            @parameters = []
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'ParameterValue' then @parameter['ParameterValue'] = value
+            when 'DataType' then @parameter['DataType'] = value
+            when 'AllowedValues' then @parameter['AllowedValues'] = value
+            when 'Source' then @parameter['Source'] = value
+            when 'IsModifiable' then 
+              @parameter['IsModifiable'] =  value == 'true' ? true : false
+            when 'Description' then @parameter['Description'] = value
+            when 'ApplyType' then @parameter['ApplyType'] = value
+            when 'ParameterName' then @parameter['ParameterName'] = value
+            when 'Parameter' 
+              @parameters << @parameter
+              @parameter = {}
+            when 'Marker'
+              @response['DescribeDBParametersResult']['Marker'] = value
+            when 'Parameters'
+              @response['DescribeDBParametersResult']['Parameters'] = @parameters
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_security_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_security_groups.rb
new file mode 100644
index 0000000..acb0dd5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_security_groups.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/security_group_parser'
+
+        class DescribeDBSecurityGroups < Fog::Parsers::AWS::RDS::SecurityGroupParser
+
+          def reset
+            @response = { 'DescribeDBSecurityGroupsResult' => {'DBSecurityGroups' => []}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSecurityGroup' then
+              @response['DescribeDBSecurityGroupsResult']['DBSecurityGroups'] << @security_group
+              @security_group = fresh_security_group
+            when 'Marker'
+              @response['DescribeDBSecurityGroupsResult']['Marker'] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_snapshots.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_snapshots.rb
new file mode 100644
index 0000000..3f68dee
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/describe_db_snapshots.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/snapshot_parser'
+        
+        class DescribeDBSnapshots < Fog::Parsers::AWS::RDS::SnapshotParser
+
+          def reset
+            @response = { 'DescribeDBSnapshotsResult' => {'DBSnapshots' => []}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSnapshot' then 
+              @response['DescribeDBSnapshotsResult']['DBSnapshots'] << @db_snapshot
+              @db_snapshot = fresh_snapshot
+            when 'Marker'
+              @response['DescribeDBSnapshotsResult']['Marker'] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_instance.rb
new file mode 100644
index 0000000..90b9d34
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_instance.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class ModifyDBInstance < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'ModifyDBInstanceResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super            
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['ModifyDBInstanceResult']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_parameter_group.rb
new file mode 100644
index 0000000..fd922cb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/modify_db_parameter_group.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class ModifyDbParameterGroup < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ModifyDBParameterGroupResult' => {}, 'ResponseMetadata' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBParameterGroupName'
+              @response['ModifyDBParameterGroupResult']['DBParameterGroupName'] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/reboot_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/reboot_db_instance.rb
new file mode 100644
index 0000000..c4bbb5a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/reboot_db_instance.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+        
+        class RebootDBInstance < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'RebootDBInstanceResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super            
+          end
+
+          def end_element(name)
+            case name
+              
+            when 'DBInstance'
+              @response['RebootDBInstanceResult']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_from_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_from_db_snapshot.rb
new file mode 100644
index 0000000..d022e5d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_from_db_snapshot.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+
+        class RestoreDBInstanceFromDBSnapshot < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'RestoreDBInstanceFromDBSnapshot' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['RestoreDBInstanceFromDBSnapshot']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_to_point_in_time.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_to_point_in_time.rb
new file mode 100644
index 0000000..b8482f0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/restore_db_instance_to_point_in_time.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/db_parser'
+
+        class RestoreDBInstanceToPointInTime < Fog::Parsers::AWS::RDS::DbParser
+
+          def reset
+            @response = { 'RestoreDBInstanceToPointInTime' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBInstance'
+              @response['RestoreDBInstanceToPointInTime']['DBInstance'] = @db_instance
+              @db_instance = fresh_instance
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+          end
+        end
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/revoke_db_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/revoke_db_security_group_ingress.rb
new file mode 100644
index 0000000..e846ba3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/revoke_db_security_group_ingress.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        require 'fog/aws/parsers/rds/security_group_parser'
+
+        class RevokeDBSecurityGroupIngress < Fog::Parsers::AWS::RDS::SecurityGroupParser
+
+          def reset
+            @response = { 'RevokeDBSecurityGroupIngressResult' => {}, 'ResponseMetadata' => {} }
+            super
+          end
+
+          def start_element(name, attrs = [])
+            super
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSecurityGroup' then
+              @response['RevokeDBSecurityGroupIngressResult']['DBSecurityGroup'] = @security_group
+              @security_group = fresh_security_group
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            else
+              super
+            end
+
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/security_group_parser.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/security_group_parser.rb
new file mode 100644
index 0000000..37317f5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/security_group_parser.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class SecurityGroupParser < Fog::Parsers::Base
+
+          def reset
+            @security_group = fresh_security_group
+          end
+
+          def fresh_security_group
+            {'EC2SecurityGroups' => [], 'IPRanges' => []}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'EC2SecurityGroup', 'IPRange'; then @ingress = {}
+            end
+
+          end
+
+          def end_element(name)
+            case name
+            when 'DBSecurityGroupDescription' then @security_group['DBSecurityGroupDescription'] = value
+            when 'DBSecurityGroupName' then @security_group['DBSecurityGroupName'] = value
+            when 'OwnerId' then @security_group['OwnerId'] = value
+            when 'EC2SecurityGroup', 'IPRange'
+              @security_group["#{name}s"] << @ingress unless @ingress.empty?
+            when 'EC2SecurityGroupName', 'EC2SecurityGroupOwnerId', 'CIDRIP', 'Status'
+              @ingress[name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/snapshot_parser.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/snapshot_parser.rb
new file mode 100644
index 0000000..3be89f8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/rds/snapshot_parser.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module RDS
+
+        class SnapshotParser < Fog::Parsers::Base
+
+          def reset
+            @db_snapshot = fresh_snapshot
+          end
+          
+          def fresh_snapshot
+            {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            
+          end
+
+          def end_element(name)
+            case name
+            when 'AllocatedStorage' then @db_snapshot['AllocatedStorage'] = value.to_i
+            when 'AvailabilityZone' then @db_snapshot['AvailabilityZone'] = value
+            when 'DBInstanceIdentifier' then @db_snapshot['DBInstanceIdentifier'] = value
+            when 'DBSnapshotIdentifier' then @db_snapshot['DBSnapshotIdentifier'] = value
+            when 'Engine' then @db_snapshot['Engine'] = value
+            when 'EngineVersion' then @db_snapshot['EngineVersion'] = value
+            when 'InstanceCreateTime' then @db_snapshot['InstanceCreateTime'] = Time.parse value
+            when 'MasterUsername' then @db_snapshot['MasterUsername'] = value
+            when 'Port' then @db_snapshot['Port'] = value.to_i
+            when 'SnapshotCreateTime' then @db_snapshot['SnapshotCreateTime'] = Time.parse value
+            when 'Status' then @db_snapshot['Status'] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/delete_verified_email_address.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/delete_verified_email_address.rb
new file mode 100644
index 0000000..1472b92
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/delete_verified_email_address.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class DeleteVerifiedEmailAddress < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_quota.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_quota.rb
new file mode 100644
index 0000000..ffff267
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_quota.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class GetSendQuota < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when "Max24HourSend", "MaxSendRate", "SentLast24Hours"
+              @response[name] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_statistics.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_statistics.rb
new file mode 100644
index 0000000..76821e4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/get_send_statistics.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class GetSendStatistics < Fog::Parsers::Base
+
+          def reset
+            @response = { 'SendDataPoints' => [], 'ResponseMetadata' => {} }
+            @send_data_point = {}
+          end
+
+          def end_element(name)
+            case name
+            when "Bounces", "Complaints", "DeliveryAttempts", "Rejects", "Timestamp"
+              @send_data_point[name] = value
+            when 'member'
+              @response['SendDataPoints'] << @send_data_point
+              @send_data_point = {}
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/list_verified_email_addresses.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/list_verified_email_addresses.rb
new file mode 100644
index 0000000..3ce65d9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/list_verified_email_addresses.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class ListVerifiedEmailAddresses < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VerifiedEmailAddresses' => [], 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'member'
+              @response['VerifiedEmailAddresses'] << value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_email.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_email.rb
new file mode 100644
index 0000000..5d2ec10
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_email.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class SendEmail < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'MessageId'
+              @response[name] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_raw_email.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_raw_email.rb
new file mode 100644
index 0000000..e48a875
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/send_raw_email.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class SendRawEmail < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'MessageId'
+              @response[name] = value
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/verify_email_address.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/verify_email_address.rb
new file mode 100644
index 0000000..983a8b4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/ses/verify_email_address.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module SES
+
+        class VerifyEmailAddress < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ResponseMetadata' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'RequestId'
+              @response['ResponseMetadata'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/basic.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/basic.rb
new file mode 100644
index 0000000..b97f247
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/basic.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Basic < Fog::Parsers::Base
+
+          def initialize(nil_string)
+            @nil_string = nil_string
+            reset
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = value.to_f
+            when 'RequestId'
+              response[name] = value
+            end
+          end
+
+          def sdb_decode(value)
+            value.eql?(@nil_string) ? nil : value
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/domain_metadata.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..5171f0c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/domain_metadata.rb
@@ -0,0 +1,32 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class DomainMetadata < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'AttributeNameCount', 'AttributeNamesSizeBytes', 'AttributeValueCount', 'AttributeValuesSizeBytes', 'ItemCount', 'ItemNamesSizeBytes'
+              response[name] = value.to_i
+            when 'BoxUsage'
+              response[name] = value.to_f
+            when 'RequestId'
+              response[name] = value
+            when 'Timestamp'
+              response[name] = Time.at(value.to_i)
+            end
+          end
+
+        end
+        
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/get_attributes.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/get_attributes.rb
new file mode 100644
index 0000000..ea00b6f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/get_attributes.rb
@@ -0,0 +1,36 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class GetAttributes < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @attribute = nil
+            @response = { 'Attributes' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Attribute'
+              @attribute = nil
+            when 'BoxUsage'
+              response[name] = value.to_f
+            when 'Name'
+              @attribute = value
+              response['Attributes'][@attribute] ||= []
+            when 'RequestId'
+              response[name] = value
+            when 'Value'
+              response['Attributes'][@attribute] << sdb_decode(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/list_domains.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/list_domains.rb
new file mode 100644
index 0000000..f294126
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/list_domains.rb
@@ -0,0 +1,30 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class ListDomains < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @response = { 'Domains' => [] }
+          end
+
+          def end_element(name)
+            case(name)
+            when 'BoxUsage'
+              response[name] = value.to_f
+            when 'DomainName'
+              response['Domains'] << value
+            when 'NextToken', 'RequestId'
+              response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/select.rb b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/select.rb
new file mode 100644
index 0000000..29ad579
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/parsers/simpledb/select.rb
@@ -0,0 +1,41 @@
+require 'fog/aws/parsers/simpledb/basic'
+
+module Fog
+  module Parsers
+    module AWS
+      module SimpleDB
+
+        class Select < Fog::Parsers::AWS::SimpleDB::Basic
+
+          def reset
+            @item_name = @attribute_name = nil
+            @response = { 'Items' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'BoxUsage'
+              response[name] = value.to_f
+            when 'Item'
+              @item_name = @attribute_name = nil
+            when 'Name'
+              if @item_name.nil? 
+                @item_name = value
+                response['Items'][@item_name] = {}
+              else
+                @attribute_name = value
+                response['Items'][@item_name][@attribute_name] ||= []
+              end
+            when 'NextToken', 'RequestId'
+              response[name] = value
+            when 'Value'
+              response['Items'][@item_name][@attribute_name] << sdb_decode(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/rds.rb b/vendor/fog-0.8.2/lib/fog/aws/rds.rb
new file mode 100644
index 0000000..dd010f9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/rds.rb
@@ -0,0 +1,161 @@
+module Fog
+  module AWS
+    class RDS < Fog::Service
+
+      class IdentifierTaken < Fog::Errors::Error; end
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :region, :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/rds'
+
+      request :create_db_instance
+      request :modify_db_instance
+      request :describe_db_instances
+      request :delete_db_instance
+      request :reboot_db_instance
+      request :create_db_instance_read_replica
+
+      request :describe_db_snapshots
+      request :create_db_snapshot
+      request :delete_db_snapshot
+
+
+      request :create_db_parameter_group
+      request :delete_db_parameter_group
+      request :modify_db_parameter_group
+      request :describe_db_parameter_groups
+
+      request :describe_db_security_groups
+      request :create_db_security_group
+      request :delete_db_security_group
+      request :authorize_db_security_group_ingress
+      request :revoke_db_security_group_ingress
+
+      request :describe_db_parameters
+
+      request :restore_db_instance_from_db_snapshot
+      request :restore_db_instance_to_point_in_time
+
+      model_path 'fog/aws/models/rds'
+      model       :server
+      collection  :servers
+      model       :snapshot
+      collection  :snapshots
+      model       :parameter_group
+      collection  :parameter_groups
+
+      model       :parameter
+      collection  :parameters
+
+      model       :security_group
+      collection  :security_groups
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to ELB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   elb = ELB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1'i, 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * ELB object with connection to AWS.
+        def initialize(options={})
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-northeast-1'
+            'rds.ap-northeast-1.amazonaws.com'
+          when 'ap-southeast-1'
+            'rds.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'rds.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'rds.us-east-1.amazonaws.com'
+          when 'us-west-1'
+            'rds.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-07-28'
+            }
+          )
+
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :idempotent => idempotent,
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::HTTPStatusError => error
+            if match = error.message.match(/<Code>(.*)<\/Code>[\s\\\w]+<Message>(.*)<\/Message>/m)
+              case match[1].split('.').last
+              when 'DBInstanceNotFound', 'DBParameterGroupNotFound', 'DBSnapshotNotFound', 'DBSecurityGroupNotFound'
+                raise Fog::AWS::RDS::NotFound.slurp(error, match[2])
+              when 'DBParameterGroupAlreadyExists'
+                raise Fog::AWS::RDS::IdentifierTaken.slurp(error, match[2])
+              else
+                raise
+              end
+            else
+              raise
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/create_stack.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/create_stack.rb
new file mode 100644
index 0000000..62211ce
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/create_stack.rb
@@ -0,0 +1,71 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/create_stack'
+
+        # Create a stack
+        #
+        # ==== Parameters
+        # * stack_name<~String>: name of the stack to create
+        # * options<~Hash>:
+        #   * TemplateBody<~String>: structure containing the template body
+        #   or (one of the two Template parameters is required)
+        #   * TemplateURL<~String>: URL of file containing the template body
+        #   * DisableRollback<~Boolean>: Controls rollback on stack creation failure, defaults to false
+        #   * NotificationARNs<~Array>: List of SNS topics to publish events to
+        #   * Parameters<~Hash>: Hash of providers to supply to template
+        #   * TimeoutInMinutes<~Integer>: Minutes to wait before status is set to CREATE_FAILED
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'StackId'<~String> - Id of the new stack
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_CreateStack.html
+        #
+        def create_stack(stack_name, options = {})
+          params = {
+            'StackName' => stack_name,
+          }
+
+          if options['DisableRollback']
+            params['DisableRollback'] = options['DisableRollback']
+          end
+
+          if options['NotificationARNs']
+            params.merge!(AWS.indexed_param("NotificationARNs.member", [*options['NotificationARNs']]))
+          end
+
+          if options['Parameters']
+            options['Parameters'].keys.each_with_index do |key, index|
+              index += 1 # params are 1-indexed
+              params.merge!({
+                "Parameters.member.#{index}.ParameterKey"   => key,
+                "Parameters.member.#{index}.ParameterValue" => options['Parameters'][key]
+              })
+            end
+          end
+
+          if options['TemplateBody']
+            params['TemplateBody'] = options['TemplateBody']
+          elsif options['TemplateURL']
+            params['TemplateURL'] = options['TemplateURL']
+          end
+
+          if options['TimeoutInMinutes']
+            params['TimeoutInMinutes'] = options['TimeoutInMinutes']
+          end
+
+          request({
+            'Action'    => 'CreateStack',
+            :parser     => Fog::Parsers::AWS::CloudFormation::CreateStack.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/delete_stack.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/delete_stack.rb
new file mode 100644
index 0000000..85251a6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/delete_stack.rb
@@ -0,0 +1,30 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/basic'
+
+        # Delete a stack
+        #
+        # ==== Parameters
+        # * stack_name<~String>: name of the stack to create
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_DeleteStack.html
+        #
+        def delete_stack(stack_name)
+          request(
+            'Action'    => 'DeleteStack',
+            'StackName' => stack_name,
+            :parser     => Fog::Parsers::AWS::CloudFormation::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_events.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_events.rb
new file mode 100644
index 0000000..58040ab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_events.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/describe_stack_events'
+
+        # Describe stack events
+        #
+        # ==== Parameters
+        # * stack_name<~String>: stack name to return events for
+        # * options<~Hash>:
+        #   * NextToken<~String>: identifies the start of the next list of events, if there is one
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'StackEvents'<~Array> - Matching resources
+        #       * event<~Hash>:
+        #         * 'EventId'<~String> -
+        #         * 'StackId'<~String> -
+        #         * 'StackName'<~String> -
+        #         * 'LogicalResourceId'<~String> -
+        #         * 'PhysicalResourceId'<~String> -
+        #         * 'ResourceType'<~String> -
+        #         * 'Timestamp'<~Time> -
+        #         * 'ResourceStatus'<~String> -
+        #         * 'ResourceStatusReason'<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_DescribeStackEvents.html
+        #
+        def describe_stack_events(stack_name, options = {})
+          request({
+            'Action'    => 'DescribeStackEvents',
+            'StackName' => stack_name,
+            :parser     => Fog::Parsers::AWS::CloudFormation::DescribeStackEvents.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_resources.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_resources.rb
new file mode 100644
index 0000000..4398746
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stack_resources.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/describe_stack_resources'
+
+        # Describe stack resources
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'PhysicalResourceId'<~String>: name or unique identifier that corresponds to a physical instance ID
+        #   or (one of PhysicalResourceId and StackName is required)
+        #   * 'StackName'<~String>: only return events related to this stack name
+        #   * 'LogicalResourceId'<~String>: logical name of the resource as specified in the template
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'StackResources'<~Array> - Matching resources
+        #       * resource<~Hash>:
+        #         * 'StackId'<~String> -
+        #         * 'StackName'<~String> -
+        #         * 'LogicalResourceId'<~String> -
+        #         * 'PhysicalResourceId'<~String> -
+        #         * 'ResourceType'<~String> -
+        #         * 'Timestamp'<~Time> -
+        #         * 'ResourceStatus'<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_DescribeStackResources.html
+        #
+        def describe_stack_resources(options = {})
+          request({
+            'Action'    => 'DescribeStackResources',
+            :parser     => Fog::Parsers::AWS::CloudFormation::DescribeStackResources.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stacks.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stacks.rb
new file mode 100644
index 0000000..20176bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/describe_stacks.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/describe_stacks'
+
+        # Describe stacks
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'StackName'<~String>: name of the stack to describe
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Stacks'<~Array> - Matching stacks
+        #       * stack<~Hash>:
+        #         * 'StackName'<~String> -
+        #         * 'StackId'<~String> -
+        #         * 'CreationTime'<~String> -
+        #         * 'StackStatus'<~String> -
+        #         * 'DisableRollback'<~String> -
+        #         * 'Outputs'<~Array> -
+        #           * output<~Hash>:
+        #             * 'OutputKey'<~String> -
+        #             * 'OutputValue'<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_DescribeStacks.html
+        #
+        def describe_stacks(options = {})
+          request({
+            'Action'    => 'DescribeStacks',
+            :parser     => Fog::Parsers::AWS::CloudFormation::DescribeStacks.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/get_template.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/get_template.rb
new file mode 100644
index 0000000..18e2352
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/get_template.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/get_template'
+
+        # Describe stacks
+        #
+        # ==== Parameters
+        # * stack_name<~String> - stack name to get template from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'TemplateBody'<~String> - structure containing the template body (json)
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_GetTemplate.html
+        #
+        def get_template(stack_name)
+          request(
+            'Action'    => 'GetTemplate',
+            'StackName' => stack_name,
+            :parser     => Fog::Parsers::AWS::CloudFormation::GetTemplate.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/validate_template.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/validate_template.rb
new file mode 100644
index 0000000..70414f7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/cloud_formation/validate_template.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class CloudFormation
+      class Real
+
+        require 'fog/aws/parsers/cloud_formation/validate_template'
+
+        # Describe stacks
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'TemplateBody'<~String> - template structure
+        #   * 'TemplateURL'<~String> - template url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Description'<~String> - description found within the template
+        #     * 'Parameters'<~String> - list of template parameter structures
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AWSCloudFormation/latest/APIReference/API_ValidateTemplate.html
+        #
+        def validate_template(options = {})
+          request({
+            'Action'    => 'ValidateTemplate',
+            :parser     => Fog::Parsers::AWS::CloudFormation::ValidateTemplate.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/configure_health_check.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/configure_health_check.rb
new file mode 100644
index 0000000..651ffc0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/configure_health_check.rb
@@ -0,0 +1,41 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/configure_health_check'
+
+        # Enables the client to define an application healthcheck for the instances.
+        # See http://docs.amazonwebservices.com/ElasticLoadBalancing/latest/APIReference/index.html?API_ConfigureHealthCheck.html
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB
+        # * health_check<~Hash> - A hash of parameters describing the health check
+        #   * 'HealthyThreshold'<~Integer> - Specifies the number of consecutive
+        #     health probe successes required before moving the instance to the Healthy state.
+        #   * 'Interval'<~Integer> - Specifies the approximate interval, in seconds,
+        #     between health checks of an individual instance.
+        #   * 'Target'<~String> - Specifies the instance being checked.
+        #     The protocol is either TCP or HTTP. The range of valid ports is one (1) through 65535.
+        #   * 'Timeout'<~Integer> - Specifies the amount of time, in seconds,
+        #   during which no response means a failed health probe.
+        #   * 'UnhealthyThreshold'<~Integer> - Specifies the number of consecutive
+        #     health probe failures required before moving the instance to the Unhealthy state.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def configure_health_check(lb_name, health_check)
+          params = {'LoadBalancerName' => lb_name}
+          health_check.each {|key, value| params["HealthCheck.#{key}"] = value }
+
+          request({
+            'Action'           => 'ConfigureHealthCheck',
+            :parser            => Fog::Parsers::AWS::ELB::ConfigureHealthCheck.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_app_cookie_stickiness_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_app_cookie_stickiness_policy.rb
new file mode 100644
index 0000000..356680a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_app_cookie_stickiness_policy.rb
@@ -0,0 +1,33 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Create an app cookie stickiness policy
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB
+        # * policy_name<~String> - The name of the policy being created.
+        #   The name must be unique within the set of policies for this Load Balancer.
+        # * cookie_name<~String> - Name of the application cookie used for stickiness.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def create_app_cookie_stickiness_policy(lb_name, policy_name, cookie_name)
+          params = {'CookieName' => cookie_name, 'PolicyName' => policy_name}
+
+          request({
+            'Action'           => 'CreateAppCookieStickinessPolicy',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_lb_cookie_stickiness_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_lb_cookie_stickiness_policy.rb
new file mode 100644
index 0000000..d373ffb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_lb_cookie_stickiness_policy.rb
@@ -0,0 +1,35 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Create a Load Balancer Cookie Stickiness Policy
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB
+        # * policy_name<~String> - The name of the policy being created. The name
+        #   must be unique within the set of policies for this Load Balancer.
+        # * cookie_expiration_period<~Integer> - The time period in seconds after
+        #   which the cookie should be considered stale. Not specifying this
+        #   parameter indicates that the sticky session will last for the duration of the browser session.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def create_lb_cookie_stickiness_policy(lb_name, policy_name, cookie_expiration_period=nil)
+          params = {'PolicyName' => policy_name, 'CookieExpirationPeriod' => cookie_expiration_period}
+
+          request({
+            'Action'           => 'CreateLBCookieStickinessPolicy',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer.rb
new file mode 100644
index 0000000..af47d5c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/create_load_balancer'
+
+        # Create a new Elastic Load Balancer
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones for the ELB
+        # * lb_name<~String> - Name for the new ELB -- must be unique
+        # * listeners<~Array> - Array of Hashes describing ELB listeners to assign to the ELB
+        #   * 'Protocol'<~String> - Protocol to use. Either HTTP or TCP.
+        #   * 'LoadBalancerPort'<~Integer> - The port that the ELB will listen to for outside traffic
+        #   * 'InstancePort'<~Integer> - The port on the instance that the ELB will forward traffic to
+        #   * 'SSLCertificateId'<~String> - ARN of the server certificate
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'CreateLoadBalancerResult'<~Hash>:
+        #       * 'DNSName'<~String> - DNS name for the newly created ELB
+        def create_load_balancer(availability_zones, lb_name, listeners)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones])
+
+          listener_protocol = []
+          listener_lb_port = []
+          listener_instance_port = []
+          listener_ssl_certificate_id = []
+          listeners.each do |listener|
+            listener_protocol.push(listener['Protocol'])
+            listener_lb_port.push(listener['LoadBalancerPort'])
+            listener_instance_port.push(listener['InstancePort'])
+            listener_ssl_certificate_id.push(listener['SSLCertificateId'])
+          end
+
+          params.merge!(AWS.indexed_param('Listeners.member.%d.Protocol', listener_protocol))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.LoadBalancerPort', listener_lb_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.InstancePort', listener_instance_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.SSLCertificateId', listener_ssl_certificate_id))
+
+          request({
+            'Action'           => 'CreateLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::CreateLoadBalancer.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer_listeners.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer_listeners.rb
new file mode 100644
index 0000000..b5e86c7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/create_load_balancer_listeners.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Create Elastic Load Balancer Listeners
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name for the new ELB -- must be unique
+        # * listeners<~Array> - Array of Hashes describing ELB listeners to add to the ELB
+        #   * 'Protocol'<~String> - Protocol to use. Either HTTP or TCP.
+        #   * 'LoadBalancerPort'<~Integer> - The port that the ELB will listen to for outside traffic
+        #   * 'InstancePort'<~Integer> - The port on the instance that the ELB will forward traffic to
+        #   * 'SSLCertificateId'<~String> - ARN of the server certificate
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def create_load_balancer_listeners(lb_name, listeners)
+          params = {}
+
+          listener_protocol = []
+          listener_lb_port = []
+          listener_instance_port = []
+          listener_ssl_certificate_id = []
+          listeners.each do |listener|
+            listener_protocol.push(listener['Protocol'])
+            listener_lb_port.push(listener['LoadBalancerPort'])
+            listener_instance_port.push(listener['InstancePort'])
+            listener_ssl_certificate_id.push(listener['SSLCertificateId'])
+          end
+
+          params.merge!(AWS.indexed_param('Listeners.member.%d.Protocol', listener_protocol))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.LoadBalancerPort', listener_lb_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.InstancePort', listener_instance_port))
+          params.merge!(AWS.indexed_param('Listeners.member.%d.SSLCertificateId', listener_ssl_certificate_id))
+
+          request({
+            'Action'           => 'CreateLoadBalancerListeners',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer.rb
new file mode 100644
index 0000000..62771cc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer.rb
@@ -0,0 +1,33 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/delete_load_balancer'
+
+        # Delete an existing Elastic Load Balancer
+        #
+        # Note that this API call, as defined by Amazon, is idempotent.
+        # That is, it will not return an error if you try to delete an
+        # ELB that does not exist.
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB to be deleted
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DeleteLoadBalancerResponse'<~nil>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_load_balancer(lb_name)
+          request({
+            'Action'           => 'DeleteLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeleteLoadBalancer.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_listeners.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_listeners.rb
new file mode 100644
index 0000000..b9c3575
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_listeners.rb
@@ -0,0 +1,31 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Delet Elastic Load Balancer Listeners
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name for the new ELB -- must be unique
+        # * load_balancer_ports<~Array> - Array of client port numbers of the LoadBalancerListeners to remove
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_load_balancer_listeners(lb_name, load_balancer_ports)
+          params = AWS.indexed_param('LoadBalancerPorts.memeber.%d', load_balancer_ports)
+
+          request({
+            'Action'           => 'DeleteLoadBalancerListeners',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_policy.rb
new file mode 100644
index 0000000..3180eb9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/delete_load_balancer_policy.rb
@@ -0,0 +1,31 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Delete a Load Balancer Stickiness Policy
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB
+        # * policy_name<~String> - The name of the policy to delete
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_load_balancer_policy(lb_name, policy_name)
+          params = {'PolicyName' => policy_name}
+
+          request({
+            'Action'           => 'DeleteLoadBalancerPolicy',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
new file mode 100644
index 0000000..56f08b0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/deregister_instances_from_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/deregister_instances_from_load_balancer'
+
+        # Deregister an instance from an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to remove from ELB
+        # * lb_name<~String> - Load balancer to remove instances from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DeregisterInstancesFromLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DeregisterInstancesFromLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DeregisterInstancesFromLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+      class Mock
+
+        def deregister_instances_from_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :deregister_instances :deregister_instances_from_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_instance_health.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_instance_health.rb
new file mode 100644
index 0000000..8220010
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_instance_health.rb
@@ -0,0 +1,37 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_instance_health'
+
+        # Get health status for one or more instances on an existing ELB
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Load balancer to check instances health on
+        # * instance_ids<~Array> - Optional list of instance IDs to check
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeInstanceHealthResult'<~Hash>:
+        #       * 'InstanceStates'<~Array> - array of hashes describing instance health
+        #         * 'Description'<~String>
+        #         * 'State'<~String>
+        #         * 'InstanceId'<~String>
+        #         * 'ReasonCode'<~String>
+        def describe_instance_health(lb_name, instance_ids = [])
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'DescribeInstanceHealth',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DescribeInstanceHealth.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_load_balancers.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_load_balancers.rb
new file mode 100644
index 0000000..ed3f494
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/describe_load_balancers.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/describe_load_balancers'
+
+        # Describe all or specified load balancers
+        #
+        # ==== Parameters
+        # * lb_name<~Array> - List of load balancer names to describe, defaults to all
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DescribeLoadBalancersResult'<~Hash>:
+        #       * 'LoadBalancerDescriptions'<~Array>
+        #         * 'LoadBalancerName'<~String> - name of load balancer
+        #         * 'DNSName'<~String> - external DNS name of load balancer
+        #         * 'CreatedTime'<~Time> - time load balancer was created
+        #         * 'ListenerDescriptions'<~Array>
+        #           * 'PolicyNames'<~Array> - list of policies enabled
+        #           * 'Listener'<~Hash>:
+        #             * 'InstancePort'<~Integer> - port on instance that requests are sent to
+        #             * 'Protocol'<~String> - transport protocol used for routing in [TCP, HTTP]
+        #             * 'LoadBalancerPort'<~Integer> - port that load balancer listens on for requests
+        #         * 'HealthCheck'<~Hash>:
+        #           * 'HealthyThreshold'<~Integer> - number of consecutive health probe successes required before moving the instance to the Healthy state
+        #           * 'Timeout'<~Integer> - number of seconds after which no response means a failed health probe
+        #           * 'Interval'<~Integer> - interval (in seconds) between health checks of an individual instance
+        #           * 'UnhealthyThreshold'<~Integer> - number of consecutive health probe failures that move the instance to the unhealthy state
+        #           * 'Target'<~String> - string describing protocol type, port and URL to check
+        #         * 'Policies'<~Hash>:
+        #           * 'LBCookieStickinessPolicies'<~Array> - list of Load Balancer Generated Cookie Stickiness policies for the LoadBalancer
+        #           * 'AppCookieStickinessPolicies'<~Array> - list of Application Generated Cookie Stickiness policies for the LoadBalancer
+        #         * 'AvailabilityZones'<~Array> - list of availability zones covered by this load balancer
+        #         * 'Instances'<~Array> - list of instances that the load balancer balances between
+        def describe_load_balancers(lb_name = [])
+          params = AWS.indexed_param('LoadBalancerNames.member', [*lb_name])
+          request({
+            'Action'  => 'DescribeLoadBalancers',
+            :parser   => Fog::Parsers::AWS::ELB::DescribeLoadBalancers.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..ab1e872
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/disable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/disable_availability_zones_for_load_balancer'
+
+        # Disable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to disable on ELB
+        # * lb_name<~String> - Load balancer to disable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'DisableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones])
+          request({
+            'Action'           => 'DisableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::DisableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def disable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :disable_zones :disable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
new file mode 100644
index 0000000..5711d03
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/enable_availability_zones_for_load_balancer.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/enable_availability_zones_for_load_balancer'
+
+        # Enable an availability zone for an existing ELB
+        #
+        # ==== Parameters
+        # * availability_zones<~Array> - List of availability zones to enable on ELB
+        # * lb_name<~String> - Load balancer to enable availability zones on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'EnableAvailabilityZonesForLoadBalancerResult'<~Hash>:
+        #       * 'AvailabilityZones'<~Array> - array of strings describing instances currently enabled
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          params = AWS.indexed_param('AvailabilityZones.member', [*availability_zones])
+          request({
+            'Action'           => 'EnableAvailabilityZonesForLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::EnableAvailabilityZonesForLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+      class Mock
+
+        def enable_availability_zones_for_load_balancer(availability_zones, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :enable_zones :enable_availability_zones_for_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
new file mode 100644
index 0000000..9d4445d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/register_instances_with_load_balancer.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/register_instances_with_load_balancer'
+
+        # Register an instance with an existing ELB
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - List of instance IDs to associate with ELB
+        # * lb_name<~String> - Load balancer to assign instances to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        #     * 'RegisterInstancesWithLoadBalancerResult'<~Hash>:
+        #       * 'Instances'<~Array> - array of hashes describing instances currently enabled
+        #         * 'InstanceId'<~String>
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          params = AWS.indexed_param('Instances.member.%d.InstanceId', [*instance_ids])
+          request({
+            'Action'           => 'RegisterInstancesWithLoadBalancer',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::RegisterInstancesWithLoadBalancer.new
+          }.merge!(params))
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+      class Mock
+
+        def register_instances_with_load_balancer(instance_ids, lb_name)
+          Fog::Mock.not_implemented
+        end
+
+        alias :register_instances :register_instances_with_load_balancer
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/elb/set_load_balancer_policies_of_listener.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/set_load_balancer_policies_of_listener.rb
new file mode 100644
index 0000000..f8b209b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/elb/set_load_balancer_policies_of_listener.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class ELB
+      class Real
+
+        require 'fog/aws/parsers/elb/empty'
+
+        # Associates, updates, or disables a policy with a listener on the
+        # load balancer. Currently only zero (0) or one (1) policy can be
+        # associated with a listener.
+        #
+        # ==== Parameters
+        # * lb_name<~String> - Name of the ELB
+        # * load_balancer_port<~Integer> - The external port of the LoadBalancer
+        #   with which this policy has to be associated.
+
+        # * policy_names<~Array> - List of policies to be associated with the
+        #   listener. Currently this list can have at most one policy. If the
+        #   list is empty, the current policy is removed from the listener.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def set_load_balancer_policies_of_listener(lb_name, load_balancer_port, policy_names)
+          params = {'LoadBalancerPort' => load_balancer_port}
+          if policy_names.any?
+            params.merge!(AWS.indexed_param('PolicyNames.member', policy_names))
+          else
+            params['PolicyNames'] = ''
+          end
+
+          request({
+            'Action'           => 'SetLoadBalancerPoliciesOfListener',
+            'LoadBalancerName' => lb_name,
+            :parser            => Fog::Parsers::AWS::ELB::Empty.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/add_user_to_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/add_user_to_group.rb
new file mode 100644
index 0000000..35b5e86
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/add_user_to_group.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add a user to a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * user_name<~String>: name of user to add
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_AddUserToGroup.html
+        #
+        def add_user_to_group(group_name, user_name)
+          request(
+            'Action'    => 'AddUserToGroup',
+            'GroupName' => group_name,
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_access_key.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_access_key.rb
new file mode 100644
index 0000000..4ad7ba8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_access_key.rb
@@ -0,0 +1,37 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_access_key'
+
+        # Create a access keys for user (by default detects user from access credentials)
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessKey'<~Hash>:
+        #       * 'AccessKeyId'<~String> -
+        #       * 'UserName'<~String> -
+        #       * 'SecretAccessKey'<~String> -
+        #       * 'Status'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateAccessKey.html
+        #
+        def create_access_key(options = {})
+          request({
+            'Action'    => 'CreateAccessKey',
+            :parser     => Fog::Parsers::AWS::IAM::CreateAccessKey.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_group.rb
new file mode 100644
index 0000000..6049ee5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_group.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_group'
+
+        # Create a new group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group to create (do not include path)
+        # * path<~String>: optional path to group, defaults to '/'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Group'<~Hash>:
+        #       * Arn<~String> -
+        #       * GroupId<~String> -
+        #       * GroupName<~String> -
+        #       * Path<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateGroup.html
+        #
+        def create_group(group_name, path = '/')
+          request(
+            'Action'    => 'CreateGroup',
+            'GroupName' => group_name,
+            'Path'      => path,
+            :parser     => Fog::Parsers::AWS::IAM::CreateGroup.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_login_profile.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_login_profile.rb
new file mode 100644
index 0000000..5ca264f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_login_profile.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/login_profile'
+
+        # Creates a login profile for a user
+        # 
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateLoginProfile.html
+        # ==== Parameters
+        # * user_name<~String> - Name of user to create a login profile for
+        # * password<~String> - The new password for this user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'LoginProfile'<~Hash>
+        #        * UserName<~String>
+        #        * CreateDate
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        #
+        def create_login_profile(user_name, password)
+          request({
+            'Action'    => 'CreateLoginProfile',
+            'UserName'  => user_name,
+            'Password'  => password,
+            :parser     => Fog::Parsers::AWS::IAM::LoginProfile.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_user.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_user.rb
new file mode 100644
index 0000000..9f85ca8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/create_user.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/create_user'
+
+        # Create a new user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user to create (do not include path)
+        # * path<~String>: optional path to group, defaults to '/'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'User'<~Hash>:
+        #       * 'Arn'<~String> -
+        #       * 'Path'<~String> -
+        #       * 'UserId'<~String> -
+        #       * 'UserName'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateUser.html
+        #
+        def create_user(user_name, path = '/')
+          request(
+            'Action'    => 'CreateUser',
+            'UserName'  => user_name,
+            'Path'      => path,
+            :parser     => Fog::Parsers::AWS::IAM::CreateUser.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_access_key.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_access_key.rb
new file mode 100644
index 0000000..7ecb504
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_access_key.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete an access key
+        # 
+        # ==== Parameters
+        # * access_key_id<~String> - Access key id to delete
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteAccessKey.html
+        #
+        def delete_access_key(access_key_id, options = {})
+          request({
+            'AccessKeyId' => access_key_id,
+            'Action'      => 'DeleteAccessKey',
+            :parser       => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group.rb
new file mode 100644
index 0000000..7f7957d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteGroup.html
+        #
+        def delete_group(group_name)
+          request(
+            'Action'    => 'DeleteGroup',
+            'GroupName' => group_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group_policy.rb
new file mode 100644
index 0000000..81f9de0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_group_policy.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a policy from a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * policy_name<~String>: name of policy document
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteGroupPolicy.html
+        #
+        def delete_group_policy(group_name, policy_name)
+          request(
+            'Action'          => 'DeleteGroupPolicy',
+            'GroupName'       => group_name,
+            'PolicyName'      => policy_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_login_profile.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_login_profile.rb
new file mode 100644
index 0000000..93cd492
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_login_profile.rb
@@ -0,0 +1,31 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Deletes a user's login profile
+        # 
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteLoginProfile.html
+        # ==== Parameters
+        # * user_name<~String> - Name of user whose login profile you want to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        #
+        def delete_login_profile(user_name)
+          request({
+            'Action'    => 'DeleteLoginProfile',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_server_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_server_certificate.rb
new file mode 100644
index 0000000..a3db3d1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_server_certificate.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Deletes the specified server certificate.
+        #
+        # ==== Parameters
+        # * server_certificate_name<~String>: The name of the server certificate you want to delete.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteServerCertificate.html
+        #
+        def delete_server_certificate(server_certificate_name)
+          request({
+            'Action'                => 'DeleteServerCertificate',
+            'ServerCertificateName' => server_certificate_name,
+            :parser                 => Fog::Parsers::AWS::IAM::Basic.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_signing_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_signing_certificate.rb
new file mode 100644
index 0000000..12d3970
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_signing_certificate.rb
@@ -0,0 +1,33 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Upload signing certificate for user (by default detects user from access credentials)
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to upload certificate for (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_DeleteSigningCertificate.html
+        #
+        def delete_signing_certificate(certificate_id, options = {})
+          request({
+            'Action'        => 'DeleteSigningCertificate',
+            'CertificateId' => certificate_id,
+            :parser         => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user.rb
new file mode 100644
index 0000000..6dc7cd9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Delete a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteUser.html
+        #
+        def delete_user(user_name)
+          request(
+            'Action'    => 'DeleteUser',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user_policy.rb
new file mode 100644
index 0000000..ee76bd7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/delete_user_policy.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a policy from a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user
+        # * policy_name<~String>: name of policy document
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_DeleteUserPolicy.html
+        #
+        def delete_user_policy(user_name, policy_name)
+          request(
+            'Action'          => 'DeleteUserPolicy',
+            'PolicyName'      => policy_name,
+            'UserName'        => user_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_group.rb
new file mode 100644
index 0000000..cee3788
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_group.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/get_group'
+
+        # Get Group
+        # 
+        # ==== Parameters        
+        # * 'GroupName'<~String>: Name of the Group
+        # * options<~Hash>:
+        #   * 'Marker'<~String>: Use this only when paginating results, and only in a subsequent request after you've received a response where the results are truncated. Set it to the value of the Marker element in the response you just received.
+        #   * 'MaxItems'<~String>: Use this only when paginating results to indicate the maximum number of User names you want in the response. If there are additional User names beyond the maximum you specify, the IsTruncated response element is true.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Group'<~Hash> - Group
+        #       * 'Path'<~String>
+        #       * 'GroupName'<~String>
+        #       * 'Arn'<~String>
+        #     * 'Users'<~Hash>? - List of users belonging to the group.
+        #       * 'User'<~Hash> - User
+        #         * Arn<~String> -
+        #         * UserId<~String> -
+        #         * UserName<~String> -
+        #         * Path<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_GetGroup.html
+        #
+        def get_group(group_name, options = {})
+          request({
+            'Action'    => 'GetGroup',
+            'GroupName' => group_name,
+            :parser     => Fog::Parsers::AWS::IAM::GetGroup.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_login_profile.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_login_profile.rb
new file mode 100644
index 0000000..9305d8e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_login_profile.rb
@@ -0,0 +1,35 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/login_profile'
+
+        # Retrieves the login profile for a user
+        # 
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_CreateLoginProfile.html
+        # ==== Parameters
+        # * user_name<~String> - Name of user to retrieve the login profile for
+        # * password<~String> - The new password for this user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'LoginProfile'<~Hash>
+        #        * UserName<~String>
+        #        * CreateDate
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        #
+        def get_login_profile(user_name)
+          request({
+            'Action'    => 'GetLoginProfile',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::LoginProfile.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user.rb
new file mode 100644
index 0000000..a251772
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/get_user'
+
+        # Get User
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String>: Name of the User. Defaults to current user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'User'<~Hash> - User
+        #       * Arn<~String> -
+        #       * UserId<~String> -
+        #       * UserName<~String> -
+        #       * Path<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_Getuser.html
+        #
+        def get_user(options = {})
+          request({
+            'Action'  => 'GetUser',
+            :parser   => Fog::Parsers::AWS::IAM::GetUser.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user_policy.rb
new file mode 100644
index 0000000..87bf73d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/get_user_policy.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/get_user_policy'
+
+        # Get User Policy
+        # 
+        # ==== Parameters
+        # * 'PolicyName'<~String>: Name of the policy to get
+        # * 'UserName'<~String>: Name of the User who the policy is associated with.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #       * PolicyDocument<~String> The policy document.
+        #       * PolicyName<~String> The name of the policy.
+        #       * UserName<~String> The User the policy is associated with.
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_GetUserPolicy.html
+        #
+        def get_user_policy(policy_name, user_name)
+          request({
+            'Action'      => 'GetUserPolicy',
+            'PolicyName'  => policy_name,
+            'UserName'    => user_name,
+            :parser       => Fog::Parsers::AWS::IAM::GetUserPolicy.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_access_keys.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_access_keys.rb
new file mode 100644
index 0000000..8ea3d27
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_access_keys.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_access_keys'
+
+        # List access_keys
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String> - used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer> - limit results to this number per page
+        #   * 'UserName'<~String> - optional: username to lookup access keys for, defaults to current user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessKeys'<~Array> - Matching access keys
+        #       * access_key<~Hash>:
+        #         * AccessKeyId<~String> -
+        #         * Status<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListAccessKeys.html
+        #
+        def list_access_keys(options = {})
+          request({
+            'Action'  => 'ListAccessKeys',
+            :parser   => Fog::Parsers::AWS::IAM::ListAccessKeys.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_group_policies.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_group_policies.rb
new file mode 100644
index 0000000..99df385
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_group_policies.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_policies'
+
+        # List policies for a group
+        # 
+        # ==== Parameters
+        # * group_name<~String> - Name of group to list policies for
+        # * options<~Hash>: Optional
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PolicyNames'<~Array> - Matching policy names
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListGroupPolicies.html
+        #
+        def list_group_policies(group_name, options = {})
+          request({
+            'Action'    => 'ListGroupPolicies',
+            'GroupName' => group_name,
+            :parser     => Fog::Parsers::AWS::IAM::ListPolicies.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups.rb
new file mode 100644
index 0000000..7a90ca9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_groups'
+
+        # List groups
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Groups'<~Array> - Matching groups
+        #       * group<~Hash>:
+        #         * Arn<~String> -
+        #         * GroupId<~String> -
+        #         * GroupName<~String> -
+        #         * Path<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListGroups.html
+        #
+        def list_groups(options = {})
+          request({
+            'Action'  => 'ListGroups',
+            :parser   => Fog::Parsers::AWS::IAM::ListGroups.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups_for_user.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups_for_user.rb
new file mode 100644
index 0000000..0826221
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_groups_for_user.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_groups_for_user'
+
+        # List groups_for_user
+        #
+        # ==== Parameters
+        # * user_name<~String> - the username you want to look up group membership for
+        # * options<~Hash>:
+        #   * 'Marker'<~String> - used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer> - limit results to this number per page
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'GroupsForUser'<~Array> - Groups for a user
+        #       * group_for_user<~Hash>:
+        #         * 'Arn' -
+        #         * 'GroupId' -
+        #         * 'GroupName' -
+        #         * 'Path' -
+        #     * 'IsTruncated'<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListGroupsForUser.html
+        #
+        def list_groups_for_user(user_name, options = {})
+          request({
+            'Action'    => 'ListGroupsForUser',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::ListGroupsForUser.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_server_certificates.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_server_certificates.rb
new file mode 100644
index 0000000..37b7558
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_server_certificates.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_server_certificates'
+
+        # List server certificates
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String> - The marker from the previous result (for pagination)
+        #   * 'MaxItems'<~String> - The maximum number of server certificates you want in the response
+        #   * 'PathPrefix'<~String> - The path prefix for filtering the results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Certificates'<~Array> - Matching server certificates
+        #       * server_certificate<~Hash>:
+        #         * Arn<~String> -
+        #         * Path<~String> -
+        #         * ServerCertificateId<~String> -
+        #         * ServerCertificateName<~String> -
+        #         * UploadDate<~Time> -
+        #       * 'IsTruncated'<~Boolean> - Whether or not the results were truncated
+        #       * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_ListServerCertificates.html
+        #
+        def list_server_certificates(options = {})
+          request({
+            'Action'  => 'ListServerCertificates',
+            :parser   => Fog::Parsers::AWS::IAM::ListServerCertificates.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_signing_certificates.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_signing_certificates.rb
new file mode 100644
index 0000000..f28f4a4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_signing_certificates.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_signing_certificates'
+
+        # List signing certificates for user (by default detects user from access credentials)
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to list certificates for (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'SigningCertificates'<~Array> - Matching signing certificates
+        #       * signing_certificate<~Hash>:
+        #         * CertificateId<~String> -
+        #         * Status<~String> -
+        #       * 'IsTruncated'<~Boolean> - Whether or not the results were truncated
+        #       * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #       * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_ListSigningCertificates.html
+        #
+        def list_signing_certificates(options = {})
+          request({
+            'Action'  => 'ListSigningCertificates',
+            :parser   => Fog::Parsers::AWS::IAM::ListSigningCertificates.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_user_policies.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_user_policies.rb
new file mode 100644
index 0000000..048eea8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_user_policies.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_policies'
+
+        # List policies for a user
+        # 
+        # ==== Parameters
+        # * user_name<~String> - Name of user to list policies for
+        # * options<~Hash>: Optional
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PolicyNames'<~Array> - Matching policy names
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListUserPolicies.html
+        #
+        def list_user_policies(user_name, options = {})
+          request({
+            'Action'    => 'ListUserPolicies',
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::ListPolicies.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_users.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_users.rb
new file mode 100644
index 0000000..1c54fbb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/list_users.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/list_users'
+
+        # List users
+        # 
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'Marker'<~String>: used to paginate subsequent requests
+        #   * 'MaxItems'<~Integer>: limit results to this number per page
+        #   * 'PathPrefix'<~String>: prefix for filtering results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Users'<~Array> - Matching groups
+        #       * user<~Hash>:
+        #         * Arn<~String> -
+        #         * Path<~String> -
+        #         * UserId<~String> -
+        #         * UserName<~String> -
+        #     * 'IsTruncated<~Boolean> - Whether or not results were truncated
+        #     * 'Marker'<~String> - appears when IsTruncated is true as the next marker to use
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_ListUsers.html
+        #
+        def list_users(options = {})
+          request({
+            'Action'  => 'ListUsers',
+            :parser   => Fog::Parsers::AWS::IAM::ListUsers.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_group_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_group_policy.rb
new file mode 100644
index 0000000..48837f1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_group_policy.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add or update a policy for a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * policy_name<~String>: name of policy document
+        # * policy_document<~Hash>: policy document, see: http://docs.amazonwebservices.com/IAM/latest/UserGuide/PoliciesOverview.html
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_PutGroupPolicy.html
+        #
+        def put_group_policy(group_name, policy_name, policy_document)
+          request(
+            'Action'          => 'PutGroupPolicy',
+            'GroupName'       => group_name,
+            'PolicyName'      => policy_name,
+            'PolicyDocument'  => policy_document.to_json,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_user_policy.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_user_policy.rb
new file mode 100644
index 0000000..d0b8840
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/put_user_policy.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Add or update a policy for a user
+        # 
+        # ==== Parameters
+        # * user_name<~String>: name of the user
+        # * policy_name<~String>: name of policy document
+        # * policy_document<~Hash>: policy document, see: http://docs.amazonwebservices.com/IAM/latest/UserGuide/PoliciesOverview.html
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_PutUserPolicy.html
+        #
+        def put_user_policy(user_name, policy_name, policy_document)
+          request(
+            'Action'          => 'PutUserPolicy',
+            'PolicyName'      => policy_name,
+            'PolicyDocument'  => policy_document.to_json,
+            'UserName'        => user_name,
+            :parser           => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/remove_user_from_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/remove_user_from_group.rb
new file mode 100644
index 0000000..3a89176
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/remove_user_from_group.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Remove a user from a group
+        # 
+        # ==== Parameters
+        # * group_name<~String>: name of the group
+        # * user_name<~String>: name of user to remove
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_RemoveUserFromGroup.html
+        #
+        def remove_user_from_group(group_name, user_name)
+          request(
+            'Action'    => 'RemoveUserFromGroup',
+            'GroupName' => group_name,
+            'UserName'  => user_name,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_access_key.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_access_key.rb
new file mode 100644
index 0000000..f19ccfe
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_access_key.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Update an access key for a user
+        # 
+        # ==== Parameters
+        # * access_key_id<~String> - Access key id to delete
+        # * status<~String> - status of keys in ['Active', 'Inactive']
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to create (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_UpdateAccessKey.html
+        #
+        def update_access_key(access_key_id, status, options = {})
+          request({
+            'AccessKeyId' => access_key_id,
+            'Action'      => 'UpdateAccessKey',
+            'Status'      => status,
+            :parser       => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_group.rb
new file mode 100644
index 0000000..6504ed0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_group.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/update_group'
+
+        # Update a Group
+        #
+        # ==== Parameters
+        # * group_name<~String> - Required. Name of the Group to update. If you're changing the name of the Group, this is the original Group name.
+        # * options<~Hash>:
+        #   * new_path<~String> - New path for the Group. Include this parameter only if you're changing the Group's path.
+        #   * new_group_name<~String> - New name for the Group. Include this parameter only if you're changing the Group's name.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #     * 'Group'<~Hash> - Changed Group info
+        #       * 'Arn'<~String> -
+        #       * 'Path'<~String> -
+        #       * 'GroupId'<~String> -
+        #       * 'GroupName'<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UpdateGroup.html
+        #
+        def update_group(group_name, options = {})
+          request({
+            'Action'      => 'UpdateGroup',
+            'GroupName'    => group_name,
+            :parser       => Fog::Parsers::AWS::IAM::UpdateGroup.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_login_profile.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_login_profile.rb
new file mode 100644
index 0000000..cc89b40
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_login_profile.rb
@@ -0,0 +1,33 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/basic'
+
+        # Updates a login profile for a user
+        # 
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/API_UpdateLoginProfile.html
+        # ==== Parameters
+        # * user_name<~String> - Name of user to change the login profile for
+        # * password<~String> - The new password for this user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        #
+        def update_login_profile(user_name, password)
+          request({
+            'Action'    => 'UpdateLoginProfile',
+            'UserName'  => user_name,
+            'Password'  => password,
+            :parser     => Fog::Parsers::AWS::IAM::Basic.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_signing_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_signing_certificate.rb
new file mode 100644
index 0000000..da18730
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_signing_certificate.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+        # Update a Signing Certificate
+        #
+        # ==== Parameters
+        # * certificate_id<~String> - Required. ID of the Certificate to update.
+        # * status<~String> - Required. Active/Inactive
+        # * options<~Hash>:
+        #   * user_name<~String> - Name of the user the signing certificate belongs to.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UpdateSigningCertificate.html
+        #
+        def update_signing_certificate(certificate_id, status, options = {})
+          request({
+            'Action'        => 'UpdateSigningCertificate',
+            'CertificateId' => certificate_id,
+            'Status'        => status,
+            :parser         => Fog::Parsers::AWS::IAM::Basic.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_user.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_user.rb
new file mode 100644
index 0000000..2c31cd6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/update_user.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/update_user'
+
+        # Update a user
+        # 
+        # ==== Parameters
+        # * user_name<~String> - Required. Name of the User to update. If you're changing the name of the User, this is the original User name.
+        # * options<~Hash>:
+        #   * new_path<~String> - New path for the User. Include this parameter only if you're changing the User's path.
+        #   * new_user_name<~String> - New name for the User. Include this parameter only if you're changing the User's name.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'RequestId'<~String> - Id of the request
+        #     * 'User'<~Hash> - Changed user info
+        #       * 'Arn'<~String> -
+        #       * 'Path'<~String> -
+        #       * 'UserId'<~String> -
+        #       * 'UserName'<~String> -
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UpdateUser.html
+        #
+        def update_user(user_name, options = {})
+          request({
+            'Action'      => 'UpdateUser',
+            'UserName'    => user_name,
+            :parser       => Fog::Parsers::AWS::IAM::UpdateUser.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_server_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_server_certificate.rb
new file mode 100644
index 0000000..7d4db71
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_server_certificate.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/upload_server_certificate'
+
+        # Uploads a server certificate entity for the AWS Account.
+        # Includes a public key certificate, a private key, and an optional certificate chain, which should all be PEM-encoded.
+        #
+        # ==== Parameters
+        # * certificate<~Hash>: The contents of the public key certificate in PEM-encoded format.
+        # * private_key<~Hash>: The contents of the private key in PEM-encoded format.
+        # * name<~Hash>: The name for the server certificate. Do not include the path in this value.
+        # * options<~Hash>:
+        #   * 'CertificateChain'<~String> - The contents of the certificate chain. Typically a concatenation of the PEM-encoded public key certificates of the chain.
+        #   * 'Path'<~String> - The path for the server certificate.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'UploadServerCertificateResult'<~Hash>:
+        #       * 'CertificateId'<~String> -
+        #       * 'UserName'<~String> -
+        #       * 'CertificateBody'<~String> -
+        #       * 'Status'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UploadServerCertificate.html
+        #
+        def upload_server_certificate(certificate, private_key, name, options = {})
+          request({
+            'Action'                => 'UploadServerCertificate',
+            'CertificateBody'       => certificate,
+            'PrivateKey'            => private_key,
+            'ServerCertificateName' => name,
+            :parser                 => Fog::Parsers::AWS::IAM::UploadServerCertificate.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_signing_certificate.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_signing_certificate.rb
new file mode 100644
index 0000000..c45b14b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/iam/upload_signing_certificate.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class IAM
+      class Real
+
+        require 'fog/aws/parsers/iam/upload_signing_certificate'
+
+        # Upload signing certificate for user (by default detects user from access credentials)
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'UserName'<~String> - name of the user to upload certificate for (do not include path)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Certificate'<~Hash>:
+        #       * 'CertificateId'<~String> -
+        #       * 'UserName'<~String> -
+        #       * 'CertificateBody'<~String> -
+        #       * 'Status'<~String> -
+        #     * 'RequestId'<~String> - Id of the request
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/IAM/latest/APIReference/index.html?API_UploadSigningCertificate.html
+        #
+        def upload_signing_certificate(certificate, options = {})
+          request({
+            'Action'          => 'UploadSigningCertificate',
+            'CertificateBody' => certificate,
+            :parser           => Fog::Parsers::AWS::IAM::UploadSigningCertificate.new
+          }.merge!(options))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/authorize_db_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/authorize_db_security_group_ingress.rb
new file mode 100644
index 0000000..52a1f89
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/authorize_db_security_group_ingress.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/authorize_db_security_group_ingress'
+
+        # authorizes a db security group ingress
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_AuthorizeDBSecurityGroupIngress.html
+        # ==== Parameters
+        # * CIDRIP <~String> - The IP range to authorize
+        # * DBSecurityGroupName <~String> - The name for the DB Security Group.
+        # * EC2SecurityGroupName <~String> - Name of the EC2 Security Group to authorize.
+        # * EC2SecurityGroupOwnerId <~String> - AWS Account Number of the owner of the security group specified in the EC2SecurityGroupName parameter. The AWS Access Key ID is not an acceptable value.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def authorize_db_security_group_ingress(name, opts={})
+          unless opts.key?('CIDRIP') || (opts.key?('EC2SecurityGroupName') && opts.key?('EC2SecurityGroupOwnerId'))
+            raise ArgumentError, 'Must specify CIDRIP, or both EC2SecurityGroupName and EC2SecurityGroupOwnerId'
+          end
+
+          request({
+            'Action'  => 'AuthorizeDBSecurityGroupIngress',
+            :parser   => Fog::Parsers::AWS::RDS::AuthorizeDBSecurityGroupIngress.new,
+            'DBSecurityGroupName' => name
+          }.merge(opts))
+
+        end
+
+      end
+
+      class Mock
+
+        def authorize_db_security_group_ingress(name, opts = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance.rb
new file mode 100644
index 0000000..91efb2d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/create_db_instance'
+
+        # create a db instance
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_CreateDBInstance.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - name of the db instance to modify
+        #                                     
+        # * AllocatedStorage  <~Integer> Storage space, in GB
+        # * AutoMinorVersionUpgrade <~Boolean> Indicates that minor version upgrades will be applied automatically to the DB Instance during the maintenance window 
+        # * AvailabilityZone <~String> The availability zone to create the instance in
+        # * BackupRetentionPeriod  <~Integer> 0-8 The number of days to retain automated backups.
+        # * DBInstanceClass <~String> The new compute and memory capacity of the DB Instance
+        # * DBName <~String> The name of the database to create when the DB Instance is created
+        # * DBParameterGroupName <~String> The name of the DB Parameter Group to apply to this DB Instance  
+        # * DBSecurityGroups <~Array> A list of DB Security Groups to authorize on this DB Instance 
+        # * Engine <~String> The name of the database engine to be used for this instance.
+        # * EngineVersion <~String> The version number of the database engine to use.
+        # * MasterUsername <~String> The db master user
+        # * MasterUserPassword  <~String> The new password for the DB Instance master user
+        # * MultiAZ <~Boolean> Specifies if the DB Instance is a Multi-AZ deployment
+        # * Port <~Integer> The port number on which the database accepts connections.
+        # * PreferredBackupWindow <~String> The daily time range during which automated backups are created if automated backups are enabled
+        # * PreferredMaintenanceWindow <~String> The weekly time range (in UTC) during which system maintenance can occur, which may result in an outage
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def create_db_instance(db_name, options={})
+          
+          if security_groups = options.delete('DBSecurityGroups')
+            options.merge!(AWS.indexed_param('DBSecurityGroups.member.%d', [*security_groups]))
+          end
+    
+          request({
+            'Action'  => 'CreateDBInstance',
+            'DBInstanceIdentifier' => db_name,
+            :parser   => Fog::Parsers::AWS::RDS::CreateDBInstance.new,
+          }.merge(options))
+        end
+
+      end
+
+      class Mock
+
+        def create_db_instance(db_name, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance_read_replica.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance_read_replica.rb
new file mode 100644
index 0000000..e613530
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_instance_read_replica.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/create_db_instance_read_replica'
+
+        # create a read replica db instance
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_CreateDBInstanceReadReplica.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - name of the db instance to create
+        # * SourceDBInstanceIdentifier <~String> - name of the db instance that will be the source. Must have backup retention on
+        # * AutoMinorVersionUpgrade <~Boolean> Indicates that minor version upgrades will be applied automatically to the DB Instance during the maintenance window 
+        # * AvailabilityZone <~String> The availability zone to create the instance in
+        # * DBInstanceClass <~String> The new compute and memory capacity of the DB Instance
+        # * Port <~Integer> The port number on which the database accepts connections.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def create_db_instance_read_replica(instance_identifier, source_identifier, options={})
+          
+    
+          request({
+            'Action'  => 'CreateDBInstanceReadReplica',
+            'DBInstanceIdentifier' => instance_identifier,
+            'SourceDBInstanceIdentifier' => source_identifier,
+            :parser   => Fog::Parsers::AWS::RDS::CreateDBInstanceReadReplica.new,
+          }.merge(options))
+        end
+
+      end
+
+      class Mock
+
+        def create_db_instance_read_replica(instance_identifier, source_identifier, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_parameter_group.rb
new file mode 100644
index 0000000..9fdcf68
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_parameter_group.rb
@@ -0,0 +1,41 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/create_db_parameter_group'
+
+        # create a database parameter group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_CreateDBParameterGroup.html
+        # ==== Parameters
+        # * DBParameterGroupName <~String> - name of the parameter group
+        # * DBParameterGroupFamily <~String> - The DB parameter group family name. Current valid values: MySQL5.1 | MySQL5.5
+        # * Description <~String> - The description for the DB Parameter Grou
+        #                                     
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def create_db_parameter_group(group_name, group_family, description)
+          
+          request({
+            'Action'  => 'CreateDBParameterGroup',
+            'DBParameterGroupName' => group_name,
+            'DBParameterGroupFamily' => group_family,
+            'Description' => description,
+            
+            :parser   => Fog::Parsers::AWS::RDS::CreateDbParameterGroup.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def create_db_parameter_group(group_name, group_family, description)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_security_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_security_group.rb
new file mode 100644
index 0000000..fae4976
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_security_group.rb
@@ -0,0 +1,37 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/create_db_security_group'
+
+        # creates a db security group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_CreateDBSecurityGroup.html
+        # ==== Parameters
+        # * DBSecurityGroupDescription <~String> - The description for the DB Security Group
+        # * DBSecurityGroupName <~String> - The name for the DB Security Group. This value is stored as a lowercase string. Must contain no more than 255 alphanumeric characters or hyphens. Must not be "Default".
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def create_db_security_group(name, description = name)
+          request({
+            'Action'  => 'CreateDBSecurityGroup',
+            'DBSecurityGroupName' => name,
+            'DBSecurityGroupDescription' => description,
+            :parser   => Fog::Parsers::AWS::RDS::CreateDBSecurityGroup.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def create_db_security_group(name, description = name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_snapshot.rb
new file mode 100644
index 0000000..24a2574
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/create_db_snapshot.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/create_db_snapshot'
+
+        # creates a db snapshot
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_CreateDBSnapshot.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - ID of instance to create snapshot for
+        # * DBSnapshotIdentifier <~String> - The identifier for the DB Snapshot. 1-255 alphanumeric or hyphen characters. Must start with a letter
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def create_db_snapshot(identifier, name)
+          request({
+            'Action'  => 'CreateDBSnapshot',
+            'DBInstanceIdentifier' => identifier,
+            'DBSnapshotIdentifier' => name,
+            :parser   => Fog::Parsers::AWS::RDS::CreateDBSnapshot.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def create_db_snapshot(identifier, name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_instance.rb
new file mode 100644
index 0000000..0c5979b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_instance.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/delete_db_instance'
+
+        # delete a database instance
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DeleteDBInstance.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - The DB Instance identifier for the DB Instance to be deleted.
+        # * FinalDBSnapshotIdentifier <~String> - The DBSnapshotIdentifier of the new DBSnapshot created when SkipFinalSnapshot is set to false
+        # * SkipFinalSnapshot <~Boolean> - Determines whether a final DB Snapshot is created before the DB Instance is deleted
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def delete_db_instance(identifier, snapshot_identifier, skip_snapshot = false)          
+          params = {}
+          params['FinalDBSnapshotIdentifier'] = snapshot_identifier if snapshot_identifier
+          request({
+            'Action'  => 'DeleteDBInstance',
+            'DBInstanceIdentifier' => identifier,
+            'SkipFinalSnapshot' => skip_snapshot,            
+            :parser   => Fog::Parsers::AWS::RDS::DeleteDBInstance.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def delete_db_snapshot(identifier, snapshot_identifier, skip_snapshot = false)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_parameter_group.rb
new file mode 100644
index 0000000..d7f294b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_parameter_group.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/delete_db_parameter_group'
+
+        # delete a database parameter group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DeleteDBParameterGroup.html
+        # ==== Parameters
+        # * DBParameterGroupName <~String> - name of the parameter group. Must not be associated with any instances
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def delete_db_parameter_group(group_name)
+          
+          request({
+            'Action'  => 'DeleteDBParameterGroup',
+            'DBParameterGroupName' => group_name,
+            
+            :parser   => Fog::Parsers::AWS::RDS::DeleteDbParameterGroup.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_db_parameter_group(group_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_security_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_security_group.rb
new file mode 100644
index 0000000..f6fe2c0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_security_group.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/delete_db_security_group'
+
+        # deletes a db security group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_DeleteDBSecurityGroup.html
+        # ==== Parameters
+        # * DBSecurityGroupName <~String> - The name for the DB Security Group to delete
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def delete_db_security_group(name)
+          request({
+            'Action'  => 'DeleteDBSecurityGroup',
+            'DBSecurityGroupName' => name,
+            :parser   => Fog::Parsers::AWS::RDS::DeleteDBSecurityGroup.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_db_security_group(name, description = name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_snapshot.rb
new file mode 100644
index 0000000..ea42c35
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/delete_db_snapshot.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/delete_db_snapshot'
+
+        # delete a database snapshot
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DeleteDBSnapshot.html
+        # ==== Parameters
+        # * DBSnapshotIdentifier <~String> - name of the snapshot
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def delete_db_snapshot(group_name)
+          
+          request({
+            'Action'  => 'DeleteDBSnapshot',
+            'DBSnapshotIdentifier' => group_name,
+            
+            :parser   => Fog::Parsers::AWS::RDS::DeleteDBSnapshot.new
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_db_snapshot(group_name)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_instances.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_instances.rb
new file mode 100644
index 0000000..ea7bd34
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_instances.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/describe_db_instances'
+
+        # Describe all or specified load db instances
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - ID of instance to retrieve information for. if absent information for all instances is returned
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def describe_db_instances(identifier=nil, opts={})
+          params = {}
+          params['DBInstanceIdentifier'] = identifier if identifier
+          if opts[:marker]
+            params['Marker'] = opts[:marker]
+          end
+          if opts[:max_records]
+            params['MaxRecords'] = opts[:max_records]
+          end
+          
+          request({
+            'Action'  => 'DescribeDBInstances',
+            :parser   => Fog::Parsers::AWS::RDS::DescribeDBInstances.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_db_instances(identifier=nil, opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameter_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameter_groups.rb
new file mode 100644
index 0000000..26244a2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameter_groups.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/describe_db_parameter_groups'
+
+        # This API returns a list of DBParameterGroup descriptions. If a DBParameterGroupName is specified, the list will contain only the descriptions of the specified DBParameterGroup
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DescribeDBParameterGroups.html
+        # ==== Parameters
+        # * DBParameterGroupName <~String> - The name of a specific database parameter group to return details for.
+        # * Source <~String> - The parameter types to return. user | system | engine-default
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def describe_db_parameter_groups(name=nil, opts={})
+          params={}
+          if opts[:marker]
+            params['Marker'] = opts[:marker]
+          end
+          if name
+            params['DBParameterGroupName'] = name
+          end
+          if opts[:max_records]
+            params['MaxRecords'] = opts[:max_records]
+          end
+          
+          request({
+            'Action'  => 'DescribeDBParameterGroups',
+            :parser   => Fog::Parsers::AWS::RDS::DescribeDBParameterGroups.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_db_parameter_groups(name=nil, opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameters.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameters.rb
new file mode 100644
index 0000000..d76036b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_parameters.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/describe_db_parameters'
+
+        # Describe  parameters from a parameter group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DescribeDBParameters.html
+        # ==== Parameters
+        # * DBParameterGroupName <~String> - name of parameter group to retrieve parameters for
+        # * Source <~String> - The parameter types to return. user | system | engine-default
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def describe_db_parameters(name, opts={})
+          params={}
+          if opts[:marker]
+            params['Marker'] = opts[:marker]
+          end
+          if opts[:source]
+            params['Source'] = opts[:source]
+          end
+          if opts[:max_records]
+            params['MaxRecords'] = opts[:max_records]
+          end
+          
+          request({
+            'Action'  => 'DescribeDBParameters',
+            'DBParameterGroupName' => name,
+            :parser   => Fog::Parsers::AWS::RDS::DescribeDBParameters.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_db_parameters(name, opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_security_groups.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_security_groups.rb
new file mode 100644
index 0000000..f22f9b2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_security_groups.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/describe_db_security_groups'
+
+        # Describe all or specified db snapshots
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_DescribeDBSecurityGroups.html
+        # ==== Parameters
+        # * DBSecurityGroupName <~String> - The name of the DB Security Group to return details for.
+        # * Marker               <~String> - An optional marker provided in the previous DescribeDBInstances request
+        # * MaxRecords           <~Integer> - Max number of records to return (between 20 and 100)
+        # Only one of DBInstanceIdentifier or DBSnapshotIdentifier can be specified
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def describe_db_security_groups(opts={})
+          opts = {'DBSecurityGroupName' => opts} if opts.is_a?(String)
+
+          request({
+            'Action'  => 'DescribeDBSecurityGroups',
+            :parser   => Fog::Parsers::AWS::RDS::DescribeDBSecurityGroups.new
+          }.merge(opts))
+        end
+
+      end
+
+      class Mock
+
+        def describe_db_security_group(opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_snapshots.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_snapshots.rb
new file mode 100644
index 0000000..473e076
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/describe_db_snapshots.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/describe_db_snapshots'
+
+        # Describe all or specified db snapshots
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_DescribeDBSnapshots.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - ID of instance to retrieve information for. if absent information for all instances is returned
+        # * DBSnapshotIdentifier <~String> - ID of snapshot to retrieve information for. if absent information for all snapshots is returned
+        # * Marker               <~String> - An optional marker provided in the previous DescribeDBInstances request
+        # * MaxRecords           <~Integer> - Max number of records to return (between 20 and 100) 
+        # Only one of DBInstanceIdentifier or DBSnapshotIdentifier can be specified
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def describe_db_snapshots(opts={})
+          params = {}
+          params['DBInstanceIdentifier'] = opts[:identifier] if opts[:identifier]
+          params['DBSnapshotIdentifier'] = opts[:snapshot_id] if opts[:snapshot_id]
+          params['Marker'] = opts[:marker] if opts[:marker]
+          params['MaxRecords'] = opts[:max_records] if opts[:max_records]
+          request({
+            'Action'  => 'DescribeDBSnapshots',
+            :parser   => Fog::Parsers::AWS::RDS::DescribeDBSnapshots.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_db_snapshots(opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_instance.rb
new file mode 100644
index 0000000..084e648
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_instance.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/modify_db_instance'
+
+        # modifies a database instance
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - name of the db instance to modify
+        # * ApplyImmediately <~Boolean> - whether to apply the changes immediately or wait for the next maintenance window
+        #                                     
+        # * AllocatedStorage  <~Integer> Storage space, in GB
+        # * AllowMajorVersionUpgrade <~Boolean> Must be set to true if EngineVersion specifies a different major version  
+        # * AutoMinorVersionUpgrade <~Boolean> Indicates that minor version upgrades will be applied automatically to the DB Instance during the maintenance window 
+        # * BackupRetentionPeriod  <~Integer> 0-8 The number of days to retain automated backups.
+        # * DBInstanceClass <~String> The new compute and memory capacity of the DB Instanc 
+        # * DBParameterGroupName <~String> The name of the DB Parameter Group to apply to this DB Instance  
+        # * DBSecurityGroups <~Array> A list of DB Security Groups to authorize on this DB Instance 
+        # * EngineVersion <~String> The version number of the database engine to upgrade to.
+        # * MasterUserPassword  <~String> The new password for the DB Instance master user
+        # * MultiAZ <~Boolean> Specifies if the DB Instance is a Multi-AZ deployment
+        # * PreferredBackupWindow <~String> The daily time range during which automated backups are created if automated backups are enabled
+        # * PreferredMaintenanceWindow <~String> The weekly time range (in UTC) during which system maintenance can occur, which may result in an outage
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def modify_db_instance(db_name, apply_immediately, options={})
+          
+          if security_groups = options.delete('DBSecurityGroups')
+            options.merge!(AWS.indexed_param('DBSecurityGroups.member.%d', [*security_groups]))
+          end
+    
+          request({
+            'Action'  => 'ModifyDBInstance',
+            'DBInstanceIdentifier' => db_name,
+            'ApplyImmediately' => apply_immediately,
+            :parser   => Fog::Parsers::AWS::RDS::ModifyDBInstance.new,
+          }.merge(options))
+        end
+
+      end
+
+      class Mock
+
+        def modify_db_instance(db_name, apply_immediately, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_parameter_group.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_parameter_group.rb
new file mode 100644
index 0000000..7cb0015
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/modify_db_parameter_group.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/modify_db_parameter_group'
+
+        # modifies a database parameter group
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_ModifyDBParameterGroup.html
+        # ==== Parameters
+        # * DBParameterGroupName <~String> - name of the parameter group
+        # * Parameters<~Array> - Array of up to 20 Hashes describing parameters to set
+        #   * 'ParameterName'<~String> - parameter name.
+        #   * 'ParameterValue'<~String> - new paremeter value
+        #   * 'ApplyMethod'<~String> - immediate | pending-reboot whether to set the parameter immediately or not (may require an instance restart)
+        #                                     
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def modify_db_parameter_group(group_name, parameters)
+          
+          parameter_names = []
+          parameter_values = []
+          parameter_apply_methods = []
+          
+          parameters.each do |parameter|
+            parameter_names.push(parameter['ParameterName'])
+            parameter_values.push(parameter['ParameterValue'])
+            parameter_apply_methods.push(parameter['ApplyMethod'])
+          end
+          params = {}
+          params.merge!(AWS.indexed_param('Parameters.member.%d.ParameterName', parameter_names))
+          params.merge!(AWS.indexed_param('Parameters.member.%d.ParameterValue', parameter_values))
+          params.merge!(AWS.indexed_param('Parameters.member.%d.ApplyMethod', parameter_apply_methods))
+          
+          request({
+            'Action'  => 'ModifyDBParameterGroup',
+            'DBParameterGroupName' => group_name,
+            
+            :parser   => Fog::Parsers::AWS::RDS::ModifyDbParameterGroup.new
+          }.merge(params))
+        end
+
+      end
+
+      class Mock
+
+        def modify_db_parameter_group(group_name, parameters)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/reboot_db_instance.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/reboot_db_instance.rb
new file mode 100644
index 0000000..7d54b70
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/reboot_db_instance.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/reboot_db_instance'
+
+        # reboots a database instance
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/API_RebootDBInstance.html
+        # ==== Parameters
+        # * DBInstanceIdentifier <~String> - name of the db instance to reboot
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def reboot_db_instance(instance_identifier)
+          request({
+            'Action'  => 'RebootDBInstance',
+            'DBInstanceIdentifier' => instance_identifier,
+            :parser   => Fog::Parsers::AWS::RDS::RebootDBInstance.new,
+          })
+        end
+
+      end
+
+      class Mock
+
+        def reboot_db_instance(instance_identifier)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_from_db_snapshot.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_from_db_snapshot.rb
new file mode 100644
index 0000000..87e0fce
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_from_db_snapshot.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/restore_db_instance_from_db_snapshot'
+
+        # Restores a DB Instance from a DB Snapshot
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_RestoreDBInstanceFromDBSnapshot.html
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def restore_db_instance_from_db_snapshot(snapshot_id, db_name, opts={})
+          request({
+            'Action'  => 'RestoreDBInstanceFromDBSnapshot',
+            'DBSnapshotIdentifier' => snapshot_id,
+            'DBInstanceIdentifier' => db_name,
+            :parser   => Fog::Parsers::AWS::RDS::RestoreDBInstanceFromDBSnapshot.new,
+          }.merge(opts))
+        end
+
+      end
+
+      class Mock
+
+        def restore_db_instance_from_db_snapshot(snapshot_id, db_id, options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_to_point_in_time.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_to_point_in_time.rb
new file mode 100644
index 0000000..a1a598f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/restore_db_instance_to_point_in_time.rb
@@ -0,0 +1,35 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/restore_db_instance_to_point_in_time'
+
+        # Restores a DB Instance to a point in time
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_RestoreDBInstanceToPointInTime.html
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def restore_db_instance_to_point_in_time(source_db_name, target_db_name, opts={})
+          request({
+            'Action'  => 'RestoreDBInstanceToPointInTime',
+            'SourceDBInstanceIdentifier' => source_db_name,
+            'TargetDBInstanceIdentifier' => target_db_name,
+            :parser   => Fog::Parsers::AWS::RDS::RestoreDBInstanceToPointInTime.new,
+          }.merge(opts))
+        end
+
+      end
+
+      class Mock
+
+        def restore_db_instance_to_point_in_time(source_db_name, target_db_name, opts={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/rds/revoke_db_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/revoke_db_security_group_ingress.rb
new file mode 100644
index 0000000..e528fb2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/rds/revoke_db_security_group_ingress.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class RDS
+      class Real
+
+        require 'fog/aws/parsers/rds/revoke_db_security_group_ingress'
+
+        # revokes a db security group ingress
+        # http://docs.amazonwebservices.com/AmazonRDS/latest/APIReference/index.html?API_RevokeDBSecurityGroupIngress.html
+        # ==== Parameters
+        # * CIDRIP <~String> - The IP range to revoke
+        # * DBSecurityGroupName <~String> - The name for the DB Security Group.
+        # * EC2SecurityGroupName <~String> - Name of the EC2 Security Group to revoke.
+        # * EC2SecurityGroupOwnerId <~String> - AWS Account Number of the owner of the security group specified in the EC2SecurityGroupName parameter. The AWS Access Key ID is not an acceptable value.
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        def revoke_db_security_group_ingress(name, opts={})
+          unless opts.key?('CIDRIP') || (opts.key?('EC2SecurityGroupName') && opts.key?('EC2SecurityGroupOwnerId'))
+            raise ArgumentError, 'Must specify CIDRIP, or both EC2SecurityGroupName and EC2SecurityGroupOwnerId'
+          end
+
+          request({
+            'Action'  => 'RevokeDBSecurityGroupIngress',
+            :parser   => Fog::Parsers::AWS::RDS::RevokeDBSecurityGroupIngress.new,
+            'DBSecurityGroupName' => name
+          }.merge(opts))
+
+        end
+
+      end
+
+      class Mock
+
+        def revoke_db_security_group_ingress(name, opts = {})
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
+
+
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/delete_verified_email_address.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/delete_verified_email_address.rb
new file mode 100644
index 0000000..7017e3e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/delete_verified_email_address.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/delete_verified_email_address'
+
+        # Delete an existing verified email address
+        #
+        # ==== Parameters
+        # * email_address<~String> - Email Address to be removed
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def delete_verified_email_address(email_address)
+          request({
+            'Action'           => 'DeleteVerifiedEmailAddress',
+            'EmailAddress'     => email_address,
+            :parser            => Fog::Parsers::AWS::SES::DeleteVerifiedEmailAddress.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_quota.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_quota.rb
new file mode 100644
index 0000000..fc9a0a8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_quota.rb
@@ -0,0 +1,31 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/get_send_quota'
+
+        # Returns the user's current activity limits.
+        #
+        # ==== Parameters
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'GetSendQuotaResult'<~Hash>
+        #       * 'Max24HourSend' <~String>
+        #       * 'MaxSendRate' <~String>
+        #       * 'SentLast24Hours' <~String>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def get_send_quota
+          request({
+            'Action' => 'GetSendQuota',
+            :parser  => Fog::Parsers::AWS::SES::GetSendQuota.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_statistics.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_statistics.rb
new file mode 100644
index 0000000..a197ff3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/get_send_statistics.rb
@@ -0,0 +1,34 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/get_send_statistics'
+
+        # Returns the user's current activity limits.
+        #
+        # ==== Parameters
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'GetSendStatisticsResult'<~Hash>
+        #       * 'SendDataPoints' <~Array>
+        #         * 'Bounces' <~String>
+        #         * 'Complaints' <~String>
+        #         * 'DeliveryAttempts' <~String>
+        #         * 'Rejects' <~String>
+        #         * 'Timestamp' <~String>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def get_send_statistics
+          request({
+            'Action' => 'GetSendStatistics',
+            :parser  => Fog::Parsers::AWS::SES::GetSendStatistics.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/list_verified_email_addresses.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/list_verified_email_addresses.rb
new file mode 100644
index 0000000..ff90814
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/list_verified_email_addresses.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/list_verified_email_addresses'
+
+        # Returns a list containing all of the email addresses that have been verified
+        #
+        # ==== Parameters
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'VerifiedEmailAddresses' <~Array>
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def list_verified_email_addresses
+          request({
+            'Action' => 'ListVerifiedEmailAddresses',
+            :parser  => Fog::Parsers::AWS::SES::ListVerifiedEmailAddresses.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_email.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_email.rb
new file mode 100644
index 0000000..a3e39ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_email.rb
@@ -0,0 +1,73 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/send_email'
+
+        # Send an email
+        #
+        # ==== Parameters
+        # * Source <~String> - The sender's email address
+        # * Destination <~Hash> - The destination for this email, composed of To:, From:, and CC: fields.
+        #   * BccAddresses <~Array> - The BCC: field(s) of the message.
+        #   * CcAddresses <~Array> - The CC: field(s) of the message.
+        #   * ToAddresses <~Array> - The To: field(s) of the message.
+        # * Message <~Hash> - The message to be sent.
+        #   * Body <~Hash>
+        #     * Html <~Hash>
+        #       * Charset <~String>
+        #       * Data <~String>
+        #     * Text <~Hash>
+        #       * Charset <~String>
+        #       * Data <~String>
+        #   * Subject <~Hash>
+        #     * Charset <~String>
+        #     * Data <~String>
+        # * options <~Hash>:
+        #   * ReplyToAddresses <~Array> - The reply-to email address(es) for the message. If the recipient replies to the message, each reply-to address will receive the reply.
+        #   * ReturnPath <~String> - The email address to which bounce notifications are to be forwarded. If the message cannot be delivered to the recipient, then an error message will be returned from the recipient's ISP; this message will then be forwarded to the email address specified by the ReturnPath parameter.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'MessageId'<~String> - Id of message
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def send_email(source, destination, message, options = {})
+          params = {
+            'Source' => source
+          }
+
+          for key, values in destination
+            params.merge!(AWS.indexed_param("Destination.#{key}.member", [*values]))
+          end
+
+          for key, value in message['Subject']
+            params["Message.Subject.#{key}"] = value
+          end
+
+          for type, data in message['Body']
+            for key, value in data
+              params["Message.Body.#{type}.#{key}"] = value
+            end
+          end
+
+          if options.has_key?('ReplyToAddresses')
+            params.merge!(AWS.indexed_param("ReplyToAddresses.member", [*options['ReplyToAddresses']]))
+          end
+
+          if options.has_key?('ReturnPath')
+            params['ReturnPath'] = options['ReturnPath']
+          end
+
+          request({
+            'Action'           => 'SendEmail',
+            :parser            => Fog::Parsers::AWS::SES::SendEmail.new
+          }.merge(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_raw_email.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_raw_email.rb
new file mode 100644
index 0000000..34f6457
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/send_raw_email.rb
@@ -0,0 +1,41 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/send_raw_email'
+
+        # Send a raw email
+        #
+        # ==== Parameters
+        # * RawMessage <~String> - The message to be sent.
+        # * Options <~Hash>
+        #   * Source <~String> - The sender's email address. Takes precenence over Return-Path if specified in RawMessage
+        #   * Destinations <~Array> - All destinations for this email.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'MessageId'<~String> - Id of message
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def send_raw_email(raw_message, options = {})
+          params = {}
+          if options.has_key?('Destinations')
+            params.merge!(AWS.indexed_param('Destinations.member', [*options['Destinations']]))
+          end
+          if options.has_key?('Source')
+            params['Source'] = options['Source']
+          end
+
+          request({
+            'Action'          => 'SendRawEmail',
+            'RawMessage.Data' => Base64.encode64(raw_message).chomp!,
+            :parser           => Fog::Parsers::AWS::SES::SendRawEmail.new
+          }.merge(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/ses/verify_email_address.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/verify_email_address.rb
new file mode 100644
index 0000000..8f37f76
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/ses/verify_email_address.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class SES
+      class Real
+
+        require 'fog/aws/parsers/ses/verify_email_address'
+
+        # Verifies an email address. This action causes a confirmation email message to be sent to the specified address.
+        #
+        # ==== Parameters
+        # * email_address<~String> - The email address to be verified
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResponseMetadata'<~Hash>:
+        #       * 'RequestId'<~String> - Id of request
+        def verify_email_address(email_address)
+          request({
+            'Action'           => 'VerifyEmailAddress',
+            'EmailAddress'     => email_address,
+            :parser            => Fog::Parsers::AWS::SES::VerifyEmailAddress.new
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/batch_put_attributes.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
new file mode 100644
index 0000000..6af0828
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/batch_put_attributes.rb
@@ -0,0 +1,64 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put items attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * items<~Hash> - Keys are the items names and may use any UTF-8
+        #   characters valid in xml.  Control characters and sequences not allowed
+        #   in xml are not valid.  Can be up to 1024 bytes long.  Values are the
+        #   attributes to add to the given item and may use any UTF-8 characters
+        #   valid in xml. Control characters and sequences not allowed in xml are
+        #   not valid.  Each name and value can be up to 1024 bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          request({
+            'Action'      => 'BatchPutAttributes',
+            'DomainName'  => domain_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_batch_attributes(items, replace_attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def batch_put_attributes(domain_name, items, replace_attributes = Hash.new([]))
+          response = Excon::Response.new
+          if self.data[:domains][domain_name]
+            for item_name, attributes in items do
+              for key, value in attributes do
+                self.data[:domains][domain_name][item_name] ||= {}
+                if replace_attributes[item_name] && replace_attributes[item_name].include?(key)
+                  self.data[:domains][domain_name][item_name][key.to_s] = []
+                else
+                  self.data[:domains][domain_name][item_name][key.to_s] ||= []
+                end
+                self.data[:domains][domain_name][item_name][key.to_s] << value.to_s
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/create_domain.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/create_domain.rb
new file mode 100644
index 0000000..6101dda
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/create_domain.rb
@@ -0,0 +1,44 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Create a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def create_domain(domain_name)
+          request(
+            'Action'      => 'CreateDomain',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_domain(domain_name)
+          response = Excon::Response.new
+          self.data[:domains][domain_name] = {}
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_attributes.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_attributes.rb
new file mode 100644
index 0000000..7aa8696
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_attributes.rb
@@ -0,0 +1,63 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to remove from the item.  Defaults to
+        #   nil, which will delete the entire item. Attribute names and values may
+        #   use any UTF-8 characters valid in xml. Control characters and sequences
+        #   not allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          request({
+            'Action'      => 'DeleteAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_attributes(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def delete_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if self.data[:domains][domain_name]
+            if attributes
+              for key, value in attributes
+                if self.data[:domains][domain_name][key]
+                  self.data[:domains][domain_name][key].delete('value')
+                end
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_domain.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_domain.rb
new file mode 100644
index 0000000..6282199
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/delete_domain.rb
@@ -0,0 +1,45 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Delete a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String>:: Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # 
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def delete_domain(domain_name)
+          request(
+            'Action'      => 'DeleteDomain',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_domain(domain_name)
+          response = Excon::Response.new
+          if self.data[:domains].delete(domain_name)
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/domain_metadata.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/domain_metadata.rb
new file mode 100644
index 0000000..213856b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/domain_metadata.rb
@@ -0,0 +1,76 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/domain_metadata'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AttributeNameCount' - number of unique attribute names in domain
+        #     * 'AttributeNamesSizeBytes' - total size of unique attribute names, in bytes
+        #     * 'AttributeValueCount' - number of all name/value pairs in domain
+        #     * 'AttributeValuesSizeBytes' - total size of attributes, in bytes
+        #     * 'BoxUsage'
+        #     * 'ItemCount' - number of items in domain
+        #     * 'ItemNameSizeBytes' - total size of item names in domain, in bytes
+        #     * 'RequestId'
+        #     * 'Timestamp' - last update time for metadata.
+        def domain_metadata(domain_name)
+          request(
+            'Action'      => 'DomainMetadata',
+            'DomainName'  => domain_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::DomainMetadata.new(@nil_string)
+          )
+        end
+
+      end
+
+      class Mock
+
+        def domain_metadata(domain_name)
+          response = Excon::Response.new
+          if domain = self.data[:domains][domain_name]
+            response.status = 200
+          
+            attribute_names = []
+            attribute_values = []
+            for item in domain.values
+              for key, values in item
+                attribute_names << key
+                for value in values
+                  attribute_values << value
+                end
+              end
+            end
+          
+            response.body = {
+              'AttributeNameCount'        => attribute_names.length,
+              'AttributeNamesSizeBytes'   => attribute_names.join('').length,
+              'AttributeValueCount'       => attribute_values.length,
+              'AttributeValuesSizeBytes'  => attribute_values.join('').length,
+              'BoxUsage'                  => Fog::AWS::Mock.box_usage,
+              'ItemCount'                 => domain.keys.length,
+              'ItemNamesSizeBytes'        => domain.keys.join('').length,
+              'RequestId'                 => Fog::AWS::Mock.request_id,
+              'Timestamp'                 => Time.now
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/get_attributes.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/get_attributes.rb
new file mode 100644
index 0000000..89a99a4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/get_attributes.rb
@@ -0,0 +1,72 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/get_attributes'
+
+        # List metadata for SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        #   following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Array> - Attributes to return from the item.  Defaults to
+        #   {}, which will return all attributes. Attribute names and values may use
+        #   any UTF-8 characters valid in xml. Control characters and sequences not 
+        #   allowed in xml are not valid.  Each name and value can be up to 1024
+        #   bytes long.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Attributes' - list of attribute name/values for the item
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def get_attributes(domain_name, item_name, attributes = {})
+          
+          request({
+            'Action'      => 'GetAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::SimpleDB::GetAttributes.new(@nil_string)
+          }.merge!(encode_attribute_names(attributes)))
+        end
+
+      end
+
+      class Mock
+
+        def get_attributes(domain_name, item_name, attributes = nil)
+          response = Excon::Response.new
+          if self.data[:domains][domain_name]
+            object = {}
+            if attributes
+              for attribute in attributes
+                if self.data[:domains][domain_name][item_name] && self.data[:domains][domain_name][item_name]
+                  object[attribute] = self.data[:domains][domain_name][item_name][attribute]
+                end
+              end
+            elsif self.data[:domains][domain_name][item_name]
+              object = self.data[:domains][domain_name][item_name]
+            end
+            response.status = 200
+            response.body = {
+              'Attributes'  => object,
+              'BoxUsage'    => Fog::AWS::Mock.box_usage,
+              'RequestId'   => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/list_domains.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/list_domains.rb
new file mode 100644
index 0000000..c76829e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/list_domains.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/list_domains'
+
+        # List SimpleDB domains
+        #
+        # ==== Parameters
+        # * options<~Hash> - options, defaults to {}
+        #   * 'MaxNumberOfDomains'<~Integer> - number of domains to return
+        #     between 1 and 100, defaults to 100
+        #   * 'NextToken'<~String> - Offset token to start listing, defaults to nil
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'Domains' - array of domain names.
+        #     * 'NextToken' - offset to start with if there are are more domains to list
+        #     * 'RequestId'
+        def list_domains(options = {})
+          request({
+            'Action'    => 'ListDomains',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::SimpleDB::ListDomains.new(@nil_string)
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def list_domains(options = {})
+          response = Excon::Response.new
+          keys = self.data[:domains].keys
+          max = options['MaxNumberOfDomains'] || keys.size
+          offset = options['NextToken'] || 0
+          domains = []
+          for key, value in self.data[:domains].keys[offset...max]
+            domains << key
+          end
+          response.status = 200
+          response.body = {
+            'BoxUsage'  => Fog::AWS::Mock.box_usage,
+            'Domains'   => domains,
+            'RequestId' => Fog::AWS::Mock.request_id
+          }
+          if max < keys.size
+            response.body['NextToken'] = max + 1
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/put_attributes.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/put_attributes.rb
new file mode 100644
index 0000000..c891100
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/put_attributes.rb
@@ -0,0 +1,78 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        # Put item attributes into a SimpleDB domain
+        #
+        # ==== Parameters
+        # * domain_name<~String> - Name of domain. Must be between 3 and 255 of the
+        # following characters: a-z, A-Z, 0-9, '_', '-' and '.'.
+        # * item_name<~String> - Name of the item.  May use any UTF-8 characters valid
+        #   in xml.  Control characters and sequences not allowed in xml are not
+        #   valid.  Can be up to 1024 bytes long.
+        # * attributes<~Hash> - Name/value pairs to add to the item.  Attribute names
+        #   and values may use any UTF-8 characters valid in xml. Control characters
+        #   and sequences not allowed in xml are not valid.  Each name and value can
+        #   be up to 1024 bytes long.
+        # * options<~Hash> - Accepts the following keys.
+        #   :replace => [Array of keys to replace]
+        #   :expect => {name/value pairs for performing conditional put}
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'
+        #     * 'RequestId'
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          request({
+            'Action'      => 'PutAttributes',
+            'DomainName'  => domain_name,
+            'ItemName'    => item_name,
+            :parser       => Fog::Parsers::AWS::SimpleDB::Basic.new(@nil_string)
+          }.merge!(encode_attributes(attributes, options[:replace], options[:expect])))
+        end
+
+      end
+
+      class Mock
+
+        def put_attributes(domain_name, item_name, attributes, options = {})
+          options[:expect] = {} unless options[:expect]
+          options[:replace] = [] unless options[:replace]
+          response = Excon::Response.new
+          if self.data[:domains][domain_name]
+            options[:expect].each do |ck, cv|
+              if self.data[:domains][domain_name][item_name][ck] != [cv]
+                response.status = 409
+                raise(Excon::Errors.status_error({:expects => 200}, response))
+              end
+            end
+            attributes.each do |key, value|
+              self.data[:domains][domain_name][item_name] ||= {}
+              self.data[:domains][domain_name][item_name][key.to_s] = [] unless self.data[:domains][domain_name][item_name][key.to_s]
+              if options[:replace].include?(key.to_s)
+                self.data[:domains][domain_name][item_name][key.to_s] = [*value].map {|x| x.to_s}
+              else
+                self.data[:domains][domain_name][item_name][key.to_s] += [*value].map {|x| x.to_s}
+              end
+            end
+            response.status = 200
+            response.body = {
+              'BoxUsage'  => Fog::AWS::Mock.box_usage,
+              'RequestId' => Fog::AWS::Mock.request_id
+            }
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/select.rb b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/select.rb
new file mode 100644
index 0000000..37cfe24
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/requests/simpledb/select.rb
@@ -0,0 +1,35 @@
+module Fog
+  module AWS
+    class SimpleDB
+      class Real
+
+        require 'fog/aws/parsers/simpledb/select'
+
+        # Select item data from SimpleDB
+        #
+        # ==== Parameters
+        # * select_expression<~String> - Expression to query domain with.
+        # * next_token<~String> - Offset token to start list, defaults to nil.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BoxUsage'<~Float>
+        #     * 'RequestId'<~String>
+        #     * 'Items'<~Hash> - list of attribute name/values for the items formatted as 
+        #       { 'item_name' => { 'attribute_name' => ['attribute_value'] }}
+        #     * 'NextToken'<~String> - offset to start with if there are are more domains to list
+        def select(select_expression, next_token = nil)
+          request(
+            'Action'            => 'Select',
+            'NextToken'         => next_token,
+            'SelectExpression'  => select_expression,
+            :idempotent         => true,
+            :parser             => Fog::Parsers::AWS::SimpleDB::Select.new(@nil_string)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/ses.rb b/vendor/fog-0.8.2/lib/fog/aws/ses.rb
new file mode 100644
index 0000000..3f8f8dc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/ses.rb
@@ -0,0 +1,109 @@
+module Fog
+  module AWS
+    class SES < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :region, :host, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/ses'
+      request :delete_verified_email_address
+      request :verify_email_address
+      request :get_send_quota
+      request :get_send_statistics
+      request :list_verified_email_addresses
+      request :send_email
+      request :send_raw_email
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to SES
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   ses = SES.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in ['eu-west-1', 'us-east-1', 'us-west-1'i, 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * SES object with connection to AWS.
+        def initialize(options={})
+          require 'fog/core/parser'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'us-east-1'
+            'email.us-east-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          headers = {
+            'Content-Type'  => 'application/x-www-form-urlencoded',
+            'Date'          => Fog::Time.now.to_date_header
+          }
+
+          #AWS3-HTTPS AWSAccessKeyId=<Your AWS Access Key ID>, Algorithm=HmacSHA256, Signature=<Signature>
+          headers['X-Amzn-Authorization'] = 'AWS3-HTTPS '
+          headers['X-Amzn-Authorization'] << 'AWSAccessKeyId=' << @aws_access_key_id
+          headers['X-Amzn-Authorization'] << ', Algorithm=HmacSHA256'
+          headers['X-Amzn-Authorization'] << ', Signature=' << Base64.encode64(@hmac.sign(headers['Date'])).chomp!
+
+          body = ''
+          for key in params.keys.sort
+            unless (value = params[key]).nil?
+              body << "#{key}=#{CGI.escape(value.to_s).gsub(/\+/, '%20')}&"
+            end
+          end
+          body.chop! # remove trailing '&'
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => headers,
+            :idempotent => idempotent,
+            :host       => @host,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/aws/simpledb.rb b/vendor/fog-0.8.2/lib/fog/aws/simpledb.rb
new file mode 100644
index 0000000..ce5bc88
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/aws/simpledb.rb
@@ -0,0 +1,194 @@
+module Fog
+  module AWS
+    class SimpleDB < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :nil_string, :path, :port, :scheme, :persistent
+
+      request_path 'fog/aws/requests/simpledb'
+      request :batch_put_attributes
+      request :create_domain
+      request :delete_attributes
+      request :delete_domain
+      request :domain_metadata
+      request :get_attributes
+      request :list_domains
+      request :put_attributes
+      request :select
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :domains => {}
+            }
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          @aws_access_key_id = options[:aws_access_key_id]
+        end
+
+        def data
+          self.class.data[@aws_access_key_id]
+        end
+
+        def reset_data
+          self.class.data.delete(@aws_access_key_id)
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to SimpleDB
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * SimpleDB object with connection to aws.
+        def initialize(options={})
+          require 'fog/core/parser'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac       = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @nil_string = options[:nil_string]|| 'nil'
+
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-northeast-1'
+            'sdb.ap-northeast-1.amazonaws.com'
+          when 'ap-southeast-1'
+            'sdb.ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            'sdb.eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            'sdb.amazonaws.com'
+          when 'us-west-1'
+            'sdb.us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @path       = options[:path]      || '/'
+          @port       = options[:port]      || 443
+          @scheme     = options[:scheme]    || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        private
+
+        def encode_attributes(attributes, replace_attributes = [], expected_attributes = {})
+          encoded_attributes = {}
+          if attributes
+
+            expected_attributes.keys.each_with_index do |exkey, index|
+              for value in Array(expected_attributes[exkey])
+                encoded_attributes["Expected.#{index}.Name"] = exkey.to_s
+                encoded_attributes["Expected.#{index}.Value"] = sdb_encode(value)
+              end
+            end
+
+            index = 0
+            for key in attributes.keys
+              for value in Array(attributes[key])
+                encoded_attributes["Attribute.#{index}.Name"] = key.to_s
+                if replace_attributes.include?(key)
+                  encoded_attributes["Attribute.#{index}.Replace"] = 'true'
+                end
+                encoded_attributes["Attribute.#{index}.Value"] = sdb_encode(value)
+                index += 1
+              end
+            end
+          end
+          encoded_attributes
+        end
+
+        def encode_attribute_names(attributes)
+          AWS.indexed_param('AttributeName', attributes.map {|attribute| attributes.to_s})
+        end
+
+        def encode_batch_attributes(items, replace_attributes = Hash.new([]))
+          encoded_attributes = {}
+          if items
+            item_index = 0
+            for item_key in items.keys
+              encoded_attributes["Item.#{item_index}.ItemName"] = item_key.to_s
+              attribute_index = 0
+              for attribute_key in items[item_key].keys
+                for value in Array(items[item_key][attribute_key])
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Name"] = attribute_key.to_s
+                  if replace_attributes[item_key].include?(attribute_key)
+                    encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Replace"] = 'true'
+                  end
+                  encoded_attributes["Item.#{item_index}.Attribute.#{attribute_index}.Value"] = sdb_encode(value)
+                  attribute_index += 1
+                end
+              end
+              item_index += 1
+            end
+          end
+          encoded_attributes
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          idempotent = params.delete(:idempotent)
+          parser = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2009-04-15'
+            }
+          )
+
+          response = @connection.request({
+            :body       => body,
+            :expects    => 200,
+            :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded; charset=utf-8' },
+            :host       => @host,
+            :idempotent => idempotent,
+            :method     => 'POST',
+            :parser     => parser
+          })
+
+          response
+        end
+
+        def sdb_encode(value)
+          if value.nil?
+            @nil_string
+          else
+            value.to_s
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin.rb b/vendor/fog-0.8.2/lib/fog/bin.rb
new file mode 100644
index 0000000..22ba042
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin.rb
@@ -0,0 +1,72 @@
+require 'fog/core/credentials'
+
+module Fog
+  class << self
+
+    def available_providers
+      @providers.select {|provider| Kernel.const_get(provider).available?}
+    end
+
+  end
+
+  class Bin
+    class << self
+
+      def available?
+        availability = true
+        for service in services
+          begin
+            service = self.class_for(service)
+            availability &&= service.requirements.all? { |requirement| Fog.credentials.include?(requirement) }
+          rescue ArgumentError => e
+            warning = "[yellow][WARN] #{e.message}[/]"
+            Formatador.display_line(warning)
+            availability = false
+          rescue => e
+            availability = false
+          end
+        end
+
+        if availability
+          for service in services
+            for collection in self.class_for(service).collections
+              unless self.respond_to?(collection)
+                self.class_eval <<-EOS, __FILE__, __LINE__
+                  def self.#{collection}
+                    self[:#{service}].#{collection}
+                  end
+                EOS
+              end
+            end
+          end
+        end
+
+        availability
+      end
+
+      def collections
+        services.map {|service| self[service].collections}.flatten.sort_by {|service| service.to_s}
+      end
+
+    end
+  end
+
+end
+
+require 'fog/bin/aws'
+require 'fog/bin/bluebox'
+require 'fog/bin/brightbox'
+require 'fog/bin/dnsimple'
+require 'fog/bin/ecloud'
+require 'fog/bin/go_grid'
+require 'fog/bin/google'
+require 'fog/bin/linode'
+require 'fog/bin/local'
+require 'fog/bin/new_servers'
+require 'fog/bin/rackspace'
+require 'fog/bin/slicehost'
+require 'fog/bin/stormondemand'
+require 'fog/bin/terremark'
+require 'fog/bin/virtual_box'
+require 'fog/bin/voxel'
+require 'fog/bin/zerigo'
diff --git a/vendor/fog-0.8.2/lib/fog/bin/aws.rb b/vendor/fog-0.8.2/lib/fog/bin/aws.rb
new file mode 100644
index 0000000..ad81b34
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/aws.rb
@@ -0,0 +1,71 @@
+class AWS < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :cdn
+        Fog::AWS::CDN
+      when :cloud_formation
+        Fog::AWS::CloudFormation
+      when :compute
+        Fog::AWS::Compute
+      when :dns
+        Fog::AWS::DNS
+      when :elb
+        Fog::AWS::ELB
+      when :iam
+        Fog::AWS::IAM
+      when :sdb, :simpledb
+        Fog::AWS::SimpleDB
+      when :ses
+        Fog::AWS::SES
+      when :eu_storage, :storage
+        Fog::AWS::Storage
+      when :rds
+        Fog::AWS::RDS
+      else
+        # @todo Replace most instances of ArgumentError with NotImplementedError
+        # @todo For a list of widely supported Exceptions, see:
+        # => http://www.zenspider.com/Languages/Ruby/QuickRef.html#35
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :cdn
+          Fog::CDN.new(:provider => 'AWS')
+        when :cloud_formation
+          Fog::AWS::CloudFormation.new
+        when :compute
+          Fog::Compute.new(:provider => 'AWS')
+        when :dns
+          Fog::DNS.new(:provider => 'AWS')
+        when :elb
+          Fog::AWS::ELB.new
+        when :iam
+          Fog::AWS::IAM.new
+        when :rds
+          Fog::AWS::RDS.new
+        when :eu_storage
+          Fog::Storage.new(:provider => 'AWS', :region => 'eu-west-1')
+        when :sdb, :simpledb
+          Fog::AWS::SimpleDB.new
+        when :ses
+          Fog::AWS::SES.new
+        when :storage
+          Fog::Storage.new(:provider => 'AWS')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::AWS.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/bluebox.rb b/vendor/fog-0.8.2/lib/fog/bin/bluebox.rb
new file mode 100644
index 0000000..ab37c62
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/bluebox.rb
@@ -0,0 +1,34 @@
+class Bluebox < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Bluebox::Compute
+      when :dns
+        Fog::Bluebox::DNS
+      else
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Bluebox')
+        when :dns
+          Fog::DNS.new(:provider => 'Bluebox')
+        else
+          raise ArgumentError, "Unrecognized service: #{service}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Bluebox.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/brightbox.rb b/vendor/fog-0.8.2/lib/fog/bin/brightbox.rb
new file mode 100644
index 0000000..64c2972
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/brightbox.rb
@@ -0,0 +1,34 @@
+class Brightbox < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Brightbox::Compute
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Brightbox')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def account
+      @@connections[:compute].account
+    end
+
+    def services
+      Fog::Brightbox.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/dnsimple.rb b/vendor/fog-0.8.2/lib/fog/bin/dnsimple.rb
new file mode 100644
index 0000000..1032996
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/dnsimple.rb
@@ -0,0 +1,30 @@
+class DNSimple < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :dns
+        Fog::DNSimple::DNS
+      else
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+                    when :dns
+                      Fog::DNS.new(:provider => 'DNSimple')
+                    else
+                      raise ArgumentError, "Unrecognized service: #{key.inspect}"
+                    end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::DNSimple.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/ecloud.rb b/vendor/fog-0.8.2/lib/fog/bin/ecloud.rb
new file mode 100644
index 0000000..31bd993
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/ecloud.rb
@@ -0,0 +1,30 @@
+class Ecloud < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Ecloud::Compute
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Ecloud')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Ecloud.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/go_grid.rb b/vendor/fog-0.8.2/lib/fog/bin/go_grid.rb
new file mode 100644
index 0000000..e936c6f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/go_grid.rb
@@ -0,0 +1,30 @@
+class GoGrid < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::GoGrid::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'GoGrid')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::GoGrid.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/google.rb b/vendor/fog-0.8.2/lib/fog/bin/google.rb
new file mode 100644
index 0000000..cb2f274
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/google.rb
@@ -0,0 +1,30 @@
+class Google < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :storage
+        Fog::Google::Storage
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :storage
+          Fog::Storage.new(:provider => 'Google')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Google.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/linode.rb b/vendor/fog-0.8.2/lib/fog/bin/linode.rb
new file mode 100644
index 0000000..d55156b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/linode.rb
@@ -0,0 +1,34 @@
+class Linode < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Linode::Compute
+      when :dns
+        Fog::Linode::DNS
+      else
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Linode')
+        when :dns
+          Fog::DNS.new(:provider => 'Linode')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Linode.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/local.rb b/vendor/fog-0.8.2/lib/fog/bin/local.rb
new file mode 100644
index 0000000..58ff77d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/local.rb
@@ -0,0 +1,30 @@
+class Local < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :storage
+        Fog::Local::Storage
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :storage
+          Fog::Storage.new(:provider => 'Local')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Local.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/new_servers.rb b/vendor/fog-0.8.2/lib/fog/bin/new_servers.rb
new file mode 100644
index 0000000..1b897fa
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/new_servers.rb
@@ -0,0 +1,30 @@
+class NewServers < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::NewServers::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'NewServers')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::NewServers.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/rackspace.rb b/vendor/fog-0.8.2/lib/fog/bin/rackspace.rb
new file mode 100644
index 0000000..68f20d7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/rackspace.rb
@@ -0,0 +1,40 @@
+class Rackspace < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :cdn
+        Fog::Rackspace::CDN
+      when :compute
+        Fog::Rackspace::Compute
+      when :storage
+        Fog::Rackspace::Storage
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :cdn
+          Fog::CDN.new(:provider => 'Rackspace')
+        when :compute
+          Fog::Compute.new(:provider => 'Rackspace')
+        when :dns
+          Fog::DNS.new(:provider => 'Rackspace')
+        when :storage
+          Fog::Storage.new(:provider => 'Rackspace')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Rackspace.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/slicehost.rb b/vendor/fog-0.8.2/lib/fog/bin/slicehost.rb
new file mode 100644
index 0000000..39fc809
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/slicehost.rb
@@ -0,0 +1,34 @@
+class Slicehost < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Slicehost::Compute
+      when :dns
+        Fog::Slicehost::DNS
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Slicehost')
+        when :dns
+          Fog::DNS.new(:provider => 'Slicehost')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Slicehost.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/stormondemand.rb b/vendor/fog-0.8.2/lib/fog/bin/stormondemand.rb
new file mode 100644
index 0000000..f28b418
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/stormondemand.rb
@@ -0,0 +1,30 @@
+class StormOnDemand < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::StormOnDemand::Compute
+      else 
+        raise ArgumentError, "Unsupported #{self} service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'StormOnDemand')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::StormOnDemand.services
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/bin/terremark.rb b/vendor/fog-0.8.2/lib/fog/bin/terremark.rb
new file mode 100644
index 0000000..76258c7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/terremark.rb
@@ -0,0 +1,31 @@
+class Terremark < Fog::Bin
+  class << self
+
+    def available?
+      Fog::Terremark::VCLOUD_OPTIONS.all? {|requirement| Fog.credentials.include?(requirement)}
+    end
+
+    def terremark_service(service)
+      case service
+      when :vcloud
+        Fog::Terremark::Vcloud
+      else
+        raise "Unsupported Terremark Service"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        credentials = Fog.credentials.reject do |k,v|
+          case key
+          when :vcloud
+            !Fog::Terremark::VCLOUD_OPTIONS.include?(k)
+          end
+        end
+        hash[key] = terremark_service(key).new(credentials)
+      end
+      @@connections[service]
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/virtual_box.rb b/vendor/fog-0.8.2/lib/fog/bin/virtual_box.rb
new file mode 100644
index 0000000..37247b9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/virtual_box.rb
@@ -0,0 +1,52 @@
+module VirtualBox # deviates from other bin stuff to accomodate gem
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::VirtualBox::Compute
+      else
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'VirtualBox')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def available?
+      availability = !Gem.source_index.find_name('virtualbox').empty?
+      if availability
+        for service in services
+          for collection in self.class_for(service).collections
+            unless self.respond_to?(collection)
+              self.class_eval <<-EOS, __FILE__, __LINE__
+                def self.#{collection}
+                  self[:#{service}].#{collection}
+                end
+              EOS
+            end
+          end
+        end
+      end
+      availability
+    end
+
+    def collections
+      services.map {|service| self[service].collections}.flatten.sort_by {|service| service.to_s}
+    end
+
+    def services
+      Fog::VirtualBox.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/voxel.rb b/vendor/fog-0.8.2/lib/fog/bin/voxel.rb
new file mode 100644
index 0000000..e8c03d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/voxel.rb
@@ -0,0 +1,30 @@
+class Voxel < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :compute
+        Fog::Voxel::Compute
+      else
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :compute
+          Fog::Compute.new(:provider => 'Voxel')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Voxel.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/bin/zerigo.rb b/vendor/fog-0.8.2/lib/fog/bin/zerigo.rb
new file mode 100644
index 0000000..18c09ae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/bin/zerigo.rb
@@ -0,0 +1,30 @@
+class Zerigo < Fog::Bin
+  class << self
+
+    def class_for(key)
+      case key
+      when :dns
+        Fog::Zerigo::DNS
+      else 
+        raise ArgumentError, "Unrecognized service: #{key}"
+      end
+    end
+
+    def [](service)
+      @@connections ||= Hash.new do |hash, key|
+        hash[key] = case key
+        when :dns
+          Fog::DNS.new(:provider => 'Zerigo')
+        else
+          raise ArgumentError, "Unrecognized service: #{key.inspect}"
+        end
+      end
+      @@connections[service]
+    end
+
+    def services
+      Fog::Zerigo.services
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn.rb b/vendor/fog-0.8.2/lib/fog/cdn.rb
new file mode 100644
index 0000000..78487f1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn.rb
@@ -0,0 +1,19 @@
+module Fog
+  class CDN
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes[:provider] # attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/cdn/aws'
+        Fog::AWS::CDN.new(attributes)
+      when 'Rackspace'
+        require 'fog/cdn/rackspace'
+        Fog::Rackspace::CDN.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized cdn provider")
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/aws.rb b/vendor/fog-0.8.2/lib/fog/cdn/aws.rb
new file mode 100644
index 0000000..54e7c46
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/aws.rb
@@ -0,0 +1,127 @@
+module Fog
+  module AWS
+    class CDN < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :version, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/cdn/models/aws'
+
+      request_path 'fog/cdn/requests/aws'
+      request 'delete_distribution'
+      request 'get_distribution'
+      request 'get_distribution_list'
+      request 'post_distribution'
+      request 'post_invalidation'
+      request 'put_distribution_config'
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::CDN.new is deprecated, use Fog::CDN.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @aws_access_key_id  = options[:aws_access_key_id]
+          @region             = options[:region]
+        end
+
+        def data
+          self.class.data[@region][@aws_access_key_id]
+        end
+
+        def reset_data
+          self.class.data[@region].delete(@aws_access_key_id)
+        end
+
+        def signature(params)
+          "foo"
+        end
+
+      end
+
+      class Real
+
+        # Initialize connection to Cloudfront
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   cdn = Fog::AWS::CDN.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * cdn object with connection to aws.
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::CDN.new is deprecated, use Fog::CDN.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac     = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          @host     = options[:host]      || 'cloudfront.amazonaws.com'
+          @path     = options[:path]      || '/'
+          @port     = options[:port]      || 443
+          @scheme   = options[:scheme]    || 'https'
+          @version  = options[:version]  || '2010-11-01'
+          unless options.has_key?(:persistent)
+            options[:persistent] = true
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers] ||= {}
+          params[:headers]['Date'] = Fog::Time.now.to_date_header
+          params[:headers]['Authorization'] = "AWS #{@aws_access_key_id}:#{signature(params)}"
+          params[:path] = "/#{@version}/#{params[:path]}" 
+          @connection.request(params, &block)
+        end
+
+        def signature(params)
+          string_to_sign = params[:headers]['Date']
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/distribution.rb b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/distribution.rb
new file mode 100644
index 0000000..a0fa2b5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/distribution.rb
@@ -0,0 +1,59 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class Distribution < Fog::Parsers::Base
+
+          def reset
+            @response = { 'DistributionConfig' => { 'CNAME' => [], 'Logging' => {}, 'TrustedSigners' => [] } }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CustomOrigin', 'S3Origin'
+              @origin = name
+              @response['DistributionConfig'][@origin] = {}
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'AwsAccountNumber'
+              @response['DistributionConfig']['TrustedSigners'] << value
+            when 'Bucket', 'Prefix'
+              @response['DistributionConfig']['Logging'][name] = value
+            when 'CNAME'
+              @response['DistributionConfig']['CNAME'] << value
+            when 'DNSName', 'OriginAccessIdentity', 'OriginProtocolPolicy'
+              @response['DistributionConfig'][@origin][name] = value
+            when 'DomainName', 'Id', 'Status'
+              @response[name] = value
+            when 'CallerReference', 'Comment', 'DefaultRootObject', 'Origin', 'OriginAccessIdentity'
+              @response['DistributionConfig'][name] = value
+            when 'Enabled'
+              if value == 'true'
+                @response['DistributionConfig'][name] = true
+              else
+                @response['DistributionConfig'][name] = false
+              end
+            when 'HTTPPort', 'HTTPSPort'
+              @response['DistributionConfig'][@origin][name] = value.to_i
+            when 'InProgressInvalidationBatches'
+              @response[name] = value.to_i
+            when 'LastModifiedTime'
+              @response[name] = Time.parse(value)
+            when 'Protocol'
+              @response['DistributionConfig']['RequireProtocols'] = value
+            when 'Self'
+              @response['DistributionConfig']['TrustedSigners'] << 'Self'
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/get_distribution_list.rb b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/get_distribution_list.rb
new file mode 100644
index 0000000..d539a8a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/get_distribution_list.rb
@@ -0,0 +1,61 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class GetDistributionList < Fog::Parsers::Base
+
+          def reset
+            @distribution_summary = { 'CNAME' => [], 'TrustedSigners' => [] }
+            @response = { 'DistributionSummary' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CustomOrigin', 'S3Origin'
+              @origin = name
+              @distribution_summary[@origin] = {}
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DistributionSummary'
+              @response['DistributionSummary'] << @distribution_summary
+              @distribution_summary = { 'CNAME' => [], 'TrustedSigners' => [] }
+            when 'Comment', 'DomainName', 'Id', 'Origin', 'Status'
+              @distribution_summary[name] = value
+            when 'CNAME'
+              @distribution_summary[name] << value
+            when 'DNSName', 'OriginAccessIdentity', 'OriginProtocolPolicy'
+              @distribution_summary[@origin][name] = value
+            when 'Enabled'
+              if value == 'true'
+                @distribution_summary[name] = true
+              else
+                @distribution_summary[name] = false
+              end
+            when 'HTTPPort', 'HTTPSPort'
+              @distribution_summary[@origin][name] = value.to_i
+            when 'LastModifiedTime'
+              @distribution_summary[name] = Time.parse(value)
+            when 'IsTruncated'
+              if value == 'true'
+                @response[name] = true
+              else
+                @response[name] = false
+              end
+            when 'Marker', 'NextMarker'
+              @response[name] = value
+            when 'MaxItems'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/post_invalidation.rb b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/post_invalidation.rb
new file mode 100644
index 0000000..27cc542
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/parsers/aws/post_invalidation.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module CDN
+
+        class PostInvalidation < Fog::Parsers::Base
+
+          def reset
+            @response = { 'InvalidationBatch' => { 'Path' => [] } }
+          end
+
+          def end_element(name)
+            case name
+            when 'CallerReference'
+              @response['InvalidationBatch'][name] = value
+            when 'CreateTime', 'Id', 'Status'
+              @response[name] = value
+            when 'Path'
+              @response['InvalidationBatch'][name] << value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/rackspace.rb b/vendor/fog-0.8.2/lib/fog/cdn/rackspace.rb
new file mode 100644
index 0000000..2b67b98
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/rackspace.rb
@@ -0,0 +1,103 @@
+module Fog
+  module Rackspace
+    class CDN < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/cdn/models/rackspace'
+
+      request_path 'fog/cdn/requests/rackspace'
+      request :get_containers
+      request :head_container
+      request :post_container
+      request :put_container
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::CDN.new is deprecated, use Fog::CDN.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @rackspace_username = options[:rackspace_username]
+        end
+
+        def data
+          self.class.data[@rackspace_username]
+        end
+
+        def reset_data
+          self.class.data.delete(@rackspace_username)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::CDN.new is deprecated, use Fog::CDN.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+
+          uri = URI.parse(credentials['X-CDN-Management-Url'])
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @cdn_connection.reset
+        end
+
+        def request(params, parse_json = true)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+            }))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/delete_distribution.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/delete_distribution.rb
new file mode 100644
index 0000000..d90278f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/delete_distribution.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        # Delete a distribution from CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution to delete
+        # * etag<~String> - etag of that distribution from earlier get or put
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/DeleteDistribution.html
+
+        def delete_distribution(distribution_id, etag)
+          request({
+            :expects    => 204,
+            :headers    => { 'If-Match' => etag },
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => "/distribution/#{distribution_id}"
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution.rb
new file mode 100644
index 0000000..5b9eb93
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/cdn/parsers/aws/distribution'
+
+        # Get information about a distribution from CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - id of distribution
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'S3Origin'<~Hash>:
+        #       * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #       * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #     or
+        #     * 'CustomOrigin'<~Hash>:
+        #       * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #       * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #       * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #       * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'InProgressInvalidationBatches'<~Integer> - number of invalidation batches in progress
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/GetDistribution.html
+
+        def get_distribution(distribution_id)
+          request({
+            :expects    => 200,
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution/#{distribution_id}"
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution_list.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution_list.rb
new file mode 100644
index 0000000..d500703
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/get_distribution_list.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/cdn/parsers/aws/get_distribution_list'
+
+        # List information about distributions in CloudFront
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'Marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'MaxItems'<~Integer> - limits number of object keys returned
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxItems'<~Integer> - Maximum number of keys specified for query
+        #     * 'NextMarker'<~String> - Marker to specify for next page (id of last result of current page)
+        #     * 'DistributionSummary'<~Array>:
+        #       * 'S3Origin'<~Hash>:
+        #         * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #         * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #       or
+        #       * 'CustomOrigin'<~Hash>:
+        #         * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #         * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #         * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #       * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Id'<~String> - Id of distribution
+        #       * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'Status'<~String> - Status of distribution
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/ListDistributions.html
+
+        def get_distribution_list(options = {})
+          request({
+            :expects    => 200,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::CDN::GetDistributionList.new,
+            :path       => "/distribution",
+            :query      => options
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_distribution.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_distribution.rb
new file mode 100644
index 0000000..141defb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_distribution.rb
@@ -0,0 +1,91 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/cdn/parsers/aws/distribution'
+
+        # create a new distribution in CloudFront
+        #
+        # ==== Parameters
+        # * options<~Hash> - config for distribution.  Defaults to {}.
+        #   REQUIRED:
+        #   * 'S3Origin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #     * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #   or
+        #   * 'CustomOrigin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #     * 'HTTPPort'<~Integer> - Optional HTTP port of origin, in [80, 443] or (1024...65535), defaults to 80
+        #     * 'HTTPSPort'<~Integer> - Optional HTTPS port of origin, in [80, 443] or (1024...65535), defaults to 443
+        #     * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #   OPTIONAL:
+        #   * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #   * 'Comment'<~String> - Optional comment about distribution
+        #   * 'CNAME'<~Array> - Optional array of strings to set as CNAMEs
+        #   * 'DefaultRootObject'<~String> - Optional default object to return for '/'
+        #   * 'Enabled'<~Boolean> - Whether or not distribution should accept requests, defaults to true
+        #   * 'Logging'<~Hash>: Optional logging config
+        #     * 'Bucket'<~String> - Bucket to store logs in, ie 'mylogs.s3.amazonaws.com'
+        #     * 'Prefix'<~String> - Optional prefix for log filenames, ie 'myprefix/'
+        #   * 'OriginAccessIdentity'<~String> - Used for serving private content, in format 'origin-access-identity/cloudfront/ID'
+        #   * 'RequiredProtocols'<~String> - Optional, set to 'https' to force https connections
+        #   * 'TrustedSigners'<~Array> - Optional grant of rights to up to 5 aws accounts to generate signed URLs for private content, elements are either 'Self' for your own account or an AWS Account Number
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DomainName'<~String>: Domain name of distribution
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html
+
+        def post_distribution(options = {})
+          options['CallerReference'] = Time.now.to_i.to_s
+          data = '<?xml version="1.0" encoding="UTF-8"?>'
+          data << "<DistributionConfig xmlns=\"http://cloudfront.amazonaws.com/doc/#{@version}/\">"
+          for key, value in options
+            case value
+            when Array
+              for item in value
+                data << "<#{key}>#{item}</#{key}>"
+              end
+            when Hash
+              data << "<#{key}>"
+              for inner_key, inner_value in value
+                data << "<#{inner_key}>#{inner_value}</#{inner_key}>"
+              end
+              data << "</#{key}>"
+            else
+              data << "<#{key}>#{value}</#{key}>"
+            end
+          end
+          data << "</DistributionConfig>"
+          request({
+            :body       => data,
+            :expects    => 201,
+            :headers    => { 'Content-Type' => 'text/xml' },
+            :idempotent => true,
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution"
+          })
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_invalidation.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_invalidation.rb
new file mode 100644
index 0000000..ef7d44e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/post_invalidation.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/cdn/parsers/aws/post_invalidation'
+
+        # List information about distributions in CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution for invalidations
+        # * paths<~Array> - Array of string paths to objects to invalidate
+        # * caller_reference<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Id'<~String> - Id of invalidation
+        #     * 'Status'<~String> - Status of invalidation
+        #     * 'CreateTime'<~Integer> - Time of invalidation creation
+        #     * 'InvalidationBatch'<~Array>:
+        #       * 'Path'<~Array> - Array of strings of objects to invalidate
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateInvalidation.html
+
+        def post_invalidation(distribution_id, paths, caller_reference = Time.now.to_i.to_s)
+          body = '<?xml version="1.0" encoding="UTF-8"?>'
+          body << "<InvalidationBatch>"
+          for path in [*paths]
+            body << "<Path>" << path << "</Path>"
+          end
+          body << "<CallerReference>" << caller_reference << "</CallerReference>"
+          body << "</InvalidationBatch>"
+          request({
+            :body       => body,
+            :expects    => 201,
+            :headers    => {'Content-Type' => 'text/xml'},
+            :idempotent => true,
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::CDN::PostInvalidation.new,
+            :path       => "/distribution/#{distribution_id}/invalidation"
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/put_distribution_config.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/put_distribution_config.rb
new file mode 100644
index 0000000..e3323cc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/aws/put_distribution_config.rb
@@ -0,0 +1,94 @@
+module Fog
+  module AWS
+    class CDN
+      class Real
+
+        require 'fog/cdn/parsers/aws/distribution'
+
+        # update a distribution in CloudFront
+        #
+        # ==== Parameters
+        # * distribution_id<~String> - Id of distribution to update config for
+        # * options<~Hash> - config for distribution.  Defaults to {}.
+        #   REQUIRED:
+        #   * 'S3Origin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'mybucket.s3.amazonaws.com'
+        #     * 'OriginAccessIdentity'<~String> - Optional: Used when serving private content
+        #   or
+        #   * 'CustomOrigin'<~Hash>:
+        #     * 'DNSName'<~String> - origin to associate with distribution, ie 'www.example.com'
+        #     * 'HTTPPort'<~Integer> - HTTP port of origin, in [80, 443] or (1024...65535)
+        #     * 'HTTPSPort'<~Integer> - HTTPS port of origin, in [80, 443] or (1024...65535)
+        #     * 'OriginProtocolPolicy'<~String> - Policy on using http vs https, in ['http-only', 'match-viewer']
+        #   OPTIONAL:
+        #   * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #   * 'Comment'<~String> - Optional comment about distribution
+        #   * 'CNAME'<~Array> - Optional array of strings to set as CNAMEs
+        #   * 'DefaultRootObject'<~String> - Optional default object to return for '/'
+        #   * 'Enabled'<~Boolean> - Whether or not distribution should accept requests, defaults to true
+        #   * 'Logging'<~Hash>: Optional logging config
+        #     * 'Bucket'<~String> - Bucket to store logs in, ie 'mylogs.s3.amazonaws.com'
+        #     * 'Prefix'<~String> - Optional prefix for log filenames, ie 'myprefix/'
+        #   * 'OriginAccessIdentity'<~String> - Used for serving private content, in format 'origin-access-identity/cloudfront/ID'
+        #   * 'RequiredProtocols'<~String> - Optional, set to 'https' to force https connections
+        #   * 'TrustedSigners'<~Array> - Optional grant of rights to up to 5 aws accounts to generate signed URLs for private content, elements are either 'Self' for your own account or an AWS Account Number
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'DomainName'<~String>: Domain name of distribution
+        #     * 'Id'<~String> - Id of distribution
+        #     * 'LastModifiedTime'<~String> - Timestamp of last modification of distribution
+        #     * 'Status'<~String> - Status of distribution
+        #     * 'DistributionConfig'<~Array>:
+        #       * 'CallerReference'<~String> - Used to prevent replay, defaults to Time.now.to_i.to_s
+        #       * 'CNAME'<~Array> - array of associated cnames
+        #       * 'Comment'<~String> - comment associated with distribution
+        #       * 'Enabled'<~Boolean> - whether or not distribution is enabled
+        #       * 'Logging'<~Hash>:
+        #         * 'Bucket'<~String> - bucket logs are stored in
+        #         * 'Prefix'<~String> - prefix logs are stored with
+        #       * 'Origin'<~String> - s3 origin bucket
+        #       * 'TrustedSigners'<~Array> - trusted signers
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonCloudFront/latest/APIReference/CreateDistribution.html
+
+        def put_distribution_config(distribution_id, etag, options = {})
+          data = '<?xml version="1.0" encoding="UTF-8"?>'
+          data << "<DistributionConfig xmlns=\"http://cloudfront.amazonaws.com/doc/#{@version}/\">"
+          for key, value in options
+            case value
+            when Array
+              for item in value
+                data << "<#{key}>#{item}</#{key}>"
+              end
+            when Hash
+              data << "<#{key}>"
+              for inner_key, inner_value in value
+                data << "<#{inner_key}>#{inner_value}</#{inner_key}>"
+              end
+              data << "</#{key}>"
+            else
+              data << "<#{key}>#{value}</#{key}>"
+            end
+          end
+          data << "</DistributionConfig>"
+          request({
+            :body       => data,
+            :expects    => 200,
+            :headers    => {
+              'Content-Type'  => 'text/xml',
+              'If-Match'      => etag
+            },
+            :idempotent => true,
+            :method     => 'PUT',
+            :parser     => Fog::Parsers::AWS::CDN::Distribution.new,
+            :path       => "/distribution/#{distribution_id}/config"
+          })
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/get_containers.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/get_containers.rb
new file mode 100644
index 0000000..7db2750
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/get_containers.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # List existing cdn-enabled storage containers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'enabled_only'<~Boolean> - Set to true to limit results to cdn enabled containers
+        #   * 'limit'<~Integer> - Upper limit to number of results returned
+        #   * 'marker'<~String> - Only return objects with name greater than this value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * container<~String>: Name of container
+        def get_containers(options = {})
+          response = request(
+            :expects  => [200, 204],
+            :method   => 'GET',
+            :path     => '',
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/head_container.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/head_container.rb
new file mode 100644
index 0000000..d31afd6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/head_container.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # List cdn properties for a container
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-CDN-Enabled'<~Boolean> - cdn status for container
+        #     * 'X-CDN-URI'<~String> - cdn url for this container
+        #     * 'X-TTL'<~String> - integer seconds before data expires, defaults to 86400 (1 day)
+        #     * 'X-Log-Retention'<~Boolean> - ?
+        #     * 'X-User-Agent-ACL'<~String> - ?
+        #     * 'X-Referrer-ACL'<~String> - ?
+        def head_container(container)
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => container,
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/post_container.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/post_container.rb
new file mode 100644
index 0000000..26fe9ce
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/post_container.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # modify CDN properties for a container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        # # options<~Hash>:
+        #   * 'X-CDN-Enabled'<~Boolean> - cdn status for container
+        #   * 'X-CDN-URI'<~String> - cdn url for this container
+        #   * 'X-TTL'<~String> - integer seconds before data expires, defaults to 86400 (1 day), in 3600..259200
+        #   * 'X-Log-Retention'<~Boolean> - ?
+        #   * 'X-User-Agent-ACL'<~String> - ?
+        #   * 'X-Referrer-ACL'<~String> - ?
+        def post_container(name, options = {})
+          response = request(
+            :expects  => [201, 202],
+            :headers  => options,
+            :method   => 'POST',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/put_container.rb b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/put_container.rb
new file mode 100644
index 0000000..fd0560d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/cdn/requests/rackspace/put_container.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Rackspace
+    class CDN
+      class Real
+
+        # enable CDN for a container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        # # options<~Hash>:
+        #   * 'X-CDN-Enabled'<~Boolean> - cdn status for container
+        #   * 'X-CDN-URI'<~String> - cdn url for this container
+        #   * 'X-TTL'<~String> - integer seconds before data expires, defaults to 86400 (1 day), in 3600..259200
+        #   * 'X-Log-Retention'<~Boolean> - ?
+        #   * 'X-User-Agent-ACL'<~String> - ?
+        #   * 'X-Referrer-ACL'<~String> - ?
+        def put_container(name, options = {})
+          response = request(
+            :expects  => [201, 202],
+            :headers  => options,
+            :method   => 'PUT',
+            :path     => CGI.escape(name)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute.rb b/vendor/fog-0.8.2/lib/fog/compute.rb
new file mode 100644
index 0000000..3863aad
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute.rb
@@ -0,0 +1,49 @@
+module Fog
+  class Compute
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes[:provider] # attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/compute/aws'
+        Fog::AWS::Compute.new(attributes)
+      when 'Bluebox'
+        require 'fog/compute/bluebox'
+        Fog::Bluebox::Compute.new(attributes)
+      when 'Brightbox'
+        require 'fog/compute/brightbox'
+        Fog::Brightbox::Compute.new(attributes)
+      when 'Ecloud'
+        require 'fog/compute/ecloud'
+        Fog::Ecloud::Compute.new(attributes)
+      when 'GoGrid'
+        require 'fog/compute/go_grid'
+        Fog::GoGrid::Compute.new(attributes)
+      when 'Linode'
+        require 'fog/compute/linode'
+        Fog::Linode::Compute.new(attributes)
+      when 'NewServers'
+        require 'fog/compute/new_servers'
+        Fog::NewServers::Compute.new(attributes)
+      when 'Rackspace'
+        require 'fog/compute/rackspace'
+        Fog::Rackspace::Compute.new(attributes)
+      when 'Slicehost'
+        require 'fog/compute/slicehost'
+        Fog::Slicehost::Compute.new(attributes)
+      when 'StormOnDemand'
+        require 'fog/compute/storm_on_demand'
+        Fog::StormOnDemand::Compute.new(attributes)
+      when 'VirtualBox'
+        require 'fog/compute/virtual_box'
+        Fog::VirtualBox::Compute.new(attributes)
+      when 'Voxel'
+        require 'fog/compute/voxel'
+        Fog::Voxel::Compute.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized compute provider")
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/aws.rb b/vendor/fog-0.8.2/lib/fog/compute/aws.rb
new file mode 100644
index 0000000..d6f2771
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/aws.rb
@@ -0,0 +1,300 @@
+module Fog
+  module AWS
+    class Compute < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :endpoint, :region, :host, :path, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/aws'
+      model       :address
+      collection  :addresses
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :key_pair
+      collection  :key_pairs
+      model       :security_group
+      collection  :security_groups
+      model       :server
+      collection  :servers
+      model       :snapshot
+      collection  :snapshots
+      model       :tag
+      collection  :tags
+      model       :volume
+      collection  :volumes
+
+      request_path 'fog/compute/requests/aws'
+      request :allocate_address
+      request :associate_address
+      request :attach_volume
+      request :authorize_security_group_ingress
+      request :create_image
+      request :create_key_pair
+      request :create_security_group
+      request :create_snapshot
+      request :create_tags
+      request :create_volume
+      request :delete_key_pair
+      request :delete_security_group
+      request :delete_snapshot
+      request :delete_tags
+      request :delete_volume
+      request :deregister_image
+      request :describe_addresses
+      request :describe_availability_zones
+      request :describe_images
+      request :describe_instances
+      request :describe_reserved_instances
+      request :describe_key_pairs
+      request :describe_regions
+      request :describe_reserved_instances_offerings
+      request :describe_security_groups
+      request :describe_snapshots
+      request :describe_tags
+      request :describe_volumes
+      request :detach_volume
+      request :disassociate_address
+      request :get_console_output
+      request :get_password_data
+      request :import_key_pair
+      request :modify_image_attributes
+      request :modify_snapshot_attribute
+      request :reboot_instances
+      request :release_address
+      request :register_image
+      request :revoke_security_group_ingress
+      request :run_instances
+      request :terminate_instances
+      request :start_instances
+      request :stop_instances
+      request :monitor_instances
+      request :unmonitor_instances
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            owner_id = Fog::AWS::Mock.owner_id
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :deleted_at => {},
+                :addresses  => {},
+                :images     => {},
+                :instances  => {},
+                :key_pairs  => {},
+                :limits     => { :addresses => 5 },
+                :owner_id   => owner_id,
+                :security_groups => {
+                  'default' => {
+                    'groupDescription'  => 'default group',
+                    'groupName'         => 'default',
+                    'ipPermissions'     => [
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => -1,
+                        'toPort'      => -1,
+                        'ipProtocol'  => 'icmp',
+                        'ipRanges'    => []
+                      },
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => 0,
+                        'toPort'      => 65535,
+                        'ipProtocol'  => 'tcp',
+                        'ipRanges'    => []
+                      },
+                      {
+                        'groups'      => [{'groupName' => 'default', 'userId' => owner_id}],
+                        'fromPort'    => 0,
+                        'toPort'      => 65535,
+                        'ipProtocol'  => 'udp',
+                        'ipRanges'    => []
+                      }
+                    ],
+                    'ownerId'           => owner_id
+                  }
+                },
+                :snapshots => {},
+                :volumes => {},
+                :tags => {}
+              }
+            end
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute.new is deprecated, use Fog::Compute.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/compute/parsers/aws/basic'
+
+          @aws_access_key_id = options[:aws_access_key_id]
+
+          @region = options[:region] || 'us-east-1'
+
+          unless ['ap-northeast-1', 'ap-southeast-1', 'eu-west-1', 'us-east-1', 'us-west-1'].include?(@region)
+            raise ArgumentError, "Unknown region: #{@region.inspect}"
+          end
+        end
+
+        def data
+          self.class.data[@region][@aws_access_key_id]
+        end
+
+        def reset_data
+          self.class.data[@region].delete(@aws_access_key_id)
+        end
+
+        def apply_tag_filters(resources, filters)
+          # tag-key: match resources tagged with this key (any value)
+          if filters.has_key?('tag-key')
+            value = filters.delete('tag-key')
+            resources = resources.select{|r| r['tagSet'].has_key?(value)}
+          end
+          
+          # tag-value: match resources tagged with this value (any key)
+          if filters.has_key?('tag-value')
+            value = filters.delete('tag-value')
+            resources = resources.select{|r| r['tagSet'].values.include?(value)}
+          end
+          
+          # tag:key: match resources taged with a key-value pair.  Value may be an array, which is OR'd.
+          tag_filters = {}
+          filters.keys.each do |key| 
+            tag_filters[key.gsub('tag:', '')] = filters.delete(key) if /^tag:/ =~ key
+          end
+          for tag_key, tag_value in tag_filters
+            resources = resources.select{|r| tag_value.include?(r['tagSet'][tag_key])}
+          end
+          
+          resources
+        end
+      end
+
+      class Real
+
+        # Initialize connection to EC2
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and 
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   sdb = SimpleDB.new(
+        #    :aws_access_key_id => your_aws_access_key_id,
+        #    :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #   * region<~String> - optional region to use, in
+        #     ['eu-west-1', 'us-east-1', 'us-west-1', 'ap-northeast-1', 'ap-southeast-1']
+        #
+        # ==== Returns
+        # * EC2 object with connection to aws.
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute.new is deprecated, use Fog::Compute.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @aws_access_key_id      = options[:aws_access_key_id]
+          @aws_secret_access_key  = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha256', @aws_secret_access_key)
+          @region = options[:region] ||= 'us-east-1'
+
+          if @endpoint = options[:endpoint]
+            endpoint = URI.parse(@endpoint)
+            @host = endpoint.host
+            @path = endpoint.path
+            @port = endpoint.port
+            @scheme = endpoint.scheme
+          else
+            @host = options[:host] || case options[:region]
+            when 'ap-northeast-1'
+              'ec2.ap-northeast-1.amazonaws.com'
+            when 'ap-southeast-1'
+              'ec2.ap-southeast-1.amazonaws.com'
+            when 'eu-west-1'
+              'ec2.eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              'ec2.us-east-1.amazonaws.com'
+            when 'us-west-1'
+              'ec2.us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+            @path   = options[:path]      || '/'
+            @port   = options[:port]      || 443
+            @scheme = options[:scheme]    || 'https'
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+        
+        def request(params)
+          idempotent  = params.delete(:idempotent)
+          parser      = params.delete(:parser)
+
+          body = AWS.signed_params(
+            params,
+            {
+              :aws_access_key_id  => @aws_access_key_id,
+              :hmac               => @hmac,
+              :host               => @host,
+              :path               => @path,
+              :port               => @port,
+              :version            => '2010-08-31'
+            }
+          )
+
+          begin
+            response = @connection.request({
+              :body       => body,
+              :expects    => 200,
+              :headers    => { 'Content-Type' => 'application/x-www-form-urlencoded' },
+              :idempotent => idempotent,
+              :host       => @host,
+              :method     => 'POST',
+              :parser     => parser
+            })
+          rescue Excon::Errors::HTTPStatusError => error
+            if match = error.message.match(/<Code>(.*)<\/Code><Message>(.*)<\/Message>/)
+              raise case match[1].split('.').last
+              when 'NotFound'
+                Fog::AWS::Compute::NotFound.slurp(error, match[2])
+              else
+                Fog::AWS::Compute::Error.slurp(error, "#{match[1]} => #{match[2]}")
+              end
+            else
+              raise error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/bluebox.rb b/vendor/fog-0.8.2/lib/fog/compute/bluebox.rb
new file mode 100644
index 0000000..1cdf4e9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/bluebox.rb
@@ -0,0 +1,109 @@
+module Fog
+  module Bluebox
+    class Compute < Fog::Service
+
+      requires :bluebox_api_key, :bluebox_customer_id
+      recognizes :bluebox_host, :bluebox_port, :bluebox_scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/bluebox'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/compute/requests/bluebox'
+      request :create_block
+      request :destroy_block
+      request :get_block
+      request :get_blocks
+      request :get_product
+      request :get_products
+      request :get_template
+      request :get_templates
+      request :reboot_block
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Bluebox::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Bluebox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @bluebox_api_key = options[:bluebox_api_key]
+        end
+
+        def data
+          self.class.data[@bluebox_api_key]
+        end
+
+        def reset_data
+          self.class.data.delete(@bluebox_api_key)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Bluebox::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Bluebox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+          @bluebox_api_key      = options[:bluebox_api_key]
+          @bluebox_customer_id  = options[:bluebox_customer_id]
+          @host   = options[:bluebox_host]    || "boxpanel.bluebox.net"
+          @port   = options[:bluebox_port]    || 443
+          @scheme = options[:bluebox_scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64([@bluebox_customer_id, @bluebox_api_key].join(':')).delete("\r\n")}"
+          })
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Bluebox::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/brightbox.rb b/vendor/fog-0.8.2/lib/fog/compute/brightbox.rb
new file mode 100644
index 0000000..547fffb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/brightbox.rb
@@ -0,0 +1,162 @@
+module Fog
+  module Brightbox
+    class Compute < Fog::Service
+
+      API_URL = "https://api.gb1.brightbox.com/"
+
+      requires :brightbox_client_id, :brightbox_secret
+      recognizes :brightbox_auth_url, :brightbox_api_url
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/brightbox'
+      model       :account # Singular resource, no collection
+      collection  :servers
+      model       :server
+      collection  :flavors
+      model       :flavor
+      collection  :images
+      model       :image
+      collection  :load_balancers
+      model       :load_balancer
+      collection  :zones
+      model       :zone
+      collection  :cloud_ips
+      model       :cloud_ip
+      collection  :users
+      model       :user
+
+      request_path 'fog/compute/requests/brightbox'
+      request :activate_console_server
+      request :add_listeners_load_balancer
+      request :add_nodes_load_balancer
+      request :create_api_client
+      request :create_cloud_ip
+      request :create_image
+      request :create_load_balancer
+      request :create_server
+      request :destroy_api_client
+      request :destroy_cloud_ip
+      request :destroy_image
+      request :destroy_load_balancer
+      request :destroy_server
+      request :get_account
+      request :get_api_client
+      request :get_cloud_ip
+      request :get_image
+      request :get_interface
+      request :get_load_balancer
+      request :get_server
+      request :get_server_type
+      request :get_user
+      request :get_zone
+      request :list_api_clients
+      request :list_cloud_ips
+      request :list_images
+      request :list_load_balancers
+      request :list_server_types
+      request :list_servers
+      request :list_users
+      request :list_zones
+      request :map_cloud_ip
+      request :remove_listeners_load_balancer
+      request :remove_nodes_load_balancer
+      request :reset_ftp_password_account
+      request :resize_server
+      request :shutdown_server
+      request :snapshot_server
+      request :start_server
+      request :stop_server
+      request :unmap_cloud_ip
+      request :update_account
+      request :update_api_client
+      request :update_image
+      request :update_load_balancer
+      request :update_server
+      request :update_user
+
+      class Mock
+
+        def initialize(options)
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Brightbox::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Brightbox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @brightbox_client_id = options[:brightbox_client_id] || Fog.credentials[:brightbox_client_id]
+          @brightbox_secret = options[:brightbox_secret] || Fog.credentials[:brightbox_secret]
+        end
+
+        def request(options)
+          raise "Not implemented"
+        end
+      end
+
+      class Real
+
+        def initialize(options)
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Brightbox::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Brightbox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require "json"
+          # Currently authentication and api endpoints are the same but may change
+          @auth_url = options[:brightbox_auth_url] || Fog.credentials[:brightbox_auth_url] || API_URL
+          @api_url = options[:brightbox_api_url] || Fog.credentials[:brightbox_api_url] || API_URL
+          @brightbox_client_id = options[:brightbox_client_id] || Fog.credentials[:brightbox_client_id]
+          @brightbox_secret = options[:brightbox_secret] || Fog.credentials[:brightbox_secret]
+          @connection = Fog::Connection.new(@api_url)
+        end
+
+        def request(params)
+          begin
+            get_oauth_token if @oauth_token.nil?
+            response = authenticated_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            get_oauth_token
+            response = authenticated_request(params)
+          end
+          unless response.body.empty?
+            response = JSON.parse(response.body)
+          end
+        end
+
+        def account
+          Fog::Brightbox::Compute::Account.new(get_account)
+        end
+
+      private
+        def get_oauth_token(options = {})
+          auth_url = options[:brightbox_auth_url] || @auth_url
+
+          connection = Fog::Connection.new(auth_url)
+          @authentication_body = {'client_id' => @brightbox_client_id, 'grant_type' => 'none'}.to_json
+
+          response = connection.request({
+            :path => "/token",
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic " + Base64.encode64("#{@brightbox_client_id}:#{@brightbox_secret}").chomp,
+              'Content-Type' => 'application/json'
+            },
+            :method   => 'POST',
+            :body     => @authentication_body
+          })
+          @oauth_token = JSON.parse(response.body)["access_token"]
+          return @oauth_token
+        end
+
+        def authenticated_request(options)
+          headers = options[:headers] || {}
+          headers.merge!("Authorization" => "OAuth #{@oauth_token}")
+          options[:headers] = headers
+          @connection.request(options)
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/ecloud.rb b/vendor/fog-0.8.2/lib/fog/compute/ecloud.rb
new file mode 100644
index 0000000..fc5a23d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/ecloud.rb
@@ -0,0 +1,1311 @@
+require 'fog/core'
+require 'ipaddr'
+
+class IPAddr
+  def mask
+    _to_string(@mask_addr)
+  end
+end
+
+module Fog
+  module Ecloud
+    class Collection < Fog::Collection
+
+      def load(objects)
+        objects = [ objects ] if objects.is_a?(Hash)
+        super
+      end
+
+      def check_href!(opts = {})
+        unless href
+          if opts.is_a?(String)
+            t = Hash.new
+            t[:parent] = opts
+            opts = t
+          end
+          msg = ":href missing, call with a :href pointing to #{if opts[:message]
+                  opts[:message]
+                elsif opts[:parent]
+                  "the #{opts[:parent]} whos #{self.class.to_s.split('::').last.downcase} you want to enumerate"
+                else
+                  "the resource"
+                end}"
+          raise Fog::Errors::Error.new(msg)
+        end
+      end
+
+    end
+  end
+end
+
+module Fog
+  module Ecloud
+    module MockDataClasses
+      class Base < Hash
+        def self.base_url=(url)
+          @base_url = url
+        end
+
+        self.base_url = "http://vcloud.example.com"
+
+        def self.base_url
+          @base_url
+        end
+
+        def first
+          raise "Don't do this"
+        end
+
+        def last
+          raise "Don't do this"
+        end
+
+        def initialize(data = {}, parent = nil)
+          @parent = parent
+
+          replace(data)
+        end
+
+        def _parent
+          @parent
+        end
+
+        def base_url
+          Base.base_url
+        end
+
+        def href
+          [base_url, self.class.name.split("::").last, object_id].join("/")
+        end
+
+        def inspect
+          "<#{self.class.name} #{object_id} data=#{super}>"
+        end
+      end
+
+      class MockData < Base
+        def versions
+          @versions ||= []
+        end
+
+        def organizations
+          @organizations ||= []
+        end
+
+        def organization_from_href(href)
+          find_href_in(href, organizations)
+        end
+
+        def all_vdcs
+          organizations.map(&:vdcs).flatten
+        end
+
+        def vdc_from_href(href)
+          find_href_in(href, all_vdcs)
+        end
+
+        def all_catalogs
+          all_vdcs.map(&:catalog).flatten
+        end
+
+        def catalog_from_href(href)
+          find_href_in(href, all_catalogs)
+        end
+
+        def all_catalog_items
+          all_catalogs.map(&:items).flatten
+        end
+
+        def catalog_item_from_href(href)
+          find_href_in(href, all_catalog_items)
+        end
+
+        def all_virtual_machines
+          all_vdcs.map(&:virtual_machines).flatten
+        end
+
+        def virtual_machine_from_href(href)
+          find_href_prefixed_in(href, all_virtual_machines)
+        end
+
+
+        def all_networks
+          all_vdcs.map(&:networks).flatten
+        end
+
+        def network_from_href(href)
+          find_href_in(href, all_networks)
+        end
+
+        def all_network_extensions
+          all_networks.map(&:extensions).flatten
+        end
+
+        def network_extension_from_href(href)
+          find_href_in(href, all_network_extensions)
+        end
+
+        def all_vdc_internet_service_collections
+          all_vdcs.map(&:internet_service_collection).flatten
+        end
+
+        def vdc_internet_service_collection_from_href(href)
+          find_href_in(href, all_vdc_internet_service_collections)
+        end
+
+        def all_backup_internet_services
+          all_vdc_internet_service_collections.map(&:backup_internet_services).flatten
+        end
+
+        def backup_internet_service_from_href(href)
+          find_href_in(href, all_backup_internet_services)
+        end
+
+        def all_public_ip_collections
+          all_vdcs.map {|v| v.public_ip_collection }.flatten
+        end
+
+        def public_ip_collection_from_href(href)
+          find_href_in(href, all_public_ip_collections)
+        end
+
+        def all_public_ips
+          all_public_ip_collections.map(&:items).flatten
+        end
+
+        def public_ip_from_href(href)
+          find_href_in(href, all_public_ips)
+        end
+
+        def all_public_ip_internet_service_collections
+          all_public_ips.map(&:internet_service_collection).flatten
+        end
+
+        def public_ip_internet_service_collection_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_collections)
+        end
+
+        def all_public_ip_internet_services
+          all_public_ip_internet_service_collections.map(&:items).flatten
+        end
+
+        def public_ip_internet_service_from_href(href)
+          find_href_in(href, all_public_ip_internet_services)
+        end
+
+        def all_public_ip_internet_service_node_collections
+          all_public_ip_internet_services.map(&:node_collection).flatten
+        end
+
+        def public_ip_internet_service_node_collection_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_node_collections)
+        end
+
+        def all_public_ip_internet_service_nodes
+          all_public_ip_internet_service_node_collections.map(&:items).flatten
+        end
+
+        def public_ip_internet_service_node_from_href(href)
+          find_href_in(href, all_public_ip_internet_service_nodes)
+        end
+
+        def all_network_ip_collections
+          all_networks.map(&:ip_collection)
+        end
+
+        def network_ip_collection_from_href(href)
+          find_href_in(href, all_network_ip_collections)
+        end
+
+        def all_network_ips
+          all_network_ip_collections.map {|c| c.items.values }.flatten
+        end
+
+        def network_ip_from_href(href)
+          find_href_in(href, all_network_ips)
+        end
+
+        private
+
+        def find_href_in(href, objects)
+          objects.detect {|o| o.href == href }
+        end
+
+        def find_href_prefixed_in(href, objects)
+          objects.detect {|o| href =~ %r{^#{o.href}($|/)} }
+        end
+      end
+
+      class MockVersion < Base
+        def version
+          self[:version]
+        end
+
+        def supported
+          !!self[:supported]
+        end
+
+        def login_url
+          href
+        end
+      end
+
+      class MockOrganization < Base
+        def name
+          self[:name]
+        end
+
+        def vdcs
+          @vdcs ||= []
+        end
+      end
+
+      class MockVdc < Base
+        def name
+          self[:name]
+        end
+
+        def storage_allocated
+          self[:storage_allocated] || 200
+        end
+
+        def storage_used
+          self[:storage_used] || 105
+        end
+
+        def cpu_allocated
+          self[:cpu_allocated] || 10000
+        end
+
+        def memory_allocated
+          self[:memory_allocated] || 20480
+        end
+
+        def catalog
+          @catalog ||= MockCatalog.new({}, self)
+        end
+
+        def networks
+          @networks ||= []
+        end
+
+        def virtual_machines
+          @virtual_machines ||= []
+        end
+
+        def task_list
+          @task_list ||= MockTaskList.new({}, self)
+        end
+
+        # for TM eCloud, should probably be subclassed
+        def public_ip_collection
+          @public_ip_collection ||= MockPublicIps.new({}, self)
+        end
+
+        def internet_service_collection
+          @internet_service_collection ||= MockVdcInternetServices.new({}, self)
+        end
+
+        def firewall_acls
+          @firewall_acls ||= MockFirewallAcls.new({}, self)
+        end
+      end
+
+      class MockTaskList < Base
+        def name
+          self[:name] || "Tasks List"
+        end
+      end
+
+      class MockCatalog < Base
+        def name
+          self[:name] || "Catalog"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockCatalogItem < Base
+        def name
+          self[:name]
+        end
+
+        def disks
+          @disks ||= MockVirtualMachineDisks.new(self)
+        end
+
+        def customization
+          @customization ||= MockCatalogItemCustomization.new({}, self)
+        end
+
+        def vapp_template
+          @vapp_template ||= MockCatalogItemVappTemplate.new({ :name => name }, self)
+        end
+      end
+
+      class MockCatalogItemCustomization < Base
+        def name
+          self[:name] || "Customization Options"
+        end
+      end
+
+      class MockCatalogItemVappTemplate < Base
+        def name
+          self[:name]
+        end
+      end
+
+      class MockNetwork < Base
+        def name
+          self[:name] || subnet
+        end
+
+        def subnet
+          self[:subnet]
+        end
+
+        def gateway
+          self[:gateway] || subnet_ips[1]
+        end
+
+        def netmask
+          self[:netmask] || subnet_ipaddr.mask
+        end
+
+        def dns
+          "8.8.8.8"
+        end
+
+        def features
+          [
+           { :type => :FenceMode, :value => "isolated" }
+          ]
+        end
+
+        def ip_collection
+          @ip_collection ||= MockNetworkIps.new({}, self)
+        end
+
+        def extensions
+          @extensions ||= MockNetworkExtensions.new({}, self)
+        end
+
+        def random_ip
+          usable_subnet_ips[rand(usable_subnet_ips.length)]
+        end
+
+        # for TM eCloud. should probably be a subclass
+        def rnat
+          self[:rnat]
+        end
+
+        def usable_subnet_ips
+          subnet_ips[3..-2]
+        end
+
+        def address
+          subnet_ips.first
+        end
+
+        def broadcast
+          subnet_ips.last
+        end
+
+        private
+
+        def subnet_ipaddr
+          @ipaddr ||= IPAddr.new(subnet)
+        end
+
+        def subnet_ips
+          subnet_ipaddr.to_range.to_a.map(&:to_s)
+        end
+      end
+
+      class MockNetworkIps < Base
+        def items
+          @items ||= _parent.usable_subnet_ips.inject({}) do |out, subnet_ip|
+            out.update(subnet_ip => MockNetworkIp.new({ :ip => subnet_ip }, self))
+          end
+        end
+
+        def ordered_ips
+          items.values.sort_by {|i| i.ip.split(".").map(&:to_i) }
+        end
+
+        def name
+          "IP Addresses"
+        end
+      end
+
+      class MockNetworkIp < Base
+        def name
+          self[:name] || ip
+        end
+
+        def ip
+          self[:ip]
+        end
+
+        def used_by
+          self[:used_by] || _parent._parent._parent.virtual_machines.detect {|v| v.ip == ip }
+        end
+
+        def status
+          if used_by
+            "Assigned"
+          else
+            "Available"
+          end
+        end
+
+        def rnat
+          self[:rnat] || _parent._parent.rnat
+        end
+
+        def rnat_set?
+          !!self[:rnat]
+        end
+      end
+
+      class MockNetworkExtensions < Base
+        def name
+          _parent.name
+        end
+
+        def gateway
+          _parent.gateway
+        end
+
+        def broadcast
+          _parent.broadcast
+        end
+
+        def address
+          _parent.address
+        end
+
+        def rnat
+          _parent.rnat
+        end
+
+        def type
+          self[:type] || "DMZ"
+        end
+
+        def vlan
+          object_id.to_s
+        end
+
+        def friendly_name
+          "#{name} (#{type}_#{object_id})"
+        end
+      end
+
+      class MockVirtualMachine < Base
+        def name
+          self[:name]
+        end
+
+        def ip
+          self[:ip]
+        end
+
+        def cpus
+          self[:cpus] || 1
+        end
+
+        def memory
+          self[:memory] || 1024
+        end
+
+        def disks
+          @disks ||= MockVirtualMachineDisks.new(self)
+        end
+
+        def status
+          self[:status] || 2
+        end
+
+        def power_off!
+          self[:status] = 2
+        end
+
+        def power_on!
+          self[:status] = 4
+        end
+
+        def size
+          disks.inject(0) {|s, d| s + d.vcloud_size }
+        end
+
+        def network_ip
+          if network = _parent.networks.detect {|n| n.ip_collection.items[ip] }
+            network.ip_collection.items[ip]
+          end
+        end
+
+        # from fog ecloud server's _compose_vapp_data
+        def to_configure_vapp_hash
+          {
+            :name   => name,
+            :cpus   => cpus,
+            :memory => memory,
+            :disks  => disks.map {|d| { :number => d.address.to_s, :size => d.vcloud_size, :resource => d.vcloud_size.to_s } }
+          }
+        end
+
+        def href(purpose = :base)
+          case purpose
+          when :base
+            super()
+          when :power_on
+            super() + "/power/action/powerOn"
+          when :power_off
+            super() + "/power/action/powerOff"
+          end
+        end
+      end
+
+      class MockVirtualMachineDisks < Array
+        def initialize(parent = nil)
+          @parent = parent
+        end
+
+        def _parent
+          @parent
+        end
+
+        def <<(disk)
+          next_address = 0
+          disk_with_max_address = max {|a, b| a[:address] <=> b[:address] }
+          disk_with_max_address && next_address = disk_with_max_address.address + 1
+          disk[:address] ||= next_address
+
+          super(disk)
+
+          if (addresses = map {|d| d.address }).uniq.size != size
+            raise "Duplicate disk address in: #{addresses.inspect} (#{size})"
+          end
+
+          sort! {|a, b| a.address <=> b.address }
+          self
+        end
+
+        def at_address(address)
+          detect {|d| d.address == address }
+        end
+      end
+
+      class MockVirtualMachineDisk < Base
+        def size
+          self[:size].to_i
+        end
+
+        def vcloud_size
+          # kilobytes
+          size * 1024
+        end
+
+        def address
+          self[:address].to_i
+        end
+      end
+
+      # for Terremark eCloud
+
+      class MockVdcInternetServices < Base
+        def href
+          _parent.href + "/internetServices"
+        end
+
+        def name
+          "Internet Services"
+        end
+
+        def items
+          public_ip_internet_services + backup_internet_services
+        end
+
+        def public_ip_internet_services
+          _parent.public_ip_collection.items.inject([]) do |services, public_ip|
+            services + public_ip.internet_service_collection.items
+          end
+        end
+
+        def backup_internet_services
+          @backup_internet_services ||= []
+        end
+      end
+
+      class MockBackupInternetService < Base
+        def name
+          self[:name] || "Backup Internet Service #{object_id}"
+        end
+
+        def protocol
+          self[:protocol]
+        end
+
+        def port
+          0
+        end
+
+        def enabled
+          self[:enabled].to_s.downcase != "false"
+        end
+
+        def timeout
+          self[:timeout] || 2
+        end
+
+        def description
+          self[:description] || "Description for Backup Service #{name}"
+        end
+
+        def redirect_url
+          nil
+        end
+
+        def node_collection
+          @node_collection ||= MockPublicIpInternetServiceNodes.new({}, self)
+        end
+      end
+
+      class MockFirewallAcls < Base
+        def name
+          "Firewall Access List"
+        end
+      end
+
+      class MockPublicIps < Base
+        def name
+          self[:name] || "Public IPs"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockPublicIp < Base
+        def name
+          self[:name]
+        end
+
+        def internet_service_collection
+          @internet_service_collection ||= MockPublicIpInternetServices.new({}, self)
+        end
+      end
+
+      class MockPublicIpInternetServices < Base
+        def href
+          _parent.href + "/internetServices"
+        end
+
+        def items
+          @items ||= []
+        end
+      end
+
+      class MockPublicIpInternetService < Base
+        def name
+          self[:name] || "Public IP Service #{object_id}"
+        end
+
+        def description
+          self[:description] || "Description for Public IP Service #{name}"
+        end
+
+        def protocol
+          self[:protocol]
+        end
+
+        def port
+          self[:port]
+        end
+
+        def enabled
+          !!self[:enabled]
+        end
+
+        def redirect_url
+          self[:redirect_url]
+        end
+
+        def timeout
+          self[:timeout] || 2
+        end
+
+        def node_collection
+          @node_collection ||= MockPublicIpInternetServiceNodes.new({}, self)
+        end
+
+        def monitor
+          nil
+        end
+
+        def backup_service
+          self[:backup_service]
+        end
+      end
+
+      class MockPublicIpInternetServiceNodes < Base
+        def href
+          _parent.href + "/nodeServices"
+        end
+
+        def items
+          @items ||= [].tap do |node_array|
+            node_array.instance_variable_set("@default_port", _parent.port)
+
+            def node_array.<<(node)
+              node[:port] ||= @default_port
+              super
+            end
+          end
+        end
+      end
+
+      class MockPublicIpInternetServiceNode < Base
+        def ip_address
+          self[:ip_address]
+        end
+
+        def name
+          self[:name] || "Public IP Service Node #{object_id}"
+        end
+
+        def description
+          self[:description] || "Description for Public IP Service Node #{name}"
+        end
+
+        def port
+          self[:port]
+        end
+
+        def enabled
+          self[:enabled].to_s.downcase != "false"
+        end
+
+        def enabled=(new_value)
+          self[:enabled] = new_value
+        end
+      end
+    end
+  end
+end
+
+
+module Fog
+  module Ecloud
+    class Model < Fog::Model
+
+      attr_accessor :loaded
+      alias_method :loaded?, :loaded
+
+      def reload
+        instance = super
+        @loaded = true
+        instance
+      end
+
+      def load_unless_loaded!
+        unless @loaded
+          reload
+        end
+      end
+
+    end
+  end
+end
+
+module Fog
+  module Ecloud
+    class Compute < Fog::Service
+
+      class UnsupportedVersion < Exception ; end
+
+      requires   :ecloud_username, :ecloud_password, :ecloud_versions_uri
+      recognizes :ecloud_version
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/ecloud'
+      model :catalog_item
+      model :catalog
+      model :firewall_acl
+      collection :firewall_acls
+      model :internet_service
+      collection :internet_services
+      model :backup_internet_service
+      collection :backup_internet_services
+      model :ip
+      collection :ips
+      model :network
+      collection :networks
+      model :node
+      collection :nodes
+      model :public_ip
+      collection :public_ips
+      model :server
+      collection :servers
+      model :task
+      collection :tasks
+      model :vdc
+      collection :vdcs
+
+      request_path 'fog/compute/requests/ecloud'
+      request :add_internet_service
+      request :add_backup_internet_service
+      request :add_node
+      request :clone_vapp
+      request :configure_internet_service
+      request :configure_network
+      request :configure_network_ip
+      request :configure_node
+      request :configure_vapp
+      request :delete_internet_service
+      request :delete_node
+      request :delete_vapp
+      request :get_catalog
+      request :get_catalog_item
+      request :get_customization_options
+      request :get_firewall_acls
+      request :get_firewall_acl
+      request :get_internet_services
+      request :get_network
+      request :get_network_ip
+      request :get_network_ips
+      request :get_network_extensions
+      request :get_organization
+      request :get_node
+      request :get_nodes
+      request :get_public_ip
+      request :get_public_ips
+      request :get_task
+      request :get_task_list
+      request :get_vapp
+      request :get_vapp_template
+      request :get_vdc
+      request :get_versions
+      request :instantiate_vapp_template
+      request :login
+      request :power_off
+      request :power_on
+      request :power_reset
+      request :power_shutdown
+
+      module Shared
+
+        attr_reader :versions_uri
+
+        def default_organization_uri
+          @default_organization_uri ||= begin
+            unless @login_results
+              do_login
+            end
+            case @login_results.body[:Org]
+            when Array
+              @login_results.body[:Org].first[:href]
+            when Hash
+              @login_results.body[:Org][:href]
+            else
+              nil
+            end
+          end
+        end
+
+        # login handles the auth, but we just need the Set-Cookie
+        # header from that call.
+        def do_login
+          @login_results = login
+          @cookie = @login_results.headers['Set-Cookie']
+        end
+
+        def ecloud_xmlns
+          {
+            "xmlns"     => "urn:tmrk:eCloudExtensions-2.6",
+            "xmlns:i"   => "http://www.w3.org/2001/XMLSchema-instance"
+          }
+        end
+
+        def ensure_unparsed(uri)
+          if uri.is_a?(String)
+            uri
+          else
+            uri.to_s
+          end
+        end
+
+        def supported_versions
+          @supported_versions ||= get_versions(@versions_uri).body[:VersionInfo]
+        end
+
+        def xmlns
+          { "xmlns" => "http://www.vmware.com/vcloud/v0.8",
+            "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance",
+            "xmlns:xsd" => "http://www.w3.org/2001/XMLSchema" }
+        end
+
+      end
+
+      class Mock
+        include Shared
+        include MockDataClasses
+
+        def self.base_url
+          "https://fakey.com/api/v0.8b-ext2.6"
+        end
+
+        def self.data( base_url = self.base_url )
+          @mock_data ||= MockData.new.tap do |vcloud_mock_data|
+            vcloud_mock_data.versions.clear
+            vcloud_mock_data.versions << MockVersion.new(:version => "v0.8b-ext2.6", :supported => true)
+
+            vcloud_mock_data.organizations << MockOrganization.new(:name => "Boom Inc.").tap do |mock_organization|
+              mock_organization.vdcs << MockVdc.new(:name => "Boomstick").tap do |mock_vdc|
+                mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 0").tap do |mock_catalog_item|
+                  mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+                end
+                mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 1").tap do |mock_catalog_item|
+                  mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+                end
+                mock_vdc.catalog.items << MockCatalogItem.new(:name => "Item 2").tap do |mock_catalog_item|
+                  mock_catalog_item.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+                end
+
+                mock_vdc.networks << MockNetwork.new({ :subnet => "1.2.3.0/24" }, mock_vdc)
+                mock_vdc.networks << MockNetwork.new({ :subnet => "4.5.6.0/24" }, mock_vdc)
+
+                mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Broom 1", :ip => "1.2.3.3" }, mock_vdc)
+                mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Broom 2", :ip => "1.2.3.4" }, mock_vdc)
+                mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Email!", :ip => "1.2.3.10" }, mock_vdc)
+              end
+
+              mock_organization.vdcs << MockVdc.new(:name => "Rock-n-Roll", :storage_allocated => 150, :storage_used => 40, :cpu_allocated => 1000, :memory_allocated => 2048).tap do |mock_vdc|
+                mock_vdc.networks << MockNetwork.new({ :subnet => "7.8.9.0/24" }, mock_vdc)
+
+                mock_vdc.virtual_machines << MockVirtualMachine.new({ :name => "Master Blaster", :ip => "7.8.9.10" }, mock_vdc)
+              end
+            end
+
+            vcloud_mock_data.organizations.detect {|o| o.name == "Boom Inc." }.tap do |mock_organization|
+              mock_organization.vdcs.detect {|v| v.name == "Boomstick" }.tap do |mock_vdc|
+                mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.2.3").tap do |mock_public_ip|
+                  mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                        :protocol => "HTTP",
+                                                                                                        :port => 80,
+                                                                                                        :name => "Web Site",
+                                                                                                        :description => "Web Servers",
+                                                                                                        :redirect_url => "http://fakey.com"
+                                                                                                      }, mock_public_ip.internet_service_collection
+                                                                                                      ).tap do |mock_public_ip_service|
+                    mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.5", :name => "Test Node 1", :description => "web 1"}, mock_public_ip_service.node_collection)
+                    mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.6", :name => "Test Node 2", :description => "web 2"}, mock_public_ip_service.node_collection)
+                    mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({:ip_address => "1.2.3.7", :name => "Test Node 3", :description => "web 3"}, mock_public_ip_service.node_collection)
+                  end
+
+                  mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                        :protocol => "TCP",
+                                                                                                        :port => 7000,
+                                                                                                        :name => "An SSH Map",
+                                                                                                        :description => "SSH 1"
+                                                                                                      }, mock_public_ip.internet_service_collection
+                                                                                                      ).tap do |mock_public_ip_service|
+                    mock_public_ip_service.node_collection.items << MockPublicIpInternetServiceNode.new({ :ip_address => "1.2.3.5", :port => 22, :name => "SSH", :description => "web ssh" }, mock_public_ip_service.node_collection)
+                  end
+                end
+
+                mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.2.4").tap do |mock_public_ip|
+                  mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                        :protocol => "HTTP",
+                                                                                                        :port => 80,
+                                                                                                        :name => "Web Site",
+                                                                                                        :description => "Web Servers",
+                                                                                                        :redirect_url => "http://fakey.com"
+                                                                                                      }, mock_public_ip.internet_service_collection
+                                                                                                      )
+
+                  mock_public_ip.internet_service_collection.items << MockPublicIpInternetService.new({
+                                                                                                        :protocol => "TCP",
+                                                                                                        :port => 7000,
+                                                                                                        :name => "An SSH Map",
+                                                                                                        :description => "SSH 2"
+                                                                                                      }, mock_public_ip.internet_service_collection
+                                                                                                      )
+                end
+
+                mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.1.9.7")
+
+                mock_vdc.internet_service_collection.backup_internet_services << MockBackupInternetService.new({ :port => 10000, :protocol => "TCP"}, self)
+              end
+
+              mock_organization.vdcs.detect {|v| v.name == "Rock-n-Roll" }.tap do |mock_vdc|
+                mock_vdc.public_ip_collection.items << MockPublicIp.new(:name => "99.99.99.99")
+              end
+            end
+
+            vcloud_mock_data.organizations.each do |organization|
+              organization.vdcs.each do |vdc|
+                vdc.networks.each do |network|
+                  network[:rnat] = vdc.public_ip_collection.items.first.name
+                end
+                vdc.virtual_machines.each do |virtual_machine|
+                  virtual_machine.disks << MockVirtualMachineDisk.new(:size => 25 * 1024)
+                  virtual_machine.disks << MockVirtualMachineDisk.new(:size => 50 * 1024)
+                end
+              end
+            end
+          end
+        end
+
+        def self.reset
+          @mock_data = nil
+        end
+
+        def self.data_reset
+          Formatador.display_line("[yellow][WARN] #{self} => #data_reset is deprecated, use #reset instead[/] [light_black](#{caller.first})[/]")
+          self.reset
+        end
+
+        def initialize(options = {})
+          require 'builder'
+          require 'fog/core/parser'
+
+          @versions_uri = URI.parse('https://vcloud.fakey.com/api/versions')
+        end
+
+        def mock_data
+          Fog::Ecloud::Compute::Mock.data
+        end
+
+        def mock_error(expected, status, body='', headers={})
+          raise Excon::Errors::Unauthorized.new("Expected(#{expected}) <=> Actual(#{status})")
+        end
+
+        def mock_it(status, mock_data, mock_headers = {})
+          response = Excon::Response.new
+
+          #Parse the response body into a hash
+          if mock_data.empty?
+            response.body = mock_data
+          else
+            document = Fog::ToHashDocument.new
+            parser = Nokogiri::XML::SAX::PushParser.new(document)
+            parser << mock_data
+            parser.finish
+            response.body = document.body
+          end
+
+          response.status = status
+          response.headers = mock_headers
+          response
+        end
+
+      end
+
+      class Real
+        include Shared
+
+        class << self
+
+          def basic_request(*args)
+            self.class_eval <<-EOS, __FILE__,__LINE__
+              def #{args[0]}(uri)
+                request({
+                  :expects => #{args[1] || 200},
+                  :method  => '#{args[2] || 'GET'}',
+                  :headers => #{args[3] ? args[3].inspect : '{}'},
+                  :body => '#{args[4] ? args[4] : ''}',
+                  :parse => true,
+                  :uri     => uri })
+              end
+            EOS
+          end
+
+          def unauthenticated_basic_request(*args)
+            self.class_eval <<-EOS, __FILE__,__LINE__
+              def #{args[0]}(uri)
+                unauthenticated_request({
+                  :expects => #{args[1] || 200},
+                  :method  => '#{args[2] || 'GET'}',
+                  :headers => #{args[3] ? args[3].inspect : '{}'},
+                  :parse => true,
+                  :uri     => uri })
+              end
+            EOS
+          end
+
+        end
+
+        def initialize(options = {})
+          require 'builder'
+          require 'fog/core/parser'
+
+          @connections = {}
+          @versions_uri = URI.parse(options[:ecloud_versions_uri])
+          @version = options[:ecloud_version]
+          @username = options[:ecloud_username]
+          @password = options[:ecloud_password]
+          @persistent = options[:persistent]
+        end
+
+        def default_organization_uri
+          @default_organization_uri ||= begin
+            unless @login_results
+              do_login
+            end
+            case @login_results.body[:Org]
+            when Array
+              @login_results.body[:Org].first[:href]
+            when Hash
+              @login_results.body[:Org][:href]
+            else
+              nil
+            end
+          end
+        end
+
+        def reload
+          @connections.each_value { |k,v| v.reset if v }
+        end
+
+        # If the cookie isn't set, do a get_organizations call to set it
+        # and try the request.
+        # If we get an Unauthorized error, we assume the token expired, re-auth and try again
+        def request(params)
+          unless @cookie
+            do_login
+          end
+          begin
+            do_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            do_login
+            do_request(params)
+          end
+        end
+
+        def supporting_versions
+          ["v0.8b-ext2.6", "0.8b-ext2.6"]
+        end
+
+        private
+
+        def ensure_parsed(uri)
+          if uri.is_a?(String)
+            URI.parse(uri)
+          else
+            uri
+          end
+        end
+
+        def supported_version_numbers
+          case supported_versions
+          when Array
+            supported_versions.map { |version| version[:Version] }
+          when Hash
+            [ supported_versions[:Version] ]
+          end
+        end
+
+        def get_login_uri
+          check_versions
+          URI.parse case supported_versions
+          when Array
+            supported_versions.detect {|version| version[:Version] == @version }[:LoginUrl]
+          when Hash
+            supported_versions[:LoginUrl]
+          end
+        end
+
+        # If we don't support any versions the service does, then raise an error.
+        # If the @version that super selected isn't in our supported list, then select one that is.
+        def check_versions
+          if @version
+            unless supported_version_numbers.include?(@version.to_s)
+              raise UnsupportedVersion.new("#{@version} is not supported by the server.")
+            end
+            unless supporting_versions.include?(@version.to_s)
+              raise UnsupportedVersion.new("#{@version} is not supported by #{self.class}")
+            end
+          else
+            unless @version = (supported_version_numbers & supporting_versions).sort.first
+              raise UnsupportedVersion.new("\nService @ #{@versions_uri} supports: #{supported_version_numbers.join(', ')}\n" +
+                                           "#{self.class} supports: #{supporting_versions.join(', ')}")
+            end
+          end
+        end
+
+        # Don't need to  set the cookie for these or retry them if the cookie timed out
+        def unauthenticated_request(params)
+          do_request(params)
+        end
+
+        # Use this to set the Authorization header for login
+        def authorization_header
+          "Basic #{Base64.encode64("#{@username}:#{@password}").chomp!}"
+        end
+
+        def login_uri
+          @login_uri ||= get_login_uri
+        end
+
+        # login handles the auth, but we just need the Set-Cookie
+        # header from that call.
+        def do_login
+          @login_results = login
+          @cookie = @login_results.headers['Set-Cookie']
+        end
+
+        # Actually do the request
+        def do_request(params)
+          # Convert the uri to a URI if it's a string.
+          if params[:uri].is_a?(String)
+            params[:uri] = URI.parse(params[:uri])
+          end
+          host_url = "#{params[:uri].scheme}://#{params[:uri].host}#{params[:uri].port ? ":#{params[:uri].port}" : ''}"
+
+          # Hash connections on the host_url ... There's nothing to say we won't get URI's that go to
+          # different hosts.
+          @connections[host_url] ||= Fog::Connection.new(host_url, @persistent)
+
+          # Set headers to an empty hash if none are set.
+          headers = params[:headers] || {}
+
+          # Add our auth cookie to the headers
+          if @cookie
+            headers.merge!('Cookie' => @cookie)
+          end
+
+          # Make the request
+          response = @connections[host_url].request({
+            :body     => params[:body] || '',
+            :expects  => params[:expects] || 200,
+            :headers  => headers,
+            :method   => params[:method] || 'GET',
+            :path     => params[:uri].path
+          })
+
+          # Parse the response body into a hash
+          #puts response.body
+          unless response.body.empty?
+            if params[:parse]
+              document = Fog::ToHashDocument.new
+              parser = Nokogiri::XML::SAX::PushParser.new(document)
+              parser << response.body
+              parser.finish
+
+              response.body = document.body
+            end
+          end
+
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/go_grid.rb b/vendor/fog-0.8.2/lib/fog/compute/go_grid.rb
new file mode 100644
index 0000000..8788480
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/go_grid.rb
@@ -0,0 +1,127 @@
+module Fog
+  module GoGrid
+    class Compute < Fog::Service
+
+      requires :go_grid_api_key, :go_grid_shared_secret
+      recognizes :host, :path, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/go_grid'
+      model         :image
+      collection    :images
+      model         :server
+      collection    :servers
+      model         :password
+      collection    :passwords
+
+      request_path 'fog/compute/requests/go_grid'
+      request :common_lookup_list
+      request :grid_image_get
+      request :grid_image_list
+      request :grid_ip_list
+      request :grid_loadbalancer_list
+      request :grid_server_add
+      request :grid_server_delete
+      request :grid_server_get
+      request :grid_server_list
+      request :grid_server_power
+      request :support_password_get
+      request :support_password_list
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::GoGrid::Compute.new is deprecated, use Fog::Compute.new(:provider => 'GoGrid') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+        end
+
+        def data
+          self.class.data[@go_grid_api_key]
+        end
+
+        def reset_data
+          self.class.data.delete(@go_grid_api_key)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::GoGrid::Compute.new is deprecated, use Fog::Compute.new(:provider => 'GoGrid') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'digest/md5'
+          require 'json'
+          @go_grid_api_key = options[:go_grid_api_key]
+          @go_grid_shared_secret = options[:go_grid_shared_secret]
+          @host   = options[:host]    || "api.gogrid.com"
+          @path   = options[:path]    || "/api"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params = {
+            :expects  => 200,
+            :method   => 'GET'
+          }.merge!(params)
+
+          params[:query] ||= {}
+          params[:query].merge!({
+            'api_key' => @go_grid_api_key,
+            'format'  => 'json',
+            'sig'     => Digest::MD5.hexdigest("#{@go_grid_api_key}#{@go_grid_shared_secret}#{Time.now.to_i}"),
+            'v'       => '1.5'
+          })
+
+          begin
+            response = @connection.request(
+              params.merge!(:path => "#{@path}/#{params[:path]}")
+            )
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::GoGrid::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/linode.rb b/vendor/fog-0.8.2/lib/fog/compute/linode.rb
new file mode 100644
index 0000000..23bbaf8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/linode.rb
@@ -0,0 +1,131 @@
+module Fog
+  module Linode
+    class Compute < Fog::Service
+
+      requires :linode_api_key
+      recognizes :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/linode'
+      model :flavor
+      collection :flavors
+      model :image
+      collection :images
+      model :server
+      collection :servers
+      model :kernel
+      collection :kernels
+      model :data_center
+      collection :data_centers
+      model :stack_script
+      collection :stack_scripts
+      model :ip
+      collection :ips
+      model :disk
+      collection :disks
+
+      request_path 'fog/compute/requests/linode'
+      request :avail_datacenters
+      request :avail_distributions
+      request :avail_kernels
+      request :avail_linodeplans
+      request :avail_stackscripts
+      request :linode_disk_create
+      request :linode_disk_list
+      request :linode_disk_delete
+      request :linode_disk_createfromdistribution
+      request :linode_disk_createfromstackscript     
+      request :linode_ip_list
+      request :linode_ip_addprivate
+      request :linode_config_list
+      request :linode_config_create
+      request :linode_create
+      request :linode_delete
+      request :linode_list
+      request :linode_boot
+      request :linode_reboot
+      request :linode_shutdown
+      request :linode_update
+      request :stackscript_list
+      # request :linode_resize      
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Linode::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Linode') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @linode_api_key = options[:linode_api_key]
+        end
+
+        def data
+          self.class.data[@linode_api_key]
+        end
+
+        def reset_data
+          self.class.data.delete(@linode_api_key)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Linode::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Linode') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+          @linode_api_key = options[:linode_api_key]
+          @host   = options[:host]    || "api.linode.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!(:api_key => @linode_api_key)
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+            if data = response.body['ERRORARRAY'].first
+              error = case data['ERRORCODE']
+              when 5
+                Fog::Linode::Compute::NotFound
+              else
+                Fog::Linode::Compute::Error
+              end
+              raise error.new(data['ERRORMESSAGE'])
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/address.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/address.rb
new file mode 100644
index 0000000..b978d1b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/address.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Address < Fog::Model
+
+        identity  :public_ip, :aliases => 'publicIp'
+
+        attribute :server_id, :aliases => 'instanceId'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :public_ip
+
+          connection.release_address(public_ip)
+          true
+        end
+
+        def server=(new_server)
+          if new_server
+            associate(new_server)
+          else
+            disassociate
+          end
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          data = connection.allocate_address.body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        private
+
+        def associate(new_server)
+          if new_record?
+            @server = new_server
+          else
+            @server = nil
+            self.server_id = new_server.id
+            connection.associate_address(server_id, public_ip)
+          end
+        end
+
+        def disassociate
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.disassociate_address(public_ip)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/addresses.rb
new file mode 100644
index 0000000..aab7a3b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/addresses.rb
@@ -0,0 +1,100 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws//address'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Addresses < Fog::Collection
+
+        attribute :filters
+        attribute :server
+
+        model Fog::AWS::Compute::Address
+
+        # Used to create an IP address
+        #
+        # ==== Returns
+        #
+        #>> AWS.addresses.create
+        #  <Fog::AWS::Compute::Address
+        #    public_ip="4.88.524.95",
+        #    server_id=nil
+        #  >
+        #
+        # The IP address can be retreived by running AWS.addresses.get("test").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # AWS.addresses.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all IP addresses
+        #
+        #>> AWS.addresses.all
+        #  <Fog::AWS::Compute::Addresses
+        #    filters={},
+        #    server=nil
+        #    [
+        #      <Fog::AWS::Compute::Address
+        #        public_ip="76.7.46.54",
+        #        server_id=nil
+        #      >,
+        #      .......
+        #      <Fog::AWS::Compute::Address
+        #        public_ip="4.88.524.95",
+        #        server_id=nil
+        #      >
+        #    ]
+        #  >
+        #>>
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_addresses(filters).body
+          load(
+            data['addressesSet'].map do |address|
+              address.reject {|key, value| value.nil? || value.empty? }
+            end
+          )
+          if server
+            self.replace(self.select {|address| address.server_id == server.id})
+          end
+          self
+        end
+
+        # Used to retreive an IP address
+        #
+        # public_ip is required to get the associated IP information.
+        #
+        # You can run the following command to get the details:
+        # AWS.addresses.get("76.7.46.54")
+
+        def get(public_ip)
+          if public_ip
+            self.class.new(:connection => connection).all('public-ip' => public_ip).first
+          end
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super(attributes)
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavor.rb
new file mode 100644
index 0000000..78ae6ee
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavor.rb
@@ -0,0 +1,21 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :bits
+        attribute :cores
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavors.rb
new file mode 100644
index 0000000..449d090
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/flavors.rb
@@ -0,0 +1,167 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/flavor'
+
+module Fog
+  module AWS
+    class Compute
+
+      FLAVORS = [
+        { :bits => 0,  :cores =>   2,  :disk => 0,    :id =>  't1.micro',   :name => 'Micro Instance',       :ram => 613},
+
+        { :bits => 32, :cores =>   1,  :disk => 160,  :id =>  'm1.small',   :name => 'Small Instance',       :ram => 1740.8},
+        { :bits => 64, :cores =>   4,  :disk => 850,  :id =>  'm1.large',   :name => 'Large Instance',       :ram => 7680},
+        { :bits => 64, :cores =>   8,  :disk => 1690, :id =>  'm1.xlarge',  :name => 'Extra Large Instance', :ram => 15360},
+
+        { :bits => 32, :cores =>   5,  :disk => 350,  :id =>  'c1.medium',  :name => 'High-CPU Medium',      :ram => 1740.8},
+        { :bits => 64, :cores =>  20,  :disk => 1690, :id =>  'c1.xlarge',  :name => 'High-CPU Extra Large', :ram => 7168},
+
+        { :bits => 64, :cores =>  6.5, :disk => 420,  :id =>  'm2.xlarge',  :name => 'High-Memory Extra Large',           :ram => 17510.4},
+        { :bits => 64, :cores =>   13, :disk => 850,  :id =>  'm2.2xlarge', :name => 'High Memory Double Extra Large',    :ram => 35020.8},
+        { :bits => 64, :cores =>   26, :disk => 1690, :id =>  'm2.4xlarge', :name => 'High Memory Quadruple Extra Large', :ram => 70041.6},
+
+        { :bits => 64, :cores => 33.5, :disk => 1690, :id => 'cc1.4xlarge', :name => 'Cluster Compute Quadruple Extra Large', :ram => 23552},
+        { :bits => 64, :cores => 33.5, :disk => 1690, :id => 'cg1.4xlarge', :name => 'Cluster GPU Quadruple Extra Large',     :ram => 22528}
+      ]
+
+      class Flavors < Fog::Collection
+
+        model Fog::AWS::Compute::Flavor
+
+        # Returns an array of all flavors that have been created
+        #
+        # AWS.flavors.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all available instance sizes
+        #
+        #>> AWS.flavors.all
+        #  <Fog::AWS::Compute::Flavors
+        #    [
+        #      <Fog::AWS::Compute::Flavor
+        #        id="t1.micro",
+        #        bits=0,
+        #        cores=2,
+        #        disk=0,
+        #        name="Micro Instance",
+        #        ram=613
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.small",
+        #        bits=32,
+        #        cores=1,
+        #        disk=160,
+        #        name="Small Instance",
+        #        ram=1740.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.large",
+        #        bits=64,
+        #        cores=4,
+        #        disk=850,
+        #        name="Large Instance",
+        #        ram=7680
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m1.xlarge",
+        #        bits=64,
+        #        cores=8,
+        #        disk=1690,
+        #        name="Extra Large Instance",
+        #        ram=15360
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="c1.medium",
+        #        bits=32,
+        #        cores=5,
+        #        disk=350,
+        #        name="High-CPU Medium",
+        #        ram=1740.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="c1.xlarge",
+        #        bits=64,
+        #        cores=20,
+        #        disk=1690,
+        #        name="High-CPU Extra Large",
+        #        ram=7168
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.xlarge",
+        #        bits=64,
+        #        cores=6.5,
+        #        disk=420,
+        #        name="High-Memory Extra Large",
+        #        ram=17510.4
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.2xlarge",
+        #        bits=64,
+        #        cores=13,
+        #        disk=850,
+        #        name="High Memory Double Extra Large",
+        #        ram=35020.8
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="m2.4xlarge",
+        #        bits=64,
+        #        cores=26,
+        #        disk=1690,
+        #        name="High Memory Quadruple Extra Large",
+        #        ram=70041.6
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="cc1.4xlarge",
+        #        bits=64,
+        #        cores=33.5,
+        #        disk=1690,
+        #        name="Cluster Compute Quadruple Extra Large",
+        #        ram=23552
+        #      >,
+        #      <Fog::AWS::Compute::Flavor
+        #        id="cg1.4xlarge",
+        #        bits=64,
+        #        cores=33.5,
+        #        disk=1690,
+        #        name="Cluster GPU Quadruple Extra Large",
+        #        ram=22528
+        #      >
+        #    ]
+        #  >
+        #
+
+        def all
+          load(Fog::AWS::Compute::FLAVORS)
+          self
+        end
+
+        # Used to retreive a flavor
+        # flavor_id is required to get the associated flavor information.
+        # flavors available currently:
+        # 't1.micro', 'm1.small', 'm1.large', 'm1.xlarge', 'c1.medium', 'c1.xlarge', 'm2.xlarge', 'm2.2xlarge', 'm2.4xlarge', 'cc1.4xlarge', 'cg1.4xlarge'
+        #
+        # You can run the following command to get the details:
+        # AWS.flavors.get("t1.micro")
+        #
+        # ==== Returns
+        #
+        #>> AWS.flavors.get("t1.micro")
+        # <Fog::AWS::Compute::Flavor
+        #  id="t1.micro",
+        #  bits=0,
+        #  cores=2,
+        #  disk=0,
+        #  name="Micro Instance",
+        #  ram=613
+        #>
+        #
+
+        def get(flavor_id)
+          self.class.new(:connection => connection).all.detect {|flavor| flavor.id == flavor_id}
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/image.rb
new file mode 100644
index 0000000..abcf983
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/image.rb
@@ -0,0 +1,43 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id,                     :aliases => 'imageId'
+
+        attribute :architecture
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :description
+        attribute :location,              :aliases => 'imageLocation'
+        attribute :owner_id,              :aliases => 'imageOwnerId'
+        attribute :state,                 :aliases => 'imageState'
+        attribute :type,                  :aliases => 'imageType'
+        attribute :is_public,             :aliases => 'isPublic'
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :platform
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+        attribute :tags,                  :aliases => 'tagSet'
+        attribute :name
+
+        def deregister(delete_snapshot = false)
+          connection.deregister_image(id)
+
+          if(delete_snapshot && root_device_type == "ebs")
+            block_device = block_device_mapping.detect {|block_device| block_device['deviceName'] == root_device_name}
+            @connection.snapshots.new(:id => block_device['snapshotId']).destroy
+          else
+            true
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/images.rb
new file mode 100644
index 0000000..c52a244
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/images.rb
@@ -0,0 +1,62 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/image'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Images < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Image
+        
+        # Creates a new Amazon machine image
+        #
+        # AWS.images.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new image
+        #
+        #>> AWS.images.new
+        #  <Fog::AWS::Compute::Image
+        #    id=nil,
+        #    architecture=nil,
+        #    block_device_mapping=nil,
+        #    location=nil,
+        #    owner_id=nil,
+        #    state=nil,
+        #    type=nil,
+        #    is_public=nil,
+        #    kernel_id=nil,
+        #    platform=nil,
+        #    product_codes=nil,
+        #    ramdisk_id=nil,
+        #    root_device_type=nil,
+        #    root_device_name=nil,
+        #    tags=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_images(filters).body
+          load(data['imagesSet'])
+        end
+        
+        def get(image_id)
+          if image_id
+            self.class.new(:connection => connection).all('image-id' => image_id).first
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pair.rb
new file mode 100644
index 0000000..d62adb8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pair.rb
@@ -0,0 +1,60 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPair < Fog::Model
+
+        identity  :name,        :aliases => 'keyName'
+
+        attribute :fingerprint, :aliases => 'keyFingerprint'
+        attribute :private_key, :aliases => 'keyMaterial'
+
+        attr_accessor :public_key
+
+        def destroy
+          requires :name
+
+          connection.delete_key_pair(name)
+          true
+        end
+
+        def save
+          requires :name
+
+          data = if public_key
+            connection.import_key_pair(name, public_key).body
+          else
+            connection.create_key_pair(name).body
+          end
+          new_attributes = data.reject {|key,value| !['keyFingerprint', 'keyMaterial', 'keyName'].include?(key)}
+          merge_attributes(new_attributes)
+          true
+
+        end
+
+        def write(path="#{ENV['HOME']}/.ssh/fog_#{Fog.credential.to_s}_#{name}.pem")
+          
+          if writable?
+            split_private_key = private_key.split(/\n/)
+            File.open(path, "w") do |f|
+              split_private_key.each {|line| f.puts line}
+              f.chmod 0600
+            end
+            "Key file built: #{path}"
+          else
+            "Invalid private key"
+          end
+        end
+
+        def writable?
+          !!(private_key && ENV.has_key?('HOME'))
+        end
+
+          private
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pairs.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pairs.rb
new file mode 100644
index 0000000..ab90fbf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/key_pairs.rb
@@ -0,0 +1,88 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/key_pair'
+
+module Fog
+  module AWS
+    class Compute
+
+      class KeyPairs < Fog::Collection
+
+        attribute :filters
+        attribute :key_name
+
+        model Fog::AWS::Compute::KeyPair
+
+        # Used to create a key pair.  There are 3 arguments and only name is required.  You can generate a new key_pair as follows:
+        # AWS.key_pairs.create(:name => "test", :fingerprint => "123", :private_key => '234234')
+        #
+        # ==== Returns
+        #
+        #<Fog::AWS::Compute::KeyPair
+        #  name="test",
+        #  fingerprint="3a:d3:e5:17:e5:e7:f7:de:fe:db:1b:c2:55:7d:94:0b:07:2e:05:aa",
+        #  private_key="-----BEGIN RSA PRIVATE KEY-----\nf/VtfXJ/ekTSlRS2GSItBSzMrEGoZ+EXeMOuiA7HFkDcgKt6aBiOX9Bysiyfc1rIrgWdFKqXBRJA\nrtvBPa3/32koMPV4FxG7RZrPuKLITmFoEV86M0DSLo+ErlOPuDChfrR9dk6eI17/o1VmSvYsIpDc\njvbgx+tt7ZEPvduoUag7YdnUI0f20fttsdXjMlyDg9pPOVF3/hqucqOb3t5y9lvVJJxdTnEDFSjb\nvodpaDT9+ssw4IsQsZEIvfL0hK+Lt4phbclUWfG7JVnYfdd2u4zU6Nqe0+3qoR0ZOH4/zaUko7z8\n7JMbJqs5bmdWfnQTrvbJ13545FRI/W48ZRJxqPcj0t2MzasbT4gMgtNJrSadq78RkRJjNTu4lZmK\nvJejkBZPicHvo5IRSEbDc90Rhdh0aZNifXn0d0DSV2N6Ywo2o1lwRAi3/l6XSjukyRpTPcMr14MP\ntGwS1Tvez41Oa7Y96VfsJB2xtKc6LGRFiPUg2ZAEHU15Q9bIISVzHXgdAcef1bsh8UN/fDBrTusm\nvJisQ+dLaPH7cZ03od+XTwJc+IyeL4RqWuASE0NNfEVJMS+qcpt0WeNzfG0C27SwIcfEKL0sC0kn\nCfX2WpZDg7T5xN+88ftKJaN9tymxTgvoJVS1/WKvWBAXVozKp4f6K8wKmwf7VdUt/FWbUi54LW02\nf1ONkaYEOVwDgWlGxVSx43MWqvVdT2MPFNEBL7OA1LPwCO2nyQQ9UM9gCE65S9Najf939Bq8xwqx\nGNFlLmaH6biZUyL8ewRJ8Y7rMQ5cXy/gHZywjkuoyLQ8vVpmVpb7r1FaM/AYSr5l6gJEWdqbJleN\ntnhjPeE6qXISzIUBvwKzzgFTyW8ZHQtgbP3bHEiPG2/OjKHnLUoOId/eetcE+ovIxWsBrTDbf2SV\nYUD91u+W9K35eX89ZaIiohLNg4z9+QHCs4rcWyOXEfprBKcP2QU5+Y9ysnXLAmZt6QhInaAsUpQZ\nyhImA24UqvqrK0yyGhf/quouK7q0QkVQR+f7nGClIaphJkxO/xylrnK/pYObr4s3B8kmksuHiYOu\n1yz6SeRkj8F9dxkRmzbBK/G0tLkxIElDbM7icI9gsEO7vvgaR/K8hSDi0RkFPG43I20tU8PqwHe7\nR4jFW+6sB2+9FDeLn+qkoDSaxzmAuIRW082z/r7rJVIpFEo14hNhQYkNXpH40+P/hA9RFgvhZe8M\nvK4rz/eu246Kij6kObieTfpZhgGHqvtU8x5cnqEZOz5Hc5m4B+gMaTA53kFSPOA0pn6gqgiuYEdI\nZUhO8P1PkNqkmLz7NJRnz3qpAo6RisAxPBVr2WdSg4bP0YpGS/0TE4OOJwGLldx6dCsX60++mn0q\n1fhNw8oyZiguYMAeEEDWP8x/bsRaFz5L8uQVnnnj8ei1oTmZ+Uw9/48snWYcurL2jsbuWhhE0NTt\nfe/cqov7ZaZHs+Tr20ZBEDEqUEWr/MMskj/ZSVxnza1G/hztFJMAThF9ZJoGQkHWHfXCGOLLGY+z\nqi0SC8EIeu8PUxjO2SRj9S9o/Dwg3iHyM3pj57kD7fDNnl3Ed6LMoCXoaQV8BdMX4xh=\n-----END RSA PRIVATE KEY-----"
+        #>
+        #
+        # The key_pair can be retreived by running AWS.key_pairs.get("test").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # Returns an array of all key pairs that have been created
+        #
+        # AWS.key_pairs.all
+        #
+        # ==== Returns
+        #
+        # <Fog::AWS::Compute::KeyPairs
+        #  key_name=nil
+        #  [
+        #    <Fog::AWS::Compute::KeyPair
+        #      name="test",
+        #      fingerprint="1f:26:3d:83:e7:4f:48:74:c3:1c:e6:b3:c7:f6:ec:d8:cb:09:b3:7f",
+        #      private_key=nil
+        #    >
+        #  ]
+        #>
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_key_pairs(filters).body
+          load(data['keySet'])
+        end
+
+        # Used to retreive a key pair that was created with the AWS.key_pairs.create method.
+        # The name is required to get the associated key_pair information.
+        #
+        # You can run the following command to get the details:
+        # AWS.key_pairs.get("test")
+        #
+        # ==== Returns
+        #
+        #>> AWS.key_pairs.get("test")
+        #  <Fog::AWS::Compute::KeyPair
+        #    name="test",
+        #    fingerprint="1f:26:3d:83:e7:4f:48:74:c3:1c:e6:b3:c7:f6:ec:d8:cb:09:b3:7f",
+        #    private_key=nil
+        #  >
+        #
+
+        def get(key_name)
+          if key_name
+            self.class.new(:connection => connection).all('key-name' => key_name).first
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_group.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_group.rb
new file mode 100644
index 0000000..ede5242
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_group.rb
@@ -0,0 +1,205 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroup < Fog::Model
+
+        identity  :name,            :aliases => 'groupName'
+
+        attribute :description,     :aliases => 'groupDescription'
+        attribute :ip_permissions,  :aliases => 'ipPermissions'
+        attribute :owner_id,        :aliases => 'ownerId'
+
+        # Authorize access by another security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.authorize_group_and_owner("some_group_name", "1234567890")
+        #
+        # == Parameters:
+        # group::
+        #   The name of the security group you're granting access to.
+        #
+        # owner::
+        #   The owner id for security group you're granting access to.
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def authorize_group_and_owner(group, owner)
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        # Authorize a new port range for a security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.authorize_port_range(20..21)
+        #
+        # == Parameters:
+        # range::
+        #   A Range object representing the port range you want to open up. E.g., 20..21
+        #
+        # options::
+        #   A hash that can contain any of the following keys:
+        #    :cidr_ip (defaults to "0.0.0.0/0")
+        #    :ip_protocol (defaults to "tcp")
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def authorize_port_range(range, options = {})
+          requires :name
+
+          connection.authorize_security_group_ingress(
+            name,
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        # Removes an existing security group
+        #
+        # security_group.destroy
+        #
+        # ==== Returns
+        #
+        # True or false depending on the result
+        #
+
+        def destroy
+          requires :name
+
+          connection.delete_security_group(name)
+          true
+        end
+
+        # Revoke access by another security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.revoke_group_and_owner("some_group_name", "1234567890")
+        #
+        # == Parameters:
+        # group::
+        #   The name of the security group you're revoking access to.
+        #
+        # owner::
+        #   The owner id for security group you're revoking access access to.
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def revoke_group_and_owner(group, owner)
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            name,
+            'SourceSecurityGroupName'     => group,
+            'SourceSecurityGroupOwnerId'  => owner
+          )
+        end
+
+        # Revoke an existing port range for a security group
+        #
+        #  >> g = AWS.security_groups.all(:description => "something").first
+        #  >> g.revoke_port_range(20..21)
+        #
+        # == Parameters:
+        # range::
+        #   A Range object representing the port range you want to open up. E.g., 20..21
+        #
+        # options::
+        #   A hash that can contain any of the following keys:
+        #    :cidr_ip (defaults to "0.0.0.0/0")
+        #    :ip_protocol (defaults to "tcp")
+        #
+        # == Returns:
+        #
+        # An excon response object representing the result
+        #
+        #  <Excon::Response:0x101fc2ae0
+        #    @status=200,
+        #    @body={"requestId"=>"some-id-string",
+        #           "return"=>true},
+        #    headers{"Transfer-Encoding"=>"chunked",
+        #            "Date"=>"Mon, 27 Dec 2010 22:12:57 GMT",
+        #            "Content-Type"=>"text/xml;charset=UTF-8",
+        #            "Server"=>"AmazonEC2"}
+        #
+
+        def revoke_port_range(range, options = {})
+          requires :name
+
+          connection.revoke_security_group_ingress(
+            name,
+            'CidrIp'      => options[:cidr_ip] || '0.0.0.0/0',
+            'FromPort'    => range.min,
+            'ToPort'      => range.max,
+            'IpProtocol'  => options[:ip_protocol] || 'tcp'
+          )
+        end
+
+        # Create a security group
+        #
+        #  >> g = AWS.security_groups.new(:name => "some_name", :description => "something")
+        #  >> g.save
+        #
+        # == Returns:
+        #
+        # True or an exception depending on the result. Keep in mind that this *creates* a new security group.
+        # As such, it yields an InvalidGroup.Duplicate exception if you attempt to save an existing group.
+        #
+
+        def save
+          requires :description, :name
+
+          data = connection.create_security_group(name, description).body
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_groups.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_groups.rb
new file mode 100644
index 0000000..01a3cfd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/security_groups.rb
@@ -0,0 +1,95 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/security_group'
+
+module Fog
+  module AWS
+    class Compute
+
+      class SecurityGroups < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::SecurityGroup
+
+        # Creates a new security group
+        #
+        # AWS.security_groups.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new image
+        #
+        #>> AWS.security_groups.new
+        #  <Fog::AWS::Compute::SecurityGroup
+        #    name=nil,
+        #    description=nil,
+        #    ip_permissions=nil,
+        #    owner_id=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+        
+        # Returns an array of all security groups that have been created
+        #
+        # AWS.security_groups.all
+        #
+        # ==== Returns
+        #
+        # Returns an array of all security groups
+        #
+        #>> AWS.security_groups.all
+        #  <Fog::AWS::Compute::SecurityGroups
+        #    filters={}
+        #    [
+        #      <Fog::AWS::Compute::SecurityGroup
+        #        name="default",
+        #        description="default group",
+        #        ip_permissions=[{"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>-1, "toPort"=>-1, "ipRanges"=>[], "ipProtocol"=>"icmp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"tcp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"udp"}],
+        #        owner_id="312571045469"
+        #      >
+        #    ]
+        #  >
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_security_groups(filters).body
+          load(data['securityGroupInfo'])
+        end
+
+        # Used to retreive a security group
+        # group name is required to get the associated flavor information.
+        #
+        # You can run the following command to get the details:
+        # AWS.security_groups.get("default")
+        #
+        # ==== Returns
+        #
+        #>> AWS.security_groups.get("default")
+        #  <Fog::AWS::Compute::SecurityGroup
+        #    name="default",
+        #    description="default group",
+        #    ip_permissions=[{"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>-1, "toPort"=>-1, "ipRanges"=>[], "ipProtocol"=>"icmp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"tcp"}, {"groups"=>[{"groupName"=>"default", "userId"=>"312571045469"}], "fromPort"=>0, "toPort"=>65535, "ipRanges"=>[], "ipProtocol"=>"udp"}],
+        #    owner_id="312571045469"
+        #  > 
+        #
+        
+        def get(group_name)
+          if group_name
+            self.class.new(:connection => connection).all('group-name' => group_name).first
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/server.rb
new file mode 100644
index 0000000..f30f205
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/server.rb
@@ -0,0 +1,253 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Server < Fog::Model
+        extend Fog::Deprecation
+        deprecate :ip_address, :public_ip_address
+
+        identity  :id,                    :aliases => 'instanceId'
+
+        attr_accessor :architecture
+        attribute :ami_launch_index,      :aliases => 'amiLaunchIndex'
+        attribute :availability_zone,     :aliases => ['availabilityZone', 'placement'], :squash => 'availabilityZone'
+        attribute :block_device_mapping,  :aliases => 'blockDeviceMapping'
+        attribute :client_token,          :aliases => 'clientToken'
+        attribute :dns_name,              :aliases => 'dnsName'
+        attribute :groups
+        attribute :flavor_id,             :aliases => 'instanceType'
+        attribute :image_id,              :aliases => 'imageId'
+        attr_accessor :instance_initiated_shutdown_behavior
+        attribute :kernel_id,             :aliases => 'kernelId'
+        attribute :key_name,              :aliases => 'keyName'
+        attribute :created_at,            :aliases => 'launchTime'
+        attribute :monitoring,            :squash => 'state'
+        attribute :product_codes,         :aliases => 'productCodes'
+        attribute :private_dns_name,      :aliases => 'privateDnsName'
+        attribute :private_ip_address,    :aliases => 'privateIpAddress'
+        attribute :public_ip_address,     :aliases => 'ipAddress'
+        attribute :ramdisk_id,            :aliases => 'ramdiskId'
+        attribute :reason
+        attribute :root_device_name,      :aliases => 'rootDeviceName'
+        attribute :root_device_type,      :aliases => 'rootDeviceType'
+        attribute :state,                 :aliases => 'instanceState', :squash => 'name'
+        attribute :state_reason,          :aliases => 'stateReason'
+        attribute :subnet_id,             :aliases => 'subnetId'
+        attribute :tags,                  :aliases => 'tagSet'
+        attribute :user_data
+
+        attr_accessor :password
+        attr_writer   :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.groups     ||= ["default"] unless attributes[:subnet_id]
+          self.flavor_id  ||= 't1.micro'
+          self.image_id ||= begin
+            case attributes[:connection].instance_variable_get(:@region) # Ubuntu 10.04 LTS 64bit (EBS)
+            when 'ap-northeast-1'
+              'ami-5e0fa45f'
+            when 'ap-southeast-1'
+              'ami-f092eca2'
+            when 'eu-west-1'
+              'ami-3d1f2b49'
+            when 'us-east-1'
+              'ami-3202f25b'
+            when 'us-west-1'
+              'ami-f5bfefb0'
+            end
+          end
+          super
+        end
+
+        def addresses
+          requires :id
+
+          connection.addresses(:server => self)
+        end
+
+        def console_output
+          requires :id
+
+          connection.get_console_output(id)
+        end
+
+        def destroy
+          requires :id
+
+          connection.terminate_instances(id)
+          true
+        end
+
+        remove_method :flavor_id
+        def flavor_id
+          @flavor && @flavor.id || attributes[:flavor_id]
+        end
+
+        def flavor=(new_flavor)
+          @flavor = new_flavor
+        end
+
+        def flavor
+          @flavor ||= connection.flavors.all.detect {|flavor| flavor.id == flavor_id}
+        end
+
+        def key_pair
+          requires :key_name
+
+          connection.key_pairs.all(key_name).first
+        end
+
+        def key_pair=(new_keypair)
+          self.key_name = new_keypair && new_keypair.name
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          state == 'running'
+        end
+
+        def reboot
+          requires :id
+          connection.reboot_instances(id)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :image_id
+
+          options = {
+            'BlockDeviceMapping'          => block_device_mapping,
+            'ClientToken'                 => client_token,
+            'InstanceInitiatedShutdownBehavior' => instance_initiated_shutdown_behavior,
+            'InstanceType'                => flavor_id,
+            'KernelId'                    => kernel_id,
+            'KeyName'                     => key_name,
+            'Monitoring.Enabled'          => monitoring,
+            'Placement.AvailabilityZone'  => availability_zone,
+            'RamdiskId'                   => ramdisk_id,
+            'SecurityGroup'               => groups,
+            'SubnetId'                    => subnet_id,
+            'UserData'                    => user_data
+          }
+          options.delete_if {|key, value| value.nil?}
+
+          # If subnet is defined we are working on a virtual private cloud.
+          # subnet & security group cannot co-exist. I wish VPC just ignored
+          # the security group parameter instead, it would be much easier!
+          if subnet_id
+            options.delete('SecurityGroup')
+          else
+            options.delete('SubnetId')
+          end
+
+          data = connection.run_instances(image_id, 1, 1, options)
+          merge_attributes(data.body['instancesSet'].first)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :identity, :ip_address, :username
+          require 'json'
+
+          commands = [
+            %{mkdir .ssh},
+            %{passwd -l #{username}},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ]
+          if public_key
+            commands << %{echo "#{public_key}" >> ~/.ssh/authorized_keys}
+          end
+          # allow some retries over the first 120 seconds because aws is weird
+          Timeout::timeout(120) do
+            begin
+              Timeout::timeout(4) do
+                Fog::SSH.new(ip_address, username, credentials).run(commands)
+              end
+            rescue Net::SSH::AuthenticationFailed, Timeout::Error
+              retry
+            end
+          end
+        rescue Errno::ECONNREFUSED => e
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :identity, :public_ip_address, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SSH.new(public_ip_address, username, options).run(commands)
+        end
+
+        def scp(local_path, remote_path)
+          requires :public_ip_address, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SCP.new(public_ip_address, username, options).upload(local_path, remote_path)
+        end
+
+        def start
+          requires :id
+          connection.start_instances(id)
+          true
+        end
+
+        def stop
+          requires :id
+          connection.stop_instances(id)
+          true
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        def volumes
+          requires :id
+          connection.volumes(:server => self)
+        end
+
+        #I tried to call it monitoring= and be smart with attributes[]
+        #but in #save a merge_attribute is called after run_instance
+        #thus making an un-necessary request. Use this until finding a clever solution
+        def monitor=(new_monitor)
+          if identity
+            case new_monitor
+            when true
+              response = connection.monitor_instances(identity)
+            when false
+              response = connection.unmonitor_instances(identity)
+            else
+              raise ArgumentError.new("only Boolean allowed here")
+            end
+          end
+          self.monitoring = new_monitor
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/servers.rb
new file mode 100644
index 0000000..6283201
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/servers.rb
@@ -0,0 +1,158 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/server'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Servers < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Server
+
+        # Creates a new server
+        #
+        # AWS.servers.new
+        #
+        # ==== Returns
+        #
+        # Returns the details of the new server
+        #
+        #>> AWS.servers.new
+        #  <Fog::AWS::Compute::Server
+        #    id=nil,
+        #    ami_launch_index=nil,
+        #    availability_zone=nil,
+        #    block_device_mapping=nil,
+        #    client_token=nil,
+        #    dns_name=nil,
+        #    groups=["default"],
+        #    flavor_id="m1.small",
+        #    image_id=nil,
+        #    ip_address=nil,
+        #    kernel_id=nil,
+        #    key_name=nil,
+        #    created_at=nil,
+        #    monitoring=nil,
+        #    product_codes=nil,
+        #    private_dns_name=nil,
+        #    private_ip_address=nil,
+        #    ramdisk_id=nil,
+        #    reason=nil,
+        #    root_device_name=nil,
+        #    root_device_type=nil,
+        #    state=nil,
+        #    state_reason=nil,
+        #    subnet_id=nil,
+        #    tags=nil,
+        #    user_data=nil
+        #  >
+        #
+        
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = self.filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_instances(filters).body
+          load(
+            data['reservationSet'].map do |reservation|
+              reservation['instancesSet'].map do |instance|
+                instance.merge(:groups => reservation['groupSet'])
+              end
+            end.flatten
+          )
+        end
+
+        def bootstrap(new_attributes = {})
+          server = connection.servers.new(new_attributes)
+
+          unless new_attributes[:key_name]
+            # first or create fog_#{credential} keypair
+            name = Fog.respond_to?(:credential) && Fog.credential || :default
+            unless server.key_pair = connection.key_pairs.get("fog_#{name}")
+              server.key_pair = connection.key_pairs.create(
+                :name => "fog_#{name}",
+                :public_key => server.public_key
+              )
+            end
+          end
+
+          # make sure port 22 is open in the first security group
+          security_group = connection.security_groups.get(server.groups.first)
+          authorized = security_group.ip_permissions.detect do |ip_permission|
+            ip_permission['ipRanges'].first && ip_permission['ipRanges'].first['cidrIp'] == '0.0.0.0/0' &&
+            ip_permission['fromPort'] == 22 &&
+            ip_permission['ipProtocol'] == 'tcp' &&
+            ip_permission['toPort'] == 22
+          end
+          unless authorized
+            security_group.authorize_port_range(22..22)
+          end
+
+          server.save
+          server.wait_for { ready? }
+          server.setup(:key_data => [server.private_key])
+          server
+        end
+
+        # Used to retreive a server
+        #
+        # server_id is required to get the associated server information.
+        #
+        # You can run the following command to get the details:
+        # AWS.servers.get("i-5c973972")
+        #
+        # ==== Returns
+        #
+        #>> AWS.servers.get("i-5c973972")
+        #  <Fog::AWS::Compute::Server
+        #    id="i-5c973972",
+        #    ami_launch_index=0,
+        #    availability_zone="us-east-1b",
+        #    block_device_mapping=[],
+        #    client_token=nil,
+        #    dns_name="ec2-25-2-474-44.compute-1.amazonaws.com",
+        #    groups=["default"],
+        #    flavor_id="m1.small",
+        #    image_id="test",
+        #    ip_address="25.2.474.44",
+        #    kernel_id="aki-4e1e1da7",
+        #    key_name=nil,
+        #    created_at=Mon Nov 29 18:09:34 -0500 2010,
+        #    monitoring=false,
+        #    product_codes=[],
+        #    private_dns_name="ip-19-76-384-60.ec2.internal",
+        #    private_ip_address="19.76.384.60",
+        #    ramdisk_id="ari-0b3fff5c",
+        #    reason=nil,
+        #    root_device_name=nil,
+        #    root_device_type="instance-store",
+        #    state="running",
+        #    state_reason={},
+        #    subnet_id=nil,
+        #    tags={},
+        #    user_data=nil
+        #  >
+        #
+        
+        def get(server_id)
+          if server_id
+            self.class.new(:connection => connection).all('instance-id' => server_id).first
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshot.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshot.rb
new file mode 100644
index 0000000..89a36e5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshot.rb
@@ -0,0 +1,56 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshot < Fog::Model
+
+        identity  :id,          :aliases => 'snapshotId'
+
+        attribute :description
+        attribute :progress
+        attribute :created_at,  :aliases => 'startTime'
+        attribute :owner_id,    :aliases => 'ownerId'
+        attribute :state,       :aliases => 'status'
+        attribute :tags,        :aliases => 'tagSet'
+        attribute :volume_id,   :aliases => 'volumeId'
+        attribute :volume_size, :aliases => 'volumeSize'
+
+        def destroy
+          requires :id
+
+          connection.delete_snapshot(id)
+          true
+        end
+
+        def ready?
+          state == 'completed'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :volume_id
+
+          data = connection.create_snapshot(volume_id, description).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          true
+        end
+
+        def volume
+          requires :id
+          connection.describe_volumes(volume_id)
+        end
+
+        private
+
+        def volume=(new_volume)
+          self.volume_id = new_volume.volume_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshots.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshots.rb
new file mode 100644
index 0000000..a8e280b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/snapshots.rb
@@ -0,0 +1,52 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/snapshot'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Snapshots < Fog::Collection
+
+        attribute :filters
+        attribute :volume
+
+        model Fog::AWS::Compute::Snapshot
+
+        def initialize(attributes)
+          self.filters ||= { 'RestorableBy' => 'self' }
+          super
+        end
+
+        def all(filters = filters, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_snapshots(filters.merge!(options)).body
+          load(data['snapshotSet'])
+          if volume
+            self.replace(self.select {|snapshot| snapshot.volume_id == volume.id})
+          end
+          self
+        end
+        
+        def get(snapshot_id)
+          if snapshot_id
+            self.class.new(:connection => connection).all('snapshot-id' => snapshot_id).first
+          end
+        end
+
+        def new(attributes = {})
+          if volume
+            super({ 'volumeId' => volume.id }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/tag.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/tag.rb
new file mode 100644
index 0000000..9525fab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/tag.rb
@@ -0,0 +1,36 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Tag < Fog::Model
+
+        identity  :key
+
+        attribute :value
+        attribute :resource_id,           :aliases => 'resourceId'
+        attribute :resource_type,         :aliases => 'resourceType'        
+
+        def initialize(attributes = {})
+          super
+        end
+
+        def destroy
+          requires :key, :resource_id
+          connection.delete_tags(resource_id, key => value)
+          true
+        end
+
+        def save
+          requires :key, :resource_id
+          connection.create_tags(resource_id, key => value)
+          true
+        end
+
+        private
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/tags.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/tags.rb
new file mode 100644
index 0000000..09aeb4e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/tags.rb
@@ -0,0 +1,34 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/tag'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Tags < Fog::Collection
+
+        attribute :filters
+
+        model Fog::AWS::Compute::Tag
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        def all(filters = filters)
+          self.filters = filters
+          data = connection.describe_tags(filters).body
+          load(data['tagSet'])
+        end
+        
+        def get(key)
+          if key
+            self.class.new(:connection => connection).all('key' => key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/volume.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/volume.rb
new file mode 100644
index 0000000..f612af0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/volume.rb
@@ -0,0 +1,107 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volume < Fog::Model
+
+        identity  :id,                    :aliases => 'volumeId'
+
+        attribute :attached_at,           :aliases => 'attachTime'
+        attribute :availability_zone,     :aliases => 'availabilityZone'
+        attribute :created_at,            :aliases => 'createTime'
+        attribute :delete_on_termination, :aliases => 'deleteOnTermination'
+        attribute :device
+        attribute :server_id,             :aliases => 'instanceId'
+        attribute :size
+        attribute :snapshot_id,           :aliases => 'snapshotId'
+        attribute :state,                 :aliases => 'status'
+        attribute :tags,                  :aliases => 'tagSet'
+
+        def initialize(attributes = {})
+          # assign server first to prevent race condition with new_record?
+          self.server = attributes.delete(:server)
+          super
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_volume(id)
+          true
+        end
+
+        def ready?
+          state == 'available'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :availability_zone, :size
+
+          data = connection.create_volume(availability_zone, size, snapshot_id).body
+          new_attributes = data.reject {|key,value| key == 'requestId'}
+          merge_attributes(new_attributes)
+          if @server
+            self.server = @server
+          end
+          true
+        end
+
+        def server=(new_server)
+          if new_server
+            attach(new_server)
+          else
+            detach
+          end
+        end
+
+        def snapshots
+          requires :id
+          connection.snapshots(:volume => self)
+        end
+
+        private
+
+        def attachmentSet=(new_attachment_set)
+          merge_attributes(new_attachment_set.first || {})
+        end
+
+        def attach(new_server)
+          if new_record?
+            @server = new_server
+            self.availability_zone = new_server.availability_zone
+          elsif new_server
+            requires :device
+            @server = nil
+            self.server_id = new_server.id
+            connection.attach_volume(server_id, id, device)
+            reload
+          end
+        end
+
+        def detach
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.detach_volume(id)
+            reload
+          end
+        end
+
+        def force_detach
+          @server = nil
+          self.server_id = nil
+          unless new_record?
+            connection.detach_volume(id, 'Force' => true)
+            reload
+          end
+        end
+
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/aws/volumes.rb b/vendor/fog-0.8.2/lib/fog/compute/models/aws/volumes.rb
new file mode 100644
index 0000000..62df3ea
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/aws/volumes.rb
@@ -0,0 +1,121 @@
+require 'fog/core/collection'
+require 'fog/compute/models/aws/volume'
+
+module Fog
+  module AWS
+    class Compute
+
+      class Volumes < Fog::Collection
+
+        attribute :filters
+        attribute :server
+
+        model Fog::AWS::Compute::Volume
+
+        # Used to create a volume.  There are 3 arguments and availability_zone and size are required.  You can generate a new key_pair as follows:
+        # AWS.volumes.create(:availability_zone => 'us-east-1a', :size => 10)
+        #
+        # ==== Returns
+        #
+        #<Fog::AWS::Compute::Volume
+        #  id="vol-1e2028b9",
+        #  attached_at=nil,
+        #  availability_zone="us-east-1a",
+        #  created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #  delete_on_termination=nil,
+        #  device=nil,
+        #  server_id=nil,
+        #  size=10,
+        #  snapshot_id=nil,
+        #  state="creating",
+        #  tags=nil
+        #>
+        #
+        # The volume can be retreived by running AWS.volumes.get("vol-1e2028b9").  See get method below.
+        #
+
+        def initialize(attributes)
+          self.filters ||= {}
+          super
+        end
+
+        # Used to return all volumes.
+        # AWS.volumes.all
+        #
+        # ==== Returns
+        #
+        #>>AWS.volumes.all
+        #<Fog::AWS::Compute::Volume
+        #  id="vol-1e2028b9",
+        #  attached_at=nil,
+        #  availability_zone="us-east-1a",
+        #  created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #  delete_on_termination=nil,
+        #  device=nil,
+        #  server_id=nil,
+        #  size=10,
+        #  snapshot_id=nil,
+        #  state="creating",
+        #  tags=nil
+        #>
+        #
+        # The volume can be retreived by running AWS.volumes.get("vol-1e2028b9").  See get method below.
+        #
+
+        def all(filters = filters)
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] all with #{filters.class} param is deprecated, use all('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+          self.filters = filters
+          data = connection.describe_volumes(filters).body
+          load(data['volumeSet'])
+          if server
+            self.replace(self.select {|volume| volume.server_id == server.id})
+          end
+          self
+        end
+
+        # Used to retreive a volume
+        # volume_id is required to get the associated volume information.
+        #
+        # You can run the following command to get the details:
+        # AWS.volumes.get("vol-1e2028b9")
+        #
+        # ==== Returns
+        #
+        #>> AWS.volumes.get("vol-1e2028b9")
+        # <Fog::AWS::Compute::Volume
+        #    id="vol-1e2028b9",
+        #    attached_at=nil,
+        #    availability_zone="us-east-1a",
+        #    created_at=Tue Nov 23 23:30:29 -0500 2010,
+        #    delete_on_termination=nil,
+        #    device=nil,
+        #    server_id=nil,
+        #    size=10,
+        #    snapshot_id=nil,
+        #    state="available",
+        #    tags={}
+        #  >
+        #
+
+        def get(volume_id)
+          if volume_id
+            self.class.new(:connection => connection).all('volume-id' => volume_id).first
+          end
+        end
+
+        def new(attributes = {})
+          if server
+            super({ :server => server }.merge!(attributes))
+          else
+            super
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavor.rb
new file mode 100644
index 0000000..5b17396
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :cost
+        attribute :description
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavors.rb
new file mode 100644
index 0000000..4025444
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/bluebox/flavor'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Bluebox::Compute::Flavor
+
+        def all
+          data = connection.get_products.body
+          load(data)
+        end
+
+        def get(product_id)
+          response = connection.get_product(product_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/image.rb
new file mode 100644
index 0000000..6347f55
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/image.rb
@@ -0,0 +1,19 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :description
+        attribute :public
+        attribute :created_at, :aliases => 'created'
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/images.rb
new file mode 100644
index 0000000..d26f6a7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/images.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/bluebox/image'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Bluebox::Compute::Image
+
+        def all
+          data = connection.get_templates.body
+          load(data)
+        end
+
+        def get(template_id)
+          response = connection.get_template(template_id)
+          new(response.body)
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/server.rb
new file mode 100644
index 0000000..24fca51
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/server.rb
@@ -0,0 +1,147 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class BlockInstantiationError < StandardError; end
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :cpu
+        attribute :description
+        attribute :flavor_id,   :aliases => :product, :squash => 'id'
+        attribute :hostname
+        attribute :image_id
+        attribute :ips
+        attribute :memory
+        attribute :state,       :aliases => :status
+        attribute :storage
+        attribute :template
+
+        attr_accessor :password, :lb_applications, :lb_services, :lb_backends
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id  ||= '94fd37a7-2606-47f7-84d5-9000deda52ae' # Block 1GB Virtual Server
+          self.image_id   ||= '03807e08-a13d-44e4-b011-ebec7ef2c928' # Ubuntu LTS 10.04 64bit
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.destroy_block(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def private_ip_address
+          nil
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_ip_address
+          ips.first
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          self.state == 'running'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_block(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id
+          options = {}
+
+          if identity.nil?  # new record
+            raise(ArgumentError, "password or public_key is required for this operation") if !password && !public_key
+            options['ssh_public_key'] = public_key if public_key
+            options['password'] = password if @password
+          end
+
+          if @lb_backends
+            options['lb_backends'] = lb_backends
+          elsif @lb_services
+            options['lb_services'] = lb_services
+          elsif @lb_applications
+            options['lb_applications'] = lb_applications
+          end
+
+          options['username'] = username
+          data = connection.create_block(flavor_id, image_id, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :identity, :ips, :public_key, :username
+          Fog::SSH.new(ips.first['address'], username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l #{username}},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :identity, :ips, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SSH.new(ips.first['address'], username, options).run(commands)
+        end
+
+        def scp(local_path, remote_path)
+          requires :ips, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SCP.new(ips.first['address'], username, options).upload(local_path, remote_path)
+        end
+
+        def username
+          @username ||= 'deploy'
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/servers.rb
new file mode 100644
index 0000000..75235a9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/bluebox/servers.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/compute/models/bluebox/server'
+
+module Fog
+  module Bluebox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Bluebox::Compute::Server
+
+        def all
+          data = connection.get_blocks.body
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:key_data => [server.private_key])
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_block(server_id).body
+            new(server)
+          end
+        rescue Fog::Bluebox::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/account.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/account.rb
new file mode 100644
index 0000000..a24ca77
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/account.rb
@@ -0,0 +1,51 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Account < Fog::Model
+
+        identity :id
+        attribute :resource_type
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :address_1
+        attribute :address_2
+        attribute :city
+        attribute :county
+        attribute :postcode
+        attribute :country_code
+        attribute :country_name
+        attribute :vat_registration_number
+        attribute :telephone_number
+        attribute :telephone_verified
+        attribute :ram_limit
+        attribute :ram_used
+        attribute :limits_cloudips
+        attribute :library_ftp_host
+        attribute :library_ftp_user
+        # This is always returned as null/nil unless performing a reset_ftp_password request
+        attribute :library_ftp_password
+        attribute :created_at, :type => :time
+
+
+
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :clients
+        attribute :images
+        attribute :servers
+        attribute :users
+        attribute :zones
+
+        def reset_ftp_password
+          requires :identity
+          connection.reset_ftp_password_account(identity)["library_ftp_password"]
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ip.rb
new file mode 100644
index 0000000..56b6fab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ip.rb
@@ -0,0 +1,47 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIp < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+        attribute :reverse_dns
+        attribute :public_ip
+
+        attribute :account_id, :aliases => "account", :squash => "id"
+        attribute :interface_id, :aliases => "interface", :squash => "id"
+        attribute :server_id, :aliases => "server", :squash => "id"
+
+        def map(interface_to_map)
+          requires :identity
+          connection.map_cloud_ip(identity, :interface => interface_to_map)
+        end
+
+        def mapped?
+          status == "mapped"
+        end
+
+        def unmap
+          requires :identity
+          connection.unmap_cloud_ip(identity)
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_cloud_ip(identity)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ips.rb
new file mode 100644
index 0000000..e78646c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/cloud_ips.rb
@@ -0,0 +1,34 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/cloud_ip'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class CloudIps < Fog::Collection
+
+        model Fog::Brightbox::Compute::CloudIp
+
+        def all
+          data = connection.list_cloud_ips
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_cloud_ip(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def allocate
+          data = connection.create_cloud_ip
+          new(data)
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavor.rb
new file mode 100644
index 0000000..805b79b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavor.rb
@@ -0,0 +1,33 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+
+        attribute :handle
+
+        attribute :bits
+        attribute :cores
+        attribute :disk, :aliases => "disk_size"
+        attribute :ram
+
+        attribute :resource_type
+        attribute :description
+
+        def bits
+          0 # This is actually based on the Image type used. 32bit or 64bit Images are supported
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavors.rb
new file mode 100644
index 0000000..5d2a0b8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/flavor'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Brightbox::Compute::Flavor
+
+        def all
+          data = connection.list_server_types
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_server_type(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/image.rb
new file mode 100644
index 0000000..4313eec
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/image.rb
@@ -0,0 +1,56 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :source
+        attribute :source_type
+
+        attribute :ancestor_id, :aliases => "ancestor", :squash => "id"
+        attribute :owner_id, :aliases => "owner", :squash => "id"
+        attribute :arch
+
+        attribute :resource_type
+        attribute :description
+        attribute :public
+        attribute :official
+        attribute :virtual_size
+        attribute :disk_size
+        attribute :created_at
+
+        def ready?
+          status == "available"
+        end
+
+        def save
+          requires :source, :arch
+          options = {
+            :source => source,
+            :arch => arch,
+            :name => name,
+            :description => description
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_image(options)
+          merge_attributes(data)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_image(identity)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/images.rb
new file mode 100644
index 0000000..7bda8bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/images.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/image'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Brightbox::Compute::Image
+
+        def all
+          data = connection.list_images
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_image(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancer.rb
new file mode 100644
index 0000000..55b184d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancer.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class LoadBalancer < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :name
+        attribute :status
+        attribute :resource_type
+
+        attribute :nodes
+        attribute :policy
+        attribute :healthcheck
+        attribute :listeners
+        attribute :account
+
+        def ready?
+          status == 'active'
+        end
+
+        def save
+          requires :nodes, :listeners, :healthcheck
+          options = {
+            :nodes => nodes,
+            :listeners => listeners,
+            :healthcheck => healthcheck,
+            :policy => policy,
+            :name => name
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_load_balancer(options)
+          merge_attributes(data)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_load_balancer(identity)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancers.rb
new file mode 100644
index 0000000..e7cc39f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/load_balancers.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/load_balancer'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class LoadBalancers < Fog::Collection
+
+        model Fog::Brightbox::Compute::LoadBalancer
+
+        def all
+          data = connection.list_load_balancers
+          load(data)
+        end
+
+        def get(identifier)
+          data = connection.get_load_balancer(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/server.rb
new file mode 100644
index 0000000..d401ea8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/server.rb
@@ -0,0 +1,114 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Server < Fog::Model
+
+        identity  :id
+
+        attribute :url
+        attribute :name
+        attribute :state,       :aliases => 'status'
+        attribute :hostname
+        attribute :created_at,  :type => :time
+        attribute :deleted_at,  :type => :time
+        attribute :started_at,  :type => :time
+        attribute :user_data
+
+        attribute :resource_type
+
+        attribute :account_id,  :aliases => "account",      :squash => "id"
+        attribute :image_id,    :aliases => "image",        :squash => "id"
+        attribute :flavor_id,   :aliases => "server_type",  :squash => "id"
+        attribute :zone_id,     :aliases => "zone",         :squash => "id"
+
+        attribute :snapshots
+        attribute :cloud_ips
+        attribute :interfaces
+
+        def initialize(attributes={})
+          self.flavor_id  ||= 'typ-4nssg' # Nano
+          self.image_id   ||= 'img-2ab98' # Ubuntu Lucid 10.04 server (i686)
+          super
+        end
+
+        def snapshot
+          requires :identity
+          connection.snapshot_server(identity)
+        end
+
+        def reboot
+          false
+        end
+
+        def start
+          requires :identity
+          connection.start_server(identity)
+          true
+        end
+
+        def stop
+          requires :identity
+          connection.stop_server(identity)
+          true
+        end
+
+        def shutdown
+          requires :identity
+          connection.shutdown_server(identity)
+          true
+        end
+
+        def destroy
+          requires :identity
+          connection.destroy_server(identity)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def private_ip_address
+          interfaces.first
+        end
+
+        def public_ip_address
+          cloud_ips.first
+        end
+
+        def ready?
+          self.state == 'active'
+        end
+
+        def activate_console
+          requires :identity
+          response = connection.activate_console_server(identity)
+          [response["console_url"], response["console_token"], response["console_token_expires"]]
+        end
+
+        def save
+          requires :image_id
+          options = {
+            :image => image_id,
+            :server_type => flavor_id,
+            :name => name,
+            :zone => zone_id,
+            :user_data => user_data
+          }.delete_if {|k,v| v.nil? || v == "" }
+          data = connection.create_server(options)
+          merge_attributes(data)
+          true
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/servers.rb
new file mode 100644
index 0000000..b414f1e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/servers.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/server'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Brightbox::Compute::Server
+
+        def all
+          data = connection.list_servers
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_server(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/user.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/user.rb
new file mode 100644
index 0000000..8432b7f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/user.rb
@@ -0,0 +1,39 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class User < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :resource_type
+        attribute :name
+        attribute :email_address
+        attribute :email_verified
+        attribute :ssh_key
+
+        attribute :account_id, :aliases => "default_account", :squash => "id"
+        attribute :accounts
+
+        def save
+          requires :identity
+
+          options = {
+            :email_address => email_address,
+            :ssh_key => ssh_key,
+            :name => name
+          }
+
+          data = connection.update_user(identity, options)
+          merge_attributes(data)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/users.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/users.rb
new file mode 100644
index 0000000..203d2a7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/users.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/user'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Users < Fog::Collection
+
+        model Fog::Brightbox::Compute::User
+
+        def all
+          data = connection.list_users
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_user(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zone.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zone.rb
new file mode 100644
index 0000000..e041561
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zone.rb
@@ -0,0 +1,21 @@
+require 'fog/core/model'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :url
+        attribute :handle
+        attribute :status
+        attribute :resource_type
+        attribute :description
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zones.rb b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zones.rb
new file mode 100644
index 0000000..3c3ba21
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/brightbox/zones.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/compute/models/brightbox/zone'
+
+module Fog
+  module Brightbox
+    class Compute
+
+      class Zones < Fog::Collection
+
+        model Fog::Brightbox::Compute::Zone
+
+        def all
+          data = connection.list_zones
+          load(data)
+        end
+
+        def get(identifier)
+          return nil if identifier.nil? || identifier == ""
+          data = connection.get_zone(identifier)
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_service.rb
new file mode 100644
index 0000000..dad08d5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_service.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Ecloud
+    class Compute
+      class BackupInternetService < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i
+
+        attribute :name, :aliases => :Name
+        attribute :id, :aliases => :Id
+        attribute :protocol, :aliases => :Protocol
+        attribute :enabled, :aliases => :Enabled
+        attribute :description, :aliases => :Description
+        attribute :timeout, :aliases => :Timeout
+        attribute :redirect_url, :aliases => :RedirectURL
+        attribute :monitor, :aliases => :Monitor
+
+        def delete
+          requires :href
+
+          connection.delete_internet_service( href )
+        end
+
+        def monitor=(new_monitor = {})
+          if new_monitor.nil? || new_monitor.empty?
+            attributes[:monitor] = nil
+          end
+        end
+
+        def save
+          if new_record?
+            result = connection.add_backup_internet_service( collection.href, _compose_service_data )
+            merge_attributes(result.body)
+          else
+            connection.configure_backup_internet_service( href, _compose_service_data )
+          end
+        end
+
+        def nodes
+          @nodes ||= Fog::Ecloud::Compute::Nodes.new( :connection => connection, :href => href + "/nodeServices" )
+        end
+
+        private
+
+        def _compose_service_data
+          #For some reason inject didn't work
+          service_data = {}
+          self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| service_data[attribute] = send(attribute) }
+          service_data
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_services.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_services.rb
new file mode 100644
index 0000000..3bea2c8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/backup_internet_services.rb
@@ -0,0 +1,33 @@
+require 'fog/compute/models/ecloud/backup_internet_service'
+
+module Fog
+  module Ecloud
+    class Compute
+      class BackupInternetServices < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::BackupInternetService
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href! :message => "the Internet Services for the Vdc you want to enumerate"
+          if data = connection.get_internet_services(href).body[:InternetService].find_all {|i| i[:IsBackupService] == "true" }
+            load(data)
+          end
+        end
+
+        # Optimize later, no need to get_internet_services again?
+        def get(uri)
+          internet_services = connection.get_internet_services(href).body[:InternetService]
+          internet_services = [ internet_services ] if internet_services.is_a?(Hash)
+          if data = internet_services.detect { |service| service[:Href] == uri }
+            new(data)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog.rb
new file mode 100644
index 0000000..96970f9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Catalog < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::CatalogItem
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href!
+          if data = connection.get_catalog(href).body[:CatalogItems][:CatalogItem]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_catalog_item(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog_item.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog_item.rb
new file mode 100644
index 0000000..adc31e7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/catalog_item.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Ecloud
+    class Compute
+      class CatalogItem < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+        attribute :type
+        attribute :name
+        attribute :entity, :aliases => :Entity
+        attribute :link, :aliases => :Link
+        attribute :property, :aliases => :Property
+
+        def customization_options
+          load_unless_loaded!
+          if data = connection.get_customization_options( link[:href] ).body
+            data.delete_if { |key, value| [:xmlns_i, :xmlns].include?(key) }
+            data
+          else
+            nil
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acl.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acl.rb
new file mode 100644
index 0000000..428c9e2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acl.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Ecloud
+    class Compute
+      class FirewallAcl < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i
+
+        attribute :name, :aliases => :Name
+        attribute :id, :aliases => :Id
+        attribute :protocol, :aliases => :Protocol
+        attribute :source, :aliases => :Source
+        attribute :destination, :aliases => :Destination
+        attribute :permission, :aliases => :Permission
+        attribute :port_start, :aliases => :PortStart
+        attribute :port_end, :aliases => :PortEnd
+        attribute :port_type, :aliases => :PortType
+        attribute :type, :aliases => :Type
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acls.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acls.rb
new file mode 100644
index 0000000..3adb8d2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/firewall_acls.rb
@@ -0,0 +1,31 @@
+require 'fog/compute/models/ecloud/firewall_acl'
+
+module Fog
+  module Ecloud
+    class Compute
+      class FirewallAcls < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::FirewallAcl
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href! :message => "the Firewall ACL href for the network you want to enumerate"
+          if data = connection.get_firewall_acls(href).body[:FirewallAcl]
+            data = [ data ] if data.is_a?(Hash)
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_firewall_acl(uri).body
+            new(data)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_service.rb
new file mode 100644
index 0000000..8fe7c56
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_service.rb
@@ -0,0 +1,117 @@
+module Fog
+  module Ecloud
+    class Compute
+      class InternetService < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i
+
+        attribute :name, :aliases => :Name
+        attribute :id, :aliases => :Id
+        attribute :protocol, :aliases => :Protocol
+        attribute :port, :aliases => :Port
+        attribute :enabled, :aliases => :Enabled
+        attribute :description, :aliases => :Description
+        attribute :public_ip, :aliases => :PublicIpAddress
+        attribute :timeout, :aliases => :Timeout
+        attribute :redirect_url, :aliases => :RedirectURL
+        attribute :monitor, :aliases => :Monitor
+        attribute :backup_service_data, :aliases => :BackupService
+
+        def delete
+          requires :href
+
+          connection.delete_internet_service( href )
+        end
+
+        def save
+          if new_record?
+            result = connection.add_internet_service( collection.href, _compose_service_data )
+            merge_attributes(result.body)
+          else
+            connection.configure_internet_service( href, _compose_service_data, _compose_ip_data )
+          end
+        end
+
+        # disables monitoring for this service
+        def disable_monitor
+          if self.monitor and self.monitor[:type] == "Disabled"
+            raise RuntimeError.new("Monitoring already disabled")
+          else
+            self.monitor = {:type => "Disabled", :is_enabled => "true"}
+            self.save
+          end
+        end
+
+        # enable default ping monitoring, use monitor= for more exotic forms (ECV & HTTP)
+        def enable_ping_monitor
+          self.monitor = nil
+          self.save
+        end
+
+        def monitor=(new_monitor = {})
+          if new_monitor.nil? || new_monitor.empty?
+            attributes[:monitor] = nil
+          elsif new_monitor.is_a?(Hash)
+            attributes[:monitor] = {}
+            attributes[:monitor][:type] = new_monitor[:MonitorType] || new_monitor[:type]
+            attributes[:monitor][:url_send_string] = new_monitor[:UrlSendString] || new_monitor[:url_send_string]
+            attributes[:monitor][:http_headers] = new_monitor[:HttpHeader] || new_monitor[:http_headers]
+            if attributes[:monitor][:http_headers]
+              if attributes[:monitor][:http_headers].is_a?(String)
+                attributes[:monitor][:http_headers] = attributes[:monitor][:http_headers].split("\n")
+              else
+                attributes[:monitor][:http_headers] = attributes[:monitor][:http_headers]
+              end
+            end
+            attributes[:monitor][:receive_string] = new_monitor[:ReceiveString] || new_monitor[:receive_string]
+            attributes[:monitor][:interval] = new_monitor[:Interval] || new_monitor[:interval]
+            attributes[:monitor][:response_timeout] = new_monitor[:ResponseTimeOut] || new_monitor[:response_timeout]
+            attributes[:monitor][:downtime] = new_monitor[:DownTime] || new_monitor[:downtime]
+            attributes[:monitor][:retries] = new_monitor[:Retries] || new_monitor[:retries]
+            attributes[:monitor][:is_enabled] = new_monitor[:IsEnabled] || new_monitor[:is_enabled]
+          else
+            raise RuntimeError.new("monitor needs to either be nil or a Hash")
+          end
+        end
+
+        def nodes
+          @nodes ||= Fog::Ecloud::Compute::Nodes.new( :connection => connection, :href => href + "/nodeServices" )
+        end
+
+        def backup_service_uri
+          if backup_service_data
+            backup_service_data[:Href]
+          end
+        end
+
+        def backup_service_uri=(new_value)
+          self.backup_service_data = {
+            :Href => new_value
+          }
+        end
+
+        private
+
+        def _compose_service_data
+          #For some reason inject didn't work
+          service_data = {}
+          self.class.attributes.select{ |attribute| attribute != :backup_service_data }.each { |attribute| service_data[attribute] = send(attribute) }
+          service_data[:backup_service_uri] = backup_service_uri
+          service_data.reject! {|k, v| v.nil? }
+          service_data
+        end
+
+        def _compose_ip_data
+          if public_ip.nil?
+            {}
+          else
+            { :id => public_ip[:Id], :href => public_ip[:Href], :name => public_ip[:Name] }
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_services.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_services.rb
new file mode 100644
index 0000000..df2a414
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/internet_services.rb
@@ -0,0 +1,33 @@
+require 'fog/compute/models/ecloud/internet_service'
+
+module Fog
+  module Ecloud
+    class Compute
+      class InternetServices < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::InternetService
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href! :message => "the Internet Services for the Vdc you want to enumerate"
+          if internet_service_data = connection.get_internet_services(href).body[:InternetService]
+            load(Array[internet_service_data].flatten.find_all {|i| i[:IsBackupService] == "false" })
+          end
+        end
+
+        # Optimize later, no need to get_internet_services again?
+        def get(uri)
+          internet_services = connection.get_internet_services(href).body[:InternetService]
+          internet_services = [ internet_services ] if internet_services.is_a?(Hash)
+          if data = internet_services.detect { |service| service[:Href] == uri }
+            new(data)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ip.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ip.rb
new file mode 100644
index 0000000..7e156fb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ip.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Ip < Fog::Ecloud::Model
+
+        ignore_attributes :xmlns_i, :xmlns
+
+        identity :href, :aliases => :Href
+
+        attribute :name, :aliases => :Name
+        attribute :status, :aliases => :Status
+        attribute :server, :aliases => :Server
+        attribute :rnat, :aliases => :RnatAddress
+        attribute :id, :aliases => :Id, :type => :integer
+
+        def rnat=(new_rnat)
+          attributes[:rnat] = new_rnat
+          @changed = true
+        end
+
+        def save
+          if @changed
+            connection.configure_network_ip( href, _compose_network_ip_data )
+          end
+          true
+        end
+
+        def reload
+          super
+          @changed = false
+          self
+        end
+
+        private
+        def _compose_network_ip_data
+          {
+            :id => id,
+            :href => href,
+            :name => name,
+            :status => status,
+            :server => server,
+            :rnat => rnat
+          }
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ips.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ips.rb
new file mode 100644
index 0000000..2563f67
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/ips.rb
@@ -0,0 +1,32 @@
+require 'fog/compute/models/ecloud/ip'
+
+module Fog
+  module Ecloud
+    class Compute
+      class Ips < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::Ip
+
+        undef_method :create
+
+        attribute :href
+
+        def all
+          check_href!( :messages => "Ips href of a Network you want to enumerate" )
+          if data = connection.get_network_ips(href).body[:IpAddress]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_network_ip(uri).body
+            new(data)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/network.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/network.rb
new file mode 100644
index 0000000..047266d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/network.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Network < Fog::Ecloud::Model
+
+        identity :href
+
+        ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd, :xmlns_i, :Configuration, :Id
+
+        attribute :name, :aliases => :Name
+        #attribute :id, :aliases => :Id
+        attribute :features, :aliases => :Features, :type => :array
+        attribute :links, :aliases => :Link, :type => :array
+        attribute :type
+        attribute :gateway, :aliases => :GatewayAddress
+        attribute :broadcast, :aliases => :BroadcastAddress
+        attribute :address, :aliases => :Address
+        attribute :rnat, :aliases => :RnatAddress
+        attribute :extension_href, :aliases => :Href
+        attribute :network_type, :aliases => :NetworkType
+        attribute :vlan, :aliases => :Vlan
+        attribute :friendly_name, :aliases => :FriendlyName
+
+        def ips
+          load_unless_loaded!
+          Fog::Ecloud::Compute::Ips.new( :connection => connection,
+               :href => links.detect { |link| link[:name] == "IP Addresses" }[:href] )
+        end
+
+        def rnat=(new_rnat)
+          attributes[:rnat] = new_rnat
+          @changed = true
+        end
+
+        def save
+          if @changed
+            connection.configure_network( extension_href, _compose_network_data )
+          end
+          true
+        end
+
+        def reload
+          super
+          merge_attributes(extension_data.body)
+          self
+        end
+
+        private
+
+        def extension_data
+          connection.get_network_extensions( extensions_link[:href] )
+        end
+
+        def extensions_link
+          links.detect { |link| link[:name] == name }
+        end
+
+        def _compose_network_data
+          {
+            :id => id,
+            :href => extension_href,
+            :name => name,
+            :rnat => rnat,
+            :address => address,
+            :broadcast => broadcast,
+            :gateway => gateway
+          }
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/networks.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/networks.rb
new file mode 100644
index 0000000..50c456a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/networks.rb
@@ -0,0 +1,33 @@
+require 'fog/compute/models/ecloud/network'
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Networks < Fog::Ecloud::Collection
+
+        undef_method :create
+
+        model Fog::Ecloud::Compute::Network
+
+        attribute :href
+
+        def all
+          check_href!("Vdc")
+          if data = connection.get_vdc(href).body[:AvailableNetworks][:Network]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_network(uri)
+            new(data.body)
+          end
+          rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/node.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/node.rb
new file mode 100644
index 0000000..eae3a37
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/node.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Node < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i
+
+        attribute :ip_address, :aliases => :IpAddress
+        attribute :description, :aliases => :Description
+        attribute :name, :aliases => :Name
+        attribute :port, :aliases => :Port
+        attribute :enabled, :aliases => :Enabled
+        attribute :id, :aliases => :Id
+
+        def delete
+          requires :href
+
+          connection.delete_node( href )
+        end
+
+        def save
+          if new_record?
+            result = connection.add_node( collection.href, _compose_node_data )
+            merge_attributes(result.body)
+          else
+            connection.configure_node( href, _compose_node_data )
+          end
+        end
+
+        private
+
+        def _compose_node_data
+          node_data = {}
+          self.class.attributes.select{ |attribute| !send(attribute).nil? }.each { |attribute| node_data[attribute] = send(attribute).to_s }
+          node_data
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/nodes.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/nodes.rb
new file mode 100644
index 0000000..9a17829
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/nodes.rb
@@ -0,0 +1,31 @@
+require 'fog/compute/models/ecloud/node'
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Nodes < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::Node
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href!( :messages => "the Nodes href of the Internet Service you want to enumerate" )
+          if data = connection.get_nodes(href).body[:NodeService]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_node(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ip.rb
new file mode 100644
index 0000000..8d205ef
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ip.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Ecloud
+    class Compute
+      class PublicIp < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i
+
+        attribute :name, :aliases => :Name
+        attribute :id, :aliases => :Id
+
+        def internet_services
+          load_unless_loaded!
+          @internet_services ||= Fog::Ecloud::Compute::InternetServices.
+            new( :connection => connection,
+                 :href => href.to_s + "/internetServices" )
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ips.rb
new file mode 100644
index 0000000..e0c1b35
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/public_ips.rb
@@ -0,0 +1,36 @@
+require 'fog/compute/models/ecloud/public_ip'
+
+module Fog
+  module Ecloud
+    class Compute
+      class PublicIps < Fog::Ecloud::Collection
+
+        undef_method :create
+
+        attribute :href, :aliases => :Href
+
+        model Fog::Ecloud::Compute::PublicIp
+
+        #get_request :get_public_ip
+        #vcloud_type "application/vnd.tmrk.ecloud.publicIp+xml"
+        #all_request lambda { |public_ips| public_ips.connection.get_public_ips(public_ips.href) }
+
+        def all
+          check_href!(:message => "the Public Ips href of the Vdc you want to enumerate")
+          if data = connection.get_public_ips(href).body[:PublicIPAddress]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_public_ip(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/server.rb
new file mode 100644
index 0000000..040acba
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/server.rb
@@ -0,0 +1,209 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Server < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+        attribute :type
+        attribute :name
+        attribute :status
+        attribute :network_connections, :aliases => :NetworkConnectionSection, :squash => :NetworkConnection
+        attribute :os, :aliases => :OperatingSystemSection
+        attribute :virtual_hardware, :aliases => :VirtualHardwareSection
+        attribute :storage_size, :aliases => :size
+        attribute :links, :aliases => :Link, :type => :array
+
+        def friendly_status
+          load_unless_loaded!
+          case status
+          when '0'
+            'creating'
+          when '2'
+            'off'
+          when '4'
+            'on'
+          else
+            'unkown'
+          end
+        end
+
+        def ready?
+          load_unless_loaded!
+          status == '2'
+        end
+
+        def on?
+          load_unless_loaded!
+          status == '4'
+        end
+
+        def off?
+          load_unless_loaded!
+          status == '2'
+        end
+
+        def power_on
+          power_operation( :power_on => :powerOn )
+        end
+
+        def power_off
+          power_operation( :power_off => :powerOff )
+        end
+
+        def shutdown
+          power_operation( :power_shutdown => :shutdown )
+        end
+
+        def power_reset
+          power_operation( :power_reset => :reset )
+        end
+
+        def graceful_restart
+          requires :href
+          shutdown
+          wait_for { off? }
+          power_on
+        end
+
+        def delete
+          requires :href
+          connection.delete_vapp( href)
+        end
+
+        def name=(new_name)
+          attributes[:name] = new_name
+          @changed = true
+        end
+
+        def cpus
+          if cpu_mess
+            { :count => cpu_mess[:VirtualQuantity].to_i,
+              :units => cpu_mess[:AllocationUnits] }
+          end
+        end
+
+        def cpus=(qty)
+          @changed = true
+          cpu_mess[:VirtualQuantity] = qty.to_s
+        end
+
+        def memory
+          if memory_mess
+            { :amount => memory_mess[:VirtualQuantity].to_i,
+              :units => memory_mess[:AllocationUnits] }
+          end
+        end
+
+        def memory=(amount)
+          @changed = true
+          memory_mess[:VirtualQuantity] = amount.to_s
+        end
+
+        def disks
+          disk_mess.map do |dm|
+            { :number => dm[:AddressOnParent], :size => dm[:VirtualQuantity].to_i, :resource => dm[:HostResource] }
+          end
+        end
+
+        def add_disk(size)
+          if @disk_change == :deleted
+            raise RuntimeError, "Can't add a disk w/o saving changes or reloading"
+          else
+            @disk_change = :added
+            load_unless_loaded!
+            virtual_hardware[:Item] << { :ResourceType => '17',
+                                         :AddressOnParent => (disk_mess.map { |dm| dm[:AddressOnParent] }.sort.last.to_i + 1).to_s,
+                                         :VirtualQuantity => size.to_s }
+          end
+          true
+        end
+
+        def delete_disk(number)
+          if @disk_change == :added
+            raise RuntimeError, "Can't delete a disk w/o saving changes or reloading"
+          else
+            @disk_change = :deleted
+            load_unless_loaded!
+            unless number == 0
+              virtual_hardware[:Item].delete_if { |vh| vh[:ResourceType] == '17' && vh[:AddressOnParent].to_i == number }
+            end
+          end
+          true
+        end
+
+        def reload
+          reset_tracking
+          super
+        end
+
+        def save
+          if new_record?
+            #Lame ...
+            raise RuntimeError, "Should not be here"
+          else
+            if on?
+              if @changed
+                raise RuntimeError, "Can't save cpu, name or memory changes while the VM is on."
+              end
+            end
+            connection.configure_vapp( href, _compose_vapp_data )
+          end
+          reset_tracking
+        end
+
+        private
+
+        def reset_tracking
+          @disk_change = false
+          @changed = false
+        end
+
+        def _compose_vapp_data
+          { :name   => name,
+            :cpus   => cpus[:count],
+            :memory => memory[:amount],
+            :disks  => disks
+          }
+        end
+
+        def memory_mess
+          load_unless_loaded!
+          if virtual_hardware && virtual_hardware[:Item]
+            virtual_hardware[:Item].detect { |item| item[:ResourceType] == "4" }
+          end
+        end
+
+        def cpu_mess
+          load_unless_loaded!
+          if virtual_hardware && virtual_hardware[:Item]
+            virtual_hardware[:Item].detect { |item| item[:ResourceType] == "3" }
+          end
+        end
+
+        def disk_mess
+          load_unless_loaded!
+          if virtual_hardware && virtual_hardware[:Item]
+            virtual_hardware[:Item].select { |item| item[:ResourceType] == "17" }
+          else
+            []
+          end
+        end
+
+        def power_operation(op)
+          requires :href
+          begin
+            connection.send(op.keys.first, href + "/power/action/#{op.values.first}" )
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered o(n|ff)/
+          end
+          true
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/servers.rb
new file mode 100644
index 0000000..e1904bb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/servers.rb
@@ -0,0 +1,57 @@
+require 'fog/compute/models/ecloud/server'
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Servers < Fog::Ecloud::Collection
+
+        undef_method :create
+
+        model Fog::Ecloud::Compute::Server
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href!(:parent => "Vdc")
+          load(_vapps)
+        end
+
+        def get(uri)
+          if data = connection.get_vapp(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+        def create( catalog_item_uri, options )
+          options[:vdc_uri] = href
+          options[:cpus] ||= 1
+          options[:memory] ||= 512
+          data = connection.instantiate_vapp_template( catalog_item_uri, options ).body
+          object = new(data)
+          object
+        end
+
+        private
+
+        def _resource_entities
+          if Hash === resource_entities = connection.get_vdc(href).body[:ResourceEntities]
+            resource_entities[:ResourceEntity]
+          end
+        end
+
+        def _vapps
+          resource_entities = _resource_entities
+          if resource_entities.nil?
+            []
+          else
+            resource_entities
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/task.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/task.rb
new file mode 100644
index 0000000..6210bae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/task.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Task < Fog::Ecloud::Model
+
+        identity :href, :aliases => :Href
+
+        ignore_attributes :xmlns, :xmlns_i, :xmlns_xsi, :xmlns_xsd
+
+        attribute :status
+        attribute :type
+        attribute :result, :aliases => :Result
+        attribute :owner, :aliases => :Owner
+        attribute :start_time, :aliases => :startTime, :type => :time
+        attribute :end_time, :aliases => :endTime, :type => :time
+        attribute :error, :aliases => :Error
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/tasks.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/tasks.rb
new file mode 100644
index 0000000..c333754
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/tasks.rb
@@ -0,0 +1,31 @@
+require 'fog/compute/models/ecloud/task'
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Tasks < Fog::Ecloud::Collection
+
+        model Fog::Ecloud::Compute::Task
+
+        attribute :href, :aliases => :Href
+
+        def all
+          check_href!
+          if data = connection.get_task_list(href).body[:Task]
+            load(data)
+          end
+        end
+
+        def get(uri)
+          if data = connection.get_task(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdc.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdc.rb
new file mode 100644
index 0000000..fce01de
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdc.rb
@@ -0,0 +1,81 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Vdc < Fog::Ecloud::Model
+
+        identity :href
+
+        ignore_attributes :xmlns, :xmlns_xsi, :xmlns_xsd
+
+        attribute :name
+        attribute :type
+        attribute :description, :aliases => :Description
+        attribute :other_links, :aliases => :Link
+        attribute :compute_capacity, :aliases => :ComputeCapacity
+        attribute :storage_capacity, :aliases => :StorageCapacity
+        attribute :available_networks, :aliases => :AvailableNetworks, :squash => :Network
+        attribute :resource_entities, :aliases => :ResourceEntities, :squash => :ResourceEntity
+        attribute :deployed_vm_quota
+        attribute :instantiated_vm_quota
+
+        def public_ips
+          @public_ips ||= collection_based_on_type("application/vnd.tmrk.ecloud.publicIpsList+xml")
+        end
+
+        def internet_services
+          @internet_services ||= collection_based_on_type("application/vnd.tmrk.ecloud.internetServicesList+xml")
+        end
+
+        def backup_internet_services
+          @backup_internet_services ||= collection_based_on_type("application/vnd.tmrk.ecloud.internetServicesList+xml", BackupInternetServices)
+        end
+
+        def networks
+          @networks ||= Fog::Ecloud::Compute::Networks.
+            new( :connection => connection,
+                 :href => href )
+        end
+
+        def servers
+          @servers ||= Fog::Ecloud::Compute::Servers.
+            new( :connection => connection,
+                 :href => href )
+        end
+
+        def tasks
+          @tasks ||= Fog::Ecloud::Compute::Tasks.
+            new( :connection => connection,
+                 :href => href + "/tasksList" )
+        end
+
+        def catalog
+          @catalog ||= collection_based_on_type("application/vnd.vmware.vcloud.catalog+xml")
+        end
+
+        def firewall_acls
+          @firewall_acls ||= collection_based_on_type("application/vnd.tmrk.ecloud.firewallAclsList+xml")
+        end
+
+        private
+
+        def collection_based_on_type(type, klass = nil)
+          load_unless_loaded!
+          if link = other_links.detect { |link| link[:type] == type }
+            case type
+            when "application/vnd.tmrk.ecloud.publicIpsList+xml"
+              Fog::Ecloud::Compute::PublicIps
+            when "application/vnd.tmrk.ecloud.internetServicesList+xml"
+              klass || Fog::Ecloud::Compute::InternetServices
+            when "application/vnd.vmware.vcloud.catalog+xml"
+              Fog::Ecloud::Compute::Catalog
+            when "application/vnd.tmrk.ecloud.firewallAclsList+xml"
+              Fog::Ecloud::Compute::FirewallAcls
+            end.new( :connection => connection, :href => link[:href] )
+          else
+            [ ]
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdcs.rb b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdcs.rb
new file mode 100644
index 0000000..55d3fd3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/ecloud/vdcs.rb
@@ -0,0 +1,40 @@
+require 'fog/compute/models/ecloud/vdc'
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Vdcs < Collection
+
+        model Fog::Ecloud::Compute::Vdc
+
+        undef_method :create
+
+        def all
+          data = connection.get_organization(organization_uri).body[:Link].select { |link| link[:type] == "application/vnd.vmware.vcloud.vdc+xml" }
+          data.each { |link| link.delete_if { |key, value| [:rel].include?(key) } }
+          load(data)
+        end
+
+        def get(uri)
+          if data = connection.get_vdc(uri)
+            new(data.body)
+          end
+        rescue Fog::Errors::NotFound
+          nil
+        end
+
+        def organization_uri
+          @organizatio_uri ||= connection.default_organization_uri
+        end
+
+        private
+
+        def organization_uri=(new_organization_uri)
+          @organization_uri = new_organization_uri
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/image.rb
new file mode 100644
index 0000000..d93fe19
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/image.rb
@@ -0,0 +1,60 @@
+require 'fog/core/model'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :description
+        attribute :friendly_name, :aliases => 'friendlyName'
+        attribute :created_at,    :aliases => 'createdTime'
+        attribute :updated_at,    :aliases => 'updatedTime'
+        attribute :server_id,     :aliases => 'id'
+        attribute :state
+        attribute :price
+        attribute :location
+        attribute :billingtokens
+        attribute :os
+        attribute :architecture
+        attribute :type
+        attribute :active,        :aliases => 'isActive'
+        attribute :public,        :aliases => 'isPublic'
+        attribute :object_type,   :aliases => 'object'
+        attribute :owner
+
+
+        def server=(new_server)
+          requires :id
+
+          @server_id = new_server.id
+        end
+
+        def destroy
+          requires :id
+
+          connection.grid_server_delete(id)
+          true
+        end
+
+        def ready?
+          status == 'Available'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :server_id
+
+          data = connection.grid_server_add(server_id, 'name' => name)
+          merge_attributes(data.body['image'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/images.rb
new file mode 100644
index 0000000..adf4eda
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/images.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/compute/models/go_grid/image'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::GoGrid::Compute::Image
+
+        attribute :server
+
+        def all
+          data = connection.grid_image_list.body['list']
+          load(data)
+          if server
+            self.replace(self.select {|image| image.server_id == server.id})
+          end
+        end
+
+        def get(image_id)
+          response = connection.grid_image_get.body['list'][image_id]
+          new(data)
+        rescue Fog::GoGrid::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/password.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/password.rb
new file mode 100644
index 0000000..fc19f6f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/password.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Password < Fog::Model
+
+        identity :id
+
+        attribute :server_id
+        attribute :applicationtype
+        attribute :username	
+        attribute :password_id,	:aliases => 'id'
+        attribute :password
+        attribute :server
+
+        def initialize(attributes={})
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.grid_server_destroy(id)
+          true
+        end
+
+        def image
+          requires :image_id
+          connection.grid_image_get(image_id)
+        end
+
+        def ready?
+          @state == 'On'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :password_id
+          data = connection.support_password_list()
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/passwords.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/passwords.rb
new file mode 100644
index 0000000..21adb4f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/passwords.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/compute/models/go_grid/password'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Passwords < Fog::Collection
+
+        model Fog::GoGrid::Compute::Password
+
+        def all
+          data = connection.support_password_list.body['list']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          password = create(new_attributes)
+          password.wait_for { ready? }
+          password
+        end
+
+        def get(id)
+          #if server_id && server = connection.grid_server_get(server_id).body['list']
+          if id && server = connection.support_password_get(id).body['list']
+            new(server)
+          end
+        rescue Fog::GoGrid::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/server.rb
new file mode 100644
index 0000000..57fb5fe
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/server.rb
@@ -0,0 +1,118 @@
+require 'fog/core/model'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class BlockInstantiationError < StandardError; end
+
+      class Server < Fog::Model
+        extend Fog::Deprecation
+        deprecate(:ip, :public_ip_address)
+
+        identity :id
+
+        attribute :name
+        attribute :image_id     # id or name
+        attribute :public_ip_address, :aliases => 'ip'
+        attribute :memory       # server.ram
+        attribute :state
+        attribute :description  # Optional
+        attribute :sandbox      # Optional. Default: False
+
+        def initialize(attributes={})
+          image_id ||= 'ubuntu_10_04_LTS_64_base' # Ubuntu 10.04 LTS 64bit
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.grid_server_delete(id)
+          true
+        end
+
+        def image
+          requires :image_id
+          connection.grid_image_get(:image => image_id)
+        end
+
+        def private_ip_address
+          nil
+        end
+
+        def ready?
+          @state && @state["name"] == 'On'
+        end
+
+        def reload
+          requires :name
+          begin
+            if data = collection.get(name)
+              new_attributes = data.attributes
+              merge_attributes(new_attributes)
+              self
+            end
+          rescue Excon::Errors::BadRequest
+            false
+          end
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :name, :image_id, :ip, :memory
+          options = {
+            'isSandbox'   => sandbox,
+            'image'       => image_id
+          }
+          options = options.reject {|key, value| value.nil?}
+          data = connection.grid_server_add(image, ip, name, memory, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        def ssh(commands)
+          requires :ip, :identity, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SSH.new(ip['ip'], username, options).run(commands)
+        end
+
+        def scp(local_path, remote_path)
+          requires :ip, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SCP.new(ip['ip'], username, options).upload(local_path, remote_path)
+        end
+
+        def setup(credentials = {})
+          requires :ip, :identity, :public_key, :username
+          Fog::SSH.new(ip['ip'], username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l root},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json},
+            %{echo "#{metadata.to_json}" >> ~/metadata.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        private
+
+        def adminPass=(new_admin_pass)
+          @password = new_admin_pass
+        end
+
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/servers.rb
new file mode 100644
index 0000000..322af0a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/go_grid/servers.rb
@@ -0,0 +1,35 @@
+require 'fog/core/collection'
+require 'fog/compute/models/go_grid/server'
+
+module Fog
+  module GoGrid
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::GoGrid::Compute::Server
+
+        def all
+          data = connection.grid_server_list.body['list']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.grid_server_get(server_id).body['list'].first
+            new(server)
+          end
+        rescue Fog::GoGrid::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_center.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_center.rb
new file mode 100644
index 0000000..9fcfab7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_center.rb
@@ -0,0 +1,12 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class DataCenter < Fog::Model
+        identity :id
+        attribute :location
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_centers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_centers.rb
new file mode 100644
index 0000000..c56733d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/data_centers.rb
@@ -0,0 +1,26 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/data_center'
+
+module Fog
+  module Linode
+    class Compute
+      class DataCenters < Fog::Collection
+        model Fog::Linode::Compute::DataCenter
+
+        def all
+          load datacenters
+        end
+
+        private
+        def datacenters(id=nil)
+          connection.avail_datacenters.body['DATA'].map { |datacenter| map_datacenter datacenter }
+        end
+        
+        def map_datacenter(datacenter)
+          datacenter = datacenter.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          datacenter.merge! :id => datacenter[:datacenterid], :name => datacenter[:location]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/disk.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/disk.rb
new file mode 100644
index 0000000..df9efd7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/disk.rb
@@ -0,0 +1,62 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Disk < Fog::Model
+        identity :id
+        attribute :name
+        attribute :type
+
+        def save
+          requires :server
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          @type, @image, @stack_script, @name, @password, @size =
+            attributes.values_at :type, :image, :stack_script, :name, :password, :size
+          create_disk
+        end        
+
+        def destroy
+          requires :identity, :server
+          connection.linode_disk_delete server.id, id
+        end
+
+        def server
+          @server
+        end
+
+        private
+        def server=(server)
+          @server = server
+        end
+
+        def create_disk
+          case
+          when @image && @stack_script then create_disk_from_stack_script
+          when @image then create_disk_from_image
+          when @type then create_disk_type
+          else raise 'disk cannot be created'
+          end
+        end
+
+        def create_disk_type
+          self.id = connection.linode_disk_create(server.id, "#{@name}_#{@type}", @type, @size).body['DATA']['DiskID']
+          reload
+        end
+
+        def create_disk_from_image
+          disk = connection.linode_disk_createfromdistribution server.id, @image.id, "#{@name}_main", @size, @password
+          self.id = disk.body['DATA']['DiskID']
+          reload
+        end        
+
+        def create_disk_from_stack_script
+          disk = connection.linode_disk_createfromstackscript(server.id, @stack_script.id, @image.id,
+                                                              "#{@name}_main", @size, @password, @stack_script.options)
+          self.id = disk.body['DATA']['DiskID']
+          reload
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/disks.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/disks.rb
new file mode 100644
index 0000000..eb7dc08
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/disks.rb
@@ -0,0 +1,40 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/disk'
+
+module Fog
+  module Linode
+    class Compute
+      class Disks < Fog::Collection
+        model Fog::Linode::Compute::Disk
+        attribute :server
+
+        def all
+          requires :server
+          load disks(server.id)
+        end
+
+        def get(id)
+          requires :server
+          new disks(server.id, id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :server
+          super({ :server => server }.merge!(attributes))
+        end
+
+        private
+        def disks(linode_id, id=nil)
+          connection.linode_disk_list(linode_id, id).body['DATA'].map { |disk| map_disk disk }
+        end
+        
+        def map_disk(disk)
+          disk = disk.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          disk.merge! :id => disk[:diskid], :name => disk[:label], :server_id => disk[:linodeid]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavor.rb
new file mode 100644
index 0000000..b3e1f55
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavor.rb
@@ -0,0 +1,23 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Flavor < Fog::Model
+        identity :id
+        attribute :disk
+        attribute :name
+        attribute :ram
+        attribute :price
+        
+        def cores
+          4 # linode always has 4 cores
+        end
+        
+        def bits
+          0 # these are determined by images you select not the hardware
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavors.rb
new file mode 100644
index 0000000..ec6f898
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/flavors.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/flavor'
+
+module Fog
+  module Linode
+    class Compute
+      class Flavors < Fog::Collection
+        model Fog::Linode::Compute::Flavor
+
+        def all
+          load flavors
+        end
+
+        def get(id)
+          new flavors(id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        private
+        def flavors(id=nil)
+          connection.avail_linodeplans(id).body['DATA'].map { |flavor| map_flavor flavor }
+        end
+        
+        def map_flavor(flavor)
+          flavor = flavor.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          flavor.merge! :id => flavor[:planid], :name => flavor[:label]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/image.rb
new file mode 100644
index 0000000..6f92532
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/image.rb
@@ -0,0 +1,14 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Image < Fog::Model
+        identity :id
+        attribute :name
+        attribute :bits
+        attribute :image_size
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/images.rb
new file mode 100644
index 0000000..d4aac4a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/images.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/image'
+
+module Fog
+  module Linode
+    class Compute
+      class Images < Fog::Collection
+        model Fog::Linode::Compute::Image
+
+        def all
+          load images
+        end
+
+        def get(id)
+          new images(id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        private
+        def images(id=nil)
+          connection.avail_distributions(id).body['DATA'].map { |image| map_image image }
+        end
+        
+        def map_image(image)
+          image = image.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          image.merge!(:id => image[:distributionid], :name => image[:label], :image_size => image[:minimagesize],
+                       :kernel_id => image[:requirespvopskernel], :bits => ((image[:is64bit] == 1) ? 64 : 32 ))
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/ip.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/ip.rb
new file mode 100644
index 0000000..aa40526
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/ip.rb
@@ -0,0 +1,30 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Ip < Fog::Model
+        identity :id
+        attribute :ip
+        attribute :public
+
+        def save
+          requires :server
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          
+          connection.linode_ip_addprivate server.id
+          server.ips.all.find { |ip| !ip.public }
+        end
+
+        def server
+          @server
+        end
+
+        private
+        def server=(server)
+          @server = server
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/ips.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/ips.rb
new file mode 100644
index 0000000..120e0c4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/ips.rb
@@ -0,0 +1,40 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/ip'
+
+module Fog
+  module Linode
+    class Compute
+      class Ips < Fog::Collection
+        model Fog::Linode::Compute::Ip
+        attribute :server
+
+        def all
+          requires :server
+          load ips(server.id)
+        end
+
+        def get(id)
+          requires :server
+          new ips(server.id, id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :server
+          super({ :server => server }.merge!(attributes))
+        end
+
+        private
+        def ips(linode_id, id=nil)
+          connection.linode_ip_list(linode_id, id).body['DATA'].map { |ip| map_ip ip }
+        end
+        
+        def map_ip(ip)
+          ip = ip.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          ip.merge! :id => ip[:ipaddressid], :ip => ip[:ipaddress], :public => ip[:ispublic]==1
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernel.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernel.rb
new file mode 100644
index 0000000..76188f5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernel.rb
@@ -0,0 +1,12 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Kernel < Fog::Model
+        identity :id
+        attribute :name
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernels.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernels.rb
new file mode 100644
index 0000000..874adab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/kernels.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/kernel'
+
+module Fog
+  module Linode
+    class Compute
+      class Kernels < Fog::Collection
+        model Fog::Linode::Compute::Kernel
+
+        def all
+          load kernels
+        end
+
+        def get(id)
+          new kernels(id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        private
+        def kernels(id=nil)
+          connection.avail_kernels(id).body['DATA'].map { |kernel| map_kernel kernel }
+        end
+        
+        def map_kernel(kernel)
+          kernel = kernel.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          kernel.merge! :id => kernel[:kernelid], :name => kernel[:label]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/server.rb
new file mode 100644
index 0000000..1fbc628
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/server.rb
@@ -0,0 +1,88 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class Server < Fog::Model
+        attr_reader :stack_script
+        identity :id
+        attribute :name
+        attribute :status
+
+        def ips
+          Fog::Linode::Compute::Ips.new :server => self, :connection => connection
+        end
+
+        def disks
+          Fog::Linode::Compute::Disks.new :server => self, :connection => connection
+        end
+
+        def disks?
+          not disks.empty?
+        end
+
+        def reboot
+          connection.linode_reboot id
+        end
+
+        def shutdown
+          connection.linode_shutdown id
+        end
+
+        def boot
+          connection.linode_boot id, config
+        end        
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          @data_center, @flavor, @image, @kernel, @type, @payment_terms, @stack_script, @name, @password, @callback =
+            attributes.values_at :data_center, :flavor, :image, :kernel, :type, :payment_terms, :stack_script, :name, :password, :callback
+
+          create_linode
+          @callback.call self if @callback
+          create_disks
+          create_config
+          boot_linode
+          self
+        rescue Exception => ex
+          destroy if id
+          raise ex
+        end
+
+        def destroy
+          requires :identity
+          connection.linode_shutdown id
+          disks.each { |disk| disk.destroy }
+          wait_for { not disks? }
+          connection.linode_delete id
+        end
+
+        private
+        def config
+          connection.linode_config_list(id).body['DATA'].first['ConfigID']
+        end
+        
+        def create_linode
+          self.id = connection.linode_create(@data_center.id, @flavor.id, @payment_terms).body['DATA']['LinodeID']
+          connection.linode_update id, :label => @name
+          ips.create
+          reload
+        end
+        
+        def create_disks
+          @swap = disks.create :type => :swap, :name => @name, :size => @flavor.ram
+          @disk = disks.create(:type => @type, :image => @image, :stack_script => @stack_script,
+                               :password => @password, :name => @name, :size => (@flavor.disk*1024)-@flavor.ram)
+        end
+
+        def create_config
+          @config = connection.linode_config_create(id, @kernel.id, @name, "#{@disk.id},#{@swap.id},,,,,,,").body['DATA']['ConfigID']
+        end
+
+        def boot_linode
+          connection.linode_boot id, @config
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/servers.rb
new file mode 100644
index 0000000..6fe74b9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/servers.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/server'
+
+module Fog
+  module Linode
+    class Compute
+      class Servers < Fog::Collection
+        model Fog::Linode::Compute::Server
+
+        def all
+          load servers
+        end
+
+        def get(id)
+          new servers(id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end
+
+        private
+        def servers(id=nil)
+          connection.linode_list(id).body['DATA'].map { |server| map_server server }
+        end
+        
+        def map_server(server)
+          server = server.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          server.merge! :id => server[:linodeid], :name => server[:label]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_script.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_script.rb
new file mode 100644
index 0000000..90826e2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_script.rb
@@ -0,0 +1,13 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class Compute
+      class StackScript < Fog::Model
+        attr_accessor :options
+        identity :id
+        attribute :name
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_scripts.rb b/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_scripts.rb
new file mode 100644
index 0000000..64d1662
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/linode/stack_scripts.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/linode/stack_script'
+
+module Fog
+  module Linode
+    class Compute
+      class StackScripts < Fog::Collection
+        model Fog::Linode::Compute::StackScript
+
+        def all
+          load stackscripts
+        end
+
+        def get(id)
+          new stackscripts(id).first
+        rescue Fog::Linode::Compute::NotFound
+          nil
+        end        
+
+        private
+        def stackscripts(id=nil)
+          connection.stackscript_list(id).body['DATA'].map { |script| map_stackscript script }
+        end
+        
+        def map_stackscript(script)
+          script = script.each_with_object({}) { |(k, v), h| h[k.downcase.to_sym] = v  }
+          script.merge! :id => script[:stackscriptid], :name => script[:label]
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavor.rb
new file mode 100644
index 0000000..4e4f9e8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavor.rb
@@ -0,0 +1,43 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :disk
+        attribute :name
+        attribute :ram
+
+        def bits
+          64
+        end
+
+        def cores
+          # 2 quad-cores >= 2Ghz = 8 cores
+          8 * case ram
+          when 256
+            1/64.0
+          when 512
+            1/32.0
+          when 1024
+            1/16.0
+          when 2048
+            1/8.0
+          when 4096
+            1/4.0
+          when 8192
+            1/2.0
+          when 15872
+            1
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavors.rb
new file mode 100644
index 0000000..add8276
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/rackspace/flavor'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Rackspace::Compute::Flavor
+
+        def all
+          data = connection.list_flavors_detail.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor_details(flavor_id).body['flavor']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/image.rb
new file mode 100644
index 0000000..6dec92f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/image.rb
@@ -0,0 +1,48 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :created_at,  :aliases => 'created'
+        attribute :updated_at,  :aliases => 'updated'
+        attribute :progress
+        attribute :status
+        attribute :server_id,   :aliases => 'serverId'
+
+        def server=(new_server)
+          requires :id
+
+          self.server_id = new_server.id
+        end
+
+        def destroy
+          requires :id
+
+          connection.delete_image(id)
+          true
+        end
+
+        def ready?
+          status == 'ACTIVE'
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :server_id
+
+          data = connection.create_image(server_id, 'name' => name)
+          merge_attributes(data.body['image'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/images.rb
new file mode 100644
index 0000000..ab877a3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/images.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/compute/models/rackspace/image'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Rackspace::Compute::Image
+
+        attribute :server
+
+        def all
+          data = connection.list_images_detail.body['images']
+          load(data)
+          if server
+            self.replace(self.select {|image| image.server_id == server.id})
+          end
+        end
+
+        def get(image_id)
+          data = connection.get_image_details(image_id).body['image']
+          new(data)
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/server.rb
new file mode 100644
index 0000000..121e4e4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/server.rb
@@ -0,0 +1,146 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :flavor_id,   :aliases => 'flavorId'
+        attribute :host_id,     :aliases => 'hostId'
+        attribute :image_id,    :aliases => 'imageId'
+        attribute :metadata
+        attribute :name
+        attribute :personality
+        attribute :progress
+        attribute :state,       :aliases => 'status'
+
+        attr_reader :password
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id  ||= 1  # 256 server
+          self.image_id   ||= 49 # Ubuntu 10.04 LTS 64bit
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_server(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def images
+          requires :id
+          connection.images(:server => self)
+        end
+
+        def private_ip_address
+          nil
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_ip_address
+          addresses['public'].first
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          self.state == 'ACTIVE'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_server(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id
+          options = {
+            'metadata'    => metadata,
+            'name'        => name,
+            'personality' => personality
+          }
+          options = options.reject {|key, value| value.nil?}
+          data = connection.create_server(flavor_id, image_id, options)
+          merge_attributes(data.body['server'])
+          true
+        end
+
+        def setup(credentials = {})
+          requires :public_ip_address, :identity, :public_key, :username
+          Fog::SSH.new(public_ip_address, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l #{username}},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json},
+            %{echo "#{metadata.to_json}" >> ~/metadata.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :public_ip_address, :identity, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SSH.new(public_ip_address, username, options).run(commands)
+        end
+
+        def scp(local_path, remote_path)
+          requires :public_ip_address, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SCP.new(public_ip_address, username, options).upload(local_path, remote_path)
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        private
+
+        def adminPass=(new_admin_pass)
+          @password = new_admin_pass
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/servers.rb
new file mode 100644
index 0000000..fb0e3fc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/rackspace/servers.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/compute/models/rackspace/server'
+
+module Fog
+  module Rackspace
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Rackspace::Compute::Server
+
+        def all
+          data = connection.list_servers_detail.body['servers']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:password => server.password)
+          server
+        end
+
+        def get(server_id)
+          if server = connection.get_server_details(server_id).body['server']
+            new(server)
+          end
+        rescue Fog::Rackspace::Compute::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavor.rb
new file mode 100644
index 0000000..99844f2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavor.rb
@@ -0,0 +1,45 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavor < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :price
+        attribute :ram
+
+        def bits
+          # 64
+          raise StandardError.new("Figure me out!?!")
+        end
+
+        def cores
+          # # 2 quad-cores >= 2Ghz = 8 cores
+          # 8 * case ram
+          # when 256
+          #   1/64.0
+          # when 512
+          #   1/32.0
+          # when 1024
+          #   1/16.0
+          # when 2048
+          #   1/8.0
+          # when 4096
+          #   1/4.0
+          # when 8192
+          #   1/2.0
+          # when 15872
+          #   1
+          # end
+          raise StandardError.new("Figure me out!?!")
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavors.rb
new file mode 100644
index 0000000..1d89935
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/flavors.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/compute/models/slicehost/flavor'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Flavors < Fog::Collection
+
+        model Fog::Slicehost::Compute::Flavor
+
+        def all
+          data = connection.get_flavors.body['flavors']
+          load(data)
+        end
+
+        def get(flavor_id)
+          data = connection.get_flavor(flavor_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/image.rb
new file mode 100644
index 0000000..05ac986
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/image.rb
@@ -0,0 +1,17 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/images.rb
new file mode 100644
index 0000000..6ca5b78
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/images.rb
@@ -0,0 +1,27 @@
+require 'fog/core/collection'
+require 'fog/compute/models/slicehost/image'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Slicehost::Compute::Image
+
+        def all
+          data = connection.get_images.body['images']
+          load(data)
+        end
+
+        def get(image_id)
+          connection.get_image(image_id)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/server.rb
new file mode 100644
index 0000000..3430bdf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/server.rb
@@ -0,0 +1,129 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :addresses
+        attribute :backup_id,     :aliases => 'backup-id'
+        attribute :bandwidth_in,  :aliases => 'bw-in'
+        attribute :bandwidth_out, :aliases => 'bw-out'
+        attribute :flavor_id,     :aliases => 'flavor-id'
+        attribute :image_id,      :aliases => 'image-id'
+        attribute :name
+        attribute :progress
+        attribute :state,         :aliases => 'status'
+
+        attr_accessor :password
+        alias_method :'root-password=', :password=
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.flavor_id  ||= 1  # 256 server
+          self.image_id   ||= 49 # Ubuntu 10.04 LTS 64bit
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.delete_slice(id)
+          true
+        end
+
+        def flavor
+          requires :flavor_id
+          connection.flavors.get(flavor_id)
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def private_ip_address
+          nil
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_ip_address
+          addresses.first
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          self.state == 'active'
+        end
+
+        def reboot(type = 'SOFT')
+          requires :id
+          connection.reboot_slice(id, type)
+          true
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :flavor_id, :image_id, :name
+
+          data = connection.create_slice(flavor_id, image_id, name)
+          merge_attributes(data.body)
+          true
+        end
+
+        def setup(credentials = {})
+          requires :addresses, :identity, :public_key, :username
+          Fog::SSH.new(addresses.first, username, credentials).run([
+            %{mkdir .ssh},
+            %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+            %{passwd -l #{username}},
+            %{echo "#{attributes.to_json}" >> ~/attributes.json}
+          ])
+        rescue Errno::ECONNREFUSED
+          sleep(1)
+          retry
+        end
+
+        def ssh(commands)
+          requires :addresses, :identity, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SSH.new(addresses.first, username, options).run(commands)
+        end
+
+        def scp(local_path, remote_path)
+          requires :addresses, :username
+
+          options = {}
+          options[:key_data] = [private_key] if private_key
+          Fog::SCP.new(addresses.first, username, options).upload(local_path, remote_path)
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/servers.rb
new file mode 100644
index 0000000..0044248
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/slicehost/servers.rb
@@ -0,0 +1,38 @@
+require 'fog/core/collection'
+require 'fog/compute/models/slicehost/server'
+
+module Fog
+  module Slicehost
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::Slicehost::Compute::Server
+
+        def all
+          data = connection.get_slices.body['slices']
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          server = create(new_attributes)
+          server.wait_for { ready? }
+          server.setup(:password => server.password)
+          server
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_slice(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancer.rb
new file mode 100644
index 0000000..b44d6ef
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancer.rb
@@ -0,0 +1,38 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Balancer < Fog::Model
+        
+        identity :uniq_id
+        
+        attribute :vip
+        attribute :price
+        attribute :name
+        attribute :session_persistence
+        attribute :ssl_termination
+        attribute :strategy
+        attribute :nodes
+        attribute :services
+
+        def initialize(attributes={})
+          super
+        end
+        
+        def add_node(options)
+          requires :identity
+          connection.add_balancer_node({:uniq_id => identity}.merge!(options))
+        end
+        
+        def remove_node(options)
+          requires :identity
+          connection.remove_balancer_node({:uniq_id => identity}.merge!(options))
+        end
+        
+        end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancers.rb
new file mode 100644
index 0000000..0e81dfd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/balancers.rb
@@ -0,0 +1,21 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/balancer'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Balancers < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::Balancer
+
+        def all
+          data = connection.list_balancers.body['loadbalancers']
+          load(data)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/config.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/config.rb
new file mode 100644
index 0000000..d062ff8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/config.rb
@@ -0,0 +1,25 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Config < Fog::Model
+        identity :id
+
+        attribute :available
+        attribute :description
+        attribute :disk
+        attribute :featured
+        attribute :memory
+        attribute :price
+        attribute :vcpu
+      end
+
+      def initialize(attributes={})
+        super
+      end
+      
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/configs.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/configs.rb
new file mode 100644
index 0000000..e97ed20
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/configs.rb
@@ -0,0 +1,22 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/config'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Configs < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::Config
+
+        def all
+          data = connection.list_configs.body['configs']
+          load(data)
+        end
+
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/image.rb
new file mode 100644
index 0000000..ba71730
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/image.rb
@@ -0,0 +1,20 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Image < Fog::Model
+        identity :id
+        attribute :accnt
+        attribute :name
+        attribute :source_hostname
+        attribute :source_subaccnt
+        attribute :template
+        attribute :template_description
+        attribute :time_taken
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/images.rb
new file mode 100644
index 0000000..6e86d6f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/images.rb
@@ -0,0 +1,21 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/image'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::Image
+
+        def all
+          data = connection.list_images.body['images']
+          load(data)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ip.rb
new file mode 100644
index 0000000..36168b3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ip.rb
@@ -0,0 +1,19 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class PrivateIp < Fog::Model
+        attribute :zone
+        attribute :uniq_id
+
+        def initialize(attributes={})
+          super
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ips.rb
new file mode 100644
index 0000000..eac78f5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/private_ips.rb
@@ -0,0 +1,31 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/private_ip'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class PrivateIps < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::PrivateIp
+
+        def all
+          data = connection.list_private_ips.body['networks']
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_private_ip(private_ip).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/server.rb
new file mode 100644
index 0000000..5277772
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/server.rb
@@ -0,0 +1,74 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Server < Fog::Model
+        identity :uniq_id
+
+        attribute :accnt
+        attribute :backup_enabled
+        attribute :backup_plan
+        attribute :backup_quota
+        attribute :backup_size
+        attribute :bandwidth_quota
+        attribute :config_description
+        attribute :config_id
+        attribute :create_date
+        attribute :domain
+        attribute :ip
+        attribute :ip_count
+        attribute :manage_level
+        attribute :subaccnt
+        attribute :template
+        attribute :template_description
+        attribute :zone
+        attribute :active
+        
+        attr_writer :password, :username
+
+        def initialize(attributes={})
+          super
+        end
+
+        def create(options)
+          data = connection.create_server(options).body['servers']
+          load(data)
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_server(:uniq_id => identity)
+          true
+        end
+
+        def ready?
+          active == 1
+        end
+
+        def reboot
+          requires :identity
+          connection.reboot_server(:uniq_id => identity)
+          true
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        def clone(options)
+          requires :identity
+          connection.clone_server({:uniq_id => identity}.merge!(options))
+          true
+        end
+        def resize(options)
+          requires :identity
+          connection.resize_server({:uniq_id => identity}.merge!(options))
+          true
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/servers.rb
new file mode 100644
index 0000000..3d7560e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/servers.rb
@@ -0,0 +1,26 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/server'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::Server
+
+        def all
+          data = connection.list_servers.body['servers']
+          load(data)
+        end
+
+        def get(uniq_id)
+          server = connection.get_server(:uniq_id => uniq_id).body
+          new(server)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stat.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stat.rb
new file mode 100644
index 0000000..5538109
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stat.rb
@@ -0,0 +1,23 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Stat < Fog::Model
+        attribute :loadavg
+        attribute :memory
+        attribute :virtual
+        attribute :domain
+        attribute :disk
+        attribute :uptime
+        
+        def initialize(attributes={})
+          super
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stats.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stats.rb
new file mode 100644
index 0000000..a8e9fdb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/stats.rb
@@ -0,0 +1,22 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/stat'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Stats < Fog::Collection
+        model Fog::StormOnDemand::Compute::Stat
+
+        def get(options)
+          data = connection.get_stats(options).body
+          load(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/template.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/template.rb
new file mode 100644
index 0000000..55011f1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/template.rb
@@ -0,0 +1,22 @@
+require 'fog/core/model'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Template < Fog::Model
+        identity :id
+        attribute :name
+        attribute :description
+        attribute :manage_level
+        attribute :os
+        attribute :price
+      end
+
+      def initialize(attributes={})
+        super
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/templates.rb b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/templates.rb
new file mode 100644
index 0000000..eea9a0c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/storm_on_demand/templates.rb
@@ -0,0 +1,21 @@
+require 'fog/core/collection'
+require 'fog/compute/models/storm_on_demand/template'
+
+module Fog
+  module StormOnDemand
+    class Compute
+
+      class Templates < Fog::Collection
+
+        model Fog::StormOnDemand::Compute::Template
+
+        def all
+          data = connection.list_templates.body['templates']
+          load(data)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium.rb
new file mode 100644
index 0000000..16518c0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium.rb
@@ -0,0 +1,87 @@
+require 'fog/core/model'
+require 'fog/compute/models/virtual_box/medium_format'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class Medium < Fog::Model
+
+        identity :id
+
+        attribute :auto_reset
+        attribute :base
+        attribute :children
+        attribute :description
+        attribute :device_type
+        attribute :format
+        attribute :host_drive
+        attribute :id
+        attribute :last_access_error
+        attribute :location
+        attribute :logical_size
+        attribute :machine_ids
+        attribute :medium_format
+        attribute :name
+        attribute :parent
+        attribute :read_only
+        attribute :size
+        attribute :state
+        attribute :type
+        attribute :variant
+
+        def destroy
+          requires :raw
+          raw.close
+          true
+        end
+
+        undef_method :medium_format
+        def medium_format
+          Fog::VirtualBox::Compute::MediumFormat.new(
+            :connection => connection,
+            :raw        => raw.medium_format
+          )
+        end
+
+        def save
+          requires :device_type, :location, :read_only
+
+          if File.exists?(location)
+
+            access_mode = if read_only
+              :access_mode_read_only
+            else
+              :access_mode_read_write
+            end
+
+            self.raw = connection.open_medium(location, device_type, access_mode)
+
+          else
+
+            raise Fog::Errors::Error.new('Creating a new medium is not yet implemented. Contributions welcome!')
+
+          end
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          for key in [:auto_reset, :base, :children, :description, :device_type, :format, :host_drive, :id, :last_access_error, :location, :logical_size, :machine_ids, :medium_format, :name, :parent, :read_only, :size, :state, :type, :variant]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium_format.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium_format.rb
new file mode 100644
index 0000000..358b14d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/medium_format.rb
@@ -0,0 +1,34 @@
+require 'fog/core/model'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class MediumFormat < Fog::Model
+
+        identity :id
+
+        # attribute :capabilities
+        attribute :name
+
+        private
+
+        def raw
+          @raw
+        end
+        
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          for key in [:id, :name]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/mediums.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/mediums.rb
new file mode 100644
index 0000000..fd8671e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/mediums.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/virtual_box/medium'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class Mediums < Fog::Collection
+
+        model Fog::VirtualBox::Compute::Medium
+
+        def all
+          data = []
+          data.concat(connection.dvd_images)
+          data.concat(connection.floppy_images)
+          data.concat(connection.hard_disks)
+          data = data.map do |medium|
+            {:raw => medium}
+          end
+          load(data)
+        end
+
+        def get(medium_identity)
+          data = connection.find_medium(medium_identity)
+          new(:raw => data)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_engine.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_engine.rb
new file mode 100644
index 0000000..a2ad067
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_engine.rb
@@ -0,0 +1,65 @@
+require 'fog/core/model'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class NATEngine < Fog::Model
+
+        # identity :?
+
+        attribute :alias_mode
+        attribute :dns_pass_domain
+        attribute :dns_proxy
+        attribute :dns_use_host_resolver
+        attribute :host_ip
+        attribute :network
+        attribute :redirects
+        attribute :tftp_boot_file
+        attribute :tftp_next_server
+        attribute :tftp_prefix
+
+        attr_accessor :machine, :network_adapter
+
+        # def save
+        #   unless identity
+        #     requires :identity, :bus, :machine
+        #     with_session do |session|
+        #       self.raw = session.machine.add_storage_controller(identity, bus)
+        #     end
+        #     true
+        #   else
+        #     raise Fog::Errors::Error.new('Updating an existing storage_controller is not yet implemented. Contributions welcome!')
+        #   end
+        # end
+
+        undef_method :redirects
+        def redirects
+          Fog::VirtualBox::Compute::NATRedirects.new(
+            :connection => connection,
+            :machine    => machine,
+            :nat_engine => self
+          )
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+        
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          for key in [:alias_mode, :dns_pass_domain, :dns_proxy, :dns_use_host_resolver, :host_ip, :network, :redirects, :tftp_boot_file, :tftp_next_server, :tftp_prefix]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirect.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirect.rb
new file mode 100644
index 0000000..8f8c3ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirect.rb
@@ -0,0 +1,91 @@
+require 'fog/core/model'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class NATRedirect < Fog::Model
+
+        identity :name
+
+        attribute :name
+        attribute :protocol
+        attribute :host_ip
+        attribute :host_port
+        attribute :guest_ip
+        attribute :guest_port
+
+        attr_accessor :machine, :nat_engine
+
+        def destroy
+          requires :nat_engine, :name
+          with_session do |session|
+            raw_network_adapter = session.machine.get_network_adapter(nat_engine.network_adapter.slot)
+            raw_nat_engine = raw_network_adapter.nat_driver
+            raw_nat_engine.remove_redirect(name)
+            session.machine.save_settings
+          end
+          true
+        end
+
+        def initialize(attributes = {})
+          self.name     = ''
+          self.protocol = :tcp
+          self.host_ip  = ''
+          self.guest_ip = ''
+          super
+        end
+
+        undef_method :protocol=
+        def protocol=(new_protocol)
+          attributes[:protocol] = case new_protocol
+          when '0'
+            :udp
+          when '1'
+            :tcp
+          else
+            new_protocol
+          end
+        end
+
+        def save
+          requires :nat_engine, :name, :protocol, :host_ip, :host_port, :guest_ip, :guest_port
+          with_session do |session|
+            raw_network_adapter = session.machine.get_network_adapter(nat_engine.network_adapter.slot)
+            raw_nat_engine = raw_network_adapter.nat_driver
+            raw_nat_engine.add_redirect(name, protocol, host_ip, host_port, guest_ip, guest_port)
+            session.machine.save_settings
+          end
+          true
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+
+        def raw=(new_raw)
+          @raw = new_raw
+          name, protocol, host_ip, host_port, guest_ip, guest_port = new_raw.split(',')
+          raw_attributes = {:name => name, :protocol => protocol, :host_ip => host_ip, :host_port => host_port, :guest_ip => guest_ip, :guest_port => guest_port}
+          merge_attributes(raw_attributes)
+        end
+
+        def session
+          ::VirtualBox::Lib.lib.session
+        end
+
+        def with_session
+          raw_machine = machine.instance_variable_get(:@raw)
+          raw_machine.lock_machine(session, :write)
+          yield session
+          session.unlock_machine
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirects.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirects.rb
new file mode 100644
index 0000000..adb6459
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/nat_redirects.rb
@@ -0,0 +1,41 @@
+require 'fog/core/collection'
+require 'fog/compute/models/virtual_box/nat_redirect'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class NATRedirects < Fog::Collection
+
+        model Fog::VirtualBox::Compute::NATRedirect
+
+        attr_accessor :machine, :nat_engine
+
+        def all
+          requires :machine, :nat_engine
+          data = nat_engine.instance_variable_get(:@raw).redirects.map do |nat_redirect|
+            {
+              :machine  => machine,
+              :raw      => nat_redirect
+            }
+          end
+          load(data)
+        end
+
+        def get(nat_redirect_name)
+          requires :machine, :nat_engine
+          all.detect do |nat_redirect|
+            nat_redirect.name == nat_redirect_name
+          end
+        end
+
+        def new(attributes = {})
+          requires :machine, :nat_engine
+          super({:machine => machine, :nat_engine => nat_engine}.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapter.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapter.rb
new file mode 100644
index 0000000..a98a20d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapter.rb
@@ -0,0 +1,82 @@
+require 'fog/core/model'
+require 'fog/compute/models/virtual_box/nat_engine'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class NetworkAdapter < Fog::Model
+
+        identity :slot
+
+        attribute :adapter_type
+        attribute :attachment_type
+        attribute :bandwidth_limit
+        attribute :boot_priority
+        attribute :cable_connected
+        attribute :enabled
+        attribute :host_interface
+        attribute :internal_network
+        attribute :line_speed
+        attribute :mac_address
+        attribute :nat_driver
+        attribute :nat_network
+        attribute :trace_enabled
+        attribute :trace_file
+        attribute :vde_network
+
+        attr_accessor :machine
+
+        def save
+          with_session do |session|
+            session_raw = session.machine.get_network_adapter(slot)
+            # for attribute in [:adapter_type, :bandwidth_limit, :boot_priority, :cable_connected, :enabled, :host_interface, :internal_network, :line_speed, :mac_address, :nat_network, :trace_enabled, :trace_file]
+            #   session_raw.send("#{attribute}=", attributes[attribute])
+            # end
+            session_raw.mac_address = mac_address
+            session.machine.save_settings
+          end
+        end
+
+        undef_method :nat_driver
+        def nat_driver
+          Fog::VirtualBox::Compute::NATEngine.new(
+            :connection       => connection,
+            :machine          => machine,
+            :network_adapter  => self,
+            :raw              => raw.nat_driver
+          )
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          for key in [:adapter_type, :attachment_type, :bandwidth_limit, :boot_priority, :cable_connected, :enabled, :host_interface, :internal_network, :line_speed, :mac_address, :nat_driver, :nat_network, :slot, :trace_enabled, :trace_file]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+        def session
+          ::VirtualBox::Lib.lib.session
+        end
+
+        def with_session
+          raw_machine = machine.instance_variable_get(:@raw)
+          raw_machine.lock_machine(session, :write)
+          yield session
+          session.unlock_machine
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapters.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapters.rb
new file mode 100644
index 0000000..f16da78
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/network_adapters.rb
@@ -0,0 +1,42 @@
+require 'fog/core/collection'
+require 'fog/compute/models/virtual_box/network_adapter'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class NetworkAdapters < Fog::Collection
+
+        model Fog::VirtualBox::Compute::NetworkAdapter
+
+        attr_accessor :machine
+
+        def all
+          requires :machine
+          data = []
+          raw_machine = machine.instance_variable_get(:@raw)
+          connection.system_properties.network_adapter_count.times do |index|
+            data << {
+              :raw  => raw_machine.get_network_adapter(index)
+            }
+          end
+          load(data)
+        end
+
+        def get(network_adapter_slot)
+          requires :machine
+          raw_machine = machine.instance_variable_get(:@raw)
+          network_adapter = raw_machine.get_network_adapter(network_adapter_slot)
+          new(:raw => network_adapter)
+        end
+
+        def new(attributes = {})
+          requires :machine
+          super({ :machine => machine }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/server.rb
new file mode 100644
index 0000000..65ca9d5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/server.rb
@@ -0,0 +1,241 @@
+require 'fog/core/model'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :description
+        attribute :memory_size
+        attribute :name
+        attribute :os,          :aliases => :os_type_id
+        attribute :rtc_use_utc
+        attribute :session_state
+        attribute :status,      :aliases => :state
+        attribute :vram_size
+
+        # property :accelerate_2d_video_enabled, T_BOOL
+        # property :accelerate_3d_enabled, T_BOOL
+        # property :access_error, :VirtualBoxErrorInfo, :readonly => true
+        # property :accessible, T_BOOL, :readonly => true
+        # property :audio_adapter, :AudioAdapter, :readonly => true
+        # property :bandwidth_control, :BandwidthControl, :readonly => true
+        # property :bios_settings, :BIOSSettings, :readonly => true
+        # property :chipset_type, :ChipsetType
+        # property :clipboard_mode, :ClipboardMode
+        # property :cpu_count, T_UINT32
+        # property :cpu_execution_cap, T_UINT64
+        # property :cpu_hot_plug_enabled, T_BOOL
+        # property :current_snapshot, :Snapshot, :readonly => true
+        # property :current_state_modified, T_BOOL, :readonly => true
+        # property :fault_tolerance_address, WSTRING
+        # property :fault_tolerance_password, WSTRING
+        # property :fault_tolerance_port, T_UINT64
+        # property :fault_tolerance_state, :FaultToleranceState
+        # property :fault_tolerance_sync_interval, T_UINT64
+        # property :firmware_type, :FirmwareType
+        # property :guest_property_notification_patterns, WSTRING
+        # property :hardware_uuid, WSTRING
+        # property :hardware_version, WSTRING
+        # property :hpet_enabled, T_BOOL
+        # property :io_cache_enabled, T_BOOL
+        # property :io_cache_size, T_UINT32
+        # property :keyboard_hid_type, T_UINT32
+        # property :last_state_change, T_INT64, :readonly => true
+        # property :log_folder, WSTRING, :readonly => true
+        # property :medium_attachments, [:MediumAttachment], :readonly => true
+        # property :memory_balloon_size, T_UINT64
+        # property :monitor_count, T_UINT64
+        # property :page_fusion_enabled, T_BOOL
+        # property :parent, :VirtualBox, :readonly => true
+        # property :pci_device_assignments, [:PciDeviceAttachment], :readonly => true
+        # property :pointing_hid_type, T_UINT32
+        # property :session_pid, T_UINT64, :readonly => true
+        # property :session_type, WSTRING, :readonly => true
+        # property :settings_file_path, WSTRING, :readonly => true
+        # property :settings_modified, T_BOOL, :readonly => true
+        # property :shared_folders, [:SharedFolder], :readonly => true
+        # property :snapshot_count, T_UINT32, :readonly => true
+        # property :snapshot_folder, WSTRING
+        # property :state_file_path, WSTRING, :readonly => true
+        # property :storage_controllers, [:StorageController], :readonly => true
+        # property :teleporter_address, WSTRING
+        # property :teleporter_enabled, T_BOOL
+        # property :teleporter_password, WSTRING
+        # property :teleporter_port, T_UINT32
+        # property :usb_controller, :USBController, :readonly => true
+        # property :vrde_server, :VRDEServer, :readonly => true
+
+        attr_writer :private_key, :private_key_path, :public_key, :public_key_path, :username
+
+        def initialize(attributes={})
+          self.memory_size = 256
+          self.rtc_use_utc = true
+          self.vram_size   = 8
+          super
+        end
+
+        def destroy
+          requires :name, :raw
+          unless raw.state == :powered_off
+            stop
+            wait_for { raw.session_state == :closed }
+          end
+          raw.unregister(:full)
+          config_file = connection.compose_machine_filename(name)
+          config_directory = config_file.split(File::SEPARATOR)[0...-1].join(File::SEPARATOR)
+          FileUtils.rm_rf(config_directory)
+          true
+        end
+
+        def network_adapters
+          Fog::VirtualBox::Compute::NetworkAdapters.new(
+            :connection => connection,
+            :machine => self
+          )
+        end
+
+        def private_ip_address
+          nil
+        end
+
+        def private_key_path
+          @private_key_path ||= Fog.credentials[:private_key_path]
+          @private_key_path &&= File.expand_path(@private_key_path)
+        end
+
+        def private_key
+          @private_key ||= private_key_path && File.read(private_key_path)
+        end
+
+        def public_ip_address
+          nil
+        end
+
+        def public_key_path
+          @public_key_path ||= Fog.credentials[:public_key_path]
+          @public_key_path &&= File.expand_path(@public_key_path)
+        end
+
+        def public_key
+          @public_key ||= public_key_path && File.read(public_key_path)
+        end
+
+        def ready?
+          status == :running
+        end
+
+        def reboot
+          requires :raw
+          session.console.reset
+          true
+        end
+
+        def save
+          unless identity
+            requires :name, :os
+            self.raw = connection.create_machine(nil, name, os)
+            connection.register_machine(raw)
+            with_session do |session|
+              for attribute in [:description, :memory_size, :rtc_use_utc, :vram_size]
+                session.machine.send(:"#{attribute}=", attributes[attribute])
+              end
+              session.machine.save_settings
+            end
+            true
+          else
+            raise Fog::Errors::Error.new('Updating an existing server is not yet implemented. Contributions welcome!')
+          end
+        end
+
+        def scp(local_path, remote_path)
+          raise 'Not Implemented'
+          # requires :addresses, :username
+          # 
+          # options = {}
+          # options[:key_data] = [private_key] if private_key
+          # Fog::SCP.new(addresses['public'].first, username, options).upload(local_path, remote_path)
+        end
+
+        def setup(credentials = {})
+          raise 'Not Implemented'
+        #   requires :addresses, :identity, :public_key, :username
+        #   Fog::SSH.new(addresses['public'].first, username, credentials).run([
+        #     %{mkdir .ssh},
+        #     %{echo "#{public_key}" >> ~/.ssh/authorized_keys},
+        #     %{passwd -l #{username}},
+        #     %{echo "#{attributes.to_json}" >> ~/attributes.json},
+        #     %{echo "#{metadata.to_json}" >> ~/metadata.json}
+        #   ])
+        # rescue Errno::ECONNREFUSED
+        #   sleep(1)
+        #   retry
+        end
+
+        def ssh(commands)
+          raise 'Not Implemented'
+          # requires :addresses, :identity, :username
+          # 
+          # options = {}
+          # options[:key_data] = [private_key] if private_key
+          # Fog::SSH.new(addresses['public'].first, username, options).run(commands)
+        end
+
+        def start(type = 'headless')
+          requires :raw
+          # session, type in ['gui', 'headless'], key[=value]\n env variables
+          raw.launch_vm_process(session, type, '').wait
+          true
+        end
+
+        def stop
+          requires :raw
+          session.console.power_down.wait
+          true
+        end
+
+        def storage_controllers
+          Fog::VirtualBox::Compute::StorageControllers.new(
+            :connection => connection,
+            :machine    => self
+          )
+        end
+
+        def username
+          @username ||= 'root'
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          for key in [:id, :description, :memory_size, :name, :os_type_id, :state]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+        def session
+          ::VirtualBox::Lib.lib.session
+        end
+
+        def with_session
+          raw.lock_machine(session, :write)
+          yield session
+          session.unlock_machine
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/servers.rb
new file mode 100644
index 0000000..3d81aec
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/servers.rb
@@ -0,0 +1,41 @@
+require 'fog/core/collection'
+require 'fog/compute/models/virtual_box/server'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class Servers < Fog::Collection
+
+        model Fog::VirtualBox::Compute::Server
+
+        def all
+          data = connection.machines.map do |machine|
+            {
+              :raw => machine
+            }
+          end
+          load(data)
+        end
+
+        def bootstrap(new_attributes = {})
+          raise 'Not Implemented'
+          # server = create(new_attributes)
+          # server.start
+          # server.wait_for { ready? }
+          # server.setup(:password => server.password)
+          # server
+        end
+
+        def get(server_id)
+          machine = connection.find_machine(server_id)
+          new(:raw => machine)
+        rescue ::VirtualBox::Exceptions::ObjectNotFoundException
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controller.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controller.rb
new file mode 100644
index 0000000..b8e1351
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controller.rb
@@ -0,0 +1,83 @@
+require 'fog/core/model'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class StorageController < Fog::Model
+
+        identity :name
+
+        attribute :bootable
+        attribute :bus
+        attribute :controller_type
+        attribute :instance
+        attribute :max_devices_per_port_count
+        attribute :max_port_count
+        attribute :min_port_count
+        attribute :port_count
+        attribute :use_host_io_cache
+
+        attr_accessor :machine
+
+        def attach(medium, port, device = 0)
+          requires :identity, :machine
+          with_session do |session|
+            session.machine.attach_device(identity, port, device, medium.device_type, medium.instance_variable_get(:@raw))
+            session.machine.save_settings
+          end
+          true
+        end
+
+        def destroy
+          requires :identity, :machine
+          with_session do |session|
+            session.machine.remove_storage_controller(identity)
+            session.machine.save_settings
+          end
+          true
+        end
+
+        def save
+          requires :bus, :identity, :machine
+          with_session do |session|
+            self.raw = session.machine.add_storage_controller(identity, bus)
+            raw.port_count = 1
+            session.machine.save_settings
+          end
+          true
+        end
+
+        private
+
+        def raw
+          @raw
+        end
+
+        def raw=(new_raw)
+          @raw = new_raw
+          raw_attributes = {}
+          # TODO: pending my patches being accepted :bootable, 
+          for key in [:bus, :controller_type, :instance, :max_devices_per_port_count, :max_port_count, :min_port_count, :port_count, :use_host_io_cache]
+            raw_attributes[key] = @raw.send(key)
+          end
+          merge_attributes(raw_attributes)
+        end
+
+        def session
+          ::VirtualBox::Lib.lib.session
+        end
+
+        def with_session
+          raw_machine = machine.instance_variable_get(:@raw)
+          raw_machine.lock_machine(session, :write)
+          yield session
+          session.unlock_machine
+        end
+
+      end
+
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controllers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controllers.rb
new file mode 100644
index 0000000..ce30cde
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/virtual_box/storage_controllers.rb
@@ -0,0 +1,38 @@
+require 'fog/core/collection'
+require 'fog/compute/models/virtual_box/storage_controller'
+
+module Fog
+  module VirtualBox
+    class Compute
+
+      class StorageControllers < Fog::Collection
+
+        model Fog::VirtualBox::Compute::StorageController
+
+        attr_accessor :machine
+
+        def all
+          requires :machine
+          data = machine.instance_variable_get(:@raw).storage_controllers.map do |storage_controller|
+            {:raw => storage_controller}
+          end
+          load(data)
+        end
+
+        def get(storage_controller_name)
+          requires :machine
+          all.detect do |storage_controller|
+            storage_controller.name == storage_controller_name
+          end
+        end
+
+        def new(attributes = {})
+          requires :machine
+          super({ :machine => machine }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/voxel/image.rb b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/image.rb
new file mode 100644
index 0000000..c1aa507
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/image.rb
@@ -0,0 +1,15 @@
+require 'fog/core/model'
+
+module Fog
+  module Voxel
+    class Compute
+      class Image < Fog::Model
+
+        identity :id
+
+        attribute :summary
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/voxel/images.rb b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/images.rb
new file mode 100644
index 0000000..3d9a78c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/images.rb
@@ -0,0 +1,30 @@
+require 'fog/core/collection'
+require 'fog/compute/models/voxel/image'
+
+module Fog
+  module Voxel
+    class Compute
+
+      class Images < Fog::Collection
+
+        model Fog::Voxel::Compute::Image
+
+        def all
+          data = connection.images_list.body['images']
+          load(data)
+        end
+
+        def get(image_id)
+          data = connection.images_list(image_id).body['images']
+
+          if data.empty?
+            nil
+          else
+            new(data.first)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/voxel/server.rb b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/server.rb
new file mode 100644
index 0000000..bb281de
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/server.rb
@@ -0,0 +1,78 @@
+require 'fog/core/model'
+
+module Fog
+  module Voxel
+    class Compute
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :processing_cores
+        attribute :image_id
+        attribute :facility
+        attribute :disk_size
+        attribute :ip_assignments, :aliases => 'ipassignments'
+
+        def initialize(attributes={})
+          self.image_id ||= '55' # Ubuntu 10.04 LTS 64bit
+          super
+        end
+
+        def destroy
+          requires :id
+          connection.voxcloud_delete(id)
+          true
+        end
+
+        def image
+          requires :image_id
+          connection.images.get(image_id)
+        end
+
+        def ready?
+          self.state == 'SUCCEEDED'
+        end
+
+        def private_ip_address
+          ip_assignments.select {|ip_assignment| ip_assignment['type'] == 'internal'}.first
+        end
+
+        def public_ip_address
+          ip_assignments.select {|ip_assignment| ip_assignment['type'] == 'external'}.first
+        end
+
+        def reboot
+          requires :id
+          connection.devices_power(id, :reboot)
+          true
+        end
+
+        def state
+          @state ||= connection.voxcloud_status(id).body['devices'].first['status']
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :name, :image_id, :processing_cores, :facility, :disk_size
+
+          data = connection.voxcloud_create({
+            :disk_size => disk_size,
+            :facility => facility,
+            :hostname => name,
+            :image_id => image_id,
+            :processing_cores => processing_cores
+          }).body
+
+          merge_attributes(data['device'])
+
+          true
+        end
+
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/models/voxel/servers.rb b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/servers.rb
new file mode 100644
index 0000000..159a84b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/models/voxel/servers.rb
@@ -0,0 +1,32 @@
+require 'fog/core/collection'
+require 'fog/compute/models/voxel/server'
+
+module Fog
+  module Voxel
+    class Compute
+      class Servers < Fog::Collection
+
+        model Fog::Voxel::Compute::Server
+
+        def all
+          data = connection.devices_list.body['devices'].select {|device| device['type']['id'] == '3'}
+          load(data)
+        end
+
+        def get(device_id)
+          if device_id && server = connection.devices_list(device_id).body['devices']
+            new(server.first)
+          end
+        rescue Fog::Service::Error => error
+          if error.message == "The device_id passed in can't be matched to a valid device."
+            nil
+          else
+            raise error
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/new_servers.rb b/vendor/fog-0.8.2/lib/fog/compute/new_servers.rb
new file mode 100644
index 0000000..b68353d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/new_servers.rb
@@ -0,0 +1,108 @@
+module Fog
+  module NewServers
+    class Compute < Fog::Service
+
+      requires :new_servers_password, :new_servers_username
+      recognizes :host, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/new_servers'
+
+      request_path 'fog/compute/requests/new_servers'
+      request :add_server
+      request :cancel_server
+      request :get_server
+      request :list_images
+      request :list_plans
+      request :list_servers
+      request :reboot_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::NewServers::Compute.new is deprecated, use Fog::Compute.new(:provider => 'NewServers') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @new_server_username = options[:new_servers_username]
+        end
+
+        def data
+          self.class.data[@new_server_username]
+        end
+
+        def reset_data
+          self.class.data.delete(@new_server_username)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::NewServers::Compute.new is deprecated, use Fog::Compute.new(:provider => 'NewServers') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @new_servers_password = options[:new_servers_password]
+          @new_servers_username = options[:new_servers_username]
+          @host   = options[:host]    || "noc.newservers.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!({
+            :password => @new_servers_password,
+            :username => @new_servers_username
+          })
+          params[:headers] ||= {}
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::NewServers::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/allocate_address.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/allocate_address.rb
new file mode 100644
index 0000000..40fcfef
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/allocate_address.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AllocateAddress < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'publicIp', 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/attach_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/attach_volume.rb
new file mode 100644
index 0000000..9293cae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/attach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class AttachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/basic.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/basic.rb
new file mode 100644
index 0000000..4affa61
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/basic.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class Basic < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId'
+              @response[name] = value
+            when 'return'
+              if value == 'true'
+                @response[name] = true
+              else
+                @response[name] = false
+              end
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_image.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_image.rb
new file mode 100644
index 0000000..a008fb2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId', 'name', 'description', 'noReboot', 'imageId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_key_pair.rb
new file mode 100644
index 0000000..a575c1b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyMaterial', 'keyName', 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_snapshot.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_snapshot.rb
new file mode 100644
index 0000000..6a36a3f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_snapshot.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateSnapshot < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+              @response[name] = value
+            when 'requestId'
+              @response[name] = value
+            when 'startTime'
+              @response[name] = Time.parse(value)
+            when 'volumeSize'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_volume.rb
new file mode 100644
index 0000000..e75fa9b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/create_volume.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class CreateVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'requestId', 'snapshotId', 'status', 'volumeId'
+              @response[name] = value
+            when 'createTime'
+              @response[name] = Time.parse(value)
+            when 'size'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/deregister_image.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/deregister_image.rb
new file mode 100644
index 0000000..cf64b94
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/deregister_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DeregisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'return', 'requestId', 'imageId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_addresses.rb
new file mode 100644
index 0000000..77c6717
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_addresses.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAddresses < Fog::Parsers::Base
+
+          def reset
+            @address = {}
+            @response = { 'addressesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'publicIp'
+              @address[name] = value
+            when 'item'
+              @response['addressesSet'] << @address
+              @address = {}
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_availability_zones.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_availability_zones.rb
new file mode 100644
index 0000000..b25061e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_availability_zones.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeAvailabilityZones < Fog::Parsers::Base
+
+          def reset
+            @availability_zone = { 'messageSet' => [] }
+            @response = { 'availabilityZoneInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['availabilityZoneInfo'] << @availability_zone
+              @availability_zone = { 'messageSet' => [] }
+            when 'message'
+              @availability_zone['messageSet'] << value
+            when 'regionName', 'zoneName', 'zoneState'
+              @availability_zone[name] = value
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_images.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_images.rb
new file mode 100644
index 0000000..c7b6941
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_images.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeImages < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @image = { 'blockDeviceMapping' => [], 'productCodes' => [], 'tagSet' => {} }
+            @response = { 'imagesSet' => [] }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_tag_set
+              case name
+                when 'item'
+                  @image['tagSet'][@tag['key']] = @tag['value']
+                  @tag = {}
+                when 'key', 'value'
+                  @tag[name] = value
+                when 'tagSet'
+                  @in_tag_set = false
+              end
+            elsif @in_block_device_mapping
+              case name
+                when 'blockDeviceMapping'
+                  @in_block_device_mapping = false
+                when 'deviceName', 'virtualName', 'snapshotId', 'deleteOnTermination'
+                  @block_device_mapping[name] = value
+                when 'volumeSize'
+                  @block_device_mapping[name] = value.to_i
+                when 'item'
+                  @image['blockDeviceMapping'] << @block_device_mapping
+                  @block_device_mapping = {}
+              end
+            else
+              case name
+              when 'architecture', 'description', 'imageId', 'imageLocation', 'imageOwnerId', 'imageState', 'imageType', 'kernelId', 'name', 'platform', 'ramdiskId', 'rootDeviceType','rootDeviceName','virtualizationType'
+                @image[name] = value
+              when 'isPublic'
+                if value == 'true'
+                  @image[name] = true
+                else
+                  @image[name] = false
+                end
+              when 'item'
+                @response['imagesSet'] << @image
+                @image = { 'blockDeviceMapping' => [], 'productCodes' => [], 'tagSet' => {} }
+              when 'productCode'
+                @image['productCodes'] << value
+              when 'requestId'
+                @response[name] = value
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_instances.rb
new file mode 100644
index 0000000..478b6c5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_instances.rb
@@ -0,0 +1,119 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [], 'stateReason' => {}, 'tagSet' => {} }
+            @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+            @response = { 'reservationSet' => [] }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when'groupSet', 'productCodes'
+              @in_subset = true
+            when 'instancesSet'
+              @in_instances_set = true
+            when 'instanceState'
+              @in_instance_state = true
+            when 'stateReason'
+              @in_state_reason = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = value.to_i
+            when 'availabilityZone'
+              @instance['placement'][name] = value
+            when 'architecture', 'clientToken', 'dnsName', 'imageId',
+                  'instanceId', 'instanceType', 'ipAddress', 'kernelId',
+                  'keyName', 'privateDnsName', 'privateIpAddress', 'ramdiskId',
+                  'reason', 'rootDeviceType'
+              @instance[name] = value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              if @in_instance_state
+                @instance['instanceState'][name] = value.to_i
+              elsif @in_state_reason
+                @instance['stateReason'][name] = value.to_i
+              end
+            when 'deleteOnTermination'
+              if value == 'true'
+                @block_device_mapping[name] = true
+              else
+                @block_device_mapping[name] = false
+              end
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = value
+            when 'groupId'
+              @reservation['groupSet'] << value
+            when 'groupSet', 'productCodes'
+              @in_subset = false
+            when 'instancesSet'
+              @in_instances_set = false
+            when 'instanceState'
+              @in_instance_state = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif @in_tag_set
+                @instance['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              elsif @in_instances_set
+                @reservation['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [], 'stateReason' => {}, 'tagSet' => {} }
+              elsif !@in_subset
+                @response['reservationSet'] << @reservation
+                @reservation = { 'groupSet' => [], 'instancesSet' => [] }
+              end
+            when 'key', 'value'
+              @tag[name] = value
+            when 'launchTime'
+              @instance[name] = Time.parse(value)
+            when 'name'
+              if @in_instance_state
+                @instance['instanceState'][name] = value
+              elsif @in_state_reason
+                @instance['stateReason'][name] = value
+              end
+            when 'ownerId', 'reservationId'
+              @reservation[name] = value
+            when 'requestId'
+              @response[name] = value
+            when 'productCode'
+              @instance['productCodes'] << value
+            when 'state'
+              if value == 'true'
+                @instance['monitoring'][name] = true
+              else
+                @instance['monitoring'][name] = false
+              end
+            when 'stateReason'
+              @in_state_reason = false
+            when 'tagSet'
+              @in_tag_set = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_key_pairs.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_key_pairs.rb
new file mode 100644
index 0000000..40cca22
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_key_pairs.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeKeyPairs < Fog::Parsers::Base
+
+          def reset
+            @key = {}
+            @response = { 'keySet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['keySet'] << @key
+              @key = {}
+            when 'keyFingerprint', 'keyName'
+              @key[name] = value
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_regions.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_regions.rb
new file mode 100644
index 0000000..279cd38
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_regions.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeRegions < Fog::Parsers::Base
+
+          def reset
+            @region = {}
+            @response = { 'regionInfo' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'item'
+              @response['regionInfo'] << @region
+              @region = {}
+            when 'regionEndpoint', 'regionName'
+              @region[name] = value
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances.rb
new file mode 100644
index 0000000..7e9b2ea
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeReservedInstances < Fog::Parsers::Base
+
+          def reset
+            @reserved_instance = {}
+            @response = { 'reservedInstancesSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'instanceType', 'productDescription', 'reservedInstancesId', 'state'
+              @reserved_instance[name] = value
+            when 'duration', 'instanceCount'
+              @reserved_instance[name] = value.to_i
+            when 'fixedPrice', 'usagePrice'
+              @reserved_instance[name] = value.to_f
+            when 'item'
+              @response['reservedInstancesSet'] << @reserved_instance
+              @reserved_instance = {}
+            when 'requestId'
+              @response[name] = value
+            when 'start'
+              @response[name] = Time.parse(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances_offerings.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances_offerings.rb
new file mode 100644
index 0000000..1ae25dc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_reserved_instances_offerings.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeReservedInstancesOfferings < Fog::Parsers::Base
+
+          def reset
+            @reserved_instances_offering = {}
+            @response = { 'reservedInstancesOfferingsSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'availabilityZone', 'instanceType', 'productDescription', 'reservedInstancesOfferingId'
+              @reserved_instances_offering[name] = value
+            when 'duration'
+              @reserved_instances_offering[name] = value.to_i
+            when 'fixedPrice', 'usagePrice'
+              @reserved_instances_offering[name] = value.to_f
+            when 'item'
+              @response['reservedInstancesOfferingsSet'] << @reserved_instances_offering
+              @reserved_instances_offering = {}
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_security_groups.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_security_groups.rb
new file mode 100644
index 0000000..e2dca7b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_security_groups.rb
@@ -0,0 +1,76 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSecurityGroups < Fog::Parsers::Base
+
+          def reset
+            @group = {}
+            @ip_permission = { 'groups' => [], 'ipRanges' => []}
+            @ip_range = {}
+            @security_group = { 'ipPermissions' => [] }
+            @response = { 'securityGroupInfo' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'groups'
+              @in_groups = true
+            when 'ipPermissions'
+              @in_ip_permissions = true
+            when 'ipRanges'
+              @in_ip_ranges = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'cidrIp'
+              @ip_range[name] = value
+            when 'fromPort', 'toPort'
+              @ip_permission[name] = value.to_i
+            when 'groups'
+              @in_groups = false
+            when 'groupDescription', 'ownerId'
+              @security_group[name] = value
+            when 'groupName'
+              if @in_groups
+                @group[name] = value
+              else
+                @security_group[name] = value
+              end
+            when 'ipPermissions'
+              @in_ip_permissions = false
+            when 'ipProtocol'
+              @ip_permission[name] = value
+            when 'ipRanges'
+              @in_ip_ranges = false
+            when 'item'
+              if @in_groups
+                @ip_permission['groups'] << @group
+                @group = {}
+              elsif @in_ip_ranges
+                @ip_permission['ipRanges'] << @ip_range
+                @ip_range = {}
+              elsif @in_ip_permissions
+                @security_group['ipPermissions'] << @ip_permission
+                @ip_permission = { 'groups' => [], 'ipRanges' => []}
+               else
+                @response['securityGroupInfo'] << @security_group
+                @security_group = { 'ipPermissions' => [] }
+              end
+            when 'requestId'
+              @response[name] = value
+            when 'userId'
+              @group[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_snapshots.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_snapshots.rb
new file mode 100644
index 0000000..58244ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_snapshots.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeSnapshots < Fog::Parsers::Base
+
+          def reset
+            @response = { 'snapshotSet' => [] }
+            @snapshot = { 'tagSet' => {} }
+            @tag = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_tag_set
+              case name
+              when 'item'
+                @snapshot['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              when 'key', 'value'
+                @tag[name] = value
+              when 'tagSet'
+                @in_tag_set = false
+              end
+            else
+              case name
+              when 'item'
+                @response['snapshotSet'] << @snapshot
+                @snapshot = { 'tagSet' => {} }
+              when 'description', 'ownerId', 'progress', 'snapshotId', 'status', 'volumeId'
+                @snapshot[name] ||= value
+              when 'requestId'
+                @response[name] = value
+              when 'startTime'
+                @snapshot[name] = Time.parse(value)
+              when 'volumeSize'
+                @snapshot[name] = value.to_i
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_tags.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_tags.rb
new file mode 100644
index 0000000..3d8167d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_tags.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeTags < Fog::Parsers::Base
+
+          def reset
+            @tag = {}
+            @response = { 'tagSet' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'resourceId', 'resourceType', 'key', 'value'
+              @tag[name] = value
+            when 'item'
+              @response['tagSet'] << @tag
+              @tag = {}
+            when 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_volumes.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_volumes.rb
new file mode 100644
index 0000000..731030b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/describe_volumes.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DescribeVolumes < Fog::Parsers::Base
+
+          def reset
+            @attachment = {}
+            @in_attachment_set = false
+            @response = { 'volumeSet' => [] }
+            @tag = {}
+            @volume = { 'attachmentSet' => [], 'tagSet' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'attachmentSet'
+              @in_attachment_set = true
+            when 'tagSet'
+              @in_tag_set = true
+            end
+          end
+
+          def end_element(name)
+            if @in_attachment_set
+              case name
+              when 'attachmentSet'
+                @in_attachment_set = false
+              when 'attachTime'
+                @attachment[name] = Time.parse(value)
+              when 'deleteOnTermination'
+                @attachment[name] = value == 'true'
+              when 'device', 'instanceId', 'status', 'volumeId'
+                @attachment[name] = value
+              when 'item'
+                @volume['attachmentSet'] << @attachment
+                @attachment = {}
+              end
+            elsif @in_tag_set
+              case name
+              when 'key', 'value'
+                @tag[name] = value
+              when 'item'
+                @volume['tagSet'][@tag['key']] = @tag['value']
+                @tag = {}
+              when 'tagSet'
+                @in_tag_set = false
+              end
+            else
+              case name
+              when 'availabilityZone', 'snapshotId', 'status', 'volumeId'
+                @volume[name] = value
+              when 'createTime'
+                @volume[name] = Time.parse(value)
+              when 'item'
+                @response['volumeSet'] << @volume
+                @volume = { 'attachmentSet' => [], 'tagSet' => {} }
+              when 'requestId'
+                @response[name] = value
+              when 'size'
+                @volume[name] = value.to_i
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/detach_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/detach_volume.rb
new file mode 100644
index 0000000..e34c201
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/detach_volume.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class DetachVolume < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'attachTime'
+              @response[name] = Time.parse(value)
+            when 'device', 'instanceId', 'requestId', 'status', 'volumeId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_console_output.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_console_output.rb
new file mode 100644
index 0000000..893a65f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_console_output.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class GetConsoleOutput < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId'
+              @response[name] = value
+            when 'output'
+              @response[name] = value && Base64.decode64(value)
+            when 'timestamp'
+              @response[name] = Time.parse(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_password_data.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_password_data.rb
new file mode 100644
index 0000000..436a2ec
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/get_password_data.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class GetPasswordData < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId', 'requestId', 'passwordData'
+              @response[name] = @value
+            when 'timestamp'
+              @response[name] = Time.parse(@value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/import_key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/import_key_pair.rb
new file mode 100644
index 0000000..9d30954
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/import_key_pair.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class ImportKeyPair < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'keyFingerprint', 'keyName', 'requestId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/monitor_unmonitor_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/monitor_unmonitor_instances.rb
new file mode 100644
index 0000000..89fc5f7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/monitor_unmonitor_instances.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class MonitorUnmonitorInstances < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+            @instance_set = []
+            @current_instance_set = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'requestId'
+              @response['requestId'] = value
+            when 'instanceId'
+              @current_instance_set['instanceId'] = value
+            when 'item'
+              @instance_set << @current_instance_set
+              @current_instance_set = {}
+            when 'state'
+              @current_instance_set['monitoring'] = value
+            when 'instancesSet'
+              @response['instancesSet'] = @instance_set
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/register_image.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/register_image.rb
new file mode 100644
index 0000000..03e9c91
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/register_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RegisterImage < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'requestId', 'imageId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/run_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/run_instances.rb
new file mode 100644
index 0000000..9edf010
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/run_instances.rb
@@ -0,0 +1,81 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class RunInstances < Fog::Parsers::Base
+
+          def reset
+            @block_device_mapping = {}
+            @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+            @response = { 'groupSet' => [], 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = true
+            when 'groupSet'
+              @in_group_set = true
+            when 'productCodes'
+              @in_product_codes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'amiLaunchIndex'
+              @instance[name] = value.to_i
+            when 'architecture', 'clientToken', 'dnsName', 'imageId',
+                  'instanceId', 'instanceType', 'ipAddress', 'kernelId',
+                  'keyName', 'privateDnsName', 'privateIpAddress', 'ramdiskId',
+                  'reason', 'rootDeviceType'
+              @instance[name] = value
+            when 'availabilityZone'
+              @instance['placement'][name] = value
+            when 'attachTime'
+              @block_device_mapping[name] = Time.parse(value)
+            when 'blockDeviceMapping'
+              @in_block_device_mapping = false
+            when 'code'
+              @instance['instanceState'][name] = value.to_i
+            when 'deleteOnTermination'
+              @block_device_mapping[name] = (value == 'true')
+            when 'deviceName', 'status', 'volumeId'
+              @block_device_mapping[name] = value
+            when 'groupId'
+              @response['groupSet'] << value
+            when 'groupSet'
+              @in_group_set = false
+            when 'item'
+              if @in_block_device_mapping
+                @instance['blockDeviceMapping'] << @block_device_mapping
+                @block_device_mapping = {}
+              elsif !@in_group_set && !@in_product_codes
+                @response['instancesSet'] << @instance
+                @instance = { 'blockDeviceMapping' => [], 'instanceState' => {}, 'monitoring' => {}, 'placement' => {}, 'productCodes' => [] }
+              end
+            when 'launchTime'
+              @instance[name] = Time.parse(value)
+            when 'name'
+              @instance['instanceState'][name] = value
+            when 'ownerId', 'requestId', 'reservationId'
+              @response[name] = value
+            when 'product_code'
+              @instance['productCodes'] << value
+            when 'productCodes'
+              @in_product_codes = false
+            when 'state'
+              @instance['monitoring'][name] = (value == 'true')
+            when 'subnetId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/start_stop_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/start_stop_instances.rb
new file mode 100644
index 0000000..9c311d0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/start_stop_instances.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class StartStopInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'currentState' => {}, 'previousState' => {} }
+            @response = { 'instancesSet' => [] }
+            @state = nil
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'currentState', 'previousState'
+              @state = name
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'code'
+              @instance[@state][name] = value.to_s
+            when 'instanceId'
+              @instance[name] = value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'currentState' => {}, 'previousState' => {} }
+            when 'name'
+              @instance[@state][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/terminate_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/terminate_instances.rb
new file mode 100644
index 0000000..3365188
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/aws/terminate_instances.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module Compute
+
+        class TerminateInstances < Fog::Parsers::Base
+
+          def reset
+            @instance = { 'previousState' => {}, 'currentState' => {} }
+            @response = { 'instancesSet' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'previousState'
+              @in_previous_state = true
+            elsif name == 'currentState'
+              @in_current_state = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'instanceId'
+              @instance[name] = value
+            when 'item'
+              @response['instancesSet'] << @instance
+              @instance = { 'previousState' => {}, 'currentState' => {} }
+            when 'code'
+              if @in_previous_state
+                @instance['previousState'][name] = value.to_i
+              elsif @in_current_state
+                @instance['currentState'][name] = value.to_i
+              end
+            when 'name'
+              if @in_previous_state
+                @instance['previousState'][name] = value
+              elsif @in_current_state
+                @instance['currentState'][name] = value
+              end
+            when 'previousState'
+              @in_previous_state = false
+            when 'requestId'
+              @response[name] = value
+            when 'currentState'
+              @in_current_state = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/create_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/create_slice.rb
new file mode 100644
index 0000000..5893c02
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/create_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class CreateSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = value.to_f
+            when 'name', 'root-password', 'status'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_backups.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_backups.rb
new file mode 100644
index 0000000..f10cc34
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_backups.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetBackups < Fog::Parsers::Base
+
+          def reset
+            @backup = {}
+            @response = { 'backups' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'backup'
+              @response['backups'] << @backup
+              @backup = {}
+            when 'date'
+              @backup[name] = Time.parse(value)
+            when 'id', 'slice-id'
+              @backup[name] = value.to_i
+            when 'name'
+              @backup[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavor.rb
new file mode 100644
index 0000000..1c13c1a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavor.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavor < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'price', 'ram'
+              @response[name] = value.to_i
+            when 'name'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavors.rb
new file mode 100644
index 0000000..7e750ba
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_flavors.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetFlavors < Fog::Parsers::Base
+
+          def reset
+            @flavor = {}
+            @response = { 'flavors' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'flavor'
+              @response['flavors'] << @flavor
+              @flavor = {}
+            when 'id', 'price', 'ram'
+              @flavor[name] = value.to_i
+            when 'name'
+              @flavor[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_image.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_image.rb
new file mode 100644
index 0000000..1e78f4a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_image.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImage < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @response[name] = value.to_i
+            when 'name'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_images.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_images.rb
new file mode 100644
index 0000000..097a469
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_images.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetImages < Fog::Parsers::Base
+
+          def reset
+            @image = {}
+            @response = { 'images' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @image[name] = value.to_i
+            when 'image'
+              @response['images'] << @image
+              @image = {}
+            when 'name'
+              @image[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slice.rb
new file mode 100644
index 0000000..0a1539a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slice.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlice < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @response['addresses'] ||= []
+              @response['addresses'] << value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @response[name] = value.to_i
+            when 'bw-in', 'bw-out'
+              @response[name] = value.to_f
+            when 'name', 'status'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slices.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slices.rb
new file mode 100644
index 0000000..e80b727
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/slicehost/get_slices.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module Compute
+
+        class GetSlices < Fog::Parsers::Base
+
+          def reset
+            @slice = {}
+            @response = { 'slices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'address'
+              @slice['addresses'] ||= []
+              @slice['addresses'] << value
+            when 'backup-id', 'flavor-id', 'id', 'image-id', 'progress'
+              @slice[name] = value.to_i
+            when 'bw-in', 'bw-out'
+              @slice[name] = value.to_f
+            when 'name', 'status'
+              @slice[name] = value
+            when 'slice'
+              @response['slices'] << @slice
+              @slice = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/basic.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/basic.rb
new file mode 100644
index 0000000..148657a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/basic.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+
+        class Basic < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/devices_list.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/devices_list.rb
new file mode 100644
index 0000000..5f7a248
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/devices_list.rb
@@ -0,0 +1,111 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+
+        class DevicesList < Fog::Parsers::Base
+
+          def reset
+            @device          = {}
+            @response        = { 'devices' => [] }
+            @in_storage      = false
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'accessmethod'
+              @access_method = { 'type' => attr_value('type', attrs) }
+            when 'accessmethods'
+              @device['access_methods'] = []
+            when 'device'
+              @device = {
+                'id'      => attr_value('id', attrs),
+                'label'   => attr_value('label', attrs),
+                'status'  => attr_value('status', attrs)
+              }
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            when 'cage', 'facility', 'rack', 'row', 'zone'
+              @device['location'][name] = { 'id' => attr_value('id', attrs) }
+              if code = attr_value('code', attrs)
+                @device['location'][name]['code'] = code
+              end
+            when 'drive'
+              @drive = { 'position' => attr_value('position', attrs) }
+            when 'ipassignment'
+              type = attr_value('type', attrs)
+              @device['ipassignments'] = []
+              @device['ipassignments'] << {
+                'id'          => attr_value('id', attrs),
+                'type'        => attr_value('type', attrs),
+                'description' => attr_value('description', attrs),
+              }
+            when 'ipassignments'
+              @device['ipassignments'] = {}
+            when 'location'
+              @device['location'] = {}
+            when 'memory'
+              @device['memory'] = { 'size' =>  attr_value('size', attrs).to_i }
+            when 'model', 'type'
+              @device[name] = { 'id'    => attr_value('id', attrs) }
+            when 'operating_system'
+              @device['operating_system'] = {}
+            when 'power_consumption'
+              @device[name] = attr_value('unit', attrs)
+            when 'processor'
+              @device['processor'] = {}
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            when 'storage'
+              @device['drives'] = []
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'access_method'
+              @device['access_methods'] << @access_method
+            when 'architecture'
+              @device['operating_system'][name] = value.to_i
+            when 'cage', 'facility', 'rack', 'row', 'zone'
+              @device['location'][name]['value'] = value
+            when 'cores'
+              @device['processor'][name] = value.to_i
+            when 'description'
+              @device[name] = value
+            when 'device'
+              @response['devices'] << @device
+              @device = {}
+            when 'drive'
+              @device['drives'] << @drive
+              @drive = {}
+            when 'cores'
+              @device['processing_cores'] = value.to_i
+            when 'ipassignment'
+              @device['ipassignments'].last['value'] = value
+            when 'model', 'type'
+              @device[name]['value'] = value
+            when 'name'
+              @device['operating_system'][name] = value
+            when 'position'
+              @device['location'][name] = value
+            when 'power_consumption'
+              @device[name] = [value, @device[name]].join(' ')
+            when 'size'
+              @drive[name] = value.to_i
+            when 'host', 'password', 'protocol', 'username'
+              @access_method[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/images_list.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/images_list.rb
new file mode 100644
index 0000000..b077ce2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/images_list.rb
@@ -0,0 +1,59 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+
+        class ImagesList < Fog::Parsers::Base
+
+          def reset
+            @image = {}
+            @response = { 'images' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            when 'size'
+              @image['filesystem']['units'] = attr_value('units', attrs)
+            when 'image'
+              @image = {
+                'id' => attr_value('id', attrs).to_i,
+                'summary' => attr_value('summary', attrs)
+              }
+            when 'filesystem', 'operating_system'
+              @image[name] = {}
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'architecture'
+              @image['operating_system'][name] = value.to_i
+            when 'admin_username', 'family', 'product_family', 'product_version', 'version'
+              @image['operating_system'][name] = value
+            when 'description'
+              @image[name] = value
+            when 'image'
+              @response['images'] << @image
+              @image = {}
+            when 'size'
+              @image['filesystem'][name] = value.to_i
+            when 'type'
+              @image['filesystem'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_create.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_create.rb
new file mode 100644
index 0000000..5eb6e2d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_create.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+
+        class VoxcloudCreate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'device' => {} }
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'id'
+              @response['device'][name] = value
+            when 'last_update'
+              @response['device'][name] = Time.at(value.to_i)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_delete.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_delete.rb
new file mode 100644
index 0000000..4cc336f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_delete.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+
+        class VoxcloudDelete < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_status.rb b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_status.rb
new file mode 100644
index 0000000..8254a85
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/parsers/voxel/voxcloud_status.rb
@@ -0,0 +1,42 @@
+module Fog
+  module Parsers
+    module Voxel
+      module Compute
+        class VoxcloudStatus < Fog::Parsers::Base
+          def reset
+            @response = { 'devices' => [] }
+            @device = {}
+          end
+
+          def start_element(name, attrs = [])
+            super
+
+            case name
+            when 'rsp'
+              @response['stat'] = attr_value('stat', attrs)
+            when 'err'
+              @response['err'] = {
+                'code'  => attr_value('code', attrs),
+                'msg'   => attr_value('msg', attrs)
+              }
+            when 'device'
+              @device = {}
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'device'
+              @response['devices'] << @device
+              @device = {}
+            when 'id', 'status'
+              @device[name] = value
+            when 'last_update'
+              @device[name] = Time.at(value.to_i)
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/rackspace.rb b/vendor/fog-0.8.2/lib/fog/compute/rackspace.rb
new file mode 100644
index 0000000..100cae6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/rackspace.rb
@@ -0,0 +1,157 @@
+module Fog
+  module Rackspace
+    class Compute < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :rackspace_servicenet, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/rackspace'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/compute/requests/rackspace'
+      request :confirm_resized_server
+      request :create_image
+      request :create_server
+      request :delete_image
+      request :delete_server
+      request :get_flavor_details
+      request :get_image_details
+      request :get_server_details
+      request :list_addresses
+      request :list_private_addresses
+      request :list_public_addresses
+      request :list_flavors
+      request :list_flavors_detail
+      request :list_images
+      request :list_images_detail
+      request :list_servers
+      request :list_servers_detail
+      request :reboot_server
+      request :revert_resized_server
+      request :resize_server
+      request :server_action
+      request :update_server
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :last_modified => {
+                :images  => {},
+                :servers => {}
+              },
+              :images  => {},
+              :servers => {}
+            }
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @rackspace_username = options[:rackspace_username]
+        end
+
+        def data
+          self.class.data[@rackspace_username]
+        end
+
+        def reset_data
+          self.class.data.delete(@rackspace_username)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+          @rackspace_api_key = options[:rackspace_api_key]
+          @rackspace_username = options[:rackspace_username]
+          @rackspace_auth_url = options[:rackspace_auth_url]
+          @rackspace_servicenet = options[:rackspace_servicenet]
+          authenticate
+          Excon.ssl_verify_peer = false if options[:rackspace_servicenet] == true
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+              :query    => ('ignore_awful_caching' << Time.now.to_i.to_s)
+            }))
+          rescue Excon::Errors::Unauthorized => error
+            if JSON.parse(response.body)['unauthorized']['message'] == 'Invalid authentication token.  Please renew.'
+              authenticate
+              retry
+            else
+              raise error
+            end
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+        private
+
+        def authenticate
+          options = {
+            :rackspace_api_key  => @rackspace_api_key,
+            :rackspace_username => @rackspace_username,
+            :rackspace_auth_url => @rackspace_auth_url
+          }
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+          uri = URI.parse(credentials['X-Server-Management-Url'])
+          @host   = @rackspace_servicenet == true ? "snet-#{uri.host}" : uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/allocate_address.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/allocate_address.rb
new file mode 100644
index 0000000..a99b405
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/allocate_address.rb
@@ -0,0 +1,53 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/allocate_address'
+
+        # Acquire an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'publicIp'<~String> - The acquired address
+        #     * 'requestId'<~String> - Id of the request
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AllocateAddress.html]
+        def allocate_address
+          request(
+            'Action'  => 'AllocateAddress',
+            :parser   => Fog::Parsers::AWS::Compute::AllocateAddress.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def allocate_address
+          response = Excon::Response.new
+          if describe_addresses.body['addressesSet'].size < self.data[:limits][:addresses]
+            response.status = 200
+            public_ip = Fog::AWS::Mock.ip_address
+            data ={
+              'instanceId' => nil,
+              'publicIp'   => public_ip
+            }
+            self.data[:addresses][public_ip] = data
+            response.body = {
+              'publicIp'  => public_ip,
+              'requestId' => Fog::AWS::Mock.request_id
+            }
+            response
+          else
+            response.status = 400
+            response.body = "<?xml version=\"1.0\"?><Response><Errors><Error><Code>AddressLimitExceeded</Code><Message>Too many addresses allocated</Message></Error></Errors><RequestID>#{Fog::AWS::Mock.request_id}</RequestID></Response>"
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/associate_address.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/associate_address.rb
new file mode 100644
index 0000000..e5401ac
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/associate_address.rb
@@ -0,0 +1,61 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Associate an elastic IP address with an instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate address with
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AssociateAddress.html]
+        def associate_address(instance_id, public_ip)
+          request(
+            'Action'      => 'AssociateAddress',
+            'InstanceId'  => instance_id,
+            'PublicIp'    => public_ip,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def associate_address(instance_id, public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          instance = self.data[:instances][instance_id]
+          address = self.data[:addresses][public_ip]
+          if instance && address
+            address['instanceId'] = instance_id
+            instance['originalIpAddress'] = instance['ipAddress']
+            instance['ipAddress'] = public_ip
+            instance['dnsName'] = Fog::AWS::Mock.dns_name_for(public_ip)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          elsif !instance
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          elsif !address
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/attach_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/attach_volume.rb
new file mode 100644
index 0000000..d0b79e7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/attach_volume.rb
@@ -0,0 +1,87 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/attach_volume'
+
+        # Attach an Amazon EBS volume with a running instance, exposing as specified device
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to associate volume with
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * device<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AttachVolume.html]
+        def attach_volume(instance_id, volume_id, device)
+          request(
+            'Action'      => 'AttachVolume',
+            'VolumeId'    => volume_id,
+            'InstanceId'  => instance_id,
+            'Device'      => device,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::AttachVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def attach_volume(instance_id, volume_id, device)
+          response = Excon::Response.new
+          if instance_id && volume_id && device
+            response.status = 200
+            instance = self.data[:instances][instance_id]
+            volume = self.data[:volumes][volume_id]
+            if instance && volume
+              unless volume['status'] == 'available'
+                raise Fog::AWS::Compute::Error.new("Client.VolumeInUse => Volume #{volume_id} is unavailable")
+              end
+
+              data = {
+                'attachTime'  => Time.now,
+                'device'      => device,
+                'instanceId'  => instance_id,
+                'status'      => 'attaching',
+                'volumeId'    => volume_id
+              }
+              volume['attachmentSet'] = [data]
+              volume['status'] = 'attaching'
+              response.status = 200
+              response.body = {
+                'requestId' => Fog::AWS::Mock.request_id
+              }.merge!(data)
+              response
+            elsif !instance
+              raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist.")
+            elsif !volume
+              raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+            end
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter instance_id'
+            elsif !volume_id
+              message << 'The request must contain the parameter volume_id'
+            else
+              message << 'The request must contain the parameter device'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/authorize_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/authorize_security_group_ingress.rb
new file mode 100644
index 0000000..600600b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/authorize_security_group_ingress.rb
@@ -0,0 +1,108 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Add permissions to a security group
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of group
+        # * options<~Hash>:
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'GroupName' - Name of group to modify
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-AuthorizeSecurityGroupIngress.html]
+        def authorize_security_group_ingress(group_name, options = {})
+          if group_name.is_a?(Hash)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute#authorize_security_group_ingress now requires the 'group_name' parameter. Only specifying an options hash is now deprecated"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+            options = group_name
+            group_name = options['GroupName']
+          end
+          request({
+            'Action'    => 'AuthorizeSecurityGroupIngress',
+            'GroupName' => group_name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def authorize_security_group_ingress(group_name, options = {})
+          if group_name.is_a?(Hash)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute#authorize_security_group_ingress now requires the 'group_name' parameter. Only specifying an options hash is now deprecated"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+            options = group_name
+            group_name = options['GroupName']
+          end
+
+          response = Excon::Response.new
+          group = self.data[:security_groups][group_name]
+
+          if group
+            group['ipPermissions'] ||= []
+            if group_name && options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              ['tcp', 'udp'].each do |protocol|
+                group['ipPermissions'] << {
+                  'groups'      => [{'groupName' => group_name, 'userId' => self.data[:owner_id]}],
+                  'fromPort'    => 1,
+                  'ipRanges'    => [],
+                  'ipProtocol'  => protocol,
+                  'toPort'      => 65535
+                }
+              end
+              group['ipPermissions'] << {
+                'groups'      => [{'groupName' => group_name, 'userId' => self.data[:owner_id]}],
+                'fromPort'    => -1,
+                'ipRanges'    => [],
+                'ipProtocol'  => 'icmp',
+                'toPort'      => -1
+              }
+            else
+              group['ipPermissions'] << {
+                'groups'      => [],
+                'fromPort'    => options['FromPort'],
+                'ipRanges'    => [],
+                'ipProtocol'  => options['IpProtocol'],
+                'toPort'      => options['ToPort']
+              }
+              if options['CidrIp']
+                group['ipPermissions'].last['ipRanges'] << { 'cidrIp' => options['CidrIp'] }
+              end
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{group_name}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_image.rb
new file mode 100644
index 0000000..7b7dfa7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_image.rb
@@ -0,0 +1,65 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/create_image'
+
+        # Create a bootable EBS volume AMI
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Instance used to create image.
+        # * name<~Name> - Name to give image.
+        # * description<~Name> - Description of image.
+        # * no_reboot<~Boolean> - Optional, whether or not to reboot the image when making the snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - The ID of the created AMI.
+        #     * 'requestId'<~String> - Id of request.
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateImage.html]
+        def create_image(instance_id, name, description, no_reboot = false)
+          request(
+            'Action'            => 'CreateImage',
+            'InstanceId'        => instance_id,
+            'Name'              => name,
+            'Description'       => description,
+            'NoReboot'          => no_reboot.to_s,
+            :parser             => Fog::Parsers::AWS::Compute::CreateImage.new
+          )
+        end
+      end
+
+      class Mock
+        
+        # Usage
+        # 
+        # AWS[:compute].create_image("i-ac65ee8c", "test", "something")
+        #
+        
+        def create_image(instance_id, name, description, no_reboot = false)
+          response = Excon::Response.new
+          if instance_id && !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'InvalidParameterValue'
+            }
+            if name.empty?
+              response.body['Message'] = "Invalid value '' for name. Must be specified."
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_key_pair.rb
new file mode 100644
index 0000000..0b648cd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_key_pair.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/create_key_pair'
+
+        # Create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyMaterial'<~String> - Unencrypted encoded PEM private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateKeyPair.html]
+        def create_key_pair(key_name)
+          request(
+            'Action'  => 'CreateKeyPair',
+            'KeyName' => key_name,
+            :parser   => Fog::Parsers::AWS::Compute::CreateKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_key_pair(key_name)
+          response = Excon::Response.new
+          unless self.data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyMaterial'     => Fog::AWS::Mock.key_material,
+              'keyName'         => key_name
+            }
+            self.data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_security_group.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_security_group.rb
new file mode 100644
index 0000000..e59e434
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_security_group.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Create a new security group
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        # * group_description<~String> - Description of group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateSecurityGroup.html]
+        def create_security_group(name, description)
+          request(
+            'Action'            => 'CreateSecurityGroup',
+            'GroupName'         => name,
+            'GroupDescription'  => description,
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_security_group(name, description)
+          response = Excon::Response.new
+          unless self.data[:security_groups][name]
+            data = {
+              'groupDescription'  => description,
+              'groupName'         => name,
+              'ipPermissions'     => [],
+              'ownerId'           => self.data[:owner_id]
+            }
+            self.data[:security_groups][name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidGroup.Duplicate => The security group '#{name}' already exists")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_snapshot.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_snapshot.rb
new file mode 100644
index 0000000..c45fd89
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_snapshot.rb
@@ -0,0 +1,73 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/create_snapshot'
+
+        # Create a snapshot of an EBS volume and store it in S3
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of EBS volume to snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'progress'<~String> - The percentage progress of the snapshot
+        #     * 'requestId'<~String> - id of request
+        #     * 'snapshotId'<~String> - id of snapshot
+        #     * 'startTime'<~Time> - timestamp when snapshot was initiated
+        #     * 'status'<~String> - state of snapshot
+        #     * 'volumeId'<~String> - id of volume snapshot targets
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateSnapshot.html]
+        def create_snapshot(volume_id, description = nil)
+          request(
+            'Action'      => 'CreateSnapshot',
+            'Description' => description,
+            'VolumeId'    => volume_id,
+            :parser       => Fog::Parsers::AWS::Compute::CreateSnapshot.new
+          )
+        end
+
+      end
+
+      class Mock
+        
+        #
+        # Usage
+        #
+        # AWS[:compute].create_snapshot("vol-f7c23423", "latest snapshot")
+        #
+        
+        def create_snapshot(volume_id, description = nil)
+          response = Excon::Response.new
+          if volume = self.data[:volumes][volume_id]
+            response.status = 200
+            snapshot_id = Fog::AWS::Mock.snapshot_id
+            data = {
+              'description' => description,
+              'ownerId'     => self.data[:owner_id],
+              'progress'    => nil,
+              'snapshotId'  => snapshot_id,
+              'startTime'   => Time.now,
+              'status'      => 'pending',
+              'volumeId'    => volume_id,
+              'volumeSize'  => volume['size']
+            }
+            self.data[:snapshots][snapshot_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            self.data[:snapshots][snapshot_id]['tagSet'] = {}
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_tags.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_tags.rb
new file mode 100644
index 0000000..08accde
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_tags.rb
@@ -0,0 +1,84 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Adds tags to resources
+        #
+        # ==== Parameters
+        # * resources<~String> - One or more resources to tag
+        # * tags<~String> - hash of key value tag pairs to assign
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateTags.html]
+        def create_tags(resources, tags)
+          resources = [*resources]
+          for key, value in tags
+            if value.nil?
+              tags[key] = ''
+            end
+          end
+          params = {}
+          params.merge!(AWS.indexed_param('ResourceId', resources))
+          params.merge!(AWS.indexed_param('Tag.%d.Key', tags.keys))
+          params.merge!(AWS.indexed_param('Tag.%d.Value', tags.values))
+          request({
+            'Action'            => 'CreateTags',
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def create_tags(resources, tags)
+          resources = [*resources]
+
+          tagged = resources.map do |resource_id|
+            type = case resource_id
+            when /^ami\-[a-z0-9]{8}$/i
+              'image'
+            when /^i\-[a-z0-9]{8}$/i
+              'instance'
+            when /^snap\-[a-z0-9]{8}$/i
+              'snapshot'
+            when /^vol\-[a-z0-9]{8}$/i
+              'volume'
+            end
+            if type && self.data[:"#{type}s"][resource_id]
+              { 'resourceId' => resource_id, 'resourceType' => type }
+            else
+              raise(Fog::Service::NotFound.new("The #{type} ID '#{resource_id}' does not exist"))
+            end
+          end
+
+          tags.each do |key, value|
+            self.data[:tags][key] ||= {}
+            self.data[:tags][key][value] ||= []
+            self.data[:tags][key][value] = self.data[:tags][key][value] & tagged
+            
+            tagged.each {|resource| self.data[:"#{resource['resourceType']}s"][resource['resourceId']]['tagSet'][key] = value}
+          end
+
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_volume.rb
new file mode 100644
index 0000000..2927186
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/create_volume.rb
@@ -0,0 +1,80 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/create_volume'
+
+        # Create an EBS volume
+        #
+        # ==== Parameters
+        # * availability_zone<~String> - availability zone to create volume in
+        # * size<~Integer> - Size in GiBs for volume.  Must be between 1 and 1024.
+        # * snapshot_id<~String> - Optional, snapshot to create volume from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'availabilityZone'<~String> - Availability zone for volume
+        #     * 'createTime'<~Time> - Timestamp for creation
+        #     * 'size'<~Integer> - Size in GiBs for volume
+        #     * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #     * 'status's<~String> - State of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-CreateVolume.html]
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          request(
+            'Action'            => 'CreateVolume',
+            'AvailabilityZone'  => availability_zone,
+            'Size'              => size,
+            'SnapshotId'        => snapshot_id,
+            :parser             => Fog::Parsers::AWS::Compute::CreateVolume.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_volume(availability_zone, size, snapshot_id = nil)
+          response = Excon::Response.new
+          if availability_zone && size
+            if snapshot_id && !self.data[:snapshots][snapshot_id]
+              raise Fog::AWS::Compute::NotFound.new("The snapshot '#{snapshot_id}' does not exist.")
+            end
+
+            response.status = 200
+            volume_id = Fog::AWS::Mock.volume_id
+            data = {
+              'availabilityZone'  => availability_zone,
+              'attachmentSet'     => [],
+              'createTime'        => Time.now,
+              'size'              => size,
+              'snapshotId'        => snapshot_id,
+              'status'            => 'creating',
+              'tagSet'            => {},
+              'volumeId'          => volume_id
+            }
+            self.data[:volumes][volume_id] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data.reject {|key,value| !['availabilityZone','createTime','size','snapshotId','status','volumeId'].include?(key) })
+          else
+            response.status = 400
+            response.body = {
+              'Code' => 'MissingParameter'
+            }
+            unless availability_zone
+              response.body['Message'] = 'The request must contain the parameter availability_zone'
+            else
+              response.body['Message'] = 'The request must contain the parameter size'
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_key_pair.rb
new file mode 100644
index 0000000..5ac6dbb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_key_pair.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Delete a key pair that you own
+        #
+        # ==== Parameters
+        # * key_name<~String> - Name of the key pair.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteKeyPair.html]
+        def delete_key_pair(key_name)
+          request(
+            'Action'    => 'DeleteKeyPair',
+            'KeyName'   => key_name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_key_pair(key_name)
+          response = Excon::Response.new
+          self.data[:key_pairs].delete(key_name)
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_security_group.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_security_group.rb
new file mode 100644
index 0000000..0748186
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_security_group.rb
@@ -0,0 +1,49 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Delete a security group that you own
+        #
+        # ==== Parameters
+        # * group_name<~String> - Name of the security group.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteSecurityGroup.html]
+        def delete_security_group(name)
+          request(
+            'Action'    => 'DeleteSecurityGroup',
+            'GroupName' => name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+        def delete_security_group(name)
+          response = Excon::Response.new
+          if self.data[:security_groups][name]
+            self.data[:security_groups].delete(name)
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{name}' does not exist")
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_snapshot.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_snapshot.rb
new file mode 100644
index 0000000..67fd611
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_snapshot.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Delete a snapshot of an EBS volume that you own
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - ID of snapshot to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteSnapshot.html]
+        def delete_snapshot(snapshot_id)
+          request(
+            'Action'      => 'DeleteSnapshot',
+            'SnapshotId'  => snapshot_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_snapshot(snapshot_id)
+          response = Excon::Response.new
+          if snapshot = self.data[:snapshots].delete(snapshot_id)
+            response.status = true
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The snapshot '#{snapshot_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_tags.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_tags.rb
new file mode 100644
index 0000000..179d8ac
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_tags.rb
@@ -0,0 +1,87 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Remove tags from resources
+        #
+        # ==== Parameters
+        # * resources<~String> - One or more resources to remove tags from
+        # * tags<~String> - hash of key value tag pairs to remove
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteTags.html]
+        def delete_tags(resources, tags)
+          resources = [*resources]
+          params = {}
+          params.merge!(AWS.indexed_param('ResourceId', resources))
+
+          # can not rely on indexed_param because nil values should be omitted
+          tags.keys.each_with_index do |key, index|
+            index += 1 # should start at 1 instead of 0
+            params.merge!("Tag.#{index}.Key" => key)
+            unless tags[key].nil?
+              params.merge("Tag.#{index}.Value" => tags[key])
+            end
+          end
+
+          request({
+            'Action'            => 'DeleteTags',
+            :parser             => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+      
+      class Mock
+        def delete_tags(resources, tags)
+          tagged = resources.map do |resource_id|
+            type = case resource_id
+            when /^ami\-[a-z0-9]{8}$/i
+              'image'
+            when /^i\-[a-z0-9]{8}$/i
+              'instance'
+            when /^snap\-[a-z0-9]{8}$/i
+              'snapshot'
+            when /^vol\-[a-z0-9]{8}$/i
+              'volume'
+            end
+            if type && self.data[:"#{type}s"][resource_id]
+              { 'resourceId' => resource_id, 'resourceType' => type }
+            else
+              raise(Fog::Service::NotFound.new("The #{type} ID '#{resource_id}' does not exist"))
+            end
+          end
+          
+          tags.each do |key, value|
+            self.data[:tags][key][value] = self.data[:tags][key][value] - tagged
+          end
+          
+          tagged.each do |resource|
+            object = self.data[:"#{resource['resourceType']}s"][resource['resourceId']]
+            tags.each do |key, value|
+              tagset = object['tagSet']
+              tagset.delete(key) if tagset.has_key?(key) && (value.nil? || tagset[key] == value)
+            end
+          end
+          
+          response = Excon::Response.new
+          response.status = true
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'return'    => true
+          }
+          response
+        end
+      end
+      
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_volume.rb
new file mode 100644
index 0000000..e054398
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/delete_volume.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Delete an EBS volume
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of volume to delete.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeleteVolume.html]
+        def delete_volume(volume_id)
+          request(
+            'Action'    => 'DeleteVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_volume(volume_id)
+          response = Excon::Response.new
+          if volume = self.data[:volumes][volume_id]
+            if volume["attachmentSet"].any?
+              attach = volume["attachmentSet"].first
+              raise Fog::AWS::Compute::Error.new("Client.VolumeInUse => Volume #{volume_id} is currently attached to #{attach["instanceId"]}")
+            end
+            self.data[:deleted_at][volume_id] = Time.now
+            volume['status'] = 'deleting'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/deregister_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/deregister_image.rb
new file mode 100644
index 0000000..e3079f6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/deregister_image.rb
@@ -0,0 +1,53 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/deregister_image'
+
+        # deregister an image
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of image to deregister 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'return'<~Boolean> - Returns true if deregistration succeeded
+        #     * 'requestId'<~String> - Id of request
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DeregisterImage.html]
+        def deregister_image(image_id)
+          request(
+            'Action'      => 'DeregisterImage',
+            'ImageId'     => image_id,
+            :parser       => Fog::Parsers::AWS::Compute::DeregisterImage.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def deregister_image(image_id)
+          response = Excon::Response.new
+          if image_id 
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return' => "true"
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if !instance_id
+              message << 'The request must contain the parameter image_id'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_addresses.rb
new file mode 100644
index 0000000..67a1c33
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_addresses.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_addresses'
+
+        # Describe all or specified IP addresses.
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'addressesSet'<~Array>:
+        #       * 'instanceId'<~String> - instance for ip address
+        #       * 'publicIp'<~String> - ip address for instance
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeAddresses.html]
+        def describe_addresses(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_addresses with #{filters.class} param is deprecated, use describe_addresses('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeAddresses',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAddresses.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_addresses(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_addresses with #{filters.class} param is deprecated, use describe_addresses('public-ip' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          addresses_set = self.data[:addresses].values
+
+          aliases = {'public-ip' => 'publicIp', 'instance-id' => 'instanceId'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            addresses_set = addresses_set.reject{|address| ![*filter_value].include?(address[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'     => Fog::AWS::Mock.request_id,
+            'addressesSet'  => addresses_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_availability_zones.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_availability_zones.rb
new file mode 100644
index 0000000..c3b66b5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_availability_zones.rb
@@ -0,0 +1,88 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_availability_zones'
+
+        # Describe all or specified availability zones
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'availabilityZoneInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'zoneName'<~String> - Name of zone
+        #       * 'zoneState'<~String> - State of zone
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeAvailabilityZones.html]
+        def describe_availability_zones(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_availability_zones with #{filters.class} param is deprecated, use describe_availability_zones('zone-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeAvailabilityZones',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeAvailabilityZones.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_availability_zones(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_availability_zones with #{filters.class} param is deprecated, use describe_availability_zones('zone-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'public-ip' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          all_zones = [
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1b", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1c", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-east-1", "zoneName" => "us-east-1d", "zoneState" => "available"},
+
+            {"messageSet" => [], "regionName" => "us-west-1", "zoneName" => "us-west-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-west-1", "zoneName" => "us-west-1b", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "us-west-1", "zoneName" => "us-west-1c", "zoneState" => "available"},
+
+            {"messageSet" => [], "regionName" => "eu-west-1", "zoneName" => "eu-west-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "eu-west-1", "zoneName" => "eu-west-1b", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "eu-west-1", "zoneName" => "eu-west-1c", "zoneState" => "available"},
+
+            {"messageSet" => [], "regionName" => "ap-northeast-1", "zoneName" => "ap-northeast-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "ap-northeast-1", "zoneName" => "ap-northeast-1b", "zoneState" => "available"},
+
+            {"messageSet" => [], "regionName" => "ap-southeast-1", "zoneName" => "ap-southeast-1a", "zoneState" => "available"},
+            {"messageSet" => [], "regionName" => "ap-southeast-1", "zoneName" => "ap-southeast-1b", "zoneState" => "available"},
+          ]
+
+          availability_zone_info = all_zones.select { |zoneinfo| zoneinfo["regionName"] == @region }
+
+          aliases = {'region-name' => 'regionName', 'zone-name' => 'zoneName', 'state' => 'zoneState'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            availability_zone_info = availability_zone_info.reject{|availability_zone| ![*filter_value].include?(availability_zone[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'availabilityZoneInfo'  => availability_zone_info,
+            'requestId'             => Fog::AWS::Mock.request_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_images.rb
new file mode 100644
index 0000000..2be1716
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_images.rb
@@ -0,0 +1,114 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_images'
+
+        # Describe all or specified images.
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #   * filters and/or the following
+        #   * 'ExecutableBy'<~String> - Only return images that the executable_by
+        #     user has explicit permission to launch
+        #   * 'ImageId'<~Array> - Ids of images to describe
+        #   * 'Owner'<~String> - Only return images belonging to owner.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'imagesSet'<~Array>:
+        #       * 'architecture'<~String> - Architecture of the image
+        #       * 'blockDeviceMapping'<~Array> - An array of mapped block devices
+        #       * 'description'<~String> - Description of image
+        #       * 'imageId'<~String> - Id of the image
+        #       * 'imageLocation'<~String> - Location of the image
+        #       * 'imageOwnerId'<~String> - Id of the owner of the image
+        #       * 'imageState'<~String> - State of the image
+        #       * 'imageType'<~String> - Type of the image
+        #       * 'isPublic'<~Boolean> - Whether or not the image is public
+        #       * 'kernelId'<~String> - Kernel id associated with image, if any
+        #       * 'platform'<~String> - Operating platform of the image
+        #       * 'productCodes'<~Array> - Product codes for the image
+        #       * 'ramdiskId'<~String> - Ramdisk id associated with image, if any
+        #       * 'rootDeviceName'<~String> - Root device name, e.g. /dev/sda1
+        #       * 'rootDeviceType'<~String> - Root device type, ebs or instance-store
+        #       * 'virtualizationType'<~String> - Type of virtualization
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeImages.html]
+        def describe_images(filters = {})
+          options = {}
+          for key in ['ExecutableBy', 'ImageId', 'Owner']
+            if filters.is_a?(Hash) && filters.key?(key)
+              options[key] = filters.delete(key)
+            end
+          end
+          params = AWS.indexed_filters(filters).merge!(options)
+          request({
+            'Action'    => 'DescribeImages',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeImages.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_images(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_images with #{filters.class} param is deprecated, use describe_snapshots('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          
+          if filters.keys.any? {|key| key =~ /^block-device/}
+            Formatador.display_line("[yellow][WARN] describe_images block-device-mapping filters are not yet mocked[/] [light_black](#{caller.first})[/]")
+            Fog::Mock.not_implemented
+          end
+          
+          if filters.keys.any? {|key| key =~ /^tag/}
+            Formatador.display_line("[yellow][WARN] describe_images tag filters are not yet mocked[/] [light_black](#{caller.first})[/]")
+            Fog::Mock.not_implemented
+          end
+          
+          response = Excon::Response.new
+          
+          aliases = {
+            'architecture'        => 'architecture',
+            'description'         => 'description',
+            'hypervisor'          => 'hypervisor',
+            'image-id'            => 'imageId',
+            'image-type'          => 'imageType',
+            'is-public'           => 'isPublic',
+            'kernel-id'           => 'kernelId',
+            'manifest-location'   => 'manifestLocation',
+            'name'                => 'name',            
+            'owner-id'            => 'imageOwnerId',
+            'ramdisk-id'          => 'ramdiskId',
+            'root-device-name'    => 'rootDeviceName',
+            'root-device-type'    => 'rootDeviceType',
+            'state'               => 'imageState',
+            'virtualization-type' => 'virtualizationType'
+          }
+          
+          image_set = self.data[:images].values
+          
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            image_set = image_set.reject{|image| ![*filter_value].include?(image[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'imagesSet' => image_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_instances.rb
new file mode 100644
index 0000000..87f1ea9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_instances.rb
@@ -0,0 +1,204 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_instances'
+
+        # Describe all or specified instances
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationSet'<~Array>:
+        #       * 'groupSet'<~Array> - Group names for reservation
+        #       * 'ownerId'<~String> - AWS Access Key ID of reservation owner
+        #       * 'reservationId'<~String> - Id of the reservation
+        #       * 'instancesSet'<~Array>:
+        #         * instance<~Hash>:
+        #           * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #           * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #           * 'blockDeviceMapping'<~Array>
+        #             * 'attachTime'<~Time> - time of volume attachment
+        #             * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #             * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #             * 'status'<~String> - status of attached volume
+        #             * 'volumeId'<~String> - Id of attached volume
+        #           * 'dnsName'<~String> - public dns name, blank until instance is running
+        #           * 'imageId'<~String> - image id of ami used to launch instance
+        #           * 'instanceId'<~String> - id of the instance
+        #           * 'instanceState'<~Hash>:
+        #             * 'code'<~Integer> - current status code
+        #             * 'name'<~String> - current status name
+        #           * 'instanceType'<~String> - type of instance
+        #           * 'ipAddress'<~String> - public ip address assigned to instance
+        #           * 'kernelId'<~String> - id of kernel used to launch instance
+        #           * 'keyName'<~String> - name of key used launch instances or blank
+        #           * 'launchTime'<~Time> - time instance was launched
+        #           * 'monitoring'<~Hash>:
+        #             * 'state'<~Boolean - state of monitoring
+        #           * 'placement'<~Hash>:
+        #             * 'availabilityZone'<~String> - Availability zone of the instance
+        #           * 'productCodes'<~Array> - Product codes for the instance
+        #           * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #           * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #           * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #           * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #           * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #           * 'reason'<~String> - reason for most recent state transition, or blank
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstances.html]
+        def describe_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_instances with #{filters.class} param is deprecated, use describe_instances('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+          params = {}
+          # when seeking single instance id, old param style provides more accurate data sooner
+          if filters['instance-id'] && !filters['instance-id'].is_a?(Array)
+            params.merge!('InstanceId' => filters.delete('instance-id'))
+          end
+          params.merge!(AWS.indexed_filters(filters))
+
+          request({
+            'Action'    => 'DescribeInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_instances with #{filters.class} param is deprecated, use describe_instances('instance-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'instance-id' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          instance_set = self.data[:instances].values
+          instance_set = apply_tag_filters(instance_set, filters)
+          
+          aliases = {
+            'architecture'      => 'architecture',
+            'availability-zone' => 'availabilityZone',
+            'client-token'      => 'clientToken',
+            'dns-name'         => 'dnsName',
+            'group-id'          => 'groupId',
+            'image-id'          => 'imageId',
+            'instance-id'       => 'instanceId',
+            'instance-lifecycle'  => 'instanceLifecycle',
+            'instance-type'     => 'instanceType',
+            'ip-address'        => 'ipAddress',
+            'kernel-id'         => 'kernelId',
+            'key-name'          => 'key-name',
+            'launch-index'      => 'launchIndex',
+            'launch-time'       => 'launchTime',
+            'monitoring-state'  => 'monitoringState',
+            'owner-id'          => 'ownerId',
+            'placement-group-name' => 'placementGroupName',
+            'platform'          => 'platform',
+            'private-dns-name'  => 'privateDnsName',
+            'private-ip-address'  => 'privateIpAddress',
+            'product-code'      => 'productCode',
+            'ramdisk-id'        => 'ramdiskId',
+            'reason'            => 'reason',
+            'requester-id'      => 'requesterId',
+            'reservation-id'    => 'reservationId',
+            'root-device-name'  => 'rootDeviceName',
+            'root-device-type'  => 'rootDeviceType',
+            'spot-instance-request-id' => 'spotInstanceRequestId',
+            'subnet-id'         => 'subnetId',
+            'virtualization-type' => 'virtualizationType',
+            'vpc-id'            => 'vpcId'
+          }
+          block_device_mapping_aliases = {
+            'attach-time'           => 'attachTime',
+            'delete-on-termination' => 'deleteOnTermination',
+            'device-name'           => 'deviceName',
+            'status'                => 'status',
+            'volume-id'             => 'volumeId',
+          }
+          instance_state_aliases = {
+            'code' => 'code',
+            'name' => 'name'
+          }
+          state_reason_aliases = {
+            'code'    => 'code',
+            'message' => 'message'
+          }
+          for filter_key, filter_value in filters
+            if block_device_mapping_key = filter_key.split('block-device-mapping.')[1]
+              aliased_key = block_device_mapping_aliases[block_device_mapping_key]
+              instance_set = instance_set.reject{|instance| !instance['blockDeviceMapping'].detect {|block_device_mapping| [*filter_value].include?(block_device_mapping[aliased_key])}}
+            elsif instance_state_key = filter_key.split('instance-state-')[1]
+              aliased_key = instance_state_aliases[instance_state_key]
+              instance_set = instance_set.reject{|instance| ![*filter_value].include?(instance['instanceState'][aliased_key])}
+            elsif state_reason_key = filter_key.split('state-reason-')[1]
+              aliased_key = state_reason_aliases[state_reason_key]
+              instance_set = instance_set.reject{|instance| ![*filter_value].include?(instance['stateReason'][aliased_key])}
+            else
+              aliased_key = aliases[filter_key]
+              instance_set = instance_set.reject {|instance| ![*filter_value].include?(instance[aliased_key])}
+            end
+          end
+
+          response.status = 200
+          reservation_set = {}
+
+          instance_set.each do |instance|
+            case instance['instanceState']['name']
+            when 'pending'
+              if Time.now - instance['launchTime'] >= Fog::Mock.delay
+                instance['ipAddress']         = Fog::AWS::Mock.ip_address
+                instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+                instance['privateIpAddress']  = Fog::AWS::Mock.ip_address
+                instance['privateDnsName']    = Fog::AWS::Mock.private_dns_name_for(instance['privateIpAddress'])
+                instance['instanceState']     = { 'code' => 16, 'name' => 'running' }
+              end
+            when 'rebooting'
+              instance['instanceState'] = { 'code' => 16, 'name' => 'running' }
+            when 'shutting-down'
+              if Time.now - self.data[:deleted_at][instance['instanceId']] >= Fog::Mock.delay * 2
+                self.data[:deleted_at].delete(instance['instanceId'])
+                self.data[:instances].delete(instance['instanceId'])
+              elsif Time.now - self.data[:deleted_at][instance['instanceId']] >= Fog::Mock.delay
+                instance['instanceState'] = { 'code' => 48, 'name' => 'terminating' }
+              end
+            when 'terminating'
+              if Time.now - self.data[:deleted_at][instance['instanceId']] >= Fog::Mock.delay
+                self.data[:deleted_at].delete(instance['instanceId'])
+                self.data[:instances].delete(instance['instanceId'])
+              end
+            end
+
+            if self.data[:instances][instance['instanceId']]
+
+              reservation_set[instance['reservationId']] ||= {
+                'groupSet'      => instance['groupSet'],
+                'instancesSet'  => [],
+                'ownerId'       => instance['ownerId'],
+                'reservationId' => instance['reservationId']
+              }
+              reservation_set[instance['reservationId']]['instancesSet'] << instance.reject{|key,value| !['amiLaunchIndex', 'architecture', 'blockDeviceMapping', 'clientToken', 'dnsName', 'imageId', 'instanceId', 'instanceState', 'instanceType', 'ipAddress', 'kernelId', 'keyName', 'launchTime', 'monitoring', 'placement', 'privateDnsName', 'privateIpAddress', 'productCodes', 'ramdiskId', 'reason', 'rootDeviceType', 'stateReason', 'tagSet'].include?(key)}
+            end
+          end
+
+          response.body = {
+            'requestId'       => Fog::AWS::Mock.request_id,
+            'reservationSet' => reservation_set.values
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_key_pairs.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_key_pairs.rb
new file mode 100644
index 0000000..000ffbe
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_key_pairs.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_key_pairs'
+
+        # Describe all or specified key pairs
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'keySet'<~Array>:
+        #       * 'keyName'<~String> - Name of key
+        #       * 'keyFingerprint'<~String> - Fingerprint of key
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeKeyPairs.html]
+        def describe_key_pairs(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_key_pairs with #{filters.class} param is deprecated, use describe_key_pairs('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeKeyPairs',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeKeyPairs.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_key_pairs(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_key_pairs with #{filters.class} param is deprecated, use describe_key_pairs('key-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'key-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          key_set = self.data[:key_pairs].values
+
+          aliases = {'fingerprint' => 'keyFingerprint', 'key-name' => 'keyName'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            key_set = key_set.reject{|key_pair| ![*filter_value].include?(key_pair[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'keySet'    => key_set.map do |key_pair|
+              key_pair.reject {|key,value| !['keyFingerprint', 'keyName'].include?(key)}
+            end
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_regions.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_regions.rb
new file mode 100644
index 0000000..9bbbc75
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_regions.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_regions'
+
+        # Describe all or specified regions
+        #
+        # ==== Params
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'regionInfo'<~Array>:
+        #       * 'regionName'<~String> - Name of region
+        #       * 'regionEndpoint'<~String> - Service endpoint for region
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeRegions.html]
+        def describe_regions(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_regions with #{filters.class} param is deprecated, use describe_regions('region-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'region-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeRegions',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeRegions.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_regions(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_regions with #{filters.class} param is deprecated, use describe_regions('region-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'region-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+          region_info = [
+            {"regionName"=>"eu-west-1", "regionEndpoint"=>"eu-west-1.ec2.amazonaws.com"},
+            {"regionName"=>"us-east-1", "regionEndpoint"=>"us-east-1.ec2.amazonaws.com"}
+          ]
+
+          aliases = {'region-name' => 'regionName', 'endpoint' => 'regionEndpoint'}
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            region_info = region_info.reject{|region| ![*filter_value].include?(region[aliased_key])}
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'   => Fog::AWS::Mock.request_id,
+            'regionInfo'  => region_info
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances.rb
new file mode 100644
index 0000000..e56e07a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances.rb
@@ -0,0 +1,46 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_reserved_instances'
+
+        # Describe all or specified reserved instances
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservedInstancesSet'<~Array>:
+        #       * 'availabilityZone'<~String> - availability zone of the instance
+        #       * 'duration'<~Integer> - duration of reservation, in seconds
+        #       * 'fixedPrice'<~Float> - purchase price of reserved instance
+        #       * 'instanceType'<~String> - type of instance
+        #       * 'instanceCount'<~Integer> - number of reserved instances
+        #       * 'productDescription'<~String> - reserved instance description
+        #       * 'reservedInstancesId'<~String> - id of the instance
+        #       * 'start'<~Time> - start time for reservation
+        #       * 'state'<~String> - state of reserved instance purchase, in .[pending-payment, active, payment-failed, retired]
+        #       * 'usagePrice"<~Float> - usage price of reserved instances, per hour
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeReservedInstances.html]
+        def describe_reserved_instances(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_reserved_instances with #{filters.class} param is deprecated, use describe_reserved_instances('reserved-instances-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'reserved-instances-id' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeReservedInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeReservedInstances.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances_offerings.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances_offerings.rb
new file mode 100644
index 0000000..fc87d78
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_reserved_instances_offerings.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_reserved_instances_offerings'
+
+        # Describe all or specified reserved instances offerings
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservedInstancesOfferingsSet'<~Array>:
+        #       * 'availabilityZone'<~String> - availability zone of offering
+        #       * 'duration'<~Integer> - duration, in seconds, of offering
+        #       * 'fixedPrice'<~Float> - purchase price of offering
+        #       * 'instanceType'<~String> - instance type of offering
+        #       * 'productDescription'<~String> - description of offering
+        #       * 'reservedInstancesOfferingId'<~String> - id of offering
+        #       * 'usagePrice'<~Float> - usage price of offering, per hour
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeReservedInstancesOfferings.html]
+        def describe_reserved_instances_offerings(filters = {})
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeReservedInstancesOfferings',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeReservedInstancesOfferings.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_security_groups.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_security_groups.rb
new file mode 100644
index 0000000..92d8658
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_security_groups.rb
@@ -0,0 +1,97 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_security_groups'
+
+        # Describe all or specified security groups
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'securityGroupInfo'<~Array>:
+        #       * 'groupDescription'<~String> - Description of security group
+        #       * 'groupName'<~String> - Name of security group
+        #       * 'ipPermissions'<~Array>:
+        #         * 'fromPort'<~Integer> - Start of port range (or -1 for ICMP wildcard)
+        #         * 'groups'<~Array>:
+        #           * 'groupName'<~String> - Name of security group
+        #           * 'userId'<~String> - AWS User Id of account
+        #         * 'ipProtocol'<~String> - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #         * 'ipRanges'<~Array>:
+        #           * 'cidrIp'<~String> - CIDR range
+        #         * 'toPort'<~Integer> - End of port range (or -1 for ICMP wildcard)
+        #       * 'ownerId'<~String> - AWS Access Key Id of the owner of the security group
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSecurityGroups.html]
+        def describe_security_groups(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_security_groups with #{filters.class} param is deprecated, use describe_security_groups('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeSecurityGroups',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSecurityGroups.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_security_groups(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_security_groups with #{filters.class} param is deprecated, use describe_security_groups('group-name' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'group-name' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          security_group_info = self.data[:security_groups].values
+
+          aliases = {
+            'description' => 'groupDescription',
+            'group-name'  => 'groupName',
+            'owner-id'    => 'ownerId'
+          }
+          permission_aliases = {
+            'cidr'      => 'cidrIp',
+            'from-port' => 'fromPort',
+            'protocol'  => 'ipProtocol',
+            'to-port'   => 'toPort'
+          }
+          for filter_key, filter_value in filters
+            if permission_key = filter_key.split('ip-permission.')[1]
+              if permission_key == 'group-name'
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions']['groups'].detect {|group| [*filter_value].include?(group['groupName'])}}
+              elsif permission_key == 'user-id'
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions']['groups'].detect {|group| [*filter_value].include?(group['userId'])}}
+              else
+                aliased_key = permission_aliases[filter_key]
+                security_group_info = security_group_info.reject{|security_group| !security_group['ipPermissions'].detect {|permission| [*filter_value].include?(permission[aliased_key])}}
+              end
+            else
+              aliased_key = aliases[filter_key]
+              security_group_info = security_group_info.reject{|security_group| ![*filter_value].include?(security_group[aliased_key])}
+            end
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId'         => Fog::AWS::Mock.request_id,
+            'securityGroupInfo' => security_group_info
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_snapshots.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_snapshots.rb
new file mode 100644
index 0000000..2723d40
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_snapshots.rb
@@ -0,0 +1,120 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_snapshots'
+
+        # Describe all or specified snapshots
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        # * options<~Hash>:
+        #   * 'Owner'<~String> - Owner of snapshot in ['self', 'amazon', account_id]
+        #   * 'RestorableBy'<~String> - Account id of user who can create volumes from this snapshot
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'snapshotSet'<~Array>:
+        #       * 'progress'<~String>: The percentage progress of the snapshot
+        #       * 'snapshotId'<~String>: Id of the snapshot
+        #       * 'startTime'<~Time>: Timestamp of when snapshot was initiated
+        #       * 'status'<~String>: Snapshot state, in ['pending', 'completed']
+        #       * 'volumeId'<~String>: Id of volume that snapshot contains
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeSnapshots.html]
+        def describe_snapshots(filters = {}, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_snapshots with #{filters.class} param is deprecated, use describe_snapshots('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          unless options.empty?
+            Formatador.display_line("[yellow][WARN] describe_snapshots with a second param is deprecated, use describe_snapshots(options) instead[/] [light_black](#{caller.first})[/]")
+          end
+
+          for key in ['ExecutableBy', 'ImageId', 'Owner', 'RestorableBy']
+            if filters.has_key?(key)
+              options[key] = filters.delete(key)
+            end
+          end
+          options['RestorableBy'] ||= 'self'
+          params = AWS.indexed_filters(filters).merge!(options)
+          request({
+            'Action'    => 'DescribeSnapshots',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeSnapshots.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_snapshots(filters = {}, options = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_snapshots with #{filters.class} param is deprecated, use describe_snapshots('snapshot-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'snapshot-id' => [*filters]}
+          end
+          unless options.empty?
+            Formatador.display_line("[yellow][WARN] describe_snapshots with a second param is deprecated, use describe_snapshots(options) instead[/] [light_black](#{caller.first})[/]")
+          end
+
+          response = Excon::Response.new
+
+          snapshot_set = self.data[:snapshots].values
+
+          if filters.delete('owner-alias')
+            Formatador.display_line("[yellow][WARN] describe_snapshots with owner-alias is not mocked[/] [light_black](#{caller.first})[/]")
+          end
+          if filters.delete('RestorableBy')
+            Formatador.display_line("[yellow][WARN] describe_snapshots with RestorableBy is not mocked[/] [light_black](#{caller.first})[/]")
+          end
+
+          snapshot_set = apply_tag_filters(snapshot_set, filters)
+          
+          aliases = {
+            'description' => 'description',
+            'owner-id'    => 'ownerId',
+            'progress'    => 'progress',
+            'snapshot-id' => 'snapshotId',
+            'start-time'  => 'startTime',
+            'status'      => 'status',
+            'volume-id'   => 'volumeId',
+            'volume-size' => 'volumeSize'
+          }
+          
+          for filter_key, filter_value in filters
+            aliased_key = aliases[filter_key]
+            snapshot_set = snapshot_set.reject{|snapshot| ![*filter_value].include?(snapshot[aliased_key])}
+          end
+          
+          snapshot_set.each do |snapshot|
+            case snapshot['status']
+            when 'in progress', 'pending'
+              if Time.now - snapshot['startTime'] >= Fog::Mock.delay * 2
+                snapshot['progress']  = '100%'
+                snapshot['status']    = 'completed'
+              elsif Time.now - snapshot['startTime'] >= Fog::Mock.delay
+                snapshot['progress']  = '50%'
+                snapshot['status']    = 'in progress'
+              else
+                snapshot['progress']  = '0%'
+                snapshot['status']    = 'in progress'
+              end
+            end
+          end
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'snapshotSet' => snapshot_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_tags.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_tags.rb
new file mode 100644
index 0000000..b917657
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_tags.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_tags'
+
+        # Describe all or specified tags
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'tagSet'<~Array>:
+        #       * 'resourceId'<~String> - id of resource tag belongs to
+        #       * 'resourceType'<~String> - type of resource tag belongs to
+        #       * 'key'<~String> - Tag's key
+        #       * 'value'<~String> - Tag's value
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeTags.html]
+        def describe_tags(filters = {})
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeTags',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeTags.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_volumes.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_volumes.rb
new file mode 100644
index 0000000..293e62f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/describe_volumes.rb
@@ -0,0 +1,116 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/describe_volumes'
+
+        # Describe all or specified volumes.
+        #
+        # ==== Parameters
+        # * filters<~Hash> - List of filters to limit results with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'volumeSet'<~Array>:
+        #       * 'availabilityZone'<~String> - Availability zone for volume
+        #       * 'createTime'<~Time> - Timestamp for creation
+        #       * 'size'<~Integer> - Size in GiBs for volume
+        #       * 'snapshotId'<~String> - Snapshot volume was created from, if any
+        #       * 'status'<~String> - State of volume
+        #       * 'volumeId'<~String> - Reference to volume
+        #       * 'attachmentSet'<~Array>:
+        #         * 'attachmentTime'<~Time> - Timestamp for attachment
+        #         * 'deleteOnTermination'<~Boolean> - Whether or not to delete volume on instance termination
+        #         * 'device'<~String> - How value is exposed to instance
+        #         * 'instanceId'<~String> - Reference to attached instance
+        #         * 'status'<~String> - Attachment state
+        #         * 'volumeId'<~String> - Reference to volume
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeVolumes.html]
+        def describe_volumes(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_volumes with #{filters.class} param is deprecated, use describe_volumes('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+          params = AWS.indexed_filters(filters)
+          request({
+            'Action'    => 'DescribeVolumes',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DescribeVolumes.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def describe_volumes(filters = {})
+          unless filters.is_a?(Hash)
+            Formatador.display_line("[yellow][WARN] describe_volumes with #{filters.class} param is deprecated, use describe_volumes('volume-id' => []) instead[/] [light_black](#{caller.first})[/]")
+            filters = {'volume-id' => [*filters]}
+          end
+
+          response = Excon::Response.new
+
+          volume_set = self.data[:volumes].values
+          volume_set = apply_tag_filters(volume_set, filters)
+          
+          aliases = {
+            'availability-zone' => 'availabilityZone',
+            'create-time' => 'createTime',
+            'size' => 'size',
+            'snapshot-id' => 'snapshotId',
+            'status' => 'status',
+            'volume-id' => 'volumeId'
+          }
+          attachment_aliases = {
+            'attach-time' => 'attachTime',
+            'delete-on-termination' => 'deleteOnTermination',
+            'device'      => 'device',
+            'instance-id' => 'instanceId',
+            'status'      => 'status'
+          }
+          for filter_key, filter_value in filters
+            if attachment_key = filter_key.split('attachment.')[1]
+              aliased_key = permission_aliases[filter_key]
+              volume_set = volume_set.reject{|volume| !volume['attachmentSet'].detect {|attachment| [*filter_value].include?(attachment[aliased_key])}}
+            else
+              aliased_key = aliases[filter_key]
+              volume_set = volume_set.reject{|volume| ![*filter_value].include?(volume[aliased_key])}
+            end
+          end
+
+          volume_set.each do |volume|
+            case volume['status']
+            when 'attaching'
+              if Time.now - volume['attachmentSet'].first['attachTime'] >= Fog::Mock.delay
+                volume['attachmentSet'].first['status'] = 'in-use'
+                volume['status'] = 'in-use'
+              end
+            when 'creating'
+              if Time.now - volume['createTime'] >= Fog::Mock.delay
+                volume['status'] = 'available'
+              end
+            when 'deleting'
+              if Time.now - self.data[:deleted_at][volume['volumeId']] >= Fog::Mock.delay
+                self.data[:deleted_at].delete(volume['volumeId'])
+                self.data[:volumes].delete(volume['volumeId'])
+              end
+            end
+          end
+          volume_set = volume_set.reject {|volume| !self.data[:volumes][volume['volumeId']]}
+
+          response.status = 200
+          response.body = {
+            'requestId' => Fog::AWS::Mock.request_id,
+            'volumeSet' => volume_set
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/detach_volume.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/detach_volume.rb
new file mode 100644
index 0000000..cbb581b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/detach_volume.rb
@@ -0,0 +1,60 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/detach_volume'
+
+        # Detach an Amazon EBS volume from a running instance
+        #
+        # ==== Parameters
+        # * volume_id<~String> - Id of amazon EBS volume to associate with instance
+        # * options<~Hash>:
+        #   * 'Device'<~String> - Specifies how the device is exposed to the instance (e.g. "/dev/sdh")
+        #   * 'Force'<~Boolean> - If true forces detach, can cause data loss/corruption
+        #   * 'InstanceId'<~String> - Id of instance to associate volume with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'attachTime'<~Time> - Time of attachment was initiated at
+        #     * 'device'<~String> - Device as it is exposed to the instance
+        #     * 'instanceId'<~String> - Id of instance for volume
+        #     * 'requestId'<~String> - Id of request
+        #     * 'status'<~String> - Status of volume
+        #     * 'volumeId'<~String> - Reference to volume
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DetachVolume.html]
+        def detach_volume(volume_id, options = {})
+          request({
+            'Action'    => 'DetachVolume',
+            'VolumeId'  => volume_id,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::DetachVolume.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def detach_volume(volume_id, options = {})
+          response = Excon::Response.new
+          response.status = 200
+          if (volume = self.data[:volumes][volume_id]) && !volume['attachmentSet'].empty?
+            data = volume['attachmentSet'].pop
+            volume['status'] = 'available'
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The volume '#{volume_id}' does not exist.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/disassociate_address.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/disassociate_address.rb
new file mode 100644
index 0000000..645e481
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/disassociate_address.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Disassociate an elastic IP address from its instance (if any)
+        #
+        # ==== Parameters
+        # * public_ip<~String> - Public ip to assign to instance
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-DisassociateAddress.html]
+        def disassociate_address(public_ip)
+          request(
+            'Action'    => 'DisassociateAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def disassociate_address(public_ip)
+          response = Excon::Response.new
+          response.status = 200
+          if address = self.data[:addresses][public_ip]
+            instance_id = address['instanceId']
+            instance = self.data[:instances][instance_id]
+            instance['ipAddress']         = instance['originalIpAddress']
+            instance['dnsName']           = Fog::AWS::Mock.dns_name_for(instance['ipAddress'])
+            address['instanceId'] = nil
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_console_output.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_console_output.rb
new file mode 100644
index 0000000..a4be079
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_console_output.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/get_console_output'
+
+        # Retrieve console output for specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~String> - Id of instance to get console output from
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'instanceId'<~String> - Id of instance
+        #     * 'output'<~String> - Console output
+        #     * 'requestId'<~String> - Id of request
+        #     * 'timestamp'<~Time> - Timestamp of last update to output
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-GetConsoleOutput.html]
+        def get_console_output(instance_id)
+          request(
+            'Action'      => 'GetConsoleOutput',
+            'InstanceId'  => instance_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::GetConsoleOutput.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_console_output(instance_id)
+          response = Excon::Response.new
+          if instance = self.data[:instances][instance_id]
+            response.status = 200
+            response.body = {
+              'instanceId'    => instance_id,
+              'output'        => nil,
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'timestamp'     => Time.now
+            }
+            response
+          else;
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_password_data.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_password_data.rb
new file mode 100644
index 0000000..ef6f3a0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/get_password_data.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/get_password_data'
+
+        # Retrieves the encrypted administrator password for an instance running Windows.
+        #
+        # ==== Parameters
+        # * instance_id<~String> - A Windows instance ID
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'instanceId'<~String> - Id of instance
+        #     * 'passwordData'<~String> - The encrypted, base64-encoded password of the instance.
+        #     * 'requestId'<~String> - Id of request
+        #     * 'timestamp'<~Time> - Timestamp of last update to output
+        #
+        # See http://docs.amazonwebservices.com/AWSEC2/2010-08-31/APIReference/index.html?ApiReference-query-GetPasswordData.html
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-GetPasswordData.html]
+        def get_password_data(instance_id)
+          request(
+            'Action'      => 'GetPasswordData',
+            'InstanceId'  => instance_id,
+            :idempotent   => true,
+            :parser       => Fog::Parsers::AWS::Compute::GetPasswordData.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_password_data(instance_id)
+          response = Excon::Response.new
+          if instance = self.data[:instances][instance_id]
+            response.status = 200
+            response.body = {
+              'instanceId'   => instance_id,
+              'passwordData' => nil,
+              'requestId'    => Fog::AWS::Mock.request_id,
+              'timestamp'    => Time.now
+            }
+            response
+          else;
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/import_key_pair.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/import_key_pair.rb
new file mode 100644
index 0000000..f6323ce
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/import_key_pair.rb
@@ -0,0 +1,56 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/import_key_pair'
+
+        # Import an existing public key to create a new key pair
+        #
+        # ==== Parameters
+        # * key_name<~String> - Unique name for key pair.
+        # * public_key_material<~String> - RSA public key
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'keyFingerprint'<~String> - SHA-1 digest of DER encoded private key
+        #     * 'keyName'<~String> - Name of key
+        #     * 'requestId'<~String> - Id of request
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ImportKeyPair.html]
+        def import_key_pair(key_name, public_key_material)
+          request(
+            'Action'  => 'ImportKeyPair',
+            'KeyName' => key_name,
+            'PublicKeyMaterial' => Base64::encode64(public_key_material),
+            :parser   => Fog::Parsers::AWS::Compute::ImportKeyPair.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def import_key_pair(key_name, public_key_material)
+          response = Excon::Response.new
+          unless self.data[:key_pairs][key_name]
+            response.status = 200
+            data = {
+              'keyFingerprint'  => Fog::AWS::Mock.key_fingerprint,
+              'keyName'         => key_name
+            }
+            self.data[:key_pairs][key_name] = data
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id
+            }.merge!(data)
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("InvalidKeyPair.Duplicate => The keypair '#{key_name}' already exists.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_image_attributes.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_image_attributes.rb
new file mode 100644
index 0000000..0a74877
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_image_attributes.rb
@@ -0,0 +1,37 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Modify image attributes
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to modify
+        # * attribute<~String> - Attribute to modify, in ['launchPermission', 'productCodes']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        #
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifyImageAttribute.html]
+        #
+        def modify_image_attributes(image_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          params.merge!(AWS.indexed_param('ProductCode', options['ProductCode']))
+          request({
+            'Action'        => 'ModifyImageAttribute',
+            'Attribute'     => attribute,
+            'ImageId'       => image_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_snapshot_attribute.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_snapshot_attribute.rb
new file mode 100644
index 0000000..736d699
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/modify_snapshot_attribute.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+        
+        require 'fog/compute/parsers/aws/basic'
+
+        # Modify snapshot attributes
+        #
+        # ==== Parameters
+        # * snapshot_id<~String> - Id of snapshot to modify
+        # * attribute<~String> - Attribute to modify, in ['createVolumePermission']
+        # * operation_type<~String> - Operation to perform on attribute, in ['add', 'remove']
+        #
+        #
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ModifySnapshotAttribute.html]
+        #
+        def modify_snapshot_attribute(snapshot_id, attribute, operation_type, options = {})
+          params = {}
+          params.merge!(AWS.indexed_param('UserId', options['UserId']))
+          params.merge!(AWS.indexed_param('UserGroup', options['UserGroup']))
+          request({
+            'Action'        => 'ModifySnapshotAttribute',
+            'Attribute'     => attribute,
+            'SnapshotId'    => snapshot_id,
+            'OperationType' => operation_type,
+            :idempotent     => true,
+            :parser         => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/monitor_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/monitor_instances.rb
new file mode 100644
index 0000000..0dd0ebf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/monitor_instances.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+
+      class Real
+
+        require 'fog/compute/parsers/aws/monitor_unmonitor_instances'
+
+        # Monitor specified instance
+        # http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-MonitorInstances.html
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - Arrays of instances Ids to monitor
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'instancesSet': http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-ItemType-MonitorInstancesResponseSetItemType.html
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-MonitorInstances.html]
+        def monitor_instances(instance_ids)
+          params = AWS.indexed_param('InstanceId', instance_ids)
+          request({
+                          'Action' => 'MonitorInstances',
+                          :idempotent => true,
+                          :parser => Fog::Parsers::AWS::Compute::MonitorUnmonitorInstances.new
+                  }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def monitor_instances(instance_ids)
+          response        = Excon::Response.new
+          response.status = 200
+          [*instance_ids].each do |instance_id|
+            if instance = self.data[:instances][instance_id]
+              instance['monitoring']['state'] = 'enabled'
+            else
+              raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_ids}' does not exist")
+            end
+          end
+          instances_set = [*instance_ids].inject([]) { |memo, id| memo << {'instanceId' => id, 'monitoring' => 'enabled'} }
+          response.body = {'requestId' => 'some_request_id', 'instancesSet' => instances_set}
+          response
+        end
+
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/reboot_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/reboot_instances.rb
new file mode 100644
index 0000000..5113805
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/reboot_instances.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Reboot specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to reboot
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RebootInstances.html]
+        def reboot_instances(instance_id = [])
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'RebootInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def reboot_instances(instance_id = [])
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (self.data[:instances].keys & instance_id).length == instance_id.length
+            for instance_id in instance_id
+              self.data[:instances][instance_id]['status'] = 'rebooting'
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID #{instance_id.inspect} does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/register_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/register_image.rb
new file mode 100644
index 0000000..814c064
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/register_image.rb
@@ -0,0 +1,93 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/register_image'
+
+        # register an image
+        #
+        # ==== Parameters
+        # * Name<~String> - Name of the AMI to be registered
+        # * Description<~String> - AMI description
+        # * Location<~String> - S3 manifest location (for S3 backed AMIs)
+        # or
+        # * RootDeviceName<~String> - Name of Root Device (for EBS snapshot backed AMIs)
+        # * BlockDevices<~Array>:
+        #   * BlockDeviceOptions<~Hash>:
+        #     * DeviceName<~String> - Name of the Block Device
+        #     * VirtualName<~String> - Name of the Virtual Device
+        #     * SnapshotId<~String> - id of the EBS Snapshot
+        #     * VolumeSize<~Integer> - Size of the snapshot (optional)
+        #     * NoDevice<~Boolean> - Do not use an ebs device (def: true)
+        #     * DeleteOnTermation<~Boolean> - Delete EBS volume on instance term (def: true)
+        # * Options<~Hash>:
+        #   * Architecture<~String> - i386 or x86_64
+        #   * KernelId<~String> - kernelId
+        #   * RamdiskId<~String> - ramdiskId
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'imageId'<~String> - Id of newly created AMI
+
+        #
+
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RegisterImage.html]
+
+        def register_image(name, description, location, block_devices=[], options={})
+          common_options = {
+            'Action'      => 'RegisterImage',
+            'Name'        => name,
+            'Description' => description,
+            :parser       => Fog::Parsers::AWS::Compute::RegisterImage.new
+          }
+
+          # This determines if we are doing a snapshot or a S3 backed AMI.
+          if(location =~ /^\/dev\/sd[a-p]\d{0,2}$/)
+            common_options['RootDeviceName'] = location
+          else
+            common_options['ImageLocation'] = location
+          end
+
+          bdi = 0
+          block_devices.each do |bd|
+            bdi += 1
+            ["DeviceName","VirtualName"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+            ["SnapshotId","VolumeSize","NoDevice","DeleteOnTermination"].each do |n|
+              common_options["BlockDeviceMapping.#{bdi}.Ebs.#{n}"] = bd["#{n}"] if bd["#{n}"]
+            end
+
+          end
+
+          request(common_options.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def register_image(name, description, location, block_devices=[], options={})
+          response = Excon::Response.new
+          if !name.empty?
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'imageId' => Fog::AWS::Mock.image_id
+            }
+            response
+          else
+            message = 'MissingParameter => '
+            if name.empty?
+              message << 'The request must contain the parameter name'
+            end
+            raise Fog::AWS::Compute::Error.new(message)
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/release_address.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/release_address.rb
new file mode 100644
index 0000000..0355600
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/release_address.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Release an elastic IP address.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-ReleaseAddress.html]
+        def release_address(public_ip)
+          request(
+            'Action'    => 'ReleaseAddress',
+            'PublicIp'  => public_ip,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          )
+        end
+
+      end
+
+      class Mock
+
+        def release_address(public_ip)
+          response = Excon::Response.new
+          if (address = self.data[:addresses].delete(public_ip))
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::Error.new("AuthFailure => The address '#{public_ip}' does not belong to you.")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/revoke_security_group_ingress.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/revoke_security_group_ingress.rb
new file mode 100644
index 0000000..f3b22cd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/revoke_security_group_ingress.rb
@@ -0,0 +1,94 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/basic'
+
+        # Remove permissions from a security group
+        #
+        # ==== Parameters
+        # * 'GroupName'<~String> - Name of group
+        # * options<~Hash>:
+        #   * 'SourceSecurityGroupName'<~String> - Name of security group to authorize
+        #   * 'SourceSecurityGroupOwnerId'<~String> - Name of owner to authorize
+        #   or
+        #   * 'CidrIp' - CIDR range
+        #   * 'FromPort' - Start of port range (or -1 for ICMP wildcard)
+        #   * 'IpProtocol' - Ip protocol, must be in ['tcp', 'udp', 'icmp']
+        #   * 'ToPort' - End of port range (or -1 for ICMP wildcard)
+        #
+        # === Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'return'<~Boolean> - success?
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RevokeSecurityGroupIngress.html]
+        def revoke_security_group_ingress(group_name, options = {})
+          if group_name.is_a?(Hash)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute#revoke_security_group_ingress now requires the 'group_name' parameter. Only specifying an options hash is now deprecated"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+            options = group_name
+            group_name = options['GroupName']
+          end
+          request({
+            'Action'    => 'RevokeSecurityGroupIngress',
+            'GroupName' => group_name,
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::Basic.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def revoke_security_group_ingress(group_name, options = {})
+          if group_name.is_a?(Hash)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Compute#revoke_security_group_ingress now requires the 'group_name' parameter. Only specifying an options hash is now deprecated"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+            options = group_name
+            group_name = options['GroupName']
+          end
+          response = Excon::Response.new
+          group = self.data[:security_groups][group_name]
+          if group
+            if options['SourceSecurityGroupName'] && options['SourceSecurityGroupOwnerId']
+              group['ipPermissions'].delete_if {|permission|
+                permission['groups'].first['groupName'] == group_name
+              }
+            else
+              ingress = group['ipPermissions'].select {|permission|
+                permission['fromPort']    == options['FromPort'] &&
+                permission['ipProtocol']  == options['IpProtocol'] &&
+                permission['toPort']      == options['ToPort'] &&
+                (
+                  permission['ipRanges'].empty? ||
+                  (
+                    permission['ipRanges'].first &&
+                    permission['ipRanges'].first['cidrIp'] == options['CidrIp']
+                  )
+                )
+              }.first
+              group['ipPermissions'].delete(ingress)
+            end
+            response.status = 200
+            response.body = {
+              'requestId' => Fog::AWS::Mock.request_id,
+              'return'    => true
+            }
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The security group '#{group_name}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/run_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/run_instances.rb
new file mode 100644
index 0000000..1d39eab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/run_instances.rb
@@ -0,0 +1,173 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/run_instances'
+
+        # Launch specified instances
+        #
+        # ==== Parameters
+        # * image_id<~String> - Id of machine image to load on instances
+        # * min_count<~Integer> - Minimum number of instances to launch. If this
+        #   exceeds the count of available instances, no instances will be
+        #   launched.  Must be between 1 and maximum allowed for your account
+        #   (by default the maximum for an account is 20)
+        # * max_count<~Integer> - Maximum number of instances to launch. If this
+        #   exceeds the number of available instances, the largest possible
+        #   number of instances above min_count will be launched instead. Must
+        #   be between 1 and maximum allowed for you account
+        #   (by default the maximum for an account is 20)
+        # * options<~Hash>:
+        #   * 'Placement.AvailabilityZone'<~String> - Placement constraint for instances
+        #   * 'BlockDeviceMapping'<~Array>: array of hashes
+        #     * 'DeviceName'<~String> - where the volume will be exposed to instance
+        #     * 'VirtualName'<~String> - volume virtual device name
+        #     * 'Ebs.SnapshotId'<~String> - id of snapshot to boot volume from
+        #     * 'Ebs.VolumeSize'<~String> - size of volume in GiBs required unless snapshot is specified
+        #     * 'Ebs.DeleteOnTermination'<~String> - specifies whether or not to delete the volume on instance termination
+        #   * 'ClientToken'<~String> - unique case-sensitive token for ensuring idempotency
+        #   * 'SecurityGroup'<~Array> or <~String> - Name of security group(s) for instances (you must omit this parameter if using Virtual Private Clouds)
+        #   * 'InstanceInitiatedShutdownBehaviour'<~String> - specifies whether volumes are stopped or terminated when instance is shutdown, in [stop, terminate]
+        #   * 'InstanceType'<~String> - Type of instance to boot. Valid options
+        #     in ['m1.small', 'm1.large', 'm1.xlarge', 'c1.medium', 'c1.xlarge', 'm2.2xlarge', 'm2.4xlarge']
+        #     default is 'm1.small'
+        #   * 'KernelId'<~String> - Id of kernel with which to launch
+        #   * 'KeyName'<~String> - Name of a keypair to add to booting instances
+        #   * 'Monitoring.Enabled'<~Boolean> - Enables monitoring, defaults to
+        #     disabled
+        #   * 'RamdiskId'<~String> - Id of ramdisk with which to launch
+        #   * 'UserData'<~String> -  Additional data to provide to booting instances
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'groupSet'<~Array>: groups the instances are members in
+        #       * 'groupName'<~String> - Name of group
+        #     * 'instancesSet'<~Array>: returned instances
+        #       * instance<~Hash>:
+        #         * 'amiLaunchIndex'<~Integer> - reference to instance in launch group
+        #         * 'architecture'<~String> - architecture of image in [i386, x86_64]
+        #         * 'blockDeviceMapping'<~Array>
+        #           * 'attachTime'<~Time> - time of volume attachment
+        #           * 'deleteOnTermination'<~Boolean> - whether or not to delete volume on termination
+        #           * 'deviceName'<~String> - specifies how volume is exposed to instance
+        #           * 'status'<~String> - status of attached volume
+        #           * 'volumeId'<~String> - Id of attached volume
+        #         * 'dnsName'<~String> - public dns name, blank until instance is running
+        #         * 'imageId'<~String> - image id of ami used to launch instance
+        #         * 'instanceId'<~String> - id of the instance
+        #         * 'instanceState'<~Hash>:
+        #           * 'code'<~Integer> - current status code
+        #           * 'name'<~String> - current status name
+        #         * 'instanceType'<~String> - type of instance
+        #         * 'ipAddress'<~String> - public ip address assigned to instance
+        #         * 'kernelId'<~String> - Id of kernel used to launch instance
+        #         * 'keyName'<~String> - name of key used launch instances or blank
+        #         * 'launchTime'<~Time> - time instance was launched
+        #         * 'monitoring'<~Hash>:
+        #           * 'state'<~Boolean - state of monitoring
+        #         * 'placement'<~Hash>:
+        #           * 'availabilityZone'<~String> - Availability zone of the instance
+        #         * 'privateDnsName'<~String> - private dns name, blank until instance is running
+        #         * 'privateIpAddress'<~String> - private ip address assigned to instance
+        #         * 'productCodes'<~Array> - Product codes for the instance
+        #         * 'ramdiskId'<~String> - Id of ramdisk used to launch instance
+        #         * 'reason'<~String> - reason for most recent state transition, or blank
+        #         * 'rootDeviceName'<~String> - specifies how the root device is exposed to the instance
+        #         * 'rootDeviceType'<~String> - root device type used by AMI in [ebs, instance-store]
+        #     * 'ownerId'<~String> - Id of owner
+        #     * 'requestId'<~String> - Id of request
+        #     * 'reservationId'<~String> - Id of reservation
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-RunInstances.html]
+        def run_instances(image_id, min_count, max_count, options = {})
+          if block_device_mapping = options.delete('BlockDeviceMapping')
+            block_device_mapping.each_with_index do |mapping, index|
+              for key, value in mapping
+                options.merge!({ format("BlockDeviceMapping.%d.#{key}", index) => value })
+              end
+            end
+          end
+          if security_groups = options.delete('SecurityGroup')
+            options.merge!(AWS.indexed_param('SecurityGroup', [*security_groups]))
+          end
+          if options['UserData']
+            options['UserData'] = Base64.encode64(options['UserData'])
+          end
+
+          idempotent = !(options['ClientToken'].nil? || options['ClientToken'].empty?)
+
+          request({
+            'Action'    => 'RunInstances',
+            'ImageId'   => image_id,
+            'MinCount'  => min_count,
+            'MaxCount'  => max_count,
+            :idempotent => idempotent,
+            :parser     => Fog::Parsers::AWS::Compute::RunInstances.new
+          }.merge!(options))
+        end
+
+      end
+
+      class Mock
+
+        def run_instances(image_id, min_count, max_count, options = {})
+          response = Excon::Response.new
+          response.status = 200
+
+          group_set = [ (options['SecurityGroup'] || 'default') ].flatten
+          instances_set = []
+          reservation_id = Fog::AWS::Mock.reservation_id
+
+          if options['KeyName'] && describe_key_pairs('key-name' => options['KeyName']).body['keySet'].empty?
+            raise Fog::AWS::Compute::NotFound.new("The key pair '#{options['KeyName']}' does not exist")
+          end
+
+          min_count.times do |i|
+            instance_id = Fog::AWS::Mock.instance_id
+            instance = {
+              'amiLaunchIndex'      => i,
+              'blockDeviceMapping'  => [],
+              'clientToken'         => options['clientToken'],
+              'dnsName'             => nil,
+              'imageId'             => image_id,
+              'instanceId'          => instance_id,
+              'instanceState'       => { 'code' => 0, 'name' => 'pending' },
+              'instanceType'        => options['InstanceType'] || 'm1.small',
+              'kernelId'            => options['KernelId'] || Fog::AWS::Mock.kernel_id,
+              'keyName'             => options['KeyName'],
+              'launchTime'          => Time.now,
+              'monitoring'          => { 'state' => options['Monitoring.Enabled'] || false },
+              'placement'           => { 'availabilityZone' => options['Placement.AvailabilityZone'] || Fog::AWS::Mock.availability_zone(@region) },
+              'privateDnsName'      => nil,
+              'productCodes'        => [],
+              'ramdiskId'           => options['RamdiskId'] || Fog::AWS::Mock.ramdisk_id,
+              'reason'              => nil,
+              'rootDeviceType'      => 'instance-store'
+            }
+            instances_set << instance
+            self.data[:instances][instance_id] = instance.merge({
+              'architecture'        => 'i386',
+              'groupSet'            => group_set,
+              'ownerId'             => self.data[:owner_id],
+              'privateIpAddress'    => nil,
+              'reservationId'       => reservation_id,
+              'stateReason'         => {},
+              'tagSet'              => {}
+            })
+          end
+          response.body = {
+            'groupSet'      => group_set,
+            'instancesSet'  => instances_set,
+            'ownerId'       => self.data[:owner_id],
+            'requestId'     => Fog::AWS::Mock.request_id,
+            'reservationId' => reservation_id
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/start_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/start_instances.rb
new file mode 100644
index 0000000..8285b6d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/start_instances.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/start_stop_instances'
+
+        # Start specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-StartInstances.html]
+        def start_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StartInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/stop_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/stop_instances.rb
new file mode 100644
index 0000000..9f0611b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/stop_instances.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/start_stop_instances'
+
+        # Stop specified instance
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Id of instance to start
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * TODO: fill in the blanks
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-StopInstances.html]
+        def stop_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'StopInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::StartStopInstances.new
+          }.merge!(params))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/terminate_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/terminate_instances.rb
new file mode 100644
index 0000000..dc33aaf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/terminate_instances.rb
@@ -0,0 +1,96 @@
+module Fog
+  module AWS
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/aws/terminate_instances'
+
+        # Terminate specified instances
+        #
+        # ==== Parameters
+        # * instance_id<~Array> - Ids of instances to terminates
+        #
+        # ==== Returns
+        # # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'instancesSet'<~Array>:
+        #       * 'instanceId'<~String> - id of the terminated instance
+        #       * 'previousState'<~Hash>: previous state of instance
+        #         * 'code'<~Integer> - previous status code
+        #         * 'name'<~String> - name of previous state
+        #       * 'shutdownState'<~Hash>: shutdown state of instance
+        #         * 'code'<~Integer> - current status code
+        #         * 'name'<~String> - name of current state
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-TerminateInstances.html]
+        def terminate_instances(instance_id)
+          params = AWS.indexed_param('InstanceId', instance_id)
+          request({
+            'Action'    => 'TerminateInstances',
+            :idempotent => true,
+            :parser     => Fog::Parsers::AWS::Compute::TerminateInstances.new
+          }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def terminate_instances(instance_id)
+          response = Excon::Response.new
+          instance_id = [*instance_id]
+          if (self.data[:instances].keys & instance_id).length == instance_id.length
+            response.body = {
+              'requestId'     => Fog::AWS::Mock.request_id,
+              'instancesSet'  => []
+            }
+            response.status = 200
+            for id in instance_id
+              instance = self.data[:instances][id]
+              self.data[:deleted_at][id] = Time.now
+              code = case instance['instanceState']['name']
+              when 'pending'
+                0
+              when 'running'
+                16
+              when 'shutting-down'
+                32
+              when 'terminated'
+                48
+              when 'stopping'
+                64
+              when 'stopped'
+                80
+              end
+              state = { 'name' => 'shutting-down', 'code' => 32}
+              response.body['instancesSet'] << {
+                'instanceId'    => id,
+                'previousState' => instance['instanceState'],
+                'currentState'  => state
+              }
+              instance['instanceState'] = state
+            end
+
+            describe_addresses.body['addressesSet'].each do |address|
+              if instance_id.include?(address['instanceId'])
+                disassociate_address(address['publicIp'])
+              end
+            end
+
+            describe_volumes.body['volumeSet'].each do |volume|
+              if volume['attachmentSet'].first && instance_id.include?(volume['attachmentSet'].first['instanceId'])
+                detach_volume(volume['volumeId'])
+              end
+            end
+
+            response
+          else
+            raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_id}' does not exist")
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/aws/unmonitor_instances.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/unmonitor_instances.rb
new file mode 100644
index 0000000..02cba87
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/aws/unmonitor_instances.rb
@@ -0,0 +1,55 @@
+module Fog
+  module AWS
+    class Compute
+
+      class Real
+
+        require 'fog/compute/parsers/aws/monitor_unmonitor_instances'
+
+        # UnMonitor specified instance
+        # http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-UnmonitorInstances.html
+        #
+        # ==== Parameters
+        # * instance_ids<~Array> - Arrays of instances Ids to monitor
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'requestId'<~String> - Id of request
+        #     * 'instancesSet': http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-ItemType-MonitorInstancesResponseSetItemType.html
+        #
+        # {Amazon API Reference}[http://docs.amazonwebservices.com/AWSEC2/latest/APIReference/ApiReference-query-UnmonitorInstances.html]
+        def unmonitor_instances(instance_ids)
+          params = AWS.indexed_param('InstanceId', instance_ids)
+          request({
+                          'Action' => 'UnmonitorInstances',
+                          :idempotent => true,
+                          :parser => Fog::Parsers::AWS::Compute::MonitorUnmonitorInstances.new
+                  }.merge!(params))
+        end
+
+      end
+
+      class Mock
+
+        def unmonitor_instances(instance_ids)
+          response        = Excon::Response.new
+          response.status = 200
+          [*instance_ids].each do |instance_id|
+            if instance = self.data[:instances][instance_id]
+              instance['monitoring']['state'] = 'enabled'
+            else
+              raise Fog::AWS::Compute::NotFound.new("The instance ID '#{instance_ids}' does not exist")
+            end
+          end
+          instances_set = [*instance_ids].inject([]) { |memo, id| memo << {'instanceId' => id, 'monitoring' => 'disabled'} }
+          response.body = {'requestId' => 'some_request_id', 'instancesSet' => instances_set}
+          response
+        end
+        
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/create_block.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/create_block.rb
new file mode 100644
index 0000000..270b7e8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/create_block.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Create a new block
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of product to create block with
+        # * template_id<~Integer> - Id of template to create block with
+        # * options<~Hash>:
+        #     * password<~String> - Password for block
+        #   or
+        #     * ssh_key<~String> - ssh public key
+        #   * username<~String> - optional, defaults to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def create_block(product_id, template_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'POST',
+            :path     => '/api/blocks.json',
+            :query    => {'product' => product_id, 'template' => template_id}.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/destroy_block.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/destroy_block.rb
new file mode 100644
index 0000000..f92c46c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/destroy_block.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Destroy a block
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to destroy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def destroy_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_block.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_block.rb
new file mode 100644
index 0000000..85d8587
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_block.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a block.
+        #
+        # ==== Parameters
+        # * block_id<~Integer> - Id of block to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def get_block(block_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/blocks/#{block_id}.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_blocks.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_blocks.rb
new file mode 100644
index 0000000..5b21787
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_blocks.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of blocks
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'ips'<~Array> - Ip addresses for the block
+        #     * 'id'<~String> - Id of the block
+        #     * 'storage'<~Integer> - Disk space quota for the block
+        #     * 'memory'<~Integer> - RAM quota for the block
+        #     * 'cpu'<~Float> - The fractional CPU quota for this block
+        #     * 'hostname'<~String> - The hostname for the block
+        def get_blocks
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/blocks.json'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_product.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_product.rb
new file mode 100644
index 0000000..9340cad
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_product.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a product
+        #
+        # ==== Parameters
+        # * product_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_product(product_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_products/#{product_id}.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_products.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_products.rb
new file mode 100644
index 0000000..7174c47
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_products.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of products
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the product
+        #     * 'description'<~String> - Description of the product
+        #     * 'cost'<~Decimal> - Hourly cost of the product
+        def get_products
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_products.json'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_template.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_template.rb
new file mode 100644
index 0000000..379d586
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_template.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get details of a template
+        #
+        # ==== Parameters
+        # * template_id<~Integer> - Id of template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO
+        def get_template(template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "api/block_templates/#{template_id}.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_templates.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_templates.rb
new file mode 100644
index 0000000..aaa079e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/get_templates.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Get list of OS templates
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String> - UUID of the image
+        #     * 'description'<~String> - Description of the image
+        #     * 'public'<~Boolean> - Public / Private image
+        #     * 'created'<~Datetime> - Timestamp of when the image was created
+        def get_templates
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => 'api/block_templates.json'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/reboot_block.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/reboot_block.rb
new file mode 100644
index 0000000..9bdb779
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/bluebox/reboot_block.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Bluebox
+    class Compute
+      class Real
+
+        # Reboot block
+        #
+        # ==== Parameters
+        # * block_id<~String> - Id of block to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        # TODO
+        def reboot_block(block_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "api/blocks/#{block_id}/#{'soft_' if type == 'SOFT'}reboot.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/activate_console_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/activate_console_server.rb
new file mode 100644
index 0000000..b9ff904
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/activate_console_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def activate_console_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/activate_console",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_listeners_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_listeners_load_balancer.rb
new file mode 100644
index 0000000..03342dc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_listeners_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def add_listeners_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/add_listeners",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_nodes_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_nodes_load_balancer.rb
new file mode 100644
index 0000000..cedddf0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/add_nodes_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def add_nodes_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/add_nodes",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_api_client.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_api_client.rb
new file mode 100644
index 0000000..c0273de
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_api_client.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_api_client(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_cloud_ip.rb
new file mode 100644
index 0000000..e859360
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_cloud_ip.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_cloud_ip(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_image.rb
new file mode 100644
index 0000000..c45fbf4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_image.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_image(options = {})
+          request(
+            :expects  => [201],
+            :method   => 'POST',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_load_balancer.rb
new file mode 100644
index 0000000..f3b4bca
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_load_balancer.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_load_balancer(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_server.rb
new file mode 100644
index 0000000..37efd63
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/create_server.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def create_server(options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_api_client.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_api_client.rb
new file mode 100644
index 0000000..fbcae1d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_api_client.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_cloud_ip.rb
new file mode 100644
index 0000000..9a3b895
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_cloud_ip.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'DELETE',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_image.rb
new file mode 100644
index 0000000..944278b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_load_balancer.rb
new file mode 100644
index 0000000..2374efa
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_server.rb
new file mode 100644
index 0000000..87df656
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/destroy_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def destroy_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'DELETE',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_account.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_account.rb
new file mode 100644
index 0000000..31c3e15
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_account.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_account(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/account",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_api_client.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_api_client.rb
new file mode 100644
index 0000000..dd04a84
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_api_client.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_cloud_ip.rb
new file mode 100644
index 0000000..fff060c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_cloud_ip.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_image.rb
new file mode 100644
index 0000000..3bf2066
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_image.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_interface.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_interface.rb
new file mode 100644
index 0000000..edf7cf1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_interface.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_interface(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/interfaces/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_load_balancer.rb
new file mode 100644
index 0000000..343e55c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server.rb
new file mode 100644
index 0000000..5fe4e82
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server_type.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server_type.rb
new file mode 100644
index 0000000..8ba4892
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_server_type.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_server_type(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_user.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_user.rb
new file mode 100644
index 0000000..69862d8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_user.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_user(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_zone.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_zone.rb
new file mode 100644
index 0000000..fc1acf7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/get_zone.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def get_zone(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_api_clients.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_api_clients.rb
new file mode 100644
index 0000000..45478f3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_api_clients.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_api_clients(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/api_clients",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_cloud_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_cloud_ips.rb
new file mode 100644
index 0000000..379e9bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_cloud_ips.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_cloud_ips(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/cloud_ips",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_images.rb
new file mode 100644
index 0000000..7b4063e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_images.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_images(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/images",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_load_balancers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_load_balancers.rb
new file mode 100644
index 0000000..087b0fb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_load_balancers.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_load_balancers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/load_balancers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_server_types.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_server_types.rb
new file mode 100644
index 0000000..590adc9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_server_types.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_server_types(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/server_types",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_servers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_servers.rb
new file mode 100644
index 0000000..dad21f2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_servers.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_servers(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/servers",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_users.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_users.rb
new file mode 100644
index 0000000..9ff39e5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_users.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_users(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/users",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_zones.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_zones.rb
new file mode 100644
index 0000000..15f2cda
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/list_zones.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def list_zones(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'GET',
+            :path     => "/1.0/zones",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/map_cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/map_cloud_ip.rb
new file mode 100644
index 0000000..323aca5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/map_cloud_ip.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def map_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/map",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_listeners_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_listeners_load_balancer.rb
new file mode 100644
index 0000000..fa99d59
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_listeners_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def remove_listeners_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/remove_listeners",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_nodes_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_nodes_load_balancer.rb
new file mode 100644
index 0000000..5c531d5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/remove_nodes_load_balancer.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def remove_nodes_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/load_balancers/#{identifier}/remove_nodes",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/reset_ftp_password_account.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/reset_ftp_password_account.rb
new file mode 100644
index 0000000..d0eac1b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/reset_ftp_password_account.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def reset_ftp_password_account(options = {})
+          request(
+            :expects  => [200],
+            :method   => 'POST',
+            :path     => "/1.0/account/reset_ftp_password",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/resize_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/resize_server.rb
new file mode 100644
index 0000000..cdbf8ca
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/resize_server.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def resize_server(identifier, options = {})
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/resize",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/shutdown_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/shutdown_server.rb
new file mode 100644
index 0000000..fec07ae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/shutdown_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def shutdown_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/shutdown",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/snapshot_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/snapshot_server.rb
new file mode 100644
index 0000000..3657d4e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/snapshot_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def snapshot_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/snapshot",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/start_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/start_server.rb
new file mode 100644
index 0000000..c8a7dde
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/start_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def start_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/start",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/stop_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/stop_server.rb
new file mode 100644
index 0000000..e0be177
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/stop_server.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def stop_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/servers/#{identifier}/stop",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/unmap_cloud_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/unmap_cloud_ip.rb
new file mode 100644
index 0000000..56754d8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/unmap_cloud_ip.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def unmap_cloud_ip(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          request(
+            :expects  => [202],
+            :method   => 'POST',
+            :path     => "/1.0/cloud_ips/#{identifier}/unmap",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_account.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_account.rb
new file mode 100644
index 0000000..450eed5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_account.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_account(options = {})
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/account",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_api_client.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_api_client.rb
new file mode 100644
index 0000000..b29c0d3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_api_client.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_api_client(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/api_clients/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_image.rb
new file mode 100644
index 0000000..c8171f7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_image.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_image(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/images/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_load_balancer.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_load_balancer.rb
new file mode 100644
index 0000000..42a6d1a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_load_balancer.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_load_balancer(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [202],
+            :method   => 'PUT',
+            :path     => "/1.0/load_balancers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_server.rb
new file mode 100644
index 0000000..3e79b4e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_server.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_server(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/servers/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_user.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_user.rb
new file mode 100644
index 0000000..61291c4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/brightbox/update_user.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Brightbox
+    class Compute
+      class Real
+
+        def update_user(identifier, options = {})
+          return nil if identifier.nil? || identifier == ""
+          return nil if options.empty? || options.nil?
+          request(
+            :expects  => [200],
+            :method   => 'PUT',
+            :path     => "/1.0/users/#{identifier}",
+            :headers  => {"Content-Type" => "application/json"},
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_backup_internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_backup_internet_service.rb
new file mode 100644
index 0000000..2799403
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_backup_internet_service.rb
@@ -0,0 +1,109 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        def validate_backup_internet_service_data(service_data, configure=false)
+          required_opts = [:name, :protocol, :description, :enabled]
+          if configure
+            required_opts + [ :id, :href, :timeout ]
+          end
+          unless required_opts.all? { |opt| service_data.keys.include?(opt) }
+            raise ArgumentError.new("Required Backup Internet Service data missing: #{(required_opts - service_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def add_backup_internet_service(internet_services_uri, service_data)
+          validate_backup_internet_service_data(service_data)
+          if monitor = service_data[:monitor]
+            validate_internet_service_monitor(monitor)
+            ensure_monitor_defaults!(monitor)
+          end
+
+          request(
+            :body     => generate_backup_internet_service_request(service_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :uri      => internet_services_uri,
+            :parse    => true
+          )
+        end
+
+        private
+
+        def generate_backup_internet_service_request(service_data)
+          builder = Builder::XmlMarkup.new
+          builder.CreateBackupInternetServiceRequest("xmlns" => "urn:tmrk:eCloudExtensions-2.5") {
+            builder.Name(service_data[:name])
+            builder.Protocol(service_data[:protocol])
+            builder.Enabled(service_data[:enabled])
+            builder.Description(service_data[:description])
+            builder.RedirectURL(service_data[:redirect_url])
+            if monitor = service_data[:monitor]
+              generate_monitor_section(builder,monitor)
+            end
+          }
+        end
+      end
+
+      class Mock
+        include Shared
+
+        #
+        # Based on
+        # http://support.theenterprisecloud.com/kb/default.asp?id=729&Lang=1&SID=
+        # and many tears shed.
+        #
+
+        def add_backup_internet_service(internet_services_uri, service_data)
+          validate_backup_internet_service_data(service_data)
+
+          internet_services_uri = ensure_unparsed(internet_services_uri)
+
+          if vdc_internet_service_collection = mock_data.vdc_internet_service_collection_from_href(internet_services_uri)
+            new_backup_internet_service = MockBackupInternetService.new(service_data, vdc_internet_service_collection.backup_internet_services)
+            vdc_internet_service_collection.backup_internet_services << new_backup_internet_service
+            xml = generate_backup_internet_service_added_response(new_backup_internet_service)
+
+            mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+        private
+
+        def generate_backup_internet_service_added_response(new_backup_internet_service)
+          builder = Builder::XmlMarkup.new
+          builder.InternetService("xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+            builder.Id new_backup_internet_service.object_id
+            builder.Href new_backup_internet_service.href
+            builder.Name new_backup_internet_service.name
+            # so broken
+            builder.PublicIpAddress do
+              builder.Id -2147483648
+              builder.Id "http://totally.invalid/1234"
+              builder.Name
+            end
+            builder.Port new_backup_internet_service.port
+            builder.Protocol new_backup_internet_service.protocol
+            builder.Enabled new_backup_internet_service.enabled
+            builder.Timeout new_backup_internet_service.timeout
+            builder.Description new_backup_internet_service.description
+            builder.RedirectURL new_backup_internet_service.redirect_url
+            builder.Monitor "i:nil" => true
+            # so broken
+            builder.IsBackupService false
+            builder.BackupService "i:nil" => true
+            builder.BackupOf "i:nil" => true
+          }
+        end
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_internet_service.rb
new file mode 100644
index 0000000..7b51aff
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_internet_service.rb
@@ -0,0 +1,149 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        def validate_internet_service_monitor(monitor)
+          #FIXME: Refactor this type of function into something generic
+          unless ['Disabled','HTTP','ECV'].include?(monitor[:type])
+            raise ArgumentError.new("Supported monitor types are: ECV & HTTP")
+          end
+
+          required_opts = case monitor[:type]
+                          when "Disabled"
+                            [:type, :is_enabled]
+                          else
+                            [:type, :url_send_string, :http_headers, :receive_string, :is_enabled]
+                          end
+
+          unless required_opts.all? { |opt| monitor.keys.include?(opt) && monitor[opt] }
+            raise ArgumentError.new("Required Monitor data missing: #{(required_opts - monitor.keys).map(&:inspect).join(", ")}")
+          end
+
+          case monitor[:type]
+            when "HTTP", "ECV"
+              unless monitor[:http_headers].is_a?(Array) || monitor[:http_headers].is_a?(String)
+                raise ArgumentError.new("Monitor :http_headers must be a String or Array")
+              end
+          end
+
+          unless [true, false, "true", "false"].include?(monitor[:is_enabled])
+            raise ArgumentError.new("Monitor :is_enabled must be true or false")
+          end
+        end
+
+        def validate_internet_service_data(service_data, configure=false)
+          required_opts = [:name, :protocol, :port, :description, :enabled]
+          if configure
+            required_opts + [ :id, :href, :timeout ]
+          end
+          unless required_opts.all? { |opt| service_data.keys.include?(opt) }
+            raise ArgumentError.new("Required Internet Service data missing: #{(required_opts - service_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+
+        def ensure_monitor_defaults!(monitor)
+          if monitor[:http_headers].is_a?(String)
+            monitor[:http_headers] = [ monitor[:http_headers] ]
+          end
+
+          unless monitor[:retries]
+            monitor[:retries] = 3
+          end
+
+          unless monitor[:response_timeout]
+            monitor[:response_timeout] = 2
+          end
+
+          unless monitor[:down_time]
+            monitor[:down_time] = 30
+          end
+
+          unless monitor[:interval]
+            monitor[:interval] = 5
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def add_internet_service(internet_services_uri, service_data)
+          validate_internet_service_data(service_data)
+          if monitor = service_data[:monitor]
+            validate_internet_service_monitor(monitor)
+            ensure_monitor_defaults!(monitor)
+          end
+
+          request(
+            :body     => generate_internet_service_request(service_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+            :method   => 'POST',
+            :uri      => internet_services_uri,
+            :parse    => true
+          )
+        end
+
+        private
+
+        def generate_internet_service_request(service_data)
+          builder = Builder::XmlMarkup.new
+          builder.CreateInternetServiceRequest(ecloud_xmlns) {
+            builder.Name(service_data[:name])
+            builder.Protocol(service_data[:protocol])
+            builder.Port(service_data[:port])
+            builder.Enabled(service_data[:enabled])
+            builder.Description(service_data[:description])
+            builder.RedirectURL(service_data[:redirect_url])
+            if monitor = service_data[:monitor]
+              generate_monitor_section(builder,monitor)
+            end
+          }
+        end
+
+        def generate_monitor_section(builder, monitor)
+          builder.Monitor {
+            builder.MonitorType(monitor[:type])
+            case monitor[:type]
+            when "ECV","HTTP"
+              builder.UrlSendString(monitor[:url_send_string])
+              builder.HttpHeader(monitor[:http_headers].join("\n"))
+              builder.ReceiveString(monitor[:receive_string])
+              builder.Interval(monitor[:interval])
+              builder.ResponseTimeOut(monitor[:response_timeout])
+              builder.DownTime(monitor[:downtime])
+              builder.Retries(monitor[:retries])
+            end
+            builder.IsEnabled(monitor[:is_enabled])
+          }
+        end
+
+      end
+
+      class Mock
+        include Shared
+
+        #
+        # Based on
+        # http://support.theenterprisecloud.com/kb/default.asp?id=561&Lang=1&SID=
+        #
+
+        def add_internet_service(internet_services_uri, service_data)
+          validate_internet_service_data(service_data)
+
+          internet_services_uri = ensure_unparsed(internet_services_uri)
+
+          if public_ip_internet_service_collection = mock_data.public_ip_internet_service_collection_from_href(internet_services_uri)
+            new_public_ip_internet_service = MockPublicIpInternetService.new(service_data, public_ip_internet_service_collection)
+            public_ip_internet_service_collection.items << new_public_ip_internet_service
+            xml = generate_internet_service(Builder::XmlMarkup.new, new_public_ip_internet_service, true)
+
+            mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_node.rb
new file mode 100644
index 0000000..8339190
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/add_node.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def generate_node_request(node_data)
+          builder = Builder::XmlMarkup.new
+          builder.CreateNodeServiceRequest(ecloud_xmlns) {
+            builder.IpAddress(node_data[:ip_address])
+            builder.Name(node_data[:name])
+            builder.Port(node_data[:port])
+            builder.Enabled(node_data[:enabled])
+            builder.Description(node_data[:description])
+          }
+        end
+
+        def validate_node_data(node_data, configure=false)
+          valid_opts = [:name, :port, :enabled, :description, :ip_address]
+          if configure
+            valid_opts.delete_if { |opt| ![:name, :enabled, :description].include?(opt) }
+          end
+          unless valid_opts.all? { |opt| node_data.keys.include?(opt) }
+            raise ArgumentError.new("Required data missing: #{(valid_opts - node_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def add_node(nodes_uri, node_data)
+          validate_node_data(node_data)
+
+          request(
+            :body     => generate_node_request(node_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+            :method   => 'POST',
+            :uri      => nodes_uri,
+            :parse    => true
+          )
+        end
+      end
+
+      class Mock
+        include Shared
+
+        def add_node(nodes_uri, node_data)
+          validate_node_data(node_data)
+          if node_collection = mock_data.public_ip_internet_service_node_collection_from_href(ensure_unparsed(nodes_uri))
+            new_node = MockPublicIpInternetServiceNode.new(node_data, node_collection)
+            node_collection.items << new_node
+            mock_it 200, mock_node_service_response(new_node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/clone_vapp.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/clone_vapp.rb
new file mode 100644
index 0000000..b070a97
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/clone_vapp.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Real
+
+        def validate_clone_vapp_options(options)
+          valid_opts = [:name, :poweron]
+          unless valid_opts.all? { |opt| options.keys.include?(opt) }
+            raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+          end
+        end
+
+        def generate_clone_vapp_request(uri, options)
+          xml = Builder::XmlMarkup.new
+          xml.CloneVAppParams(xmlns.merge!(:name => options[:name], :deploy => "true", :powerOn => options[:poweron])) {
+            xml.VApp( :href => uri, :type => "application/vnd.vmware.vcloud.vApp+xml",
+                      :xmlns => "http://www.vmware.com/vcloud/v0.8")
+          }
+        end
+
+        def clone_vapp(vdc_uri, vapp_uri, options = {})
+          unless options.has_key?(:poweron)
+            options[:poweron] = "false"
+          end
+
+          validate_clone_vapp_options(options)
+
+          request(
+            :body     => generate_clone_vapp_request(vapp_uri, options),
+            :expects  => 202,
+            :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.cloneVAppParams+xml'},
+            :method   => 'POST',
+            :uri      => vdc_uri + '/action/clonevapp',
+            :parse    => true
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_internet_service.rb
new file mode 100644
index 0000000..48147e7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_internet_service.rb
@@ -0,0 +1,112 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def validate_public_ip_address_data(ip_address_data)
+          valid_opts = [:name, :href, :id]
+          unless valid_opts.all? { |opt| ip_address_data.keys.include?(opt) }
+            raise ArgumentError.new("Required Internet Service data missing: #{(valid_opts - ip_address_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+          validate_internet_service_data(service_data, true)
+
+          validate_public_ip_address_data(ip_address_data)
+
+          if monitor = service_data[:monitor]
+            validate_internet_service_monitor(monitor)
+            ensure_monitor_defaults!(monitor)
+          end
+
+          request(
+            :body     => generate_configure_internet_service_request(service_data, ip_address_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'},
+            :method   => 'PUT',
+            :uri      => internet_service_uri,
+            :parse    => true
+          )
+        end
+
+        private
+
+        def generate_configure_internet_service_request(service_data, ip_address_data)
+          builder = Builder::XmlMarkup.new
+          builder.InternetService(ecloud_xmlns) {
+            builder.Id(service_data[:id])
+            builder.Href(service_data[:href])
+            builder.Name(service_data[:name])
+            builder.Protocol(service_data[:protocol])
+            builder.Port(service_data[:port])
+            builder.Enabled(service_data[:enabled])
+            builder.Description(service_data[:description])
+            builder.Timeout(service_data[:timeout])
+            builder.RedirectURL(service_data[:redirect_url])
+            builder.PublicIpAddress {
+              builder.Id(ip_address_data[:id])
+              builder.Href(ip_address_data[:href])
+              builder.Name(ip_address_data[:name])
+            }
+            if monitor = service_data[:monitor]
+              generate_monitor_section(builder, monitor)
+            end
+            if service_data[:backup_service_uri]
+              builder.BackupService do
+                builder.Href(service_data[:backup_service_uri])
+              end
+            end
+          }
+        end
+      end
+
+      class Mock
+        include Shared
+
+        #
+        # Based on
+        # http://support.theenterprisecloud.com/kb/default.asp?id=583&Lang=1&SID=
+        #
+
+        def configure_internet_service(internet_service_uri, service_data, ip_address_data)
+          service_data = service_data.dup
+
+          validate_internet_service_data(service_data, true)
+
+          if monitor = service_data[:monitor]
+            validate_internet_service_monitor(monitor)
+            ensure_monitor_defaults!(monitor)
+          end
+
+          validate_public_ip_address_data(ip_address_data)
+
+          internet_service_uri = ensure_unparsed(internet_service_uri)
+
+          backup_service_uri = service_data.delete(:backup_service_uri)
+          backup_service = backup_service_uri && mock_data.backup_internet_service_from_href(backup_service_uri)
+
+          xml = nil
+
+          if (public_ip_internet_service = mock_data.public_ip_internet_service_from_href(internet_service_uri)) &&
+              (backup_service_uri.nil? || backup_service)
+            public_ip_internet_service.update(service_data.reject {|k, v| [:id, :href].include?(k) })
+            public_ip_internet_service[:backup_service] = backup_service
+            xml = generate_internet_service(Builder::XmlMarkup.new, public_ip_internet_service, true)
+          end
+
+          if xml
+            mock_it 200, xml, {'Content-Type' => 'application/vnd.tmrk.ecloud.internetService+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network.rb
new file mode 100644
index 0000000..b999382
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Ecloud
+    class Compute
+      class Real
+
+        def validate_network_data(network_data, configure=false)
+          valid_opts = [:id, :href, :name, :rnat, :address, :broadcast, :gateway]
+          unless valid_opts.all? { |opt| network_data.keys.include?(opt) }
+            raise ArgumentError.new("Required data missing: #{(valid_opts - network_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+
+        def configure_network(network_uri, network_data)
+          validate_network_data(network_data)
+
+          request(
+            :body     => generate_configure_network_request(network_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.networkService+xml'},
+            :method   => 'PUT',
+            :uri      => network_uri,
+            :parse    => true
+          )
+        end
+
+        private
+
+        def generate_configure_network_request(network_data)
+          builder = Builder::XmlMarkup.new
+          builder.Network(ecloud_xmlns) {
+            builder.Id(network_data[:id])
+            builder.Href(network_data[:href])
+            builder.Name(network_data[:name])
+            builder.RnatAddress(network_data[:rnat])
+            builder.Address(network_data[:address])
+            builder.BroadcastAddress(network_data[:broadcast])
+            builder.GatewayAddress(network_data[:gateway])
+          }
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network_ip.rb
new file mode 100644
index 0000000..ee4f3df
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_network_ip.rb
@@ -0,0 +1,66 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def validate_network_ip_data(network_ip_data)
+          valid_opts = [:id, :href, :name, :status, :server, :rnat]
+          unless valid_opts.all? { |opt| network_ip_data.keys.include?(opt) }
+            raise ArgumentError.new("Required data missing: #{(valid_opts - network_ip_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def configure_network_ip(network_ip_uri, network_ip_data)
+          validate_network_ip_data(network_ip_data)
+
+          request(
+            :body     => generate_configure_network_ip_request(network_ip_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' },
+            :method   => 'PUT',
+            :uri      => network_ip_uri,
+            :parse    => true
+          )
+        end
+
+        private
+
+        def generate_configure_network_ip_request(network_ip_data)
+          builder = Builder::XmlMarkup.new
+          builder.IpAddress(ecloud_xmlns) {
+            builder.Id(network_ip_data[:id])
+            builder.Href(network_ip_data[:href])
+            builder.Name(network_ip_data[:name])
+            builder.Status(network_ip_data[:status])
+            builder.Server(network_ip_data[:server])
+            builder.RnatAddress(network_ip_data[:rnat])
+          }
+        end
+      end
+
+      class Mock
+        include Shared
+
+        def configure_network_ip(network_ip_uri, network_ip_data)
+          validate_network_ip_data(network_ip_data)
+
+          if network_ip = mock_data.network_ip_from_href(network_ip_uri)
+            network_ip[:rnat] = network_ip_data[:rnat]
+
+            builder = Builder::XmlMarkup.new
+            xml = network_ip_response(builder, network_ip, ecloud_xmlns)
+
+            mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_node.rb
new file mode 100644
index 0000000..44b5254
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_node.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def generate_configure_node_request(node_data)
+          builder = Builder::XmlMarkup.new
+          builder.NodeService(:"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance",
+                                  :xmlns => "urn:tmrk:eCloudExtensions-2.0") {
+            builder.Name(node_data[:name])
+            builder.Enabled(node_data[:enabled].to_s)
+            builder.Description(node_data[:description])
+          }
+        end
+
+      end
+
+      class Real
+        include Shared
+
+        def configure_node(node_uri, node_data)
+          validate_node_data(node_data, true)
+
+          request(
+            :body     => generate_configure_node_request(node_data),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml'},
+            :method   => 'PUT',
+            :uri      => node_uri,
+            :parse    => true
+          )
+        end
+
+      end
+
+      class Mock
+        include Shared
+
+        def configure_node(node_uri, node_data)
+          validate_node_data(node_data, true)
+
+          if node = mock_data.public_ip_internet_service_node_from_href(ensure_unparsed(node_uri))
+            node.update(node_data)
+            #if node_data[:enabled] 
+            #  node.enabled = (node_data[:enabled] == "true") ? true : false
+            #end
+            mock_it 200, mock_node_service_response(node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_vapp.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_vapp.rb
new file mode 100644
index 0000000..53b744a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/configure_vapp.rb
@@ -0,0 +1,144 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def validate_vapp_data(vapp_data)
+          valid_opts = [:name, :cpus, :memory, :disks]
+          unless valid_opts.all? { |opt| vapp_data.keys.include?(opt) }
+            raise ArgumentError.new("Required Vapp data missing: #{(valid_opts - vapp_data.keys).map(&:inspect).join(", ")}")
+          end
+        end
+      end
+
+      class Real
+        include Shared
+
+        def generate_configure_vapp_request(vapp_uri, vapp_data)
+          rasd_xmlns = { "xmlns" => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData" }
+
+          xml = Nokogiri::XML(request( :uri => vapp_uri).body)
+          xml.root['name'] = vapp_data[:name]
+
+          #cpu
+          xml.at("//xmlns:ResourceType[.='3']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:cpus]
+
+          #memory
+          xml.at("//xmlns:ResourceType[.='4']/..", rasd_xmlns).at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:memory]
+
+          #disks
+          real_disks = xml.xpath("//xmlns:ResourceType[ .='17']/..", rasd_xmlns)
+          real_disk_numbers = real_disks.map { |disk| disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content }
+          disk_numbers = vapp_data[:disks].map { |vdisk| vdisk[:number].to_s }
+
+          if vapp_data[:disks].length < real_disks.length
+            #Assume we're removing a disk
+            remove_disk_numbers = real_disk_numbers - disk_numbers
+            remove_disk_numbers.each do |number|
+              if result = xml.at("//xmlns:ResourceType[ .='17']/../xmlns:AddressOnParent[.='#{number}']/..", rasd_xmlns)
+                result.remove
+              end
+            end
+          elsif vapp_data[:disks].length > real_disks.length
+            add_disk_numbers = disk_numbers - real_disk_numbers
+
+            add_disk_numbers.each do |number|
+              new_disk = real_disks.first.dup
+              new_disk.at('.//xmlns:AddressOnParent', rasd_xmlns).content = -1
+              new_disk.at('.//xmlns:VirtualQuantity', rasd_xmlns).content = vapp_data[:disks].detect { |disk| disk[:number].to_s == number.to_s }[:size]
+              real_disks.first.parent << new_disk
+            end
+          end
+
+          #puts xml.root.to_s
+          xml.root.to_s
+
+          #builder = Builder::XmlMarkup.new
+          #builder.Vapp(:href => vapp_uri.to_s,
+          #             :type => 'application/vnd.vmware.vcloud.vApp+xml',
+          #             :name => vapp_data[:name],
+          #             :status => 2,
+          #             :size => 0,
+          #             :xmlns => 'http://www.vmware.com/vcloud/v0.8',
+          #             :"xmlns:xsi" => 'http://www.w3.org/2001/XMLSchema-instance',
+          #             :"xmlns:xsd" => 'http://www.w3.org/2001/XMLSchema') {
+          #  #builder.VirtualHardwareSection(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+          #  builder.Section(:"xsi:type" => "q2:VirtualHardwareSection_Type", :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"xmlns:q2" => "http://www.vmware.com/vcloud/v0.8") {
+          #    builder.Info('Virtual Hardware')
+          #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+          #    #builder.Item {
+          #      builder.InstanceID(1, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #      builder.ResourceType(3, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #      builder.VirtualQuantity(vapp_data[:cpus], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #    }
+          #    builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+          #    #builder.Item {
+          #      builder.InstanceID(2, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #      builder.ResourceType(4, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #      builder.VirtualQuantity(vapp_data[:memory], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #    }
+          #    vapp_data[:disks].each do |disk_data|
+          #      #builder.Item(:xmlns => 'http://schemas.dmtf.org/ovf/envelope/1') {
+          #      builder.Item {
+          #        builder.AddressOnParent(disk_data[:number], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #        builder.HostResource(disk_data[:resource], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #        builder.InstanceID(9, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #        builder.ResourceType(17, :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #        builder.VirtualQuantity(disk_data[:size], :xmlns => 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData')
+          #      }
+          #    end
+          #
+          #  }
+          #}
+        end
+
+        def configure_vapp(vapp_uri, vapp_data)
+          validate_vapp_data(vapp_data)
+
+          request(
+            :body     => generate_configure_vapp_request(vapp_uri, vapp_data),
+            :expects  => 202,
+            :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.vApp+xml' },
+            :method   => 'PUT',
+            :uri      => vapp_uri,
+            :parse    => true
+          )
+        end
+
+      end
+
+      class Mock
+        include Shared
+
+        def configure_vapp(vapp_uri, vapp_data)
+          validate_vapp_data(vapp_data)
+
+          if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+            vapp_data.each do |key, value|
+              case key
+              when :cpus, :memory
+                vapp[key] = value
+              when :disks
+                addresses_to_delete = vapp.disks.map {|d| d.address } - value.map {|d| d[:number] }
+                addresses_to_delete.each do |address_to_delete|
+                  vapp.disks.delete(vapp.disks.at_address(address_to_delete))
+                end
+
+                current_addresses = vapp.disks.map {|d| d.address }
+                disks_to_add = value.find_all {|d| !current_addresses.include?(d[:number]) }
+                disks_to_add.each do |disk_to_add|
+                  vapp.disks << MockVirtualMachineDisk.new(:size => disk_to_add[:size] / 1024, :address => disk_to_add[:number])
+                end
+              end
+            end
+
+            mock_it 200, '', { "Location" => mock_data.base_url + "/some_tasks/1234" }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_internet_service.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_internet_service.rb
new file mode 100644
index 0000000..cfee21e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_internet_service.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :delete_internet_service, 200, 'DELETE', {}, ""
+      end
+
+      class Mock
+        def delete_internet_service(service_uri)
+          if public_ip_internet_service = mock_data.public_ip_internet_service_from_href(service_uri)
+            public_ip_internet_service._parent.items.delete(public_ip_internet_service)
+
+            mock_it 200, '', { }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_node.rb
new file mode 100644
index 0000000..05883d4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_node.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :delete_node, 200, 'DELETE', {}, ""
+      end
+
+      class Mock
+
+        def delete_node(node_uri)
+          if node = mock_data.public_ip_internet_service_node_from_href(ensure_unparsed(node_uri))
+            node._parent.items.delete(node)
+            mock_it 200, '', {}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_vapp.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_vapp.rb
new file mode 100644
index 0000000..764c8ca
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/delete_vapp.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :delete_vapp, 202, "DELETE"
+      end
+
+      class Mock
+        def delete_vapp(vapp_uri)
+          if virtual_machine = mock_data.virtual_machine_from_href(vapp_uri)
+            vdc = virtual_machine._parent
+
+            if vdc.internet_service_collection.items.detect {|is| is.node_collection.items.any? {|isn| isn.ip_address == virtual_machine.ip } } ||
+                virtual_machine.status != 2 ||
+                virtual_machine.network_ip.rnat_set?
+              mock_it 202, '', {}
+            else
+              vdc.virtual_machines.delete(virtual_machine)
+              mock_it 202, '', { "Location" => mock_data.base_url + "/some_tasks/1234" }
+            end
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog.rb
new file mode 100644
index 0000000..42662e0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_catalog
+      end
+
+      class Mock
+        def get_catalog(catalog_uri)
+          catalog_uri = ensure_unparsed(catalog_uri)
+          xml = nil
+
+          if catalog = mock_data.catalog_from_href(catalog_uri)
+            builder = Builder::XmlMarkup.new
+
+            xml = builder.Catalog(xmlns.merge(
+                                              :type => "application/vnd.vmware.vcloud.catalog+xml",
+                                              :href => catalog.href,
+                                              :name => catalog.name
+                                  )) do |xml|
+              xml.CatalogItems do |xml|
+                catalog.items.each do |catalog_item|
+                  xml.CatalogItem(
+                                  :type => "application/vnd.vmware.vcloud.catalogItem+xml",
+                                  :href => catalog_item.href,
+                                  :name => catalog_item.name
+                                  )
+                end
+              end
+            end
+          end
+
+          if xml
+            mock_it 200,
+              xml, { 'Content-Type' => 'application/vnd.vmware.vcloud.catalog+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog_item.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog_item.rb
new file mode 100644
index 0000000..6b8fb7d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_catalog_item.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_catalog_item
+      end
+
+      class Mock
+
+        #
+        # Based on
+        # http://support.theenterprisecloud.com/kb/default.asp?id=542&Lang=1&SID=
+        #
+
+        def get_catalog_item(catalog_item_uri)
+          if catalog_item = mock_data.catalog_item_from_href(catalog_item_uri)
+            builder = Builder::XmlMarkup.new
+
+            xml = builder.CatalogItem(xmlns.merge(:href => catalog_item.href, :name => catalog_item.name)) do
+              builder.Link(
+                           :rel => "down",
+                           :href => catalog_item.customization.href,
+                           :type => "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml",
+                           :name => catalog_item.customization.name
+                           )
+
+              builder.Entity(
+                             :href => catalog_item.vapp_template.href,
+                             :type => "application/vnd.vmware.vcloud.vAppTemplate+xml",
+                             :name => catalog_item.vapp_template.name
+                             )
+
+              builder.Property(0, :key => "LicensingCost")
+            end
+          end
+
+          if xml
+            mock_it 200, xml, {'Content-Type' => 'application/vnd.vmware.vcloud.catalogItem+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_customization_options.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_customization_options.rb
new file mode 100644
index 0000000..eb2b4ff
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_customization_options.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_customization_options
+      end
+
+      class Mock
+        def get_customization_options(options_uri)
+          builder = Builder::XmlMarkup.new
+          xml = builder.CustomizationParameters(xmlns) do
+            builder.CustomizeNetwork "true"
+            builder.CustomizePassword "false"
+          end
+
+          mock_it 200, xml, "Content-Type" => "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml"
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acl.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acl.rb
new file mode 100644
index 0000000..d0aa0bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acl.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_firewall_acl
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acls.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acls.rb
new file mode 100644
index 0000000..5668f04
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_firewall_acls.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_firewall_acls
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_internet_services.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_internet_services.rb
new file mode 100644
index 0000000..f751839
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_internet_services.rb
@@ -0,0 +1,82 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_internet_services
+      end
+
+      class Mock
+        #
+        #Based off of:
+        #http://support.theenterprisecloud.com/kb/default.asp?id=580&Lang=1&SID=
+        #http://support.theenterprisecloud.com/kb/default.asp?id=560&Lang=1&SID=
+        #
+        #
+
+        def get_internet_services(internet_services_uri)
+          internet_services_uri = ensure_unparsed(internet_services_uri)
+          xml = nil
+
+          if vdc_internet_service_collection = mock_data.vdc_internet_service_collection_from_href(internet_services_uri)
+            xml = generate_internet_services(vdc_internet_service_collection.items)
+          elsif public_ip_internet_service_collection = mock_data.public_ip_internet_service_collection_from_href(internet_services_uri)
+            xml = generate_internet_services(public_ip_internet_service_collection.items)
+          end
+
+          if xml
+            mock_it 200,
+              xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.internetServicesList+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+        private
+
+        def generate_internet_services(services)
+          builder = Builder::XmlMarkup.new
+
+          builder.InternetServices("xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {|xml|
+            services.each do |service|
+              generate_internet_service(xml, service)
+            end
+          }
+        end
+
+        def generate_internet_service(xml, service, by_itself = false)
+          xml.InternetService(by_itself ? { "xmlns" => "urn:tmrk:eCloudExtensions-2.5", "xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance" } : {}) {
+            xml.Id service.object_id
+            xml.Href service.href
+            xml.Name service.name
+            if MockDataClasses::MockBackupInternetService === service
+              xml.PublicIpAddress "i:nil" => true
+            else
+              xml.PublicIpAddress {
+                xml.Id service._parent._parent.object_id
+                xml.Href service._parent._parent.href
+                xml.Name service._parent._parent.name
+              }
+            end
+            xml.Port service.port
+            xml.Protocol service.protocol
+            xml.Enabled service.enabled
+            xml.Timeout service.timeout
+            xml.Description service.description
+            xml.RedirectURL service.redirect_url
+            xml.Monitor "i:nil" => true
+            xml.IsBackupService MockDataClasses::MockBackupInternetService === service
+            if MockDataClasses::MockPublicIpInternetService === service && service.backup_service
+              xml.BackupService do
+                xml.Href service.backup_service.href
+              end
+            else
+              xml.BackupService "i:nil" => true
+            end
+            xml.BackupOf
+          }
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network.rb
new file mode 100644
index 0000000..0450985
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_network
+      end
+
+      class Mock
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=546&Lang=1&SID=
+        #
+
+        def get_network(network_uri)
+          network_uri = ensure_unparsed(network_uri)
+
+          if network = mock_data.network_from_href(network_uri)
+            builder = Builder::XmlMarkup.new
+            xml = builder.Network(xmlns.merge(:href => network.href, :name => network.name, :type => "application/vnd.vmware.vcloud.network+xml")) {
+              builder.Link(:rel => "down", :href => network.ip_collection.href, :type => "application/xml", :name => network.ip_collection.name)
+              builder.Link(:rel => "down", :href => network.extensions.href, :type => "application/xml", :name => network.name)
+              builder.Configuration {
+                builder.Gateway(network.gateway)
+                builder.Netmask(network.netmask)
+              }
+              if network.features
+                builder.Features {
+                  network.features.each do |feature|
+                    builder.tag!(feature[:type], feature[:value])
+                  end
+                }
+              end
+            }
+
+            mock_it 200, xml, { "Content-Type" => "application/vnd.vmware.vcloud.network+xml" }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_extensions.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_extensions.rb
new file mode 100644
index 0000000..fa50336
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_extensions.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_network_extensions
+      end
+
+      class Mock
+
+        def get_network_extensions(network_extension_uri)
+          if network_extension = mock_data.network_extension_from_href(ensure_unparsed(network_extension_uri))
+            xml = Builder::XmlMarkup.new
+            mock_it 200, xml.Network(ecloud_xmlns) {
+              xml.Address network_extension.address
+              xml.RnatAddress network_extension.rnat
+              xml.Href network_extension.href
+              xml.Id network_extension.object_id
+              xml.Name network_extension.name
+              xml.GatewayAddress network_extension.gateway
+              xml.BroadcastAddress network_extension.broadcast
+              xml.NetworkType network_extension.type
+              xml.Vlan network_extension.vlan
+              xml.FriendlyName network_extension.friendly_name
+            }, { 'Content-Type' => "application/vnd.tmrk.ecloud.network+xml" }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ip.rb
new file mode 100644
index 0000000..8c2f988
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ip.rb
@@ -0,0 +1,43 @@
+#
+# AFAICT this is basically undocumented ATM - 6/18/2010 - freeformz
+#
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_network_ip
+      end
+
+      class Mock
+
+        def get_network_ip(network_ip_uri)
+          if network_ip = mock_data.network_ip_from_href(network_ip_uri)
+            builder = Builder::XmlMarkup.new
+            xml = network_ip_response(builder, network_ip, ecloud_xmlns)
+
+            mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ip+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+        def network_ip_response(builder, network_ip, xmlns = {})
+          builder.IpAddress(xmlns) do
+            builder.Id network_ip.object_id
+            builder.Href network_ip.href
+            builder.Name network_ip.name
+
+            builder.Status network_ip.status
+            if network_ip.used_by
+              builder.Server network_ip.used_by.name
+            end
+
+            builder.RnatAddress(network_ip.rnat)
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ips.rb
new file mode 100644
index 0000000..ed54685
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_network_ips.rb
@@ -0,0 +1,35 @@
+#
+# AFAICT - This is basically undocumented - 6/18/2010 - freeformz
+#
+
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_network_ips
+      end
+
+      class Mock
+
+        def get_network_ips(network_ips_uri)
+          network_ips_uri = ensure_unparsed(network_ips_uri)
+
+          if network_ip_collection = mock_data.network_ip_collection_from_href(network_ips_uri)
+            builder = Builder::XmlMarkup.new
+            xml = builder.IpAddresses do
+              network_ip_collection.ordered_ips.each do |network_ip|
+                network_ip_response(builder, network_ip)
+              end
+            end
+
+            mock_it 200, xml, { 'Content-Type' => 'application/vnd.tmrk.ecloud.ipAddressesList+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_node.rb
new file mode 100644
index 0000000..f1b305d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_node.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_node
+      end
+
+      class Mock
+        #
+        # Based on http://support.theenterprisecloud.com/kb/default.asp?id=641&Lang=1&SID=
+        #
+
+        def mock_node_service_response(node)
+          xml = Builder::XmlMarkup.new
+          xml.NodeService(ecloud_xmlns) {
+            xml.Id(node.object_id)
+            xml.Href(node.href)
+            xml.Name(node.name)
+            xml.IpAddress(node.ip_address)
+            xml.Port(node.port)
+            xml.Enabled(node.enabled)
+            xml.Description(node.description)
+          }
+        end
+
+        def get_node(node_uri)
+          node_uri = ensure_unparsed(node_uri)
+
+          if public_ip_internet_service_node = mock_data.public_ip_internet_service_node_from_href(node_uri)
+            xml = Builder::XmlMarkup.new
+            mock_it 200, mock_node_service_response(public_ip_internet_service_node), { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_nodes.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_nodes.rb
new file mode 100644
index 0000000..31f438b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_nodes.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_nodes
+      end
+
+      class Mock
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=637&Lang=1&SID=
+        #
+
+        def get_nodes(nodes_uri)
+          nodes_uri = ensure_unparsed(nodes_uri)
+
+          if public_ip_internet_service_node_collection = mock_data.public_ip_internet_service_node_collection_from_href(nodes_uri)
+            xml = Builder::XmlMarkup.new
+            mock_it 200,
+              xml.NodeServices(ecloud_xmlns) {
+                public_ip_internet_service_node_collection.items.each do |node|
+                  xml.NodeService {
+                    xml.Id node.object_id
+                    xml.Href node.href
+                    xml.Name node.name
+                    xml.IpAddress node.ip_address
+                    xml.Port node.port
+                    xml.Enabled node.enabled
+                    xml.Description node.description
+                  }
+                end
+              }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.nodeService+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_organization.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_organization.rb
new file mode 100644
index 0000000..78d3057
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_organization.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_organization
+      end
+
+      class Mock
+
+        def get_organization(organization_uri)
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=540&Lang=1&SID=
+          #
+          # vCloud API Guide v0.9 - Page 26
+          #
+          organization_uri = ensure_unparsed(organization_uri)
+          if organization = mock_data.organization_from_href(organization_uri)
+            xml = Builder::XmlMarkup.new
+
+            mock_it 200,
+              xml.Org(xmlns.merge(:href => organization.href, :name => organization.name)) {
+
+                organization.vdcs.each do |vdc|
+                  xml.Link(:rel => "down",
+                           :href => vdc.href,
+                           :type => "application/vnd.vmware.vcloud.vdc+xml",
+                           :name => vdc.name)
+                  xml.Link(:rel => "down",
+                           :href => vdc.catalog.href,
+                           :type => "application/vnd.vmware.vcloud.catalog+xml",
+                           :name => vdc.catalog.name)
+                  xml.Link(:rel => "down",
+                           :href => vdc.task_list.href,
+                           :type => "application/vnd.vmware.vcloud.tasksList+xml",
+                           :name => vdc.task_list.name)
+                end
+              },
+              {'Content-Type' => "application/vnd.vmware.vcloud.org+xml" }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ip.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ip.rb
new file mode 100644
index 0000000..9d858b3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ip.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_public_ip
+      end
+
+      class Mock
+        #
+        #Based off of:
+        #http://support.theenterprisecloud.com/kb/default.asp?id=567&Lang=1&SID=
+        #
+
+        def get_public_ip(public_ip_uri)
+          public_ip_uri = ensure_unparsed(public_ip_uri)
+
+          if public_ip = mock_data.public_ip_from_href(public_ip_uri)
+            xml = Builder::XmlMarkup.new
+            mock_it 200,
+              xml.PublicIp(:xmlns => "urn:tmrk:eCloudExtensions-2.0", :"xmlns:i" => "http://www.w3.org/2001/XMLSchema-instance") {
+                xml.Id public_ip.object_id
+                xml.Href public_ip.href
+                xml.Name public_ip.name
+              }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIp+xml' }
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ips.rb
new file mode 100644
index 0000000..fef50b5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_public_ips.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_public_ips
+      end
+
+      class Mock
+        #
+        # Based off of:
+        # http://support.theenterprisecloud.com/kb/default.asp?id=577&Lang=1&SID=
+        #
+
+        def get_public_ips(public_ips_uri)
+          public_ips_uri = ensure_unparsed(public_ips_uri)
+
+          if public_ip_collection = mock_data.public_ip_collection_from_href(public_ips_uri)
+            xml = Builder::XmlMarkup.new
+            mock_it 200,
+              xml.PublicIPAddresses {
+                public_ip_collection.items.each do |ip|
+                  xml.PublicIPAddress {
+                    xml.Id ip.object_id
+                    xml.Href ip.href
+                    xml.Name ip.name
+                  }
+                end
+              }, { 'Content-Type' => 'application/vnd.tmrk.ecloud.publicIpsList+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task.rb
new file mode 100644
index 0000000..652ec02
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_task
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task_list.rb
new file mode 100644
index 0000000..685dce0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_task_list.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_task_list
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp.rb
new file mode 100644
index 0000000..d595f12
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp.rb
@@ -0,0 +1,99 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_vapp
+      end
+
+      class Mock
+        def return_vapp_as_creating!(name)
+          vapps_to_return_as_creating[name] = true
+        end
+
+        def vapps_to_return_as_creating
+          @vapps_to_return_as_creating ||= {}
+        end
+
+        def get_vapp(vapp_uri)
+          xml = nil
+
+          if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+            if vapps_to_return_as_creating[vapp.name]
+              xml = generate_instantiate_vapp_template_response(vapp)
+            else
+              xml = generate_get_vapp_response(vapp)
+            end
+          end
+
+          if xml
+            mock_it 200, xml, "Content-Type" => "application/vnd.vmware.vcloud.vApp+xml"
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+        private
+
+        def generate_get_vapp_response(vapp)
+          builder = Builder::XmlMarkup.new
+          builder.VApp(xmlns.merge(
+                                   :href => vapp.href,
+                                   :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                   :name => vapp.name,
+                                   :status => vapp.status,
+                                   :size => vapp.size
+                                   )) do
+            builder.Link(:rel => "up", :href => vapp._parent.href, :type => "application/vnd.vmware.vcloud.vdc+xml")
+
+            builder.NetworkConnectionSection(:xmlns => "http://schemas.dmtf.org/ovf/envelope/1") do
+              builder.NetworkConnection(:Network => "Internal", :xmlns => "http://www.vmware.com/vcloud/v0.8") do
+                builder.IpAddress vapp.ip
+              end
+            end
+
+            builder.OperatingSystemSection(
+                                           "d2p1:id" => 4,
+                                           :xmlns => "http://schemas.dmtf.org/ovf/envelope/1",
+                                           "xmlns:d2p1" => "http://schemas.dmtf.org/ovf/envelope/1") do
+              builder.Info "The kind of installed guest operating system"
+              builder.Description "Red Hat Enterprise Linux 5 (64-bit)"
+            end
+
+            builder.VirtualHardwareSection(:xmlns => "http://schemas.dmtf.org/ovf/envelope/1") do
+              builder.Info
+              builder.System
+              builder.Item do
+                # CPUs
+                builder.VirtualQuantity vapp.cpus
+                builder.ResourceType 3
+              end
+              builder.Item do
+                # memory
+                builder.VirtualQuantity vapp.memory
+                builder.ResourceType 4
+              end
+              builder.Item do
+                # SCSI controller
+                builder.Address 0
+                builder.ResourceType 6
+                builder.InstanceId 3
+              end
+
+              # Hard Disks
+              vapp.disks.each do |disk|
+                builder.Item do
+                  builder.Parent 3
+                  builder.VirtualQuantity disk.vcloud_size
+                  builder.HostResource disk.vcloud_size
+                  builder.ResourceType 17
+                  builder.AddressOnParent disk.address
+                end
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp_template.rb
new file mode 100644
index 0000000..0574bb8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vapp_template.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_vapp_template
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vdc.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vdc.rb
new file mode 100644
index 0000000..cf10ade
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_vdc.rb
@@ -0,0 +1,84 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :get_vdc
+      end
+
+      class Mock
+        #
+        #Based off of:
+        #http://support.theenterprisecloud.com/kb/default.asp?id=545&Lang=1&SID=
+
+        def get_vdc(vdc_uri)
+          vdc_uri = ensure_unparsed(vdc_uri)
+
+          if vdc = mock_data.vdc_from_href(vdc_uri)
+            xml = Builder::XmlMarkup.new
+            mock_it 200,
+            xml.Vdc(xmlns.merge(:href => vdc.href, :name => vdc.name)) {
+              xml.Link(:rel => "down",
+                       :href => vdc.catalog.href,
+                       :type => "application/vnd.vmware.vcloud.catalog+xml",
+                       :name => vdc.catalog.name)
+              xml.Link(:rel => "down",
+                       :href => vdc.public_ip_collection.href,
+                       :type => "application/vnd.tmrk.ecloud.publicIpsList+xml",
+                       :name => vdc.public_ip_collection.name)
+              xml.Link(:rel => "down",
+                       :href => vdc.internet_service_collection.href,
+                       :type => "application/vnd.tmrk.ecloud.internetServicesList+xml",
+                       :name => vdc.internet_service_collection.name)
+              xml.Link(:rel => "down",
+                       :href => vdc.firewall_acls.href,
+                       :type => "application/vnd.tmrk.ecloud.firewallAclsList+xml",
+                       :name => vdc.firewall_acls.name)
+              xml.Description("")
+              xml.StorageCapacity {
+                xml.Units("bytes * 10^9")
+                xml.Allocated(vdc.storage_allocated)
+                xml.Used(vdc.storage_used)
+              }
+              xml.ComputeCapacity {
+                xml.Cpu {
+                  xml.Units("hz * 10^6")
+                  xml.Allocated(vdc.cpu_allocated)
+                }
+                xml.Memory {
+                  xml.Units("bytes * 2^20")
+                  xml.Allocated(vdc.memory_allocated)
+                }
+                xml.DeployedVmsQuota {
+                  xml.Limit("-1")
+                  xml.Used("-1")
+                }
+                xml.InstantiatedVmsQuota {
+                  xml.Limit("-1")
+                  xml.Used("-1")
+                }
+              }
+              xml.ResourceEntities {
+                vdc.virtual_machines.each do |virtual_machine|
+                  xml.ResourceEntity(:href => virtual_machine.href,
+                                     :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                     :name => virtual_machine.name)
+                end
+              }
+              xml.AvailableNetworks {
+                vdc.networks.each do |network|
+                  xml.Network(:href => network.href,
+                              :type => "application/vnd.vmware.vcloud.network+xml",
+                              :name => network.name)
+                end
+              }
+            }, { 'Content-Type' => 'application/vnd.vmware.vcloud.vdc+xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_versions.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_versions.rb
new file mode 100644
index 0000000..f643ff6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/get_versions.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        unauthenticated_basic_request :get_versions
+      end
+
+      class Mock
+
+        def get_versions(versions_uri)
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=535&Lang=1&SID=
+          # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/02-get-versions.aspx
+          # vCloud API Guide v0.9 - Page 89
+          #
+          xml = Builder::XmlMarkup.new
+
+          mock_it 200,
+            xml.SupportedVersions( xmlns.merge("xmlns" => "http://www.vmware.com/vcloud/versions")) {
+
+              mock_data.versions.select {|version| version.supported }.each do |version|
+                xml.VersionInfo {
+                  xml.Version(version.version)
+                  xml.LoginUrl(version.login_url)
+                }
+              end
+            }
+
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/instantiate_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/instantiate_vapp_template.rb
new file mode 100644
index 0000000..170d9e0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/instantiate_vapp_template.rb
@@ -0,0 +1,142 @@
+module Fog
+  module Ecloud
+    class Compute
+      module Shared
+        private
+
+        def validate_instantiate_vapp_template_options(catalog_item_uri, options)
+          valid_opts = [:name, :vdc_uri, :network_uri, :cpus, :memory, :row, :group]
+          unless valid_opts.all? { |opt| options.keys.include?(opt) }
+            raise ArgumentError.new("Required data missing: #{(valid_opts - options.keys).map(&:inspect).join(", ")}")
+          end
+
+          # Figure out the template_uri
+          catalog_item = get_catalog_item( catalog_item_uri ).body
+          catalog_item[:Entity] = [ catalog_item[:Entity] ] if catalog_item[:Entity].is_a?(Hash)
+          catalog_item[:Link] = [ catalog_item[:Link] ] if catalog_item[:Link].is_a?(Hash)
+
+          options[:template_uri] = begin
+             catalog_item[:Entity].detect { |entity| entity[:type] == "application/vnd.vmware.vcloud.vAppTemplate+xml" }[:href]
+          rescue
+            raise RuntimeError.new("Unable to locate template uri for #{catalog_item_uri}")
+          end
+
+          customization_options = begin
+              customization_href = catalog_item[:Link].detect { |link| link[:type] == "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml" }[:href]
+              get_customization_options( customization_href ).body
+          rescue
+            raise RuntimeError.new("Unable to get customization options for #{catalog_item_uri}")
+          end
+
+          # Check to see if we can set the password
+          if options[:password] and customization_options[:CustomizePassword] == "false"
+            raise ArgumentError.new("This catalog item (#{catalog_item_uri}) does not allow setting a password.")
+          end
+
+          # According to the docs if CustomizePassword is "true" then we NEED to set a password
+          if customization_options[:CustomizePassword] == "true" and ( options[:password].nil? or options[:password].empty? )
+            raise ArgumentError.new("This catalog item (#{catalog_item_uri}) requires a :password to instantiate.")
+          end
+        end
+
+        def generate_instantiate_vapp_template_request(options)
+          xml = Builder::XmlMarkup.new
+          xml.InstantiateVAppTemplateParams(xmlns.merge!(:name => options[:name], :"xml:lang" => "en")) {
+            xml.VAppTemplate(:href => options[:template_uri])
+            xml.InstantiationParams {
+              xml.ProductSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8", :"xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1") {
+                if options[:password]
+                  xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "password", :"ovf:value" => options[:password] )
+                end
+                xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "row", :"ovf:value" => options[:row] )
+                xml.Property( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1", :"ovf:key" => "group", :"ovf:value" => options[:group] )
+              }
+              xml.VirtualHardwareSection( :"xmlns:q1" => "http://www.vmware.com/vcloud/v0.8" ) {
+                # # of CPUS
+                xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                  xml.InstanceID(1, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  xml.ResourceType(3, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  xml.VirtualQuantity(options[:cpus], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                }
+                # Memory
+                xml.Item( :xmlns => "http://schemas.dmtf.org/ovf/envelope/1" ) {
+                  xml.InstanceID(2, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  xml.ResourceType(4, :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                  xml.VirtualQuantity(options[:memory], :xmlns => "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData")
+                }
+              }
+              xml.NetworkConfigSection {
+                xml.NetworkConfig {
+                  xml.NetworkAssociation( :href => options[:network_uri] )
+                }
+              }
+            }
+          }
+        end
+      end
+
+      class Real
+        include Shared
+
+        def instantiate_vapp_template(catalog_item_uri, options = {})
+          validate_instantiate_vapp_template_options(catalog_item_uri, options)
+
+          request(
+            :body     => generate_instantiate_vapp_template_request(options),
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml'},
+            :method   => 'POST',
+            :uri      => options[:vdc_uri] + '/action/instantiatevAppTemplate',
+            :parse    => true
+          )
+        end
+      end
+
+      class Mock
+        include Shared
+
+        #
+        # Based on
+        # http://support.theenterprisecloud.com/kb/default.asp?id=554&Lang=1&SID=
+        #
+
+        def instantiate_vapp_template(catalog_item_uri, options = {})
+          validate_instantiate_vapp_template_options(catalog_item_uri, options)
+          catalog_item = mock_data.catalog_item_from_href(catalog_item_uri)
+
+          xml = nil
+          if vdc = mock_data.vdc_from_href(options[:vdc_uri])
+            if network = mock_data.network_from_href(options[:network_uri])
+              new_vm = MockVirtualMachine.new({ :name => options[:name], :ip => network.random_ip, :cpus => options[:cpus], :memory => options[:memory] }, vdc)
+              new_vm.disks.push(*catalog_item.disks.dup)
+              vdc.virtual_machines << new_vm
+
+              xml = generate_instantiate_vapp_template_response(new_vm)
+            end
+          end
+
+          if xml
+            mock_it 200, xml, {'Content-Type' => 'application/xml'}
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+
+        private
+
+        def generate_instantiate_vapp_template_response(vapp)
+          builder = Builder::XmlMarkup.new
+          builder.VApp(xmlns.merge(
+                                   :href => vapp.href,
+                                   :type => "application/vnd.vmware.vcloud.vApp+xml",
+                                   :name => vapp.name,
+                                   :status => 0,
+                                   :size => 4
+                                   )) {
+            builder.Link(:rel => "up", :href => vapp._parent.href, :type => "application/vnd.vmware.vcloud.vdc+xml")
+          }
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/login.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/login.rb
new file mode 100644
index 0000000..be67aab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/login.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+
+
+        def login
+          unauthenticated_request({
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => authorization_header
+            },
+            :method   => 'POST',
+            :parse    => true,
+            :uri      => login_uri
+          })
+        end
+
+      end
+
+      class Mock
+
+        def login
+          #
+          # Based off of:
+          # http://support.theenterprisecloud.com/kb/default.asp?id=536&Lang=1&SID=
+          # https://community.vcloudexpress.terremark.com/en-us/product_docs/w/wiki/01-get-login-token.aspx
+          # vCloud API Guide v0.9 - Page 17
+          #
+          xml = Builder::XmlMarkup.new
+
+          mock_it 200,
+            xml.OrgList(xmlns) {
+                mock_data.organizations.each do |organization|
+                  xml.Org( :type => "application/vnd.vmware.vcloud.org+xml", :href => organization.href, :name => organization.name )
+                end
+              },
+              { 'Set-Cookie' => 'vcloud-token=fc020a05-21d7-4f33-9b2a-25d8cd05a44e; path=/',
+                'Content-Type' => 'application/vnd.vmware.vcloud.orgslist+xml' }
+
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_off.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_off.rb
new file mode 100644
index 0000000..514ef58
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_off.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :power_off, 202, 'POST'
+      end
+
+      class Mock
+        def power_off(vapp_uri)
+          if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+            vapp.power_off!
+
+            builder = Builder::XmlMarkup.new
+            mock_it 200, builder.Task(xmlns)
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_on.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_on.rb
new file mode 100644
index 0000000..2f1393a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_on.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :power_on, 202, 'POST'
+      end
+
+      class Mock
+        def power_on(vapp_uri)
+          if vapp = mock_data.virtual_machine_from_href(vapp_uri)
+            vapp.power_on!
+
+            builder = Builder::XmlMarkup.new
+            mock_it 200, builder.Task(xmlns)
+          else
+            mock_error 200, "401 Unauthorized"
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_reset.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_reset.rb
new file mode 100644
index 0000000..9426edb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_reset.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :power_reset, 202, 'POST'
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_shutdown.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_shutdown.rb
new file mode 100644
index 0000000..91e79df
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/ecloud/power_shutdown.rb
@@ -0,0 +1,11 @@
+module Fog
+  module Ecloud
+    class Compute
+
+      class Real
+        basic_request :power_shutdown, 204, 'POST'
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/common_lookup_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/common_lookup_list.rb
new file mode 100644
index 0000000..c9461db
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/common_lookup_list.rb
@@ -0,0 +1,28 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List options and lookups
+        #
+        # ==== Parameters
+        # * 'lookup'<~String> - the lookup to be listed
+        # * options<~Hash>:
+        #   * 'sort'<~String> - column to sort result by in ['description', 'id', 'name']
+        #   * 'asc'<~String>  - order to sort in ['true','false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def common_lookup_list(lookup, options={})
+          request(
+            :path     => 'common/lookup/list',
+            :query    => {'lookup' => lookup}.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_get.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_get.rb
new file mode 100644
index 0000000..ff2839c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_get.rb
@@ -0,0 +1,41 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'id'<~String>         - ID of the image
+        #   * 'name'<~String>       - Name of the image
+        #   * 'image'<~String>      - ID(s) or Name(s) of the images to retrive. Can be speicifed multiple times
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_image_get(options={})
+          request(
+            :path     => 'grid/image/get',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_image_get(options={})
+          #response = Excon::Response.new
+
+          #images = self.data[:list].values
+          #for image in images
+          #  case image['state']
+          #  when 'Available'
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_list.rb
new file mode 100644
index 0000000..de65ac1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_image_list.rb
@@ -0,0 +1,44 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isPublic'<~String>   - If true only returns public images, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #   * 'state'<~String>      - state to limit results to, in ['Saving', 'Available']
+        #   * 'type'<~String>       - image type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_image_list(options={})
+          request(
+            :path     => 'grid/image/list',
+            :query    => options
+          )
+        end
+
+      end
+
+      class Mock
+
+        def grid_image_list(options={})
+          #response = Excon::Response.new
+
+          #images = self.data[:list].values
+          #for image in images
+          #  case image['state']
+          #  when 'Available'
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_ip_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_ip_list.rb
new file mode 100644
index 0000000..9b21777
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_ip_list.rb
@@ -0,0 +1,30 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List ips
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'ip.state'<~String>      - state to limit results to in ip.state
+        #   * 'ip.type'<~String>       - type to limit results to in ip.type
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer>      - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_ip_list(options={})
+          request(
+            :path     => 'grid/ip/list',
+            :query    => options
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_loadbalancer_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_loadbalancer_list.rb
new file mode 100644
index 0000000..cf79158
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_loadbalancer_list.rb
@@ -0,0 +1,28 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List load balancers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_loadbalancer_list(options={})
+          request(
+            :path     => 'grid/loadbalancer/list',
+            :query    => options
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_add.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_add.rb
new file mode 100644
index 0000000..381e0c5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_add.rb
@@ -0,0 +1,36 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * 'name'<~String>   - name of the server, 20 or fewer characters
+        # * 'image'<~String>  - image to use, in grid_image_list
+        # * 'ip'<~String> - initial public ip for this server
+        # * 'options'<~Hash>:
+        #   * 'server.ram'<~String> - flavor to use, in common_lookup_list('server.ram')
+        #   * 'description'<~String>  - description of this server
+        #   * 'isSandbox'<~String>    - treat this server as image sandbox? in ['true', 'false']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_add(image, ip, name, server_ram, options={})
+          request(
+            :path     => 'grid/server/add',
+            :query    => {
+              'image'       => image,
+              'ip'          => ip,
+              'name'        => name,
+              'server.ram'  => server_ram
+            }.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_delete.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_delete.rb
new file mode 100644
index 0000000..9bf8033
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_delete.rb
@@ -0,0 +1,25 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Delete a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_delete(server)
+          request(
+            :path     => 'grid/server/delete',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_get.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_get.rb
new file mode 100644
index 0000000..a1c1a9c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_get.rb
@@ -0,0 +1,25 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Get one or more servers by name
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server(s) to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_get(servers)
+          request(
+            :path     => 'grid/server/get',
+            :query    => {'server' => [*servers]}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_list.rb
new file mode 100644
index 0000000..3b4d010
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_list.rb
@@ -0,0 +1,30 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isSandbox'<~String> - If true only  returns Image Sandbox servers, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #   * 'server.type'<~String> - server type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_list(options={})
+          request(
+            :path     => 'grid/server/list',
+            :query    => options
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_power.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_power.rb
new file mode 100644
index 0000000..4dcff19
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/grid_server_power.rb
@@ -0,0 +1,26 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Start, Stop or Restart a server
+        #
+        # ==== Parameters
+        # * 'server'<~String> - id or name of server to power
+        # * 'power'<~String>  - power operation, in ['restart', 'start', 'stop']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def grid_server_power(server, power)
+          request(
+            :path     => 'grid/server/power',
+            :query    => {'server' => server}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_get.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_get.rb
new file mode 100644
index 0000000..0b8f733
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_get.rb
@@ -0,0 +1,28 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # Get one or more passwords by id
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'id'<~String> - id of the password to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def support_password_get(id, options={})
+          request(
+            :path     => 'support/password/get',
+            :query    => {
+              'id'    => id
+            }.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_list.rb
new file mode 100644
index 0000000..3e67b16
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/go_grid/support_password_list.rb
@@ -0,0 +1,30 @@
+module Fog
+  module GoGrid
+    class Compute
+      class Real
+
+        # List passwords
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'datacenter'<~String> - datacenter to limit results to
+        #   * 'isSandbox'<~String> - If true only  returns Image Sandbox servers, in ['false', 'true']
+        #   * 'num_items'<~Integer> - Number of items to return
+        #   * 'page'<~Integer> - Page index for paginated results
+        #   * 'server.type'<~String> - server type to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def support_password_list(options={})
+          request(
+            :path     => 'support/password/list',
+            :query    => options
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_datacenters.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_datacenters.rb
new file mode 100644
index 0000000..5684a3f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_datacenters.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        
+        # Get available data centers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_datacenters
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.datacenters' }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_distributions.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_distributions.rb
new file mode 100644
index 0000000..89b76e7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_distributions.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available distributions
+        #
+        # ==== Parameters
+        # * distributionId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs        
+        def avail_distributions(distribution_id=nil)
+          options = {}
+          if distribution_id
+            options.merge!(:distributionId => distribution_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.distributions' }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_kernels.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_kernels.rb
new file mode 100644
index 0000000..9a14c97
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_kernels.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available kernels
+        #
+        # ==== Parameters
+        # * kernelId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def avail_kernels(kernel_id=nil)
+          options = {}
+          if kernel_id
+            options.merge!(:kernelId => kernel_id)
+          end          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.kernels' }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_linodeplans.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_linodeplans.rb
new file mode 100644
index 0000000..5c7247b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_linodeplans.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available plans
+        #
+        # ==== Parameters
+        # * linodeplanId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs        
+        def avail_linodeplans(linodeplan_id = nil)
+          options = {}
+          if linodeplan_id
+            options.merge!(:planId => linodeplan_id)
+          end
+          result = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.linodeplans' }.merge!(options)
+          )
+          
+          #hack for plans not filtering by id like they should above, remove when they fix it.
+          result.body["DATA"] = result.body["DATA"].select { |item| item['PLANID'] == linodeplan_id } if linodeplan_id
+          result
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_stackscripts.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_stackscripts.rb
new file mode 100644
index 0000000..34e5dcb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/avail_stackscripts.rb
@@ -0,0 +1,17 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def avail_stackscripts(options={})
+          result = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'avail.stackscripts' }.merge!(options)
+          )
+          result.body['DATA'].each { |r| r['DISTRIBUTIONIDLIST'] = r['DISTRIBUTIONIDLIST'].to_s }
+          result
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_boot.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_boot.rb
new file mode 100644
index 0000000..0531d7a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_boot.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_boot(linode_id, config_id)
+          request(
+            :expects => 200,
+            :method => 'GET',
+            :query => { :api_action => 'linode.boot', :linodeId => linode_id, :configId => config_id }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_create.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_create.rb
new file mode 100644
index 0000000..161b910
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_create.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_config_create(linode_id, kernel_id, name, disk_list)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action => 'linode.config.create',
+              :linodeId => linode_id,
+              :kernelId => kernel_id,
+              :label => name,
+              :diskList => disk_list
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_list.rb
new file mode 100644
index 0000000..920505a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_config_list.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_config_list(linode_id, config_id=nil, options={})
+          if config_id
+            options.merge!(:configid => config_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.config.list', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_create.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_create.rb
new file mode 100644
index 0000000..bd354c2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_create.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Creates a linode and assigns you full privileges
+        #
+        # ==== Parameters 	
+        # * datacenter_id<~Integer>: id of datacenter to place new linode in
+        # * plan_id<~Integer>: id of plan to boot new linode with        
+        # * payment_term<~Integer>: Subscription term in months, in [1, 12, 24]
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_create(datacenter_id, plan_id, payment_term)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'linode.create',
+              :datacenterId => datacenter_id,
+              :paymentTerm  => payment_term,
+              :planId       => plan_id
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_delete.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_delete.rb
new file mode 100644
index 0000000..a34182a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_delete.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to delete
+        # * options<~Hash>:
+        #   * skipChecks<~Boolean>: skips safety checks and always deletes
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_delete(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.delete', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_create.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_create.rb
new file mode 100644
index 0000000..33e9d3a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_create.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_disk_create(linode_id, name, type, size)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action => 'linode.disk.create',
+              :linodeId => linode_id,
+              :label => name,
+              :type => type,
+              :size => size
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromdistribution.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromdistribution.rb
new file mode 100644
index 0000000..5495747
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromdistribution.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_disk_createfromdistribution(linode_id, distro_id, name, size, password)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action => 'linode.disk.createfromdistribution',
+              :linodeId => linode_id,
+              :distributionId => distro_id,
+              :label => name,
+              :size => size,
+              :rootPass => password
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromstackscript.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromstackscript.rb
new file mode 100644
index 0000000..1f6637c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_createfromstackscript.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_disk_createfromstackscript(linode_id, script_id, distro_id, name, size, password, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action => 'linode.disk.createfromstackscript',
+              :linodeId => linode_id,
+              :stackScriptID => script_id,
+              :distributionId => distro_id,
+              :label => name,
+              :size => size,
+              :rootPass => password,
+              :stackScriptUDFResponses => options.to_json
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_delete.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_delete.rb
new file mode 100644
index 0000000..74c35d1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_delete.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_disk_delete(linode_id, disk_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action => 'linode.disk.delete',
+              :linodeId => linode_id,
+              :diskId => disk_id
+            }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_list.rb
new file mode 100644
index 0000000..53638ab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_disk_list.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_disk_list(linode_id, disk_id=nil)
+          options = {}
+          if disk_id
+            options.merge!(:diskId => disk_id)
+          end          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.disk.list', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_addprivate.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_addprivate.rb
new file mode 100644
index 0000000..e89cfe2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_addprivate.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_ip_addprivate(linode_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.ip.addprivate', :linodeId => linode_id }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_list.rb
new file mode 100644
index 0000000..3a054c3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_ip_list.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_ip_list(linode_id, ip_id=nil)
+          options = {}
+          if ip_id
+            options.merge!(:ipaddressId => ip_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.ip.list', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_list.rb
new file mode 100644
index 0000000..97e2139
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_list.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # List all linodes user has access or delete to
+        #
+        # ==== Parameters
+        # * linodeId<~Integer>: Limit the list to the specified LinodeID
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs
+        def linode_list(linode_id=nil)
+          options = {}
+          if linode_id
+            options.merge!(:linodeId => linode_id)
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.list' }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_reboot.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_reboot.rb
new file mode 100644
index 0000000..8e50b15
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_reboot.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Issues a shutdown, and then a boot job for a given linode
+        #
+        # ==== Parameters
+        # * linode_id<~Integer>: id of linode to reboot
+        # * options<~Hash>:
+        #   * configId<~Boolean>: id of config to boot server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs        
+        def linode_reboot(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.reboot', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_shutdown.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_shutdown.rb
new file mode 100644
index 0000000..6929055
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_shutdown.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_shutdown(linode_id)
+          request(
+            :expects => 200,
+            :method => 'GET',
+            :query => { :api_action => 'linode.shutdown', :linodeId => linode_id }
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_update.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_update.rb
new file mode 100644
index 0000000..adedc54
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/linode_update.rb
@@ -0,0 +1,15 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+        def linode_update(linode_id, options={})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'linode.update', :linodeId => linode_id }.merge!(options)
+          )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/linode/stackscript_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/stackscript_list.rb
new file mode 100644
index 0000000..cdf44ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/linode/stackscript_list.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Linode
+    class Compute
+      class Real
+
+        # Get available stack scripts
+        #
+        # ==== Parameters
+        # * scriptId<~Integer>: id to limit results to
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        # TODO: docs        
+        def stackscript_list(script_id=nil)
+          options = {}
+          if script_id
+            options.merge!(:stackScriptID => script_id)
+          end          
+          result = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'stackscript.list' }.merge!(options)
+          )
+          result.body['DATA'].each { |r| r['DISTRIBUTIONIDLIST'] = r['DISTRIBUTIONIDLIST'].to_s }
+          result
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/add_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/add_server.rb
new file mode 100644
index 0000000..1a3a10f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/add_server.rb
@@ -0,0 +1,33 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Boot a new server
+        #
+        # ==== Parameters
+        # * planId<~String> - The id of the plan to boot the server with
+        # * options<~Hash>: optional extra arguments
+        #   * imageId<~String>  - Optional image to boot server from
+        #   * name<~String>     - Name to boot new server with
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def add_server(plan_id, options = {})
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/addServer',
+            :query    => {'planId' => plan_id}.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/cancel_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/cancel_server.rb
new file mode 100644
index 0000000..75eb153
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/cancel_server.rb
@@ -0,0 +1,30 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Shutdown a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to shutdown
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'server'<~Hash>:
+        #       * 'id'<~String> - Id of the image
+        #
+        def cancel_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/cancelServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/get_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/get_server.rb
new file mode 100644
index 0000000..4db0aef
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/get_server.rb
@@ -0,0 +1,36 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * server<~Hash>:
+        #     * 'id'<~String>     - Id of the server
+        #     * 'ip'<~Hash>:
+        #       * 'address'<~String>  - Address of the ip
+        #       * 'name'<~String>     - Name of the ip
+        #     * 'login'<~Hash>:
+        #       * 'name'<~String>     - Name of the login
+        #       * 'password'<~String> - Password of the login
+        #       * 'username'<~String> - Username of the login
+        #     * 'name'<~String>   - Name of the server
+        #     * 'notes'<~String>  - Notes about the server
+        #     * 'state'<~String>  - State of the server
+        #
+        def get_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/getServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_images.rb
new file mode 100644
index 0000000..7b487b0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_images.rb
@@ -0,0 +1,27 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~String>  - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'size'<~String> - Size of the image
+        #
+        def list_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listImages'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_plans.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_plans.rb
new file mode 100644
index 0000000..fcbb52e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_plans.rb
@@ -0,0 +1,30 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List available plans
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of the plan
+        #     * 'id'<~String>     - Id of the plan
+        #     * 'name'<~String>   - Name of the plan
+        #     * 'rate'<~String>   - Cost per hour of the plan
+        #     * 'os'<~String>     - Operating system of the plan
+        #     * 'config'<~String> - Configuration of the plan
+        #
+        def list_plans
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listPlans'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_servers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_servers.rb
new file mode 100644
index 0000000..1a78144
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/list_servers.rb
@@ -0,0 +1,36 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # List servers
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * server<~Hash>:
+        #       * 'id'<~String>     - Id of the server
+        #       * 'ip'<~Hash>:
+        #         * 'address'<~String>  - Address of the ip
+        #         * 'name'<~String>     - Name of the ip
+        #       * 'login'<~Hash>:
+        #         * 'name'<~String>     - Name of the login
+        #         * 'password'<~String> - Password of the login
+        #         * 'username'<~String> - Username of the login
+        #       * 'name'<~String>   - Name of the server
+        #       * 'notes'<~String>  - Notes about the server
+        #       * 'state'<~String>  - State of the server
+        #
+        def list_servers
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/listServers'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/reboot_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/reboot_server.rb
new file mode 100644
index 0000000..4fe8460
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/new_servers/reboot_server.rb
@@ -0,0 +1,24 @@
+module Fog
+  module NewServers
+    class Compute
+      class Real
+
+        # Reboot a running server
+        #
+        # ==== Parameters
+        # * serverId<~String> - The id of the server to reboot
+        #
+        def reboot_server(server_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::ToHashDocument.new,
+            :path     => 'api/rebootServer',
+            :query    => {'serverId' => server_id}
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/confirm_resized_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/confirm_resized_server.rb
new file mode 100644
index 0000000..a3faadd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/confirm_resized_server.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Confirm resizing
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to confirm
+        #
+        def confirm_resized_server(server_id)
+          body = { 'confirmResize' => nil }
+          server_action(server_id, body, 204)
+        end
+
+      end
+
+      class Mock
+
+        def confirm_resized_server(server_id)
+          response = Excon::Response.new
+          response.status = 204
+
+          self.data[:servers][server_id].delete('old_flavorId')
+          self.data[:last_modified][:servers][server_id] = Time.now
+          self.data[:servers][server_id]['status'] = 'ACTIVE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_image.rb
new file mode 100644
index 0000000..4c2e118
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_image.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create an image from a running server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to create image from
+        # * options<~Hash> - Name
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'image'<~Hash>:
+        #     * 'id'<~Integer> - Id of image
+        #     * 'name'<~String> - Name of image
+        #     * 'serverId'<~Integer> - Id of server
+        def create_image(server_id, options = {})
+          data = {
+            'image' => {
+              'serverId' => server_id
+            }
+          }
+          if options['name']
+            data['image']['name'] = options['name']
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => "images"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_image(server_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          now = Time.now
+          data = {
+            'created'   => now,
+            'id'        => Fog::Mock.random_numbers(6).to_i,
+            'name'      => options['name'] || '',
+            'serverId'  => server_id,
+            'status'    => 'SAVING',
+            'updated'   => now.to_s,
+          }
+
+          self.data[:last_modified][:images][data['id']] = now
+          self.data[:images][data['id']] = data
+          response.body = { 'image' => data.reject {|key, value| !['id', 'name', 'serverId', 'status', 'updated'].include?(key)} }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_server.rb
new file mode 100644
index 0000000..42eb3b9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/create_server.rb
@@ -0,0 +1,94 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Create a new server
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor for server
+        # * image_id<~Integer> - Id of image for server
+        # * name<~String> - Name of server
+        # * options<~Hash>:
+        #   * 'metadata'<~Hash> - Up to 5 key value pairs containing 255 bytes of info
+        #   * 'name'<~String> - Name of server, defaults to "slice#{id}"
+        #   * 'personality'<~Array>: Up to 5 files to customize server
+        #     * file<~Hash>:
+        #       * 'contents'<~String> - Contents of file (10kb total of contents)
+        #       * 'path'<~String> - Path to file (255 bytes total of path strings)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'adminPass'<~String> - Admin password for server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def create_server(flavor_id, image_id, options = {})
+          data = {
+            'server' => {
+              'flavorId'  => flavor_id,
+              'imageId'   => image_id
+            }
+          }
+          if options['metadata']
+            data['server']['metadata'] = options['metadata']
+          end
+          if options['name']
+            data['server']['name'] = options['name']
+          end
+          if options['personality']
+            data['server']['personality'] = []
+            for file in options['personality']
+              data['server']['personality'] << {
+                'contents'  => Base64.encode64(file['contents']),
+                'path'      => file['path']
+              }
+            end
+          end
+          request(
+            :body     => data.to_json,
+            :expects  => 202,
+            :method   => 'POST',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_server(flavor_id, image_id, options = {})
+          response = Excon::Response.new
+          response.status = 202
+
+          data = {
+            'addresses' => { 'private' => ['0.0.0.0'], 'public' => ['0.0.0.0'] },
+            'flavorId'  => flavor_id,
+            'id'        => Fog::Mock.random_numbers(6).to_i,
+            'imageId'   => image_id,
+            'hostId'    => "123456789ABCDEF01234567890ABCDEF",
+            'metadata'  => options['metadata'] || {},
+            'name'      => options['name'] || "server_#{rand(999)}",
+            'progress'  => 0,
+            'status'    => 'BUILD'
+          }
+          self.data[:last_modified][:servers][data['id']] = Time.now
+          self.data[:servers][data['id']] = data
+          response.body = { 'server' => data.merge({'adminPass' => 'password'}) }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_image.rb
new file mode 100644
index 0000000..7c2273b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_image.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to delete
+        #
+        def delete_image(image_id)
+          request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "images/#{image_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_image(image_id)
+          response = Excon::Response.new
+          if image = list_images_detail.body['images'].detect {|_| _['id'] == image_id}
+            if image['status'] == 'SAVING'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              self.data[:last_modified][:images].delete(image_id)
+              self.data[:images].delete(image_id)
+              response.status = 202
+            end
+            response
+          else
+            response.status = 400
+            raise(Excon::Errors.status_error({:expects => 202}, response))
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_server.rb
new file mode 100644
index 0000000..88fafb0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/delete_server.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Delete an existing server
+        #
+        # ==== Parameters
+        # * id<~Integer> - Id of server to delete
+        #
+        def delete_server(server_id)
+          request(
+            :expects => 202,
+            :method => 'DELETE',
+            :path   => "servers/#{server_id}"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_server(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            if server['status'] == 'BUILD'
+              response.status = 409
+              raise(Excon::Errors.status_error({:expects => 202}, response))
+            else
+              self.data[:last_modified][:servers].delete(server_id)
+              self.data[:servers].delete(server_id)
+              response.status = 202
+            end
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_flavor_details.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_flavor_details.rb
new file mode 100644
index 0000000..406ed64
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_flavor_details.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for flavor by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def get_flavor_details(flavor_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "flavors/#{flavor_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_flavor_details(flavor_id)
+          response = Excon::Response.new
+          flavor = {
+            1 => { 'name' => '256 server',    'ram' => 256,    'disk' => 10   },
+            2 => { 'name' => '512 server',    'ram' => 512,    'disk' => 20   },
+            3 => { 'name' => '1GB server',    'ram' => 1024,   'disk' => 40   },
+            4 => { 'name' => '2GB server',    'ram' => 2048,   'disk' => 80   },
+            5 => { 'name' => '4GB server',    'ram' => 4096,   'disk' => 160  },
+            6 => { 'name' => '8GB server',    'ram' => 8192,   'disk' => 320  },
+            7 => { 'name' => '15.5GB server', 'ram' => 15872,  'disk' => 620  }
+          }[flavor_id]
+          if flavor
+            response.status = 200
+            response.body = {
+              'flavor' => flavor
+            }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_image_details.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_image_details.rb
new file mode 100644
index 0000000..b1287bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_image_details.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details for image by id
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'serverId'<~Integer> - Id of server image was created from
+        #     * 'status'<~Integer> - Status of image
+        #     * 'updated'<~String> - Timestamp of last update
+        def get_image_details(image_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "images/#{image_id}.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_server_details.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_server_details.rb
new file mode 100644
index 0000000..a6cc024
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/get_server_details.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Get details about a server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to get details for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'server'<~Hash>:
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'id'<~Integer> - Id of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'metadata'<~Hash> - metadata
+        #     * 'name<~String> - Name of server
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'status'<~String> - Current server status
+        def get_server_details(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_server_details(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'server' => server }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_addresses.rb
new file mode 100644
index 0000000..f22ac2d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_addresses.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'addresses'<~Array>:
+        #     * 'public'<~Array> - Public ip addresses
+        #     * 'private'<~Array> - Private ip addresses
+        def list_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'addresses' => server['addresses'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors.rb
new file mode 100644
index 0000000..bccea9d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        def list_flavors
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'flavors' => [
+              { 'name' => '256 server',    'id' => 1 },
+              { 'name' => '512 server',    'id' => 2 },
+              { 'name' => '1GB server',    'id' => 3 },
+              { 'name' => '2GB server',    'id' => 4 },
+              { 'name' => '4GB server',    'id' => 5 },
+              { 'name' => '8GB server',    'id' => 6 },
+              { 'name' => '15.5GB server', 'id' => 7 }
+            ]
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors_detail.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors_detail.rb
new file mode 100644
index 0000000..8b1b637
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_flavors_detail.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        #     * 'disk'<~Integer> - Amount of diskspace for the flavor
+        def list_flavors_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'flavors/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_flavors_detail
+          response = Excon::Response.new
+          response.status = 200
+          response.body = {
+            'flavors' => [
+              { 'name' => '256 server',    'id' => 1, 'ram' => 256,    'disk' => 10   },
+              { 'name' => '512 server',    'id' => 2, 'ram' => 512,    'disk' => 20   },
+              { 'name' => '1GB server',    'id' => 3, 'ram' => 1024,   'disk' => 40   },
+              { 'name' => '2GB server',    'id' => 4, 'ram' => 2048,   'disk' => 80   },
+              { 'name' => '4GB server',    'id' => 5, 'ram' => 4096,   'disk' => 160  },
+              { 'name' => '8GB server',    'id' => 6, 'ram' => 8192,   'disk' => 320  },
+              { 'name' => '15.5GB server', 'id' => 7, 'ram' => 15872,  'disk' => 620  }
+            ]
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images.rb
new file mode 100644
index 0000000..4af6333
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def list_images
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images
+          response = Excon::Response.new
+          data = list_images_detail.body['images']
+          images = []
+          for image in data
+            images << image.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images_detail.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images_detail.rb
new file mode 100644
index 0000000..bfac996
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_images_detail.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        #     * 'updated'<~String> - Last update timestamp for image
+        #     * 'created'<~String> - Creation timestamp for image
+        #     * 'status'<~String> - Status of image
+        def list_images_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'images/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_images_detail
+          response = Excon::Response.new
+
+          images = self.data[:images].values
+          for image in images
+            case image['status']
+            when 'SAVING'
+              if Time.now - self.data[:last_modified][:images][image['id']] >= Fog::Mock.delay
+                image['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'images' => images.map {|image| image.reject {|key, value| !['id', 'name', 'status', 'updated'].include?(key)}} }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_private_addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_private_addresses.rb
new file mode 100644
index 0000000..8576582
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_private_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List private server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'private'<~Array> - Public ip addresses
+        def list_private_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/private.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_private_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'private' => server['addresses']['private'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_public_addresses.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_public_addresses.rb
new file mode 100644
index 0000000..1fbf386
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_public_addresses.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List public server addresses
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to list addresses for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'public'<~Array> - Public ip addresses
+        def list_public_addresses(server_id)
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => "servers/#{server_id}/ips/public.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_public_addresses(server_id)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            response.status = [200, 203][rand(1)]
+            response.body = { 'public' => server['addresses']['public'] }
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers.rb
new file mode 100644
index 0000000..0bf2baf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers (IDs and names only)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        def list_servers
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers
+          response = Excon::Response.new
+          data = list_servers_detail.body['servers']
+          servers = []
+          for server in data
+            servers << server.reject { |key, value| !['id', 'name'].include?(key) }
+          end
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers_detail.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers_detail.rb
new file mode 100644
index 0000000..693ca8a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/list_servers_detail.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # List all servers details
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   * 'servers'<~Array>:
+        #     * 'id'<~Integer> - Id of server
+        #     * 'name<~String> - Name of server
+        #     * 'imageId'<~Integer> - Id of image used to boot server
+        #     * 'flavorId'<~Integer> - Id of servers current flavor
+        #     * 'hostId'<~String>
+        #     * 'status'<~String> - Current server status
+        #     * 'progress'<~Integer> - Progress through current status
+        #     * 'addresses'<~Hash>:
+        #       * 'public'<~Array> - public address strings
+        #       * 'private'<~Array> - private address strings
+        #     * 'metadata'<~Hash> - metadata
+        def list_servers_detail
+          request(
+            :expects  => [200, 203],
+            :method   => 'GET',
+            :path     => 'servers/detail.json'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def list_servers_detail
+          response = Excon::Response.new
+
+          servers = self.data[:servers].values
+          for server in servers
+            case server['status']
+            when 'BUILD'
+              if Time.now - self.data[:last_modified][:servers][server['id']] > Fog::Mock.delay * 2
+                server['status'] = 'ACTIVE'
+              end
+            end
+          end
+
+          response.status = [200, 203][rand(1)]
+          response.body = { 'servers' => servers }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/reboot_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/reboot_server.rb
new file mode 100644
index 0000000..e97c8aa
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/reboot_server.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        def reboot_server(server_id, type = 'SOFT')
+          body = { 'reboot' => { 'type' => type }}
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        def reboot_server(server_id, type = 'SOFT')
+          response = Excon::Response.new
+          response.status = 202
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/resize_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/resize_server.rb
new file mode 100644
index 0000000..c150105
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/resize_server.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to resize
+        # * size<~String> - new size. call list_flavors to get available flavors
+        #
+        def resize_server(server_id, flavor_id)
+          body = { 'resize' => { 'flavorId' => flavor_id }}
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        # FIXME: should probably transition instead of skipping to VERIFY_RESIZE
+        def resize_server(server_id, flavor_id)
+          response = Excon::Response.new
+          response.status = 202
+
+          # keep track of this for reverts
+          self.data[:servers][server_id]['old_flavorId'] = self.data[:servers][server_id]['flavorId']
+
+          self.data[:servers][server_id]['flavorId'] = flavor_id
+          self.data[:last_modified][:servers][server_id] = Time.now
+          self.data[:servers][server_id]['status'] = 'VERIFY_RESIZE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/revert_resized_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/revert_resized_server.rb
new file mode 100644
index 0000000..ce30f76
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/revert_resized_server.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Revert resizing
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to revert
+        #
+        def revert_resized_server(server_id)
+          body = { 'revertResize' => nil }
+          server_action(server_id, body)
+        end
+
+      end
+
+      class Mock
+
+        def revert_resized_server(server_id)
+          response = Excon::Response.new
+          response.status = 202
+
+          self.data[:servers][server_id]['flavorId'] = self.data[:servers][server_id]['old_flavorId']
+          self.data[:servers][server_id].delete('old_flavorId')
+          self.data[:last_modified][:servers][server_id] = Time.now
+          self.data[:servers][server_id]['status'] = 'ACTIVE'
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/server_action.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/server_action.rb
new file mode 100644
index 0000000..59ce4f5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/server_action.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Reboot an existing server
+        #
+        # ==== Parameters
+        # * server_id<~Integer> - Id of server to reboot
+        # * body<~.to_json object> - Body of the request, describes the action (see reboot_server as an example)
+        # * expect<~Integer> - expected return, 202 except for confirm resize (204)
+        #
+        def server_action(server_id, body, expects=202)
+          request(
+            :body     => body.to_json,
+            :expects  => expects,
+            :method   => 'POST',
+            :path     => "servers/#{server_id}/action.json"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/update_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/update_server.rb
new file mode 100644
index 0000000..80c3215
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/rackspace/update_server.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Compute
+      class Real
+
+        # Update an existing server
+        #
+        # ==== Parameters
+        # # server_id<~Integer> - Id of server to update
+        # * options<~Hash>:
+        #   * adminPass<~String> - New admin password for server
+        #   * name<~String> - New name for server
+        def update_server(server_id, options = {})
+          request(
+            :body     => { 'server' => options }.to_json,
+            :expects  => 204,
+            :method   => 'PUT',
+            :path     => "servers/#{server_id}.json"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def update_server(server_id, options)
+          response = Excon::Response.new
+          if server = list_servers_detail.body['servers'].detect {|_| _['id'] == server_id}
+            if options['adminPass']
+              server['adminPass'] = options['adminPass']
+            end
+            if options['name']
+              server['name'] = options['name']
+            end
+            response.status = 204
+            response
+          else
+            raise Fog::Rackspace::Compute::NotFound
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/create_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/create_slice.rb
new file mode 100644
index 0000000..400b93f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/create_slice.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/create_slice'
+
+        # Create a new slice
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to create slice with
+        # * image_id<~Integer> - Id of image to create slice with
+        # * name<~String> - Name of slice
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Integer> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Integer> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor-id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'root-password'<~String> - Root password of slice
+        #     * 'status'<~String> - Current status of the slice
+        def create_slice(flavor_id, image_id, name)
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><slice><flavor-id type="integer">#{flavor_id}</flavor-id><image-id type="integer">#{image_id}</image-id><name>#{name}</name></slice>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::Compute::CreateSlice.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/delete_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/delete_slice.rb
new file mode 100644
index 0000000..6211633
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/delete_slice.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Delete a given slice
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of slice to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code is the return value
+        def delete_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_backups.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_backups.rb
new file mode 100644
index 0000000..2a90396
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_backups.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_backups'
+
+        # Get list of backups
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'date'<~Time> - Timestamp of backup creation
+        #     * 'id'<~Integer> - Id of the backup
+        #     * 'name'<~String> - Name of the backup
+        #     * 'slice-id'<~Integer> - Id of slice the backup was made from
+        def get_backups
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetBackups.new,
+            :path     => 'backups.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavor.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavor.rb
new file mode 100644
index 0000000..859289c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavor.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_flavor'
+
+        # Get details of a flavor
+        #
+        # ==== Parameters
+        # * flavor_id<~Integer> - Id of flavor to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavor(flavor_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavor.new,
+            :path     => "flavors/#{flavor_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavors.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavors.rb
new file mode 100644
index 0000000..a5bcd18
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_flavors.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_flavors'
+
+        # Get list of flavors
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the flavor
+        #     * 'name'<~String> - Name of the flavor
+        #     * 'price'<~Integer> - Price in cents
+        #     * 'ram'<~Integer> - Amount of ram for the flavor
+        def get_flavors
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetFlavors.new,
+            :path     => 'flavors.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_image.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_image.rb
new file mode 100644
index 0000000..ec93582
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_image.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_image'
+
+        # Get details of an image
+        #
+        # ==== Parameters
+        # * image_id<~Integer> - Id of image to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_image(image_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImage.new,
+            :path     => "images/#{image_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_images.rb
new file mode 100644
index 0000000..33b94a7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_images.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_images'
+
+        # Get list of images
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'id'<~Integer> - Id of the image
+        #     * 'name'<~String> - Name of the image
+        def get_images
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetImages.new,
+            :path     => 'images.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slice.rb
new file mode 100644
index 0000000..ea69ad9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slice.rb
@@ -0,0 +1,38 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_slice'
+
+        # Get details of a slice
+        #
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of slice to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slice(slice_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slices.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slices.rb
new file mode 100644
index 0000000..d252a15
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/get_slices.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/slicehost/get_slices'
+
+        # Get list of slices
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_slices
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlices.new,
+            :path     => 'slices.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/reboot_slice.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/reboot_slice.rb
new file mode 100644
index 0000000..a20ff82
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/slicehost/reboot_slice.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Slicehost
+    class Compute
+      class Real
+
+        # Reboot slice
+        # ==== Parameters
+        # * slice_id<~Integer> - Id of server to reboot
+        # * type<~String> - Type of reboot, must be in ['HARD', 'SOFT']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'bw-in'<~Float> - Incoming bandwidth total for current billing cycle, in Gigabytes
+        #     * 'bw-out'<~Float> - Outgoing bandwidth total for current billing cycle, in Gigabytes
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def reboot_slice(slice_id, type = 'SOFT')
+          request(
+            :expects  => 200,
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::Slicehost::Compute::GetSlice.new,
+            :path     => "/slices/#{slice_id}/#{'hard_' if type == 'HARD'}reboot.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/add_balancer_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/add_balancer_node.rb
new file mode 100644
index 0000000..5510242
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/add_balancer_node.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def add_balancer_node(options = {})
+          request(
+            :path     => "/network/loadbalancer/addnode",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/clone_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/clone_server.rb
new file mode 100644
index 0000000..cb43f49
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/clone_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def clone_server(options = {})
+          request(
+            :path     => "/storm/server/clone",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/create_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/create_server.rb
new file mode 100644
index 0000000..7fc9f74
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/create_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def create_server(options = {})
+          request(
+            :path     => "/storm/server/create",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/delete_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/delete_server.rb
new file mode 100644
index 0000000..3b4aa49
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/delete_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def delete_server(options = {})
+          request(
+            :path     => "/storm/server/destroy",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_server.rb
new file mode 100644
index 0000000..3120b10
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def get_server(options = {})
+          request(
+            :path     => "/storm/server/details",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_stats.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_stats.rb
new file mode 100644
index 0000000..8480173
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/get_stats.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def get_stats(options = {})
+          request(
+            :path     => "/monitoring/load/stats",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_balancers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_balancers.rb
new file mode 100644
index 0000000..1cee5bf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_balancers.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_balancers(options = {})
+          request(
+            :path     => "/network/loadbalancer/list",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_configs.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_configs.rb
new file mode 100644
index 0000000..6337854
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_configs.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_configs(options = {})
+          request(
+            :path     => "/storm/config/list",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_images.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_images.rb
new file mode 100644
index 0000000..cc016ba
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_images.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_images(options = {})
+          request(
+            :path     => "/server/image/list",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_private_ips.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_private_ips.rb
new file mode 100644
index 0000000..e80fe8a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_private_ips.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_private_ips(options = {})
+          request(
+            :path     => "/network/private/get",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_servers.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_servers.rb
new file mode 100644
index 0000000..e7abc9d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_servers.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_servers(options = {})
+          request(
+            :path     => "/storm/server/list",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_templates.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_templates.rb
new file mode 100644
index 0000000..e6fb56f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/list_templates.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def list_templates(options = {})
+          request(
+            :path     => "/server/template/list",
+            :body     => options.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/reboot_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/reboot_server.rb
new file mode 100644
index 0000000..37aba87
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/reboot_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def reboot_server(options = {})
+          request(
+            :path     => "/storm/server/reboot",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/remove_balancer_node.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/remove_balancer_node.rb
new file mode 100644
index 0000000..6ae974b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/remove_balancer_node.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def remove_balancer_node(options = {})
+          request(
+            :path     => "/network/loadbalancer/removenode",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/resize_server.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/resize_server.rb
new file mode 100644
index 0000000..355027c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/storm_on_demand/resize_server.rb
@@ -0,0 +1,16 @@
+module Fog
+  module StormOnDemand
+    class Compute
+      class Real
+
+        def resize_server(options = {})
+          request(
+            :path     => "/storm/server/resize",
+            :body     => {:params => options}.to_json
+          )
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_list.rb
new file mode 100644
index 0000000..f36357d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_list.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Voxel
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/voxel/devices_list'
+
+        def devices_list(device_id = nil)
+          options = {
+            :parser     => Fog::Parsers::Voxel::Compute::DevicesList.new,
+            :verbosity  => 'normal'
+          }
+
+          unless device_id.nil?
+            options[:device_id] = device_id
+          end
+
+          request("voxel.devices.list", options)
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_power.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_power.rb
new file mode 100644
index 0000000..e57b06b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/devices_power.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Voxel
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/voxel/basic'
+
+        def devices_power(device_id, power_action)
+          options = {
+            :device_id    => device_id,
+            :parser       => Fog::Parsers::Voxel::Compute::Basic.new,
+            :power_action => power_action,
+            :verbosity    => 'normal'
+          }
+
+          request("voxel.devices.power", options)
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/images_list.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/images_list.rb
new file mode 100644
index 0000000..3355ca6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/images_list.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Voxel
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/voxel/images_list'
+
+        def images_list(image_id = nil)
+          options = {
+            :parser     => Fog::Parsers::Voxel::Compute::ImagesList.new,
+            :verbosity  => 'compact'
+          }
+
+          unless image_id.nil?
+            options[:verbosity] = 'extended'
+            options[:image_id] = image_id
+          end
+
+          data = request("voxel.images.list", options)
+
+          if data.body['stat'] == "ok"
+            data
+          else
+            raise Fog::Voxel::Compute::NotFound
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_create.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_create.rb
new file mode 100644
index 0000000..70cb8ac
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_create.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Voxel
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/voxel/voxcloud_create'
+
+        def voxcloud_create(options)
+          options[:parser] = Fog::Parsers::Voxel::Compute::VoxcloudCreate.new
+
+          if options.has_key?(:password)
+            options[:admin_password] = options[:password]
+            options.delete(:password)
+          end
+
+          request("voxel.voxcloud.create", options)
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_delete.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_delete.rb
new file mode 100644
index 0000000..a09d528
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_delete.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Voxel
+    class Compute
+      class Real
+
+        require 'fog/compute/parsers/voxel/voxcloud_delete'
+
+        def voxcloud_delete(device_id)
+          options = {
+            :device_id  => device_id,
+            :parser     => Fog::Parsers::Voxel::Compute::VoxcloudDelete.new
+          }
+
+          request("voxel.voxcloud.delete", options)
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_status.rb b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_status.rb
new file mode 100644
index 0000000..c7e3cab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/requests/voxel/voxcloud_status.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Voxel
+    class Compute
+
+      require 'fog/compute/parsers/voxel/voxcloud_status'
+
+      class Real
+        def voxcloud_status(device_id = nil)
+          options = {
+            :parser     => Fog::Parsers::Voxel::Compute::VoxcloudStatus.new,
+            :verbosity  => 'compact'
+          }
+
+          unless device_id.nil?
+            options[:device_id] = device_id
+          end
+
+          request("voxel.voxcloud.status", options)
+        end
+      end
+
+      class Mock
+        def voxcloud_status(device_id = nil)
+          Fog::Mock.not_implemented
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/slicehost.rb b/vendor/fog-0.8.2/lib/fog/compute/slicehost.rb
new file mode 100644
index 0000000..8750a55
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/slicehost.rb
@@ -0,0 +1,114 @@
+module Fog
+  module Slicehost
+    class Compute < Fog::Service
+
+      requires :slicehost_password
+      recognizes :host, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/slicehost'
+      model       :flavor
+      collection  :flavors
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/compute/requests/slicehost'
+      request :create_slice
+      request :delete_slice
+      request :get_backups
+      request :get_flavor
+      request :get_flavors
+      request :get_image
+      request :get_images
+      request :get_slice
+      request :get_slices
+      request :reboot_slice
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Slicehost::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Slicehost') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @slicehost_password = options[:slicehost_password]
+        end
+
+        def data
+          self.class.data[@slicehost_password]
+        end
+
+        def reset_data
+          self.class.data.delete(@slicehost_password)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Slicehost::Compute.new is deprecated, use Fog::Compute.new(:provider => 'Slicehost') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @slicehost_password = options[:slicehost_password]
+          @host   = options[:host]    || "api.slicehost.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(@slicehost_password).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Slicehost::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/storm_on_demand.rb b/vendor/fog-0.8.2/lib/fog/compute/storm_on_demand.rb
new file mode 100644
index 0000000..33f765b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/storm_on_demand.rb
@@ -0,0 +1,133 @@
+module Fog
+  module StormOnDemand
+    class Compute < Fog::Service
+      
+      API_URL = 'https://api.stormondemand.com'
+      
+      requires :storm_on_demand_username, :storm_on_demand_password
+      recognizes :storm_on_demand_auth_url
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/storm_on_demand'
+      model       :config
+      collection  :configs
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+      model       :balancer
+      collection  :balancers
+      model       :private_ip
+      collection  :private_ips
+      model       :stat
+      collection  :stats
+      model       :template
+      collection  :templates
+
+      request_path 'fog/compute/requests/storm_on_demand'
+      request :clone_server
+      request :delete_server
+      request :reboot_server
+      request :list_servers
+      request :get_server
+      request :create_server
+      request :resize_server
+      request :remove_balancer_node
+      request :add_balancer_node
+      request :list_balancers
+      request :list_configs
+      request :list_templates
+      request :list_images
+      request :get_stats
+      request :list_private_ips      
+      
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :last_modified => {
+                :images  => {},
+                :servers => {}
+              },
+              :images  => {},
+              :servers => {}
+            }
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def self.reset_data(keys=data.keys)
+          for key in [*keys]
+            data.delete(key)
+          end
+        end
+
+        def initialize(options={})
+          @storm_on_demand_username = options[:storm_on_demand_username]
+        end
+
+        def data
+          self.class.data[@storm_on_demand_username]
+        end
+
+        def reset_data
+          self.class.data.delete(@storm_on_demand_username)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'json'
+          uri = URI.parse(options[:storm_on_demand_auth_url] ||= API_URL)
+          @host   = uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          @storm_on_demand_username = options[:storm_on_demand_username]
+          @storm_on_demand_password = options[:storm_on_demand_password]
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}")
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'Authorization' => 'Basic ' << Base64.encode64("#{@storm_on_demand_username}:#{@storm_on_demand_password}").chomp
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+              :expects  => 200,
+              :method   => :post
+            }))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::StormOnDemand::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          if response.body.keys.include?('full_error')
+            raise(Fog::StormOnDemand::Compute::Error, response.body.inspect)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/virtual_box.rb b/vendor/fog-0.8.2/lib/fog/compute/virtual_box.rb
new file mode 100644
index 0000000..90f6cd5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/virtual_box.rb
@@ -0,0 +1,48 @@
+module Fog
+  module VirtualBox
+    class Compute < Fog::Service
+
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/compute/models/virtual_box'
+      model       :medium
+      collection  :mediums
+      model       :medium_format
+      model       :nat_engine
+      model       :nat_redirect
+      collection  :nat_redirects
+      model       :network_adapter
+      collection  :network_adapters
+      model       :server
+      collection  :servers
+      model       :storage_controller
+      collection  :storage_controllers
+
+      class Mock
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          require 'virtualbox'
+          @connection = ::VirtualBox::Global.global.lib.virtualbox
+        end
+
+        # hack to provide 'requests'
+        def method_missing(method_sym, *arguments, &block)
+          if @connection.respond_to?(method_sym)
+            @connection.send(method_sym, *arguments)
+          else
+            super
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/compute/voxel.rb b/vendor/fog-0.8.2/lib/fog/compute/voxel.rb
new file mode 100644
index 0000000..249271e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/compute/voxel.rb
@@ -0,0 +1,121 @@
+module Fog
+  module Voxel
+    class Compute < Fog::Service
+
+      requires :voxel_api_key, :voxel_api_secret
+      recognizes :provider, :host, :port, :scheme, :persistent
+
+      model_path 'fog/compute/models/voxel'
+      model       :image
+      collection  :images
+      model       :server
+      collection  :servers
+
+      request_path 'fog/compute/requests/voxel'
+      request :images_list
+      request :devices_list
+      request :devices_power
+      request :voxcloud_create
+      request :voxcloud_status
+      request :voxcloud_delete
+
+      class Mock
+        include Collections
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :last_modified => { :servers => {}, :statuses => {}, :images => {} },
+              :servers => [],
+              :statuses => {},
+              :images  => [
+                {'id' => 1,   'name' => "CentOS 4, 32-bit, base install"},
+                {'id' => 2,   'name' => "CentOS 4, 64-bit, base install"},
+                {'id' => 3,   'name' => "CentOS 5, 32-bit, base install"},
+                {'id' => 4,   'name' => "CentOS 5, 64-bit, base install"},
+                {'id' => 7,   'name' => "Fedora 10, 32-bit, base install"},
+                {'id' => 8,   'name' => "Fedora 10, 64-bit, base install"},
+                {'id' => 10,  'name' => "OpenSUSE 11, 64-bit, base install"},
+                {'id' => 11,  'name' => "Debian 5.0 \"lenny\", 32-bit, base install"},
+                {'id' => 12,  'name' => "Debian 5.0 \"lenny\", 64-bit, base install"},
+                {'id' => 13,  'name' => "Ubuntu 8.04 \"Hardy\", 32-bit, base install"},
+                {'id' => 14,  'name' => "Ubuntu 8.04 \"Hardy\", 64-bit, base install"},
+                {'id' => 15,  'name' => "Voxel Server Environment (VSE), 32-bit, base install"},
+                {'id' => 16,  'name' => "Voxel Server Environment (VSE), 64-bit, base install"},
+                {'id' => 32,  'name' => "Pantheon Official Mercury Stack for Drupal (based on VSE/64)"},
+                {'id' => 55,  'name' => "Ubuntu 10.04 \"Lucid\", 64-bit, base install"} ]
+            }
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          @voxel_api_key = options[:voxel_api_key]
+        end
+
+        def data
+          self.class.data[@voxel_api_key]
+        end
+
+        def reset_data
+          self.class.data.delete(@voxel_api_key)
+        end
+
+      end
+
+      class Real
+        include Collections
+
+        def initialize(options = {})
+          require 'time'
+          require 'digest/md5'
+
+          @voxel_api_key = options[:voxel_api_key]
+          @voxel_api_secret = options[:voxel_api_secret]
+
+          @host   = options[:host]    || "api.voxel.net"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @persistent = options[:persistent] || false
+
+          Excon.ssl_verify_peer = false
+
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", @persistent)
+        end
+
+        def request(method_name, options = {})
+          begin
+            parser = options.delete(:parser)
+            options.merge!({ :method => method_name, :timestamp => Time.now.xmlschema, :key => @voxel_api_key })
+            options[:api_sig] = create_signature(@voxel_api_secret, options)
+            data = @connection.request(
+              :method => "POST",
+              :query  => options,
+              :parser => parser,
+              :path   => "/version/1.0/"
+            )
+            unless data.body['stat'] == 'ok'
+              raise Fog::Voxel::Compute::Error, "#{data.body['err']['msg']}"
+            end
+            data
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Voxel::Compute::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+        end
+
+        def create_signature(secret, options)
+          to_sign = options.keys.map { |k| k.to_s }.sort.map { |k| "#{k}#{options[k.to_sym]}" }.join("")
+          Digest::MD5.hexdigest( secret + to_sign )
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core.rb b/vendor/fog-0.8.2/lib/fog/core.rb
new file mode 100644
index 0000000..2c5fe2e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core.rb
@@ -0,0 +1,34 @@
+__LIB_DIR__ = File.expand_path(File.join(File.dirname(__FILE__), '..'))
+
+$LOAD_PATH.unshift __LIB_DIR__ unless
+  $LOAD_PATH.include?(__LIB_DIR__) ||
+  $LOAD_PATH.include?(File.expand_path(__LIB_DIR__))
+
+# external core dependencies
+require 'rubygems'
+require 'base64'
+require 'cgi'
+require 'uri'
+require 'excon'
+require 'fileutils'
+require 'formatador'
+require 'time'
+require 'timeout'
+
+# internal core dependencies
+require 'fog/core/attributes'
+require 'fog/core/collection'
+require 'fog/core/connection'
+require 'fog/core/credentials'
+require 'fog/core/deprecation'
+require 'fog/core/errors'
+require 'fog/core/hmac'
+require 'fog/core/model'
+require 'fog/core/mock'
+# require 'fog/core/parser'
+require 'fog/core/provider'
+require 'fog/core/service'
+require 'fog/core/ssh'
+require 'fog/core/scp'
+require 'fog/core/time'
+require 'fog/core/wait_for'
diff --git a/vendor/fog-0.8.2/lib/fog/core/attributes.rb b/vendor/fog-0.8.2/lib/fog/core/attributes.rb
new file mode 100644
index 0000000..9c64cd4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/attributes.rb
@@ -0,0 +1,192 @@
+module Fog
+  module Attributes
+    module ClassMethods
+
+      def _load(marshalled)
+        new(Marshal.load(marshalled))
+      end
+
+      def aliases
+        @aliases ||= {}
+      end
+
+      def attributes
+        @attributes ||= []
+      end
+
+      def attribute(name, options = {})
+        class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}
+            attributes[:#{name}]
+          end
+        EOS
+        case options[:type]
+        when :boolean
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = case new_#{name}
+              when 'true'
+                true
+              when 'false'
+                false
+              end
+            end
+          EOS
+        when :float
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_f
+            end
+          EOS
+        when :integer
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_i
+            end
+          EOS
+        when :string
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = new_#{name}.to_s
+            end
+          EOS
+        when :time
+          class_eval <<-EOS, __FILE__, __LINE__
+            def #{name}=(new_#{name})
+              attributes[:#{name}] = if new_#{name}.nil? || new_#{name} == "" || new_#{name}.is_a?(Time)
+                new_#{name}
+              else
+                Time.parse(new_#{name})
+              end
+            end
+          EOS
+        when :array
+          class_eval <<-EOS, __FILE__, __LINE__
+          def #{name}=(new_#{name})
+            attributes[:#{name}] = [*new_#{name}]
+          end
+          EOS
+        else
+          if squash = options[:squash]
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_data)
+                if new_data.is_a?(Hash)
+                  if new_data[:#{squash}] || new_data["#{squash}"]
+                    attributes[:#{name}] = new_data[:#{squash}] || new_data["#{squash}"]
+                  else
+                    attributes[:#{name}] = [ new_data ]
+                  end
+                else
+                  attributes[:#{name}] = new_data
+                end
+              end
+            EOS
+          else
+            class_eval <<-EOS, __FILE__, __LINE__
+              def #{name}=(new_#{name})
+                attributes[:#{name}] = new_#{name}
+              end
+            EOS
+          end
+        end
+        @attributes ||= []
+        @attributes |= [name]
+        for new_alias in [*options[:aliases]]
+          aliases[new_alias] = name
+        end
+      end
+
+      def identity(name, options = {})
+        @identity = name
+        self.attribute(name, options)
+      end
+
+      def ignore_attributes(*args)
+        @ignored_attributes = args
+      end
+
+      def ignored_attributes
+        @ignored_attributes ||= []
+      end
+
+    end
+
+    module InstanceMethods
+
+      def _dump(level)
+        Marshal.dump(attributes)
+      end
+
+      def attributes
+        @attributes ||= {}
+      end
+
+      def dup
+        copy = super
+        copy.dup_attributes!
+        copy
+      end
+
+      def identity
+        send(self.class.instance_variable_get('@identity'))
+      end
+
+      def identity=(new_identity)
+        send("#{self.class.instance_variable_get('@identity')}=", new_identity)
+      end
+
+      def merge_attributes(new_attributes = {})
+        for key, value in new_attributes
+          unless self.class.ignored_attributes.include?(key)
+            if aliased_key = self.class.aliases[key]
+              send("#{aliased_key}=", value)
+            elsif (public_methods | private_methods).detect {|method| ["#{key}=", :"#{key}="].include?(method)}
+              send("#{key}=", value)
+            else
+              attributes[key] = value
+            end
+          end
+        end
+        self
+      end
+
+      def new_record?
+        !identity
+      end
+
+      # check that the attributes specified in args exist and is not nil
+      def requires(*args)
+        missing = []
+        for arg in [:connection] | args
+          unless send("#{arg}") || attributes.has_key?(arg)
+            missing << arg
+          end
+        end
+        unless missing.empty?
+          if missing.length == 1
+            raise(ArgumentError, "#{missing.first} is required for this operation")
+          else
+            raise(ArgumentError, "#{missing[0...-1].join(", ")} and #{missing[-1]} are required for this operation")
+          end
+        end
+      end
+
+      protected
+
+      def dup_attributes!
+        @attributes = @attributes.dup
+      end
+
+      private
+
+      def remap_attributes(attributes, mapping)
+        for key, value in mapping
+          if attributes.key?(key)
+            attributes[value] = attributes.delete(key)
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/collection.rb b/vendor/fog-0.8.2/lib/fog/core/collection.rb
new file mode 100644
index 0000000..6875cb7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/collection.rb
@@ -0,0 +1,127 @@
+module Fog
+  class Collection < Array
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    Array.public_instance_methods(false).each do |method|
+      unless [:reject, :select, :slice].include?(method.to_sym)
+        class_eval <<-RUBY
+          def #{method}(*args)
+            unless @loaded
+              lazy_load
+            end
+            super
+          end
+        RUBY
+      end
+    end
+
+    %w[reject select slice].each do |method|
+      class_eval <<-RUBY
+        def #{method}(*args)
+          unless @loaded
+            lazy_load
+          end
+          data = super
+          result = self.clone.clear.concat(data)
+        end
+      RUBY
+    end
+
+    def self.model(new_model=nil)
+      if new_model == nil
+        @model
+      else
+        @model = new_model
+      end
+    end
+
+    attr_accessor :connection
+
+    remove_method :clear
+    def clear
+      @loaded = true
+      super
+    end
+
+    def create(attributes = {})
+      object = new(attributes)
+      object.save
+      object
+    end
+
+    def initialize(attributes = {})
+      @loaded = false
+      merge_attributes(attributes)
+    end
+
+    remove_method :inspect
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}\n"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+          data << "\n"
+        end
+        data << "#{Thread.current[:formatador].indentation}["
+        unless self.empty?
+          data << "\n"
+          Thread.current[:formatador].indent do
+            data << self.map {|member| member.inspect}.join(",\n")
+            data << "\n"
+          end
+          data << Thread.current[:formatador].indentation
+        end
+        data << "]\n"
+      end
+      data << "#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def load(objects)
+      clear
+      for object in objects
+        self << new(object)
+      end
+      self
+    end
+
+    def model
+      self.class.instance_variable_get('@model')
+    end
+
+    def new(attributes = {})
+      model.new(
+        attributes.merge(
+          :collection => self,
+          :connection => connection
+        )
+      )
+    end
+
+    def reload
+      clear
+      lazy_load
+      self
+    end
+
+    def table(attributes = nil)
+      Formatador.display_table(self.map {|instance| instance.attributes}, attributes)
+    end
+
+    def to_json
+      require 'json'
+      self.map {|member| member.attributes}.to_json
+    end
+
+    private
+
+    def lazy_load
+      self.all
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/connection.rb b/vendor/fog-0.8.2/lib/fog/core/connection.rb
new file mode 100644
index 0000000..95f51c7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/connection.rb
@@ -0,0 +1,35 @@
+module Fog
+  class Connection
+
+    def initialize(url, persistent=false, params={})
+      @excon = Excon.new(url, params)
+      @persistent = persistent
+    end
+
+    def request(params, &block)
+      unless @persistent
+        reset
+      end
+      unless block_given?
+        if (parser = params.delete(:parser))
+          body = Nokogiri::XML::SAX::PushParser.new(parser)
+          block = lambda { |chunk, remaining, total| body << chunk }
+        end
+      end
+
+      response = @excon.request(params, &block)
+
+      if parser
+        body.finish
+        response.body = parser.response
+      end
+
+      response
+    end
+
+    def reset
+      @excon.reset
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/credentials.rb b/vendor/fog-0.8.2/lib/fog/core/credentials.rb
new file mode 100644
index 0000000..ba05467
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/credentials.rb
@@ -0,0 +1,56 @@
+require 'yaml'
+
+module Fog
+  require 'fog/core/deprecation'
+
+  # Assign a new credential to use from configuration file
+  #   @param [String, Symbol] new_credential name of new credential to use
+  #   @ return [String, Symbol] name of the new credential
+  def self.credential=(new_credential)
+    @credentials = nil
+    @credential = new_credential
+  end
+
+  # @return [String, Symbol] The credential to use in Fog
+  def self.credential
+    @credential ||= :default
+  end
+
+  # @return [String] The path for configuration_file
+  def self.credentials_path
+    @credential_path ||= begin
+      path = ENV["FOG_RC"] || (ENV['HOME'] && File.directory?(ENV['HOME']) && '~/.fog')
+      File.expand_path(path) if path
+    end
+  end
+
+  # @return [String] The new path for credentials file
+  def self.credentials_path=(new_credentials_path)
+    @credentials = nil
+    @credential_path = new_credentials_path
+  end
+
+  # @return [Hash] The credentials pulled from the configuration file
+  # @raise [LoadError] Configuration unavailable in configuration file
+  def self.credentials
+    @credentials  ||= begin
+      if credentials_path && File.exists?(credentials_path)
+        credentials = self.symbolize_credentials(YAML.load_file(credentials_path))
+        (credentials && credentials[credential]) || Fog::Errors.missing_credentials
+      else
+        {}
+      end
+    end
+  end
+  
+  def self.symbolize_credentials(args)
+    if args.is_a? Hash
+      Hash[ args.collect do |key, value|
+        [key.to_sym, self.symbolize_credentials(value)]
+      end ]
+    else
+      args
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/deprecation.rb b/vendor/fog-0.8.2/lib/fog/core/deprecation.rb
new file mode 100644
index 0000000..6a156a1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/deprecation.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Deprecation
+
+    def deprecate(older, newer)
+      module_eval <<-EOS, __FILE__, __LINE__
+        def #{older}(*args)
+          Formatador.display_line("[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/] [light_black](#{caller.first})[/]")
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+    def self_deprecate(older, newer)
+      module_eval <<-EOS, __FILE__, __LINE__
+        def self.#{older}(*args)
+          Formatador.display_line("[yellow][WARN] #{self} => ##{older} is deprecated, use ##{newer} instead[/] [light_black](#{caller.first})[/]")
+          send(:#{newer}, *args)
+        end
+      EOS
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/errors.rb b/vendor/fog-0.8.2/lib/fog/core/errors.rb
new file mode 100644
index 0000000..46ed8e6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/errors.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Errors
+
+    class Error < StandardError
+      attr_accessor :verbose
+
+      def self.slurp(error, message = nil)
+        new_error = new(message)
+        new_error.set_backtrace(error.backtrace)
+        new_error.verbose = error.message
+        new_error
+      end
+    end
+
+    class MockNotImplemented < Fog::Errors::Error; end
+
+    class NotFound < Fog::Errors::Error; end
+
+    # @return [String] The error message that will be raised, if credentials cannot be found
+    def self.missing_credentials
+      missing_credentials_message = <<-YML
+Missing Credentials
+
+To run as '#{Fog.credential}', add the following to your resource config file: #{Fog.credentials_path}
+An alternate file may be used by placing its path in the FOG_RC environment variable
+
+#######################################################
+# Fog Credentials File
+#
+# Key-value pairs should look like:
+# :aws_access_key_id:                 022QF06E7MXBSAMPLE
+:#{Fog.credential}:
+  :aws_access_key_id:
+  :aws_secret_access_key:
+  :bluebox_api_key:
+  :bluebox_customer_id:
+  :brightbox_client_id:
+  :brightbox_secret:
+  :go_grid_api_key:
+  :go_grid_shared_secret:
+  :google_storage_access_key_id:
+  :google_storage_secret_access_key:
+  :linode_api_key:
+  :local_root:
+  :new_servers_password:
+  :new_servers_username:
+  :public_key_path:
+  :private_key_path:
+  :rackspace_api_key:
+  :rackspace_username:
+  :rackspace_servicenet:
+  :rackspace_cdn_ssl:
+  :slicehost_password:
+  :stormondemand_username:
+  :stormondemand_password:
+  :terremark_username:
+  :terremark_password:
+  :voxel_api_key:
+  :voxel_api_secret:
+  :zerigo_email:
+  :zerigo_token:
+  :dnsimple_email:
+  :dnsimple_password:
+#
+# End of Fog Credentials File
+#######################################################
+
+    YML
+    raise(LoadError.new(missing_credentials_message))
+  end
+
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/core/hmac.rb b/vendor/fog-0.8.2/lib/fog/core/hmac.rb
new file mode 100644
index 0000000..8051947
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/hmac.rb
@@ -0,0 +1,48 @@
+module Fog
+  class HMAC
+
+    def initialize(type, key)
+      @key = key
+      case type
+      when 'sha1'
+        setup_sha1
+      when 'sha256'
+        setup_sha256
+      end
+    end
+
+    def sign(data)
+      @signer.call(data)
+    end
+
+    private
+
+    def setup_sha1
+      @digest = OpenSSL::Digest::Digest.new('sha1')
+      @signer = lambda do |data|
+        OpenSSL::HMAC.digest(@digest, @key, data)
+      end
+    end
+
+    def setup_sha256
+      begin
+        @digest = OpenSSL::Digest::Digest.new('sha256')
+        @signer = lambda do |data|
+          OpenSSL::HMAC.digest(@digest, @key, data)
+        end
+      rescue RuntimeError => error
+        unless error.message == 'Unsupported digest algorithm (sha256).'
+          raise error
+        else
+          require 'hmac-sha2'
+          @hmac = ::HMAC::SHA256.new(@key)
+          @signer = lambda do |data|
+            @hmac.update(data)
+            @hmac.digest
+          end
+        end
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/core/mock.rb b/vendor/fog-0.8.2/lib/fog/core/mock.rb
new file mode 100644
index 0000000..456584c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/mock.rb
@@ -0,0 +1,81 @@
+module Fog
+
+  @mocking = false
+
+  def self.mock!
+    @mocking = true
+  end
+
+  def self.mock?
+    @mocking
+  end
+
+  def self.mocking?
+    @mocking
+  end
+
+  module Mock
+
+    @delay = 1
+    def self.delay
+      @delay
+    end
+
+    def self.delay=(new_delay)
+      raise ArgumentError, "delay must be non-negative" unless new_delay >= 0
+      @delay = new_delay
+    end
+
+    def self.not_implemented
+      raise Fog::Errors::MockNotImplemented.new("Contributions welcome!")
+    end
+
+    def self.random_base64(length)
+      random_selection(
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
+        length
+      )
+    end
+
+    def self.random_hex(length)
+      max = ('f' * length).to_i(16)
+      rand(max).to_s(16).rjust(length, '0')
+    end
+
+    def self.random_letters(length)
+      random_selection(
+        'abcdefghijklmnopqrstuvwxyz',
+        length
+      )
+    end
+
+    def self.random_numbers(length)
+      max = ('9' * length).to_i
+      rand(max).to_s
+    end
+
+    def self.random_selection(characters, length)
+      selection = ''
+      length.times do
+        position = rand(characters.length)
+        selection << characters[position..position]
+      end
+      selection
+    end
+
+    def self.reset
+      providers = Fog.providers.map {|p| Fog.const_get(p) }
+      possible_service_constants = providers.map {|p| p.constants.map {|c| p.const_get(c) } }.flatten
+      # c.to_sym is 1.8.7 / 1.9.2 compat
+      services = possible_service_constants.select {|s| s.constants.map {|c| c.to_sym }.include?(:Mock) }
+      service_mocks = services.map {|s| s.const_get(:Mock) }
+
+      service_mocks.each do |service_mock|
+        next unless service_mock.respond_to?(:reset)
+        service_mock.reset
+      end
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/model.rb b/vendor/fog-0.8.2/lib/fog/core/model.rb
new file mode 100644
index 0000000..3074720
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/model.rb
@@ -0,0 +1,62 @@
+module Fog
+  class Model
+
+    extend Fog::Attributes::ClassMethods
+    include Fog::Attributes::InstanceMethods
+
+    attr_accessor :collection, :connection
+
+    def initialize(new_attributes = {})
+      merge_attributes(new_attributes)
+    end
+
+    def inspect
+      Thread.current[:formatador] ||= Formatador.new
+      data = "#{Thread.current[:formatador].indentation}<#{self.class.name}"
+      Thread.current[:formatador].indent do
+        unless self.class.attributes.empty?
+          data << "\n#{Thread.current[:formatador].indentation}"
+          data << self.class.attributes.map {|attribute| "#{attribute}=#{send(attribute).inspect}"}.join(",\n#{Thread.current[:formatador].indentation}")
+        end
+      end
+      data << "\n#{Thread.current[:formatador].indentation}>"
+      data
+    end
+
+    def reload
+      requires :identity
+
+      return unless data = begin
+        collection.get(identity)
+      rescue Excon::Errors::SocketError
+        nil
+      end
+
+      new_attributes = data.attributes
+      merge_attributes(new_attributes)
+      self
+    end
+
+    def to_json
+      require 'json'
+      attributes.to_json
+    end
+
+    def wait_for(timeout=600, interval=1, &block)
+      reload
+      retries = 3
+      Fog.wait_for(timeout, interval) do
+        if reload
+          retries = 3
+        elsif retries > 0
+          retries -= 1
+          sleep(1)
+        elsif retries == 0
+          raise Fog::Errors::Error.new("Reload failed, #{self.class} #{self.identity} went away.")
+        end
+        instance_eval(&block)
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/parser.rb b/vendor/fog-0.8.2/lib/fog/core/parser.rb
new file mode 100644
index 0000000..9ef3f0b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/parser.rb
@@ -0,0 +1,103 @@
+require 'nokogiri'
+
+module Fog
+  module Parsers
+    class Base < Nokogiri::XML::SAX::Document
+
+      attr_reader :response
+
+      def initialize
+        reset
+      end
+
+      def attr_value(name, attrs)
+        (entry = attrs.detect {|a, v| a == name }) && entry.last
+      end
+
+      def reset
+        @response = {}
+      end
+
+      def characters(string)
+        @value ||= ''
+        @value << string
+      end
+
+      def start_element(name, attrs = [])
+        @value = nil
+      end
+
+      def value
+        @value && @value.dup
+      end
+
+    end
+  end
+end
+
+module Fog
+  class ToHashDocument < Nokogiri::XML::SAX::Document
+
+    def initialize
+      @stack = []
+    end
+
+    def characters(string)
+      @value ||= ''
+      @value << string.strip
+    end
+
+    def end_element(name)
+      last = @stack.pop
+      if last.empty? && @value.empty?
+        @stack.last[name.to_sym] = ''
+      elsif last == {:i_nil=>"true"}
+        @stack.last[name.to_sym] = nil
+      elsif !@value.empty?
+        @stack.last[name.to_sym] = @value
+      end
+      @value = ''
+    end
+
+    def body
+      @stack.first
+    end
+
+    def response
+      body
+    end
+
+    def start_element(name, attributes = [])
+      @value = ''
+      parsed_attributes = {}
+      until attributes.empty?
+        if attributes.first.is_a?(Array)
+          key, value = attributes.shift
+        else
+          key, value = attributes.shift, attributes.shift
+        end
+        parsed_attributes[key.gsub(':','_').to_sym] = value
+      end
+      if @stack.last.is_a?(Array)
+        @stack.last << {name.to_sym => parsed_attributes}
+      else
+        data = if @stack.empty?
+          @stack.push(parsed_attributes)
+          parsed_attributes
+        elsif @stack.last[name.to_sym]
+          unless @stack.last[name.to_sym].is_a?(Array)
+            @stack.last[name.to_sym] = [@stack.last[name.to_sym]]
+          end
+          @stack.last[name.to_sym] << parsed_attributes
+          @stack.last[name.to_sym].last
+        else
+          @stack.last[name.to_sym] = {}
+          @stack.last[name.to_sym].merge!(parsed_attributes)
+          @stack.last[name.to_sym]
+        end
+        @stack.push(data)
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/provider.rb b/vendor/fog-0.8.2/lib/fog/core/provider.rb
new file mode 100644
index 0000000..3df55b7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/provider.rb
@@ -0,0 +1,18 @@
+module Fog
+  module Provider
+
+    def self.extended(base)
+      Fog.providers << base.to_s.split('::').last
+    end
+
+    def service(new_service, path)
+      services << new_service
+      require File.join('fog', path)
+    end
+
+    def services
+      @services ||= []
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/scp.rb b/vendor/fog-0.8.2/lib/fog/core/scp.rb
new file mode 100644
index 0000000..37ceba5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/scp.rb
@@ -0,0 +1,63 @@
+module Fog
+  module SCP
+
+    def self.new(address, username, options = {})
+      if Fog.mocking?
+        Fog::SCP::Mock.new(address, username, options)
+      else
+        Fog::SCP::Real.new(address, username, options)
+      end
+    end
+
+    class Mock
+
+      def self.data
+        @data ||= Hash.new do |hash, key|
+          hash[key] = {}
+        end
+      end
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options
+      end
+
+      def upload(local_path, remote_path)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+    class Real
+
+      def initialize(address, username, options)
+        require 'net/scp'
+
+        key_manager = Net::SSH::Authentication::KeyManager.new(nil, options)
+
+        unless options[:key_data] || options[:keys] || options[:password] || key_manager.agent
+          raise ArgumentError.new(':key_data, :keys, :password or a loaded ssh-agent is required to initialize SSH')
+        end
+
+        @address  = address
+        @username = username
+        @options  = { :paranoid => false }.merge(options)
+      end
+
+      def upload(local_path, remote_path)
+        begin
+          Net::SCP.start(@address, @username, @options) do |scp|
+            scp.upload!(local_path, remote_path) do |ch, name, sent, total|
+              # TODO: handle progress display?
+            end
+          end
+        rescue Exception => error
+          raise error
+        end
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/service.rb b/vendor/fog-0.8.2/lib/fog/core/service.rb
new file mode 100644
index 0000000..9d187ab
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/service.rb
@@ -0,0 +1,167 @@
+module Fog
+  class Service
+
+    class Error < Fog::Errors::Error; end
+    class NotFound < Fog::Errors::NotFound; end
+
+    module Collections
+
+      def collections
+        service.collections
+      end
+
+      def mocked_requests
+        service.mocked_requests
+      end
+
+      def requests
+        service.requests
+      end
+
+    end
+
+    class << self
+
+      def inherited(child)
+        child.class_eval <<-EOS, __FILE__, __LINE__
+          module Collections
+            include Fog::Service::Collections
+
+            def service
+              #{child}
+            end
+          end
+
+          def self.service
+            #{child}
+          end
+        EOS
+      end
+
+      def new(options={})
+        # attempt to load credentials from config file
+        begin
+          default_credentials = Fog.credentials.reject {|key, value| !(recognized | requirements).include?(key)}
+          options = default_credentials.merge(options)
+        rescue LoadError
+          # if there are no configured credentials, do nothing
+        end
+
+        validate_options(options)
+        setup_requirements
+
+        if Fog.mocking?
+          service::Mock.send(:include, service::Collections)
+          service::Mock.new(options)
+        else
+          service::Real.send(:include, service::Collections)
+          service::Real.new(options)
+        end
+      end
+
+      def setup_requirements
+        if superclass.respond_to?(:setup_requirements)
+          superclass.setup_requirements
+        end
+
+        @required ||= false
+        unless @required
+          for collection in collections
+            require [@model_path, collection].join('/')
+            constant = collection.to_s.split('_').map {|characters| characters[0...1].upcase << characters[1..-1]}.join('')
+            service::Collections.module_eval <<-EOS, __FILE__, __LINE__
+              def #{collection}(attributes = {})
+                #{service}::#{constant}.new({:connection => self}.merge(attributes))
+              end
+            EOS
+          end
+          for model in models
+            require [@model_path, model].join('/')
+          end
+          for request in requests
+            require [@request_path, request].join('/')
+            if service::Mock.method_defined?(request)
+              mocked_requests << request
+            else
+              service::Mock.module_eval <<-EOS, __FILE__, __LINE__
+                def #{request}(*args)
+                  Fog::Mock.not_implemented
+                end
+              EOS
+            end
+          end
+          @required = true
+        end
+      end
+
+      def model_path(new_path)
+        @model_path = new_path
+      end
+
+      def collection(new_collection)
+        collections << new_collection
+      end
+
+      def collections
+        @collections ||= []
+      end
+
+      def mocked_requests
+        @mocked_requests ||= []
+      end
+
+      def model(new_model)
+        models << new_model
+      end
+
+      def models
+        @models ||= []
+      end
+
+      def request_path(new_path)
+        @request_path = new_path
+      end
+
+      def request(new_request)
+        requests << new_request
+      end
+
+      def requests
+        @requests ||= []
+      end
+
+      def requires(*args)
+        requirements.concat(args)
+      end
+
+      def requirements
+        @requirements ||= []
+      end
+
+      def recognizes(*args)
+        recognized.concat(args)
+      end
+
+      def recognized
+        @recognized ||= []
+      end
+
+      def validate_options(options)
+        missing = requirements - options.keys
+        unless missing.empty?
+          raise ArgumentError, "Missing required arguments: #{missing.join(', ')}"
+        end
+
+        unless recognizes.empty?
+          unrecognized = options.keys - requirements - recognized
+          unless unrecognized.empty?
+            raise ArgumentError, "Unrecognized arguments: #{unrecognized.join(', ')}"
+          end
+        end
+      end
+
+    end
+
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/core/ssh.rb b/vendor/fog-0.8.2/lib/fog/core/ssh.rb
new file mode 100644
index 0000000..93ab9bf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/ssh.rb
@@ -0,0 +1,115 @@
+module Fog
+  module SSH
+
+    def self.new(address, username, options = {})
+      if Fog.mocking?
+        Fog::SSH::Mock.new(address, username, options)
+      else
+        Fog::SSH::Real.new(address, username, options)
+      end
+    end
+
+    class Mock
+
+      def self.data
+        @data ||= Hash.new do |hash, key|
+          hash[key] = {}
+        end
+      end
+
+      def initialize(address, username, options)
+        @address  = address
+        @username = username
+        @options  = options
+      end
+
+      def run(commands)
+        Fog::Mock.not_implemented
+      end
+
+    end
+
+    class Real
+
+      def initialize(address, username, options)
+        require 'net/ssh'
+
+        key_manager = Net::SSH::Authentication::KeyManager.new(nil, options)
+
+        unless options[:key_data] || options[:keys] || options[:password] || key_manager.agent
+          raise ArgumentError.new(':key_data, :keys, :password or a loaded ssh-agent is required to initialize SSH')
+        end
+
+        @address  = address
+        @username = username
+        @options  = { :paranoid => false }.merge(options)
+      end
+
+      def run(commands)
+        commands = [*commands]
+        results  = []
+        begin
+          Net::SSH.start(@address, @username, @options) do |ssh|
+            commands.each do |command|
+              result = Result.new(command)
+              ssh.open_channel do |ssh_channel|
+                ssh_channel.request_pty
+                ssh_channel.exec(command) do |channel, success|
+                  unless success
+                    raise "Could not execute command: #{command.inspect}"
+                  end
+
+                  channel.on_data do |ch, data|
+                    result.stdout << data
+                  end
+
+                  channel.on_extended_data do |ch, type, data|
+                    next unless type == 1
+                    result.stderr << data
+                  end
+
+                  channel.on_request('exit-status') do |ch, data|
+                    result.status = data.read_long
+                  end
+
+                  channel.on_request('exit-signal') do |ch, data|
+                    result.status = 255
+                  end
+                end
+              end
+              ssh.loop
+              results << result
+            end
+          end
+        rescue Net::SSH::HostKeyMismatch => exception
+          exception.remember_host!
+          sleep 0.2
+          retry
+        end
+        results
+      end
+
+    end
+
+    class Result
+
+      attr_accessor :command, :stderr, :stdout, :status
+
+      def display_stdout
+        Formatador.display_line(stdout.split("\r\n"))
+      end
+
+      def display_stderr
+        Formatador.display_line(stderr.split("\r\n"))
+      end
+
+      def initialize(command)
+        @command = command
+        @stderr = ''
+        @stdout = ''
+      end
+
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/time.rb b/vendor/fog-0.8.2/lib/fog/core/time.rb
new file mode 100644
index 0000000..d73452d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/time.rb
@@ -0,0 +1,27 @@
+module Fog
+  class Time < ::Time
+
+    DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
+    MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
+
+    def self.now
+      at((::Time.now - offset).to_i)
+    end
+
+    def self.now=(new_now)
+      old_now = ::Time.now
+      @offset = old_now - new_now
+      new_now
+    end
+
+    def self.offset
+      @offset ||= 0
+    end
+
+    def to_date_header
+      now = self.class.now.utc
+      now.strftime("#{DAYS[now.wday]}, %d #{MONTHS[now.month - 1]} %Y %H:%M:%S +0000")
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/core/wait_for.rb b/vendor/fog-0.8.2/lib/fog/core/wait_for.rb
new file mode 100644
index 0000000..3a9133b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/core/wait_for.rb
@@ -0,0 +1,17 @@
+module Fog
+
+  def self.wait_for(timeout=600, interval=1, &block)
+    duration = 0
+    start = Time.now
+    until yield || duration > timeout
+      sleep(interval)
+      duration = Time.now - start
+    end
+    if duration > timeout
+      false
+    else
+      { :duration => duration }
+    end
+  end
+  
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/dns.rb b/vendor/fog-0.8.2/lib/fog/dns.rb
new file mode 100644
index 0000000..1842107
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns.rb
@@ -0,0 +1,31 @@
+module Fog
+  class DNS
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes[:provider] # attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/dns/aws'
+        Fog::AWS::DNS.new(attributes)
+      when 'Bluebox'
+        require 'fog/dns/bluebox'
+        Fog::Bluebox::DNS.new(attributes)
+      when 'DNSimple'
+        require 'fog/dns/dnsimple'
+        Fog::DNSimple::DNS.new(attributes)
+      when 'Linode'
+        require 'fog/dns/linode'
+        Fog::Linode::DNS.new(attributes)
+      when 'Slicehost'
+        require 'fog/dns/slicehost'
+        Fog::Slicehost::DNS.new(attributes)
+      when 'Zerigo'
+        require 'fog/dns/zerigo'
+        Fog::Zerigo::DNS.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized dns provider")
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/aws.rb b/vendor/fog-0.8.2/lib/fog/dns/aws.rb
new file mode 100644
index 0000000..03bc758
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/aws.rb
@@ -0,0 +1,131 @@
+module Fog
+  module AWS
+    class DNS < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :host, :path, :port, :scheme, :version, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/aws'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/aws'
+      request :create_hosted_zone
+      request :get_hosted_zone
+      request :delete_hosted_zone
+      request :list_hosted_zones
+      request :change_resource_record_sets
+      request :list_resource_record_sets
+      request :get_change
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::DNS.new is deprecated, use Fog::DNS.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @aws_access_key_id  = options[:aws_access_key_id]
+          @region             = options[:region]
+        end
+
+        def data
+          self.class.data[@region][@aws_access_key_id]
+        end
+
+        def reset_data
+          self.class.data[@region].delete(@aws_access_key_id)
+        end
+
+        def signature(params)
+          "foo"
+        end
+      end
+
+      class Real
+
+        # Initialize connection to Route 53 DNS service
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   dns = Fog::AWS::DNS.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * dns object with connection to aws.
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::DNS.new is deprecated, use Fog::DNS.new(:provider => 'DNS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac     = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          @host     = options[:host]      || 'route53.amazonaws.com'
+          @path     = options[:path]      || '/'
+          @port     = options[:port]      || 443
+          @scheme   = options[:scheme]    || 'https'
+          @version  = options[:version]  || '2010-10-01'
+          unless options.has_key?(:persistent)
+            options[:persistent] = true
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers] ||= {}
+          params[:headers]['Date'] = Fog::Time.now.to_date_header
+          params[:headers]['X-Amzn-Authorization'] = "AWS3-HTTPS AWSAccessKeyId=#{@aws_access_key_id},Algorithm=HmacSHA1,Signature=#{signature(params)}"
+          params[:path] = "/#{@version}/#{params[:path]}" 
+          @connection.request(params, &block)
+        end
+
+        def signature(params)
+          string_to_sign = params[:headers]['Date']
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/bluebox.rb b/vendor/fog-0.8.2/lib/fog/dns/bluebox.rb
new file mode 100644
index 0000000..7b1ed82
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/bluebox.rb
@@ -0,0 +1,114 @@
+module Fog
+  module Bluebox
+    class DNS < Fog::Service
+      requires :bluebox_api_key, :bluebox_customer_id
+      recognizes :bluebox_host, :bluebox_port, :bluebox_scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/bluebox'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/bluebox'
+      request :create_record
+      request :update_record
+      request :delete_record
+      request :create_zone
+      request :update_zone
+      request :delete_zone
+      request :get_record
+      request :get_records
+      request :get_zone
+      request :get_zones
+
+      class Mock
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Bluebox::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Bluebox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @bluebox_customer_id = options[:bluebox_customer_id]
+          @bluebox_api_key = options[:bluebox_api_key]
+        end
+
+        def data
+          self.class.data[@bluebox_customer_id]
+        end
+
+        def reset_data
+          self.class.data.delete(@bluebox_customer_id)
+        end
+      end
+
+      class Real
+        def initialize(options ={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Bluebox::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Bluebox') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @bluebox_customer_id = options[:bluebox_customer_id]
+          @bluebox_api_key = options[:bluebox_api_key]
+
+          @host   = options[:bluebox_host]    || "boxpanel.bluebox.net"
+          @port   = options[:bluebox_port]    || 443
+          @scheme = options[:bluebox_scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+
+          params[:headers]['Authorization'] = "Basic #{auth_header}"
+
+          params[:headers]['Accept'] = 'application/xml'
+          case params[:method]
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Bluebox::DNS::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+        protected
+
+        def auth_header
+          @auth_header ||= Base64.encode64("#{@bluebox_customer_id}:#{@bluebox_api_key}").gsub("\n",'')
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/dns/dnsimple.rb b/vendor/fog-0.8.2/lib/fog/dns/dnsimple.rb
new file mode 100644
index 0000000..d2005b1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/dnsimple.rb
@@ -0,0 +1,107 @@
+module Fog
+  module DNSimple
+    class DNS < Fog::Service
+
+      requires :dnsimple_email, :dnsimple_password
+      recognizes :dnsimple_url, :host, :path, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/dnsimple'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/dnsimple'
+      request :list_domains
+      request :create_domain
+      request :get_domain
+      request :delete_domain
+      request :create_record
+      request :list_records
+      request :update_record
+      request :delete_record
+      request :get_record
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::DNS::DNSimple.new is deprecated, use Fog::DNS.new(:provider => 'DNSimple') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @dnsimple_email = options[:dnsimple_email]
+          @dnsimple_password  = options[:dnsimple_password]
+        end
+
+        def data
+          self.class.data[@dnsimple_email]
+        end
+
+        def reset_data
+          self.class.data.delete(@dnsimple_email)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::DNSimple::DNS.new is deprecated, use Fog::DNS.new(:provider => 'DNSimple') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+
+          @dnsimple_email = options[:dnsimple_email]
+          @dnsimple_password  = options[:dnsimple_password]
+          if options[:dnsimple_url]
+            uri = URI.parse(options[:dnsimple_url])
+            options[:host]    = uri.host
+            options[:port]    = uri.port
+            options[:scheme]  = uri.scheme
+          end
+          @host   = options[:host]    || "dnsimple.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          key = "#{@dnsimple_email}:#{@dnsimple_password}"
+          params[:headers].merge!({ "Authorization" => "Basic " + Base64.encode64(key).chomp,
+                                    "Accept" => "application/json",
+                                    "Content-Type" => "application/json" })
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/linode.rb b/vendor/fog-0.8.2/lib/fog/dns/linode.rb
new file mode 100644
index 0000000..96b7800
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/linode.rb
@@ -0,0 +1,104 @@
+module Fog
+  module Linode
+    class DNS < Fog::Service
+
+      requires :linode_api_key
+      recognizes :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/linode'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/linode'
+      request :domain_create
+      request :domain_delete
+      request :domain_list
+      request :domain_update
+      request :domain_resource_create
+      request :domain_resource_delete
+      request :domain_resource_list
+      request :domain_resource_update
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Linode::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Linode') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @linode_api_key = options[:linode_api_key]
+        end
+
+        def data
+          self.class.data[@linode_api_key]
+        end
+
+        def reset_data
+          self.class.data.delete(@linode_api_key)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Linode::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Linode') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'json'
+          @linode_api_key = options[:linode_api_key]
+          @host   = options[:host]    || "api.linode.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:query] ||= {}
+          params[:query].merge!(:api_key => @linode_api_key)
+
+          response = @connection.request(params.merge!({:host => @host}))
+
+          unless response.body.empty?
+            response.body = JSON.parse(response.body)
+            if data = response.body['ERRORARRAY'].first
+              error = case data['ERRORCODE']
+              when 5
+                Fog::Linode::DNS::NotFound
+              else
+                Fog::Linode::DNS::Error
+              end
+              raise error.new(data['ERRORMESSAGE'])
+            end
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/aws/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/aws/record.rb
new file mode 100644
index 0000000..299b5f6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/aws/record.rb
@@ -0,0 +1,64 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id,           :aliases => ['Id']
+
+        attribute :ip,          :aliases => ['ResourceRecords']
+        attribute :name,        :aliases => ['Name']
+        attribute :ttl,         :aliases => ['TTL']
+        attribute :type,        :aliases => ['Type']
+        attribute :status,      :aliases => ['Status']
+        attribute :created_at,  :aliases => ['SubmittedAt']
+
+        def initialize(attributes={})
+          self.ttl ||= 3600
+          super
+        end
+
+        def destroy
+          requires :ip, :name, :ttl, :type, :zone
+          options = {
+            :action           => 'DELETE',
+            :name             => name,
+            :resource_records => [*ip],
+            :ttl              => ttl,
+            :type             => type
+          }
+          connection.change_resource_record_sets(zone.id, [options])
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :ip, :name, :ttl, :type, :zone
+          options = {
+            :action           => 'CREATE',
+            :name             => name,
+            :resource_records => [*ip],
+            :ttl              => ttl,
+            :type             => type
+          }
+          data = connection.change_resource_record_sets(zone.id, [options]).body
+          merge_attributes(data)
+          true
+        end
+
+        private
+
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/aws/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/aws/records.rb
new file mode 100644
index 0000000..e341a40
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/aws/records.rb
@@ -0,0 +1,49 @@
+require 'fog/core/collection'
+require 'fog/dns/models/aws/record'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :is_truncated,      :aliases => ['IsTruncated']
+        attribute :max_items,         :aliases => ['MaxItems']
+        attribute :name
+        attribute :next_record_name,  :aliases => ['NextRecordName']
+        attribute :next_record_type,  :aliases => ['NextRecordType']
+        attribute :type
+
+        attribute :zone
+
+        model Fog::AWS::DNS::Record
+
+        def all(options = {})
+          requires :zone
+          options['MaxItems'] ||= max_items
+          options['Name']     ||= name
+          options['Type']     ||= type
+          data = connection.list_resource_record_sets(zone.id, options).body
+          merge_attributes(data.reject {|key, value| !['IsTruncated', 'MaxItems', 'NextRecordName', 'NextRecordType'].include?(key)})
+          # leave out the default, read only records
+          data = data['ResourceRecordSets'].reject {|record| ['NS', 'SOA'].include?(record['Type'])}
+          load(data)
+        end
+
+        def get(record_id)
+          data = connection.get_change(record_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/aws/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/aws/zone.rb
new file mode 100644
index 0000000..6ff5be4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/aws/zone.rb
@@ -0,0 +1,53 @@
+require 'fog/core/model'
+# require 'fog/dns/models/aws/records'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id,                 :aliases => 'Id'
+
+        attribute :caller_reference,  :aliases => 'CallerReference'
+        attribute :change_info,       :aliases => 'ChangeInfo'
+        attribute :description,       :aliases => 'Comment'
+        attribute :domain,            :aliases => 'Name'
+        attribute :nameservers,       :aliases => 'NameServers'
+
+        def destroy
+          requires :identity
+          connection.delete_hosted_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::AWS::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def save
+          requires :domain
+          options = {}
+          options[:caller_ref]  = caller_reference if caller_reference
+          options[:comment]     = description if description
+          data = connection.create_hosted_zone(domain, options).body
+          merge_attributes(data)
+          true
+        end
+
+        private
+
+        define_method(:HostedZone=) do |new_hosted_zone|
+          merge_attributes(new_hosted_zone)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/aws/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/aws/zones.rb
new file mode 100644
index 0000000..86fdc90
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/aws/zones.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/dns/models/aws/zone'
+
+module Fog
+  module AWS
+    class DNS
+
+      class Zones < Fog::Collection
+
+        attribute :marker,    :aliases => 'Marker'
+        attribute :max_items, :aliases => 'MaxItems'
+
+        model Fog::AWS::DNS::Zone
+
+        def all(options = {})
+          options['marker']   ||= marker
+          options['maxitems'] ||= max_items
+          data = connection.list_hosted_zones(options).body['HostedZones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_hosted_zone(zone_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/record.rb
new file mode 100644
index 0000000..962c705
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/record.rb
@@ -0,0 +1,52 @@
+require 'fog/core/model'
+
+module Fog
+  module Bluebox
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :domain_id,   :aliases => 'domain-id'
+        attribute :domain
+        attribute :type
+        attribute :ip,          :aliases => 'content'
+
+        def initialize(attributes={})
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_record(@zone.identity, identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :zone, :type, :name, :ip
+          data = unless identity
+            connection.create_record(zone.identity, type, name, ip)
+          else
+            connection.update_record(zone.identity, identity, {:type => type, :name => name, :content => ip})
+          end
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/records.rb
new file mode 100644
index 0000000..dd93548
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/records.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/dns/models/bluebox/record'
+
+module Fog
+  module Bluebox
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Bluebox::DNS::Record
+
+        def all
+          requires :zone
+          data = connection.get_records(zone.identity).body['records']
+          load(data)
+        end
+
+        def get(record_id)
+          data = connection.get_record(zone.identity, record_id).body
+          new(data)
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zone.rb
new file mode 100644
index 0000000..f7ee6c1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zone.rb
@@ -0,0 +1,64 @@
+require 'fog/core/model'
+require 'fog/dns/models/bluebox/records'
+
+module Fog
+  module Bluebox
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :domain,        :aliases => 'name'
+        attribute :serial
+        attribute :ttl
+        attribute :retry
+        attribute :expires
+        attribute :record_count,  :aliases => 'record-count'
+        attribute :refresh
+        attribute :minimum
+
+        def initialize(attributes = {})
+          self.ttl ||= 3600
+          super(attributes)
+        end
+
+        def destroy
+          raise Fog::Errors::Error.new('Not implemented')
+        end
+
+        def records
+          @records ||= begin
+            Fog::Bluebox::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'ns1.blueblxgrid.com',
+            'ns2.blueblxgrid.com',
+            'ns3.blueblxgrid.com'
+          ]
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_zone(identity)
+          true
+        end
+
+        def save
+          requires :domain, :ttl
+          options = attributes.dup
+          options[:name] = options.delete(:domain)
+          data = identity.nil? ? connection.create_zone(options) : connection.update_zone(identity, options)
+          merge_attributes(data.body)
+          true
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zones.rb
new file mode 100644
index 0000000..3a6ac9b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/bluebox/zones.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/dns/models/bluebox/zone'
+
+module Fog
+  module Bluebox
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Bluebox::DNS::Zone
+
+        def all
+          data = connection.get_zones.body['zones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_zone(zone_id).body
+          new(data)
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/record.rb
new file mode 100644
index 0000000..b7f4917
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/record.rb
@@ -0,0 +1,64 @@
+require 'fog/core/model'
+
+module Fog
+  module DNSimple
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :ip,          :aliases => "content"
+        attribute :ttl
+        attribute :created_at
+        attribute :updated_at
+        attribute :zone_id,     :aliases => "domain_id"
+        attribute :type,        :aliases => "record_type"
+        attribute :priority,    :aliases => "prio"
+
+        def initialize(attributes={})
+          self.ttl ||= 3600
+          super
+        end
+
+        def destroy
+          connection.delete_record(zone.domain, identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :name, :type, :ip
+          options = {}
+          options[:prio] = priority if priority
+          options[:ttl]  = ttl if ttl
+
+          # decide whether its a new record or update of an existing
+          if id.nil?
+            data = connection.create_record(zone.domain, name, type, ip, options)
+          else
+            options[:name] = name if name
+            options[:content] = ip if ip
+            options[:type] = type if type
+            data = connection.update_record(zone.domain, id, options)
+          end
+          
+          merge_attributes(data.body["record"])
+          true
+        end
+
+        private
+
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/records.rb
new file mode 100644
index 0000000..3caf1f6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/records.rb
@@ -0,0 +1,38 @@
+require 'fog/core/collection'
+require 'fog/dns/models/dnsimple/record'
+
+module Fog
+  module DNSimple
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::DNSimple::DNS::Record
+
+        def all
+          requires :zone
+          clear
+          data = connection.list_records(zone.id).body.map {|record| record['record']}
+          load(data)
+        end
+
+        def get(record_id)
+          requires :zone
+          data = connection.get_record(zone.id, record_id).body["record"]
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zone.rb
new file mode 100644
index 0000000..decee56
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zone.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+require 'fog/dns/models/dnsimple/records'
+
+module Fog
+  module DNSimple
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :domain,     :aliases => 'name'
+        attribute :created_at
+        attribute :updated_at
+
+        def destroy
+          connection.delete_domain(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+                         Fog::DNSimple::DNS::Records.new(
+                                                    :zone       => self,
+                                                    :connection => connection
+                                                    )
+                       end
+        end
+
+        def nameservers
+          [
+           "ns1.dnsimple.com",
+           "ns2.dnsimple.com",
+           "ns3.dnsimple.com",
+           "ns4.dnsimple.com",
+          ]
+        end
+
+        def save
+          requires :domain
+          data = connection.create_domain(domain).body["domain"]
+          merge_attributes(data)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zones.rb
new file mode 100644
index 0000000..77c5241
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/dnsimple/zones.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/dns/models/dnsimple/zone'
+
+module Fog
+  module DNSimple
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::DNSimple::DNS::Zone
+
+        def all
+          clear
+          data = connection.list_domains.body.map {|zone| zone['domain']}
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_domain(zone_id).body['domain']
+          new(data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/linode/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/linode/record.rb
new file mode 100644
index 0000000..300e634
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/linode/record.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id,         :aliases => ['ResourceID', 'RESOURCEID']
+
+        attribute :ip,        :aliases => 'TARGET'
+        attribute :name,      :aliases => 'NAME'
+        attribute :priority,  :aliases => 'PRIORITY'
+        attribute :ttl,       :aliases => 'TTL_SEC'
+        attribute :type,      :aliases => 'TYPE'
+        attribute :zone_id,   :aliases => 'DOMAINID'
+
+        # "PROTOCOL":"",
+        # "WEIGHT":0,
+        # "PORT":0,
+
+        def initialize(attributes={})
+          self.ttl    ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity, :zone
+          connection.domain_resource_delete(zone.id, identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :type, :zone
+          options = {}
+          # * options<~Hash>
+          #   * weight<~Integer>: default: 5
+          #   * port<~Integer>: default: 80 
+          #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+          #                        types. default: udp
+          options[:name]      = name if name
+          options[:priority]  = priority if priority
+          options[:target]    = ip if ip
+          options[:ttl_sec]   = ttl if ttl
+          response = unless identity
+            connection.domain_resource_create(zone.identity, type, options)
+          else
+            options[:type] = type if type
+            connection.domain_resource_update(zone.identity, identity, options)
+          end
+          merge_attributes(response.body['DATA'])
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/linode/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/linode/records.rb
new file mode 100644
index 0000000..d28830a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/linode/records.rb
@@ -0,0 +1,37 @@
+require 'fog/core/collection'
+require 'fog/dns/models/linode/record'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Linode::DNS::Record
+
+        def all
+          requires :zone
+          data = connection.domain_resource_list(zone.id).body['DATA']
+          load(data)
+        end
+
+        def get(record_id)
+          if data = connection.domain_resource_list(zone.id, record_id).body['DATA'].first
+            new(data)
+          else
+            nil
+          end
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/linode/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/linode/zone.rb
new file mode 100644
index 0000000..99646f7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/linode/zone.rb
@@ -0,0 +1,84 @@
+require 'fog/core/model'
+require 'fog/dns/models/linode/records'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id,           :aliases => ['DomainID', 'DOMAINID', 'ResourceID']
+
+        attribute :description, :aliases => 'DESCRIPTION'
+        attribute :domain,      :aliases => 'DOMAIN'
+        attribute :email,       :aliases => 'SOA_EMAIL'
+        attribute :ttl,         :aliases => 'TTL_SEC'
+        attribute :type,        :aliases => 'TYPE'
+
+        # "STATUS":1,
+        # "RETRY_SEC":0,
+        # "MASTER_IPS":"",
+        # "EXPIRE_SEC":0,
+        # "REFRESH_SEC":0,
+        # "TTL_SEC":0
+
+        def initialize(attributes={})
+          self.type ||= 'master'
+          self.ttl  ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.domain_delete(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Linode::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'ns1.linode.com',
+            'ns2.linode.com',
+            'ns3.linode.com',
+            'ns4.linode.com',
+            'ns5.linode.com'
+          ]
+        end
+
+        def save
+          requires :domain, :type
+          requires :email if type == 'master'
+          options = {}
+          # * options<~Hash>
+          #   * refresh_sec<~Integer> numeric, default: '0'
+          #   * retry_sec<~Integer> numeric, default: '0'
+          #   * expire_sec<~Integer> numeric, default: '0'
+          #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+          #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated
+          options[:description] = description if description
+          options[:soa_email]   = email if email
+          options[:ttl_sec]     = ttl if ttl
+          response = unless identity
+            connection.domain_create(domain, type, options)
+          else
+            options[:domain]  = domain if domain
+            options[:type]    = type if type
+            connection.domain_update(identity, options)
+          end
+          merge_attributes(response.body['DATA'])
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/linode/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/linode/zones.rb
new file mode 100644
index 0000000..18e13e5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/linode/zones.rb
@@ -0,0 +1,29 @@
+require 'fog/core/collection'
+require 'fog/dns/models/linode/zone'
+
+module Fog
+  module Linode
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Linode::DNS::Zone
+
+        def all
+          data = connection.domain_list.body['DATA']
+          load(data)
+        end
+
+        def get(zone_id)
+          if data = connection.domain_list(zone_id).body['DATA'].first
+            new(data)
+          else
+            nil
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/record.rb
new file mode 100644
index 0000000..977e3a5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/record.rb
@@ -0,0 +1,66 @@
+require 'fog/core/model'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :active
+        attribute :ip,          :aliases => 'ip'
+        attribute :name
+        attribute :description, :aliases => 'aux'
+        attribute :ttl
+        attribute :type,        :aliases => 'record_type'
+        attribute :zone_id
+
+        def initialize(attributes={})
+          self.active ||= true
+          self.ttl    ||= 3600
+          super
+        end
+
+        def active=(new_active)
+          attributes[:active] = case new_active
+          when false, 'N'
+            false
+          when true, 'Y'
+            true
+          end
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_record(identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :ip, :name, :type, :zone
+          options = {}
+          options[:active]  = active ? 'Y' : 'N'
+          options[:aux]     = description if description
+          options[:ttl]     = ttl if ttl
+          data = connection.create_record(type, zone.id, name, ip, options)
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/records.rb
new file mode 100644
index 0000000..0160221
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/records.rb
@@ -0,0 +1,36 @@
+require 'fog/core/collection'
+require 'fog/dns/models/slicehost/record'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Slicehost::DNS::Record
+
+        def all
+          requires :zone
+          data = connection.get_records.body['records']
+          load(data).reject {|record| record.zone_id != zone.id}
+        end
+
+        def get(record_id)
+          data = connection.get_record(record_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zone.rb
new file mode 100644
index 0000000..b30dab8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zone.rb
@@ -0,0 +1,69 @@
+require 'fog/core/model'
+require 'fog/dns/models/slicehost/records'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :active
+        attribute :domain, :aliases => 'origin'
+        attribute :ttl
+
+        def initialize(attributes={})
+          self.active ||= true
+          self.ttl    ||= 3600
+          super
+        end
+
+        def active=(new_active)
+          attributes[:active] = case new_active
+          when false, 'N'
+            false
+          when true, 'Y'
+            true
+          end
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Slicehost::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'ns1.slicehost.net',
+            'ns2.slicehost.net',
+            'ns3.slicehost.net'
+          ]
+        end
+
+        def save
+          raise Fog::Errors::Error.new('Resaving an existing object may create a duplicate') if identity
+          requires :active, :domain, :ttl
+          options = {}
+          options[:active]  = active ? 'Y' : 'N'
+          options[:ttl]     = ttl
+          data = connection.create_zone(domain, options)
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zones.rb
new file mode 100644
index 0000000..82abcf6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/slicehost/zones.rb
@@ -0,0 +1,28 @@
+require 'fog/core/collection'
+require 'fog/dns/models/slicehost/zone'
+
+module Fog
+  module Slicehost
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Slicehost::DNS::Zone
+
+        def all
+          data = connection.get_zones.body['zones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_zone(zone_id).body
+          new(data)
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/record.rb b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/record.rb
new file mode 100644
index 0000000..4ad8aa9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/record.rb
@@ -0,0 +1,65 @@
+require 'fog/core/model'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Record < Fog::Model
+
+        identity :id
+
+        attribute :created_at,  :aliases => 'created-at'
+        attribute :ip,          :aliases => 'data'
+        attribute :domain,      :aliases => 'fqdn'
+        attribute :name,        :aliases => 'hostname'
+        attribute :description, :aliases => 'notes'
+        attribute :priority
+        attribute :ttl
+        attribute :type,        :aliases => 'host-type'
+        attribute :updated_at,  :aliases => 'updated-at'
+        attribute :zone_id,     :aliases => 'zone-id'
+
+        def initialize(attributes={})
+          self.ttl    ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_host(identity)
+          true
+        end
+
+        def zone
+          @zone
+        end
+
+        def save
+          requires :zone, :type, :ip
+          options = {}
+          options[:hostname]  = name if name
+          options[:notes]     = description if description
+          options[:priority]  = priority if priority
+          options[:ttl]       = ttl if ttl
+          data = unless identity
+            connection.create_host(@zone.id, type, ip, options)
+          else
+            options[:host_type] = type
+            options[:data]      = data
+            connection.update_host(identity, options)
+          end
+          merge_attributes(data.body)
+          true
+        end
+
+        private
+        
+        def zone=(new_zone)
+          @zone = new_zone
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/records.rb b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/records.rb
new file mode 100644
index 0000000..1e25bb8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/records.rb
@@ -0,0 +1,41 @@
+require 'fog/core/collection'
+require 'fog/dns/models/zerigo/record'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Records < Fog::Collection
+
+        attribute :zone
+
+        model Fog::Zerigo::DNS::Record
+
+        def all
+          requires :zone
+          parent = zone.collection.get(zone.identity)
+          if parent
+            merge_attributes(parent.records.attributes)
+            load(parent.records.map {|record| record.attributes})
+          else
+            nil
+          end
+        end
+
+        def get(record_id)
+          data = connection.get_host(record_id).body
+          new(data)
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :zone
+          super({ :zone => zone }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zone.rb b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zone.rb
new file mode 100644
index 0000000..2b3ca40
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zone.rb
@@ -0,0 +1,88 @@
+require 'fog/core/model'
+require 'fog/dns/models/zerigo/records'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Zone < Fog::Model
+
+        identity :id
+
+        attribute :created_at,  :aliases => 'created-at'
+        attribute :domain
+        attribute :ttl,         :aliases => 'default-ttl'
+        attribute :type,        :aliases => 'ns-type'
+        attribute :updated_at,  :aliases => 'updated-at'
+
+        # <custom-nameservers>ns1.example.com,ns2.example.com</custom-nameservers>
+        # <custom-ns type="boolean">true</custom-ns> 
+        # <hostmaster>dnsadmin@example.com</hostmaster> 
+        # <notes nil="true"/>
+        # <ns1 nil="true"/>
+        # <nx-ttl nil="true"></nx-ttl>
+        # <slave-nameservers nil="true"/>
+        # <tag-list>one two</tag-list>
+        # <hosts-count>1</hosts-count>
+
+        def initialize(attributes={})
+          self.type ||= 'pri_sec'
+          self.ttl  ||= 3600
+          super
+        end
+
+        def destroy
+          requires :identity
+          connection.delete_zone(identity)
+          true
+        end
+
+        def records
+          @records ||= begin
+            Fog::Zerigo::DNS::Records.new(
+              :zone       => self,
+              :connection => connection
+            )
+          end
+        end
+
+        def nameservers
+          [
+            'a.ns.zerigo.net',
+            'b.ns.zerigo.net',
+            'c.ns.zerigo.net',
+            'd.ns.zerigo.net',
+            'e.ns.zerigo.net'
+          ]
+        end
+
+        def save
+          requires :domain, :type, :ttl
+          options = {}
+          # * options<~Hash> - optional paramaters
+          #   * ns1<~String> - required if ns_type == sec
+          #   * nx_ttl<~Integer> -
+          #   * slave_nameservers<~String> - required if ns_type == pri
+          #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+          #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+          #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+          #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+          #   * notes<~String> - notes about the domain
+          #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+          #   * tag_list<~String> - List of all tags associated with this domain
+          data = unless identity
+            connection.create_zone(domain, ttl, type, options)
+          else
+            options[:default_ttl] = ttl
+            options[:ns_type]     = type
+            connection.update_zone(identity, options)
+          end
+          merge_attributes(data.body)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zones.rb b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zones.rb
new file mode 100644
index 0000000..590706e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/models/zerigo/zones.rb
@@ -0,0 +1,30 @@
+require 'fog/core/collection'
+require 'fog/dns/models/zerigo/zone'
+
+module Fog
+  module Zerigo
+    class DNS
+
+      class Zones < Fog::Collection
+
+        model Fog::Zerigo::DNS::Zone
+
+        def all
+          data = connection.list_zones.body['zones']
+          load(data)
+        end
+
+        def get(zone_id)
+          data = connection.get_zone(zone_id).body
+          zone = new(data)
+          zone.records.load(data['hosts'])
+          zone
+        rescue Fog::Service::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/change_resource_record_sets.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/change_resource_record_sets.rb
new file mode 100644
index 0000000..65636c0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/change_resource_record_sets.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ChangeResourceRecordSets < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+          
+          def end_element(name)
+            case name
+            when 'Id'  
+              @response[name] = value.sub('/change/', '')
+            when 'Status', 'SubmittedAt'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/create_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/create_hosted_zone.rb
new file mode 100644
index 0000000..667c4c0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/create_hosted_zone.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class CreateHostedZone < Fog::Parsers::Base
+
+          def reset
+            @hosted_zone = {}
+            @change_info = {}
+            @name_servers = []
+            @response = {}
+            @section = :hosted_zone
+          end
+
+          def end_element(name)
+            if @section == :hosted_zone
+              case name
+              when 'Id'
+                @hosted_zone[name] = value.sub('/hostedzone/', '')
+              when 'Name', 'CallerReference', 'Comment'
+                @hosted_zone[name]= value
+              when 'HostedZone'
+                @response['HostedZone'] = @hosted_zone
+                @hosted_zone = {}
+                @section = :change_info
+              end
+            elsif @section == :change_info
+              case name
+              when 'Id'
+                @change_info[name]= value.sub('/change/', '')
+              when 'Status', 'SubmittedAt'
+                @change_info[name] = value
+              when 'ChangeInfo'
+                @response['ChangeInfo'] = @change_info
+                @change_info = {}
+                @section = :name_servers
+              end
+            elsif @section == :name_servers
+              case name
+              when 'NameServer'
+                @name_servers << value
+              when 'NameServers'
+                @response['NameServers'] = @name_servers
+                @name_servers = {}
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/delete_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/delete_hosted_zone.rb
new file mode 100644
index 0000000..d7aae5d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/delete_hosted_zone.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class DeleteHostedZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+            @response['ChangeInfo'] = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Id', 'Status', 'SubmittedAt'
+              @response['ChangeInfo'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_change.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_change.rb
new file mode 100644
index 0000000..0e0752d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_change.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class GetChange < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+          
+          def end_element(name)
+            case name
+            when 'Id'
+              @response[name] = value.sub('/change/', '')
+            when 'Status', 'SubmittedAt'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_hosted_zone.rb
new file mode 100644
index 0000000..3edab4e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/get_hosted_zone.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class GetHostedZone < Fog::Parsers::Base
+
+          def reset
+            @hosted_zone = {}
+            @name_servers = []
+            @response = {}
+            @section = :hosted_zone
+          end
+
+          def end_element(name)
+            if @section == :hosted_zone
+              case name
+              when 'Id'
+                @hosted_zone[name]= value.sub('/hostedzone/', '')
+              when 'Name', 'CallerReference', 'Comment'
+                @hosted_zone[name]= value
+              when 'HostedZone'
+                @response['HostedZone'] = @hosted_zone
+                @hosted_zone = {}
+                @section = :name_servers
+              end
+            elsif @section == :name_servers
+              case name
+              when 'NameServer'
+                @name_servers << value
+              when 'NameServers'
+                @response['NameServers'] = @name_servers
+                @name_servers = {}
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_hosted_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_hosted_zones.rb
new file mode 100644
index 0000000..657fba7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_hosted_zones.rb
@@ -0,0 +1,37 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ListHostedZones < Fog::Parsers::Base
+
+          def reset
+            @hosted_zones = []
+            @zone = {}
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Id'
+              @zone[name] = value.sub('/hostedzone/', '')
+            when 'Name', 'CallerReference', 'Comment'
+              @zone[name] = value
+            when 'HostedZone'
+              @hosted_zones << @zone
+              @zone = {}
+            when 'HostedZones'
+              @response['HostedZones'] = @hosted_zones
+            when 'MaxItems'
+              @response[name] = value.to_i
+            when 'IsTruncated', 'Marker', 'NextMarker'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_resource_record_sets.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_resource_record_sets.rb
new file mode 100644
index 0000000..8535e93
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/aws/list_resource_record_sets.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module DNS
+
+        class ListResourceRecordSets < Fog::Parsers::Base
+
+          def reset
+            @resource_record = []
+            @resource_record_set = {}
+            @resource_record_set['ResourceRecords'] = []
+            @response = {}
+            @response['ResourceRecordSets'] = []
+            @section = :resource_record_set
+          end
+          
+          def end_element(name)
+            if @section == :resource_record_set
+              case name
+              when 'Name', 'Type', 'TTL'
+                @resource_record_set[name] = value
+              when 'Value'
+                @resource_record_set['ResourceRecords'] << value
+              when 'ResourceRecordSet'
+                @response['ResourceRecordSets'] << @resource_record_set
+                @resource_record_set = {}
+                @resource_record_set['ResourceRecords'] = []
+              when 'ResourceRecordSets'
+                @section = :main
+              end
+            elsif @section == :main
+                case name
+                when 'MaxItems'
+                  @response[name]= value.to_i
+                when 'IsTruncated', 'NextRecordName', 'NextRecordType'
+                  @response[name]= value
+                end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_record.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_record.rb
new file mode 100644
index 0000000..c925a35
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_record.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+
+        class CreateRecord < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'serial', 'ttl', 'retry', 'refresh', 'minimum', 'record-count', 'expires'
+              @response[name] = value.to_i
+            when 'name', 'id'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_zone.rb
new file mode 100644
index 0000000..bac49e0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/create_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+
+        class CreateZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'serial', 'ttl', 'retry', 'refresh', 'minimum', 'record-count', 'expires'
+              @response[name] = value.to_i
+            when 'name', 'id'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_record.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_record.rb
new file mode 100644
index 0000000..f8d3934
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_record.rb
@@ -0,0 +1,21 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+
+        class GetRecord < Fog::Parsers::Base
+
+          def reset
+            @response = { }
+          end
+
+          def end_element(name)
+            @response[name] = value
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_records.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_records.rb
new file mode 100644
index 0000000..2d3854c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_records.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+
+        class GetRecords < Fog::Parsers::Base
+
+          def reset
+            @record = {}
+            @response = { 'records' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'record'
+              @response['records'] << @record
+              @record = {}
+            else
+              @record[name] = value
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zone.rb
new file mode 100644
index 0000000..9aa6878
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zone.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+        class GetZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'serial', 'ttl', 'retry', 'expires', 'record-count', 'refresh', 'minimum'
+              @response[name] = value.to_i
+            when 'name', 'id'
+              @response[name] = value
+            end
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zones.rb
new file mode 100644
index 0000000..2e5c7c9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/bluebox/get_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Bluebox
+      module DNS
+
+        class GetZones < Fog::Parsers::Base
+
+          def reset
+            @zone = {}
+            @response = { 'zones' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'serial', 'ttl', 'retry', 'expires', 'record-count', 'refresh', 'minimum'
+              @zone[name] = value.to_i
+            when 'name', 'id'
+              @zone[name] = value
+            when 'record'
+              @response['zones'] << @zone
+              @zone = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_record.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_record.rb
new file mode 100644
index 0000000..2e7b1a2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_record.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class CreateRecord < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl', 'id'
+              @response[name] = value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_zone.rb
new file mode 100644
index 0000000..a296e99
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/create_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class CreateZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @response[name] = value.to_i
+            when 'origin', 'active'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_record.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_record.rb
new file mode 100644
index 0000000..a51fb2d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_record.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetRecord < Fog::Parsers::Base
+
+          def reset
+            @response = { }
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl'
+              @response[name] = value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_records.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_records.rb
new file mode 100644
index 0000000..049eba9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_records.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetRecords < Fog::Parsers::Base
+
+          def reset
+            @record = {}
+            @response = { 'records' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'zone-id', 'ttl'
+              @record[name] = value.to_i
+            when 'record-type', 'name', 'data', 'active', 'aux'
+              @record[name] = value
+            when 'record'
+              @response['records'] << @record
+              @record = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zone.rb
new file mode 100644
index 0000000..d0af414
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @response[name] = value.to_i
+            when 'origin', 'active'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zones.rb
new file mode 100644
index 0000000..8ae35ef
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/slicehost/get_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Slicehost
+      module DNS
+
+        class GetZones < Fog::Parsers::Base
+
+          def reset
+            @zone = {}
+            @response = { 'zones' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'ttl', 'id'
+              @zone[name] = value.to_i
+            when 'active', 'origin'
+              @zone[name] = value
+            when 'zone'
+              @response['zones'] << @zone
+              @zone = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_hosts.rb
new file mode 100644
index 0000000..479669f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_hosts.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CountHosts < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'count'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_zones.rb
new file mode 100644
index 0000000..931b979
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/count_zones.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CountZones < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'count'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_host.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_host.rb
new file mode 100644
index 0000000..de63b13
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_host.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CreateHost < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @response[name] = value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_zone.rb
new file mode 100644
index 0000000..c03f254
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/create_zone.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class CreateZone < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+              @response[name] = value.to_i
+            when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/find_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/find_hosts.rb
new file mode 100644
index 0000000..0bb9686
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/find_hosts.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class FindHosts < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @response = { 'hosts' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @host[name] = value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @host[name] = value
+            when 'host'
+              @response['hosts'] << @host
+              @host = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_host.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_host.rb
new file mode 100644
index 0000000..bdc510a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_host.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetHost < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @response[name] = value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone.rb
new file mode 100644
index 0000000..a1b77d4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetZone < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @hosts = []
+            @response = {}
+            @in_hosts = false
+          end
+
+          def start_element(name, attrs = [])
+            super(name, attrs)
+            #look out for start of <hosts> section
+            #needed as some of the tags have the same name as the parent <zone> section
+            if name == 'hosts'
+              @in_hosts= true
+            end
+          end
+          
+          def end_element(name)
+            if (@in_hosts)
+              #in hosts part of response
+              case name
+              when 'id', 'priority', 'ttl', 'zone-id'
+                @host[name] = value.to_i
+              when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+                @host[name] = value
+              when 'host'
+                @hosts << @host
+                @host = {}
+              when 'hosts'
+                @response[name] = @hosts
+                @in_hosts = false
+              end
+            else
+              #in zone part of data
+              case name
+              when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+                @response[name] = value.to_i
+              when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+                @response[name] = value
+              end
+            end
+            
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone_stats.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone_stats.rb
new file mode 100644
index 0000000..30649ce
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/get_zone_stats.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class GetZoneStats < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'queries'
+              @response[name] = value.to_i
+            when 'domain', 'period-begin', 'period-end'
+              @response[name] = value
+            end            
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_hosts.rb
new file mode 100644
index 0000000..a4513eb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_hosts.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class ListHosts < Fog::Parsers::Base
+
+          def reset
+            @host = {}
+            @response = { 'hosts' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'id', 'priority', 'ttl', 'zone-id'
+              @host[name] = value.to_i
+            when 'data', 'fqdn', 'host-type', 'hostname', 'notes', 'zone-id', 'created-at', 'updated-at'
+              @host[name] = value
+            when 'host'
+              @response['hosts'] << @host
+              @host = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_zones.rb
new file mode 100644
index 0000000..3c16d5a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/parsers/zerigo/list_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Zerigo
+      module DNS
+
+        class ListZones < Fog::Parsers::Base
+
+          def reset
+            @zone = {}
+            @response = { 'zones' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'default-ttl', 'id', 'nx-ttl', 'hosts-count'
+              @zone[name] = value.to_i
+            when 'created-at', 'custom-nameservers', 'custom-ns', 'domain', 'hostmaster', 'notes', 'ns1', 'ns-type', 'slave-nameservers', 'tag-list', 'updated-at', 'hosts', 'axfr-ips', 'restrict-axfr'
+              @zone[name] = value
+            when 'zone'
+              @response['zones'] << @zone
+              @zone = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/change_resource_record_sets.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/change_resource_record_sets.rb
new file mode 100644
index 0000000..b55651e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/change_resource_record_sets.rb
@@ -0,0 +1,82 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/change_resource_record_sets'
+
+        # Use this action to create or change your authoritative DNS information for a zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - ID of the zone these changes apply to
+        # * options<~Hash>
+        #   * comment<~String> - Any comments you want to include about the change.
+        #   * change_batch<~Array> - The information for a change request
+        #     * changes<~Hash> -
+        #       * action<~String> -  'CREATE' or 'DELETE'
+        #       * name<~String> - This must be a fully-specified name, ending with a final period
+        #       * type<~String> - A | AAAA | CNAME | MX | NS | PTR | SOA | SPF | SRV | TXT 
+        #       * ttl<~Integer> - 
+        #       * resource_record<~String>
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ChangeInfo'<~Hash>
+        #       * 'Id'<~String> - The ID of the request
+        #       * 'Status'<~String> - status of the request - PENDING | INSYNC
+        #       * 'SubmittedAt'<~String> - The date and time the change was made
+        #   * status<~Integer> - 201 when successful
+        def change_resource_record_sets(zone_id, change_batch, options = {})
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          optional_tags = ''
+          options.each { |option, value|
+            case option
+            when :comment
+              optional_tags+= "<Comment>#{value}</Comment>"
+            end
+          }
+          
+          #build XML
+          if change_batch.count > 0
+            
+            changes= "<ChangeBatch>#{optional_tags}<Changes>"
+            
+            change_batch.each { |change_item|
+              action_tag = %Q{<Action>#{change_item[:action]}</Action>}
+              name_tag = %Q{<Name>#{change_item[:name]}</Name>}
+              type_tag = %Q{<Type>#{change_item[:type]}</Type>}
+              ttl_tag = %Q{<TTL>#{change_item[:ttl]}</TTL>}
+              resource_records= change_item[:resource_records]
+              resource_record_tags = ''
+              resource_records.each { |record|
+                resource_record_tags+= %Q{<ResourceRecord><Value>#{record}</Value></ResourceRecord>}
+              }
+              resource_tag=  %Q{<ResourceRecords>#{resource_record_tags}</ResourceRecords>}
+              
+              change_tags = %Q{<Change>#{action_tag}<ResourceRecordSet>#{name_tag}#{type_tag}#{ttl_tag}#{resource_tag}</ResourceRecordSet></Change>}
+              changes+= change_tags
+            }          
+            
+            changes+= '</Changes></ChangeBatch>'
+          end
+
+          body =   %Q{<?xml version="1.0" encoding="UTF-8"?><ChangeResourceRecordSetsRequest xmlns="https://route53.amazonaws.com/doc/2010-10-01/">#{changes}</ChangeResourceRecordSetsRequest>}
+          request({
+            :body       => body,
+            :parser     => Fog::Parsers::AWS::DNS::ChangeResourceRecordSets.new,
+            :expects    => 200,
+            :method     => 'POST',
+            :path       => "hostedzone/#{zone_id}/rrset"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/create_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/create_hosted_zone.rb
new file mode 100644
index 0000000..5fd8fd1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/create_hosted_zone.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/create_hosted_zone'
+
+        # Creates a new hosted zone
+        #
+        # ==== Parameters
+        # * name<~String> - The name of the domain. Must be a fully-specified domain that ends with a period
+        # * options<~Hash>
+        #   * caller_ref<~String> - unique string that identifies the request & allows failed
+        #                           calls to be retried without the risk of executing the operation twice
+        #   * comment<~Integer> -
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZone'<~Hash>:
+        #       * 'Id'<~String> -
+        #       * 'Name'<~String> -
+        #       * 'CallerReference'<~String>
+        #       * 'Comment'<~String> -
+        #     * 'ChangeInfo'<~Hash> -
+        #       * 'Id'<~String>
+        #       * 'Status'<~String>
+        #       * 'SubmittedAt'<~String>
+        #     * 'NameServers'<~Array>
+        #       * 'NameServer'<~String>
+        #   * status<~Integer> - 201 when successful
+        def create_hosted_zone(name, options = {})
+
+          optional_tags = ''
+          if options[:caller_ref]
+              optional_tags+= "<CallerReference>#{options[:caller_ref]}</CallerReference>"
+          else
+            #make sure we have a unique call reference
+            caller_ref = "ref-#{rand(1000000).to_s}"
+            optional_tags+= "<CallerReference>#{caller_ref}</CallerReference>"
+          end
+          if options[:comment]
+              optional_tags+= "<HostedZoneConfig><Comment>#{options[:comment]}</Comment></HostedZoneConfig>"
+          end
+
+          request({
+            :body       => %Q{<?xml version="1.0" encoding="UTF-8"?><CreateHostedZoneRequest xmlns="https://route53.amazonaws.com/doc/2010-10-01/"><Name>#{name}</Name>#{optional_tags}</CreateHostedZoneRequest>},
+            :parser     => Fog::Parsers::AWS::DNS::CreateHostedZone.new,
+            :expects    => 201,
+            :method     => 'POST',
+            :path       => "hostedzone"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/delete_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/delete_hosted_zone.rb
new file mode 100644
index 0000000..c9ab173
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/delete_hosted_zone.rb
@@ -0,0 +1,39 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/delete_hosted_zone'
+
+        # Delete a hosted zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ChangeInfo'<~Hash> -
+        #       * 'Id'<~String> The ID of the request
+        #       * 'Status'<~String> The current state of the hosted zone
+        #       * 'SubmittedAt'<~String> The date and time the change was made
+        #   * status<~Integer> - 200 when successful
+        def delete_hosted_zone(zone_id)
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+          
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::DeleteHostedZone.new,
+            :method     => 'DELETE',
+            :path       => "hostedzone/#{zone_id}"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_change.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_change.rb
new file mode 100644
index 0000000..78ef341
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_change.rb
@@ -0,0 +1,38 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/get_change'
+
+        # returns the current state of a change request
+        #
+        # ==== Parameters
+        # * change_id<~String>
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Id'<~String>
+        #     * 'Status'<~String>
+        #     * 'SubmittedAt'<~String>
+        #   * status<~Integer> - 200 when successful
+        def get_change(change_id)
+
+          # AWS methods return change_ids that looks like '/change/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          change_id = change_id.sub('/change/', '')
+
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::GetChange.new,
+            :method     => 'GET',
+            :path       => "change/#{change_id}"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_hosted_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_hosted_zone.rb
new file mode 100644
index 0000000..5c64888
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/get_hosted_zone.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/get_hosted_zone'
+
+        # retrieve information about a hosted zone
+        #
+        # ==== Parameters
+        # * zone_id<~String> - The ID of the hosted zone
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZone'<~Hash>:
+        #       * 'Id'<~String> - 
+        #       * 'Name'<~String> - 
+        #       * 'CallerReference'<~String>
+        #       * 'Comment'<~String> - 
+        #     * 'NameServers'<~Array>
+        #       * 'NameServer'<~String>
+        #   * status<~Integer> - 201 when successful
+        def get_hosted_zone(zone_id)
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          request({
+            :expects    => 200,
+            :parser     => Fog::Parsers::AWS::DNS::GetHostedZone.new,
+            :method     => 'GET',
+            :path       => "hostedzone/#{zone_id}"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_hosted_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_hosted_zones.rb
new file mode 100644
index 0000000..e0498aa
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_hosted_zones.rb
@@ -0,0 +1,54 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/list_hosted_zones'
+
+        # Describe all or specified instances
+        #
+        # ==== Parameters
+        # * options<~Hash>
+        #   * marker<~String> - Indicates where to begin in your list of hosted zones. 
+        #   * max_items<~Integer> - The maximum number of hosted zones to be included in the response body
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'HostedZones'<~Array>:
+        #       * 'HostedZone'<~Hash>:
+        #         * 'Id'<~String> - 
+        #         * 'Name'<~String> - 
+        #         * 'CallerReference'<~String>
+        #         * 'Comment'<~String> - 
+        #     * 'Marker'<~String> - 
+        #     * 'MaxItems'<~Integer> - 
+        #     * 'IsTruncated'<~String> - 
+        #     * 'NextMarket'<~String>
+        #   * status<~Integer> - 200 when successful
+        def list_hosted_zones(options = {})
+
+          parameters = {}
+          options.each { |option, value|
+            case option
+            when :marker
+              parameters[option] = value
+            when :max_items
+              parameters[:maxitems] = value
+            end
+          }
+          
+          request({
+            :query      => parameters,
+            :parser     => Fog::Parsers::AWS::DNS::ListHostedZones.new,
+            :expects    => 200,
+            :method     => 'GET',
+            :path       => "hostedzone"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_resource_record_sets.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_resource_record_sets.rb
new file mode 100644
index 0000000..db1db94
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/aws/list_resource_record_sets.rb
@@ -0,0 +1,60 @@
+module Fog
+  module AWS
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/aws/list_resource_record_sets'
+
+        # list your resource record sets
+        #
+        # ==== Parameters
+        # * zone_id<~String> - 
+        # * options<~Hash>
+        #   * type<~String> - 
+        #   * name<~String> -
+        #   * max_items<~Integer> - 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ResourceRecordSet'<~Array>:
+        #       * 'Name'<~String> - 
+        #       * 'Type'<~String> - 
+        #       * 'TTL'<~Integer> - 
+        #       * 'ResourceRecords'<~Array>
+        #         * 'Value'<~String> - 
+        #     * 'IsTruncated'<~String> - 
+        #     * 'MaxItems'<~String> - 
+        #     * 'NextRecordName'<~String>
+        #     * 'NexRecordType'<~String>
+        #   * status<~Integer> - 201 when successful
+        def list_resource_record_sets(zone_id, options = {})
+
+          # AWS methods return zone_ids that looks like '/hostedzone/id'.  Let the caller either use 
+          # that form or just the actual id (which is what this request needs)
+          zone_id = zone_id.sub('/hostedzone/', '')
+
+          parameters = {}
+          options.each { |option, value|
+            case option
+            when :type, :name
+              parameters[option]= "#{value}"
+            when :max_items
+              parameters['maxitems']= "#{value}"
+            end
+          }
+          
+          request({
+            :query => parameters,
+            :parser     => Fog::Parsers::AWS::DNS::ListResourceRecordSets.new,
+            :expects    => 200,
+            :method     => 'GET',
+            :path       => "hostedzone/#{zone_id}/rrset"
+          })
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_record.rb
new file mode 100644
index 0000000..5f58464
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_record.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/create_record'
+
+        # Create a new record in a DNS zone
+        # ==== Parameters
+        # * type<~String> - type of DNS record to create (A, CNAME, etc)
+        # * name<~String> - host name this DNS record is for
+        # * content<~String> - data for the DNS record (ie for an A record, the IP address)
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'name'<~String> - as above
+        #     * 'id'<~Integer> - Id of zone/domain - used in future API calls for this zone
+        #     * 'ttl'<~Integer> - as above
+        #     * 'data'<~String> - as above
+        #     * 'active'<~String> - as above
+        #     * 'aux'<~String> - as above
+        def create_record(zone_id, type, name, content, options={})
+          body = %Q{<?xml version="1.0" encoding="UTF-8"?><record><type>#{type}</type><name>#{name}</name><content>#{content}</content>}
+          options.each do |k,v|
+            body += %Q{<#{k}>#{v}</#{k}>}
+          end
+          body += %Q{</record>}
+          request(
+            :body     => body,
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Bluebox::DNS::CreateRecord.new,
+            :path     => "/api/domains/#{zone_id}/records.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_record(zone_id, type, name, content)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_zone.rb
new file mode 100644
index 0000000..50a8e5d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/create_zone.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/create_zone'
+
+        # Create a new DNS zone
+        # ==== Parameters
+        #     * 'name'<~String> - The name of the zone
+        #     * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds
+        #     * 'retry'<~Integer> - Retry interval for the domain, in seconds
+        #     * 'refresh'<~Integer> - Refresh interval for the zone
+        #     * 'minimum'<~Integer> - Minimum refresh interval for the zone
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'name'<~String> - The name of the zone
+        #     * 'serial'<~Integer> - Serial number of the zone
+        #     * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds
+        #     * 'retry'<~Integer> - Retry interval for the domain, in seconds
+        #     * 'record-count'<~Integer> - Number of records in the zone
+        #     * 'id'<~String> - Id for the zone
+        #     * 'refresh'<~Integer> - Refresh interval for the zone
+        #     * 'minimum'<~Integer> - Minimum refresh interval for the zone
+        def create_zone(options)
+          body = %Q{<?xml version="1.0" encoding="UTF-8"?><domain><name>#{options[:name]}</name><ttl>#{options[:ttl]}</ttl>}
+          body += %Q{<retry>#{options[:retry]}</retry>} if options[:retry]
+          body += %Q{<refresh>#{options[:retry]}</refresh>} if options[:refresh]
+          body += %Q{<minimum>#{options[:minimum]}</minimum>} if options[:minimum]
+          body += %Q{</domain>}
+          request(
+            :body     => body,
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Bluebox::DNS::CreateZone.new,
+            :path     => "/api/domains.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_zone(options)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_record.rb
new file mode 100644
index 0000000..eead95a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_record.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        # Delete a record from the specified DNS zone
+        # ==== Parameters
+        # * record_id<~Integer> - Id of DNS record to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_record(zone_id, record_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/domains/#{zone_id}/records/#{record_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_record(zone_id, record_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_zone.rb
new file mode 100644
index 0000000..f6ac372
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/delete_zone.rb
@@ -0,0 +1,31 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        # Delete a zone from DNS
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/domains/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def delete_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_record.rb
new file mode 100644
index 0000000..fca9040
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_record.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/get_record'
+
+        # Get an individual DNS record from the specified zone
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * hash<~Hash>:
+        #     * 'id'<~String> - The id of this record
+        #     * 'type'<~String> - type of DNS record to create (A, CNAME, etc)
+        #     * 'domain-id'<~Integer> - ID of the zone
+        #     * 'name'<~String> - empty?
+        #     * 'domain'<~String> - The domain name
+        #     * 'type'<~String> - The type of DNS record (e.g. A, MX, NS, etc.)
+        #     * 'content'<~String> - data for the DNS record (ie for an A record, the IP address)
+        def get_record(zone_id, record_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Bluebox::DNS::GetRecord.new,
+            :path     => "/api/domains/#{zone_id}/records/#{record_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_record(record_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_records.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_records.rb
new file mode 100644
index 0000000..186638e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_records.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/get_records'
+
+        # Get all the DNS records across all the DNS zones for this account
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_records(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Bluebox::DNS::GetRecords.new,
+            :path     => "/api/domains/#{zone_id}/records.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_records
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zone.rb
new file mode 100644
index 0000000..b98086c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zone.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/get_zone'
+
+        # Get details of a DNS zone
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * hash<~Hash>:
+        #     * 'name'<~String> - The name of the zone
+        #     * 'serial'<~Integer> - Serial number of the zone
+        #     * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds
+        #     * 'retry'<~Integer> - Retry interval for the domain, in seconds
+        #     * 'record-count'<~Integer> - Number of records in the zone
+        #     * 'id'<~String> - Id for the zone
+        #     * 'refresh'<~Integer> - Refresh interval for the zone
+        #     * 'minimum'<~Integer> - Minimum refresh interval for the zone
+        def get_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Bluebox::DNS::GetZone.new,
+            :path     => "/api/domains/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zone(zone_id)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zones.rb
new file mode 100644
index 0000000..9f77508
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/get_zones.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/bluebox/get_zones'
+
+        # Get list of all DNS zones hosted on Bluebox (for this account)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'records'<~Array>
+        #     * 'record'
+        #       * 'name'<~String> - name of the zone
+        #       * 'serial'<~Integer> - Serial # for the zone
+        #       * 'ttl'<~Integer> - TTL for the zone record in seconds
+        #       * 'retry'<~Integer> - Retry interval for the zone record in seconds
+        #       * 'expires'<~Integer> - Expiration interval for the zone record in seconds
+        #       * 'record-count'<~Integer> - # of records in this zone
+        #       * 'id'<~String> - Id for the zone record
+        #       * 'refresh'<~Integer> - default refresh interval for this zone, in seconds
+        #       * 'minimum'<~Integer> - minimum value for intervals for this zone, in seconds
+        def get_zones
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Bluebox::DNS::GetZones.new,
+            :path     => '/api/domains.xml'
+          )
+        end
+
+      end
+
+      class Mock
+
+        def get_zones
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_record.rb
new file mode 100644
index 0000000..b69c8d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_record.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        # Updates an existing record in a DNS zone
+        # ==== Parameters
+        # * type<~String> - type of DNS record (A, CNAME, etc)
+        # * name<~String> - host name for this DNS record
+        # * content<~String> - data for the DNS record (ie for an A record, the IP address)
+        def update_record(zone_id, record_id, options)
+          body = %Q{<?xml version="1.0" encoding="UTF-8"?><record>}
+          options.each {|k,v| body += "<#{k}>#{v}</#{k}>"}
+          body += "</record>"
+          request(
+            :body     => body,
+            :expects  => 202,
+            :method   => 'PUT',
+            :path     => "/api/domains/#{zone_id}/records/#{record_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_record(zone_id, type, domain, content)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_zone.rb
new file mode 100644
index 0000000..51438ae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/bluebox/update_zone.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Bluebox
+    class DNS
+      class Real
+
+        # Updates an existing DNS zone
+        def update_zone(zone_id, options)
+          body = %Q{<?xml version="1.0" encoding="UTF-8"?><domain>}
+          options.each {|k,v| body += "<#{k}>#{v}</#{k}>"}
+          body += "</domain>"
+          request(
+            :body     => body,
+            :expects  => 202,
+            :method   => 'PUT',
+            :path     => "/api/domains/#{zone_id}.xml"
+          )
+        end
+
+      end
+
+      class Mock
+
+        def create_record(zone_id, type, domain, content)
+          Fog::Mock.not_implemented
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_domain.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_domain.rb
new file mode 100644
index 0000000..0219599
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_domain.rb
@@ -0,0 +1,27 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Create a single domain in DNSimple in your account.
+        # ==== Parameters
+        # * name<~String> - domain name to host (ie example.com)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'name'<~String>
+        def create_domain(name)
+          body = { "domain" => { "name" => name } }
+          request(
+                  :body     => body.to_json,
+                  :expects  => 201,
+                  :method   => 'POST',
+                  :path     => '/domains'
+                  )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_record.rb
new file mode 100644
index 0000000..e3e2c7a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/create_record.rb
@@ -0,0 +1,48 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Create a new host in the specified zone
+        #
+        # ==== Parameters
+        # * domain<~String>
+        # * name<~String>
+        # * type<~String>
+        # * content<~String>
+        # * options<~Hash> - optional
+        #   * priority<~Integer>
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>
+        #     * name<~String>
+        #     * ttl<~Integer>
+        #     * created_at<~String>
+        #     * special_type<~String>
+        #     * updated_at<~String>
+        #     * domain_id<~Integer>
+        #     * id<~Integer>
+        #     * content<~String>
+        #     * record_type<~String>
+        #     * prio<~Integer>
+        def create_record(domain, name, type, content, options = {})
+
+          body = {
+            "record" => {
+              "name" => name,
+              "record_type" => type,
+              "content" => content } }
+
+          body["record"].merge!(options)
+
+          request( :body     => body.to_json,
+                   :expects  => 201,
+                   :method   => 'POST',
+                   :path     => "/domains/#{domain}/records" )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_domain.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_domain.rb
new file mode 100644
index 0000000..04e8eb9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_domain.rb
@@ -0,0 +1,26 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Delete the given domain from your account. You may use
+        # either the domain ID or the domain name.
+        #
+        # Please note that for domains which are registered with
+        # DNSimple this will not delete the domain from the registry.
+        #
+        # ==== Parameters
+        # * name<~String> - domain name or numeric ID
+        #
+        def delete_domain(name)
+          request(
+                  :expects  => 200,
+                  :method   => 'DELETE',
+                  :path     => "/domains/#{name}"
+                  )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_record.rb
new file mode 100644
index 0000000..2d9b0e5
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/delete_record.rb
@@ -0,0 +1,21 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Delete the record with the given ID for the given domain.
+        #
+        # ==== Parameters
+        # * domain<~String>
+        # * record_id<~String>
+        def delete_record(domain, record_id)
+
+          request( :expects  => 200,
+                   :method   => "DELETE",
+                   :path     => "/domains/#{domain}/records/#{record_id}" )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_domain.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_domain.rb
new file mode 100644
index 0000000..6989ceb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_domain.rb
@@ -0,0 +1,37 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Get the details for a specific domain in your account. You
+        # may pass either the domain numeric ID or the domain name
+        # itself.
+        #
+        # ==== Parameters
+        # * id<~String> - domain name or numeric ID
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'domain'<~Hash>
+        #       * 'name'<~String>
+        #       * 'expires_at'<~String>
+        #       * 'created_at'<~String>
+        #       * 'registration_status'<~String>
+        #       * 'updated_at'<~String>
+        #       * 'registrant_id'<~Integer>
+        #       * 'id'<~Integer>
+        #       * 'user_id'<~Integer>
+        #       * 'name_server_status'<~String>
+        def get_domain(id)
+          request(
+                  :expects  => 200,
+                  :method   => "GET",
+                  :path     => "/domains/#{id}"
+                  )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_record.rb
new file mode 100644
index 0000000..06eed80
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/get_record.rb
@@ -0,0 +1,34 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Gets record from given domain.
+        #
+        # ==== Parameters
+        # * domain<~String>
+        # * record_id<~String>
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * record<~Hash>
+        #     * name<~String>
+        #     * ttl<~Integer>
+        #     * created_at<~String>
+        #     * special_type<~String>
+        #     * updated_at<~String>
+        #     * domain_id<~Integer>
+        #     * id<~Integer>
+        #     * content<~String>
+        #     * record_type<~String>
+        #     * prio<~Integer>
+        def get_record(domain, record_id)
+
+          request( :expects  => 200,
+                   :method   => "GET",
+                   :path     => "/domains/#{domain}/records/#{record_id}" )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_domains.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_domains.rb
new file mode 100644
index 0000000..15aedf1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_domains.rb
@@ -0,0 +1,35 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Get the details for a specific domain in your account. You
+        # may pass either the domain numeric ID or the domain name itself.
+        # ==== Parameters
+        # * id<~String> - domain name or numeric ID
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'domains'<~Array>
+        #       * 'name'<~String>
+        #       * 'expires_at'<~String>
+        #       * 'created_at'<~String>
+        #       * 'registration_status'<~String>
+        #       * 'updated_at'<~String>
+        #       * 'registrant_id'<~Integer>
+        #       * 'id'<~Integer>
+        #       * 'user_id'<~Integer>
+        #       * 'name_server_status'<~String>
+        def list_domains
+          request(
+                  :expects  => 200,
+                  :method   => 'GET',
+                  :path     => '/domains'
+                  )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_records.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_records.rb
new file mode 100644
index 0000000..5eb470d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/list_records.rb
@@ -0,0 +1,32 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Get the list of records for the specific domain.
+        #
+        # ==== Parameters
+        # * domain<~String>
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * records<Array~>
+        #     * name<~String>
+        #     * ttl<~Integer>
+        #     * created_at<~String>
+        #     * special_type<~String>
+        #     * updated_at<~String>
+        #     * domain_id<~Integer>
+        #     * id<~Integer>
+        #     * content<~String>
+        #     * record_type<~String>
+        #     * prio<~Integer>
+        def list_records(domain)
+          request( :expects  => 200,
+                   :method   => "GET",
+                   :path     => "/domains/#{domain}/records" )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/update_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/update_record.rb
new file mode 100644
index 0000000..4d2317c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/dnsimple/update_record.rb
@@ -0,0 +1,42 @@
+module Fog
+  module DNSimple
+    class DNS
+      class Real
+
+        # Update the given record for the given domain.
+        #
+        # ==== Parameters
+        # * domain<~String>
+        # * record_id<~String>
+        # * options<~Hash> - optional
+        #   * type<~String>
+        #   * content<~String>
+        #   * priority<~Integer>
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * record<~Hash>
+        #     * name<~String>
+        #     * ttl<~Integer>
+        #     * created_at<~String>
+        #     * special_type<~String>
+        #     * updated_at<~String>
+        #     * domain_id<~Integer>
+        #     * id<~Integer>
+        #     * content<~String>
+        #     * record_type<~String>
+        #     * prio<~Integer>
+        def update_record(domain, record_id, options)
+
+          body = { "record" => options }
+
+          request( :body     => body.to_json,
+                   :expects  => 200,
+                   :method   => "PUT",
+                   :path     => "/domains/#{domain}/records/#{record_id}" )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_create.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_create.rb
new file mode 100644
index 0000000..35ffea2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_create.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Creates a domain record
+        #
+        # ==== Parameters
+        # * domain<~String>: The zone's name.  Note, if master zone, SOA_email is required and if slave
+        #                    master_ips is/are required
+        # * type<~String>: master or slave 
+        # * options<~Hash>
+        #   * description<~String> Currently undisplayed
+        #   * SOA_email<~String> Required when type=master
+        #   * refresh_sec<~Integer> numeric, default: '0'
+        #   * retry_sec<~Integer> numeric, default: '0'
+        #   * expire_sec<~Integer> numeric, default: '0'
+        #   * ttl_sec<~String> numeric, default: '0'
+        #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+        #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'DomainID'<~Integer>: domain ID
+        def domain_create(domain, type, options = {})
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.create',
+              :domain => domain,
+              :type  => type
+            }.merge!( options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_delete.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_delete.rb
new file mode 100644
index 0000000..8248e68
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_delete.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Delete the given domain from the list Linode hosts
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: id of domain to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        # TODO: docs
+        def domain_delete(domain_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.delete', :domainId => domain_id }
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_list.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_list.rb
new file mode 100644
index 0000000..76fb78b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_list.rb
@@ -0,0 +1,42 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # List of domains (you have access to)
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * DATA<~Array>
+        #       * 'DOMAINID'<~Interger>
+        #       * 'SOA_EMAIL'<~String>
+        #       * 'DESCRIPTION'<~String>
+        #       * 'TTL_SEC'<~String>
+        #       * 'EXPIRE_SEC'<~Integer>
+        #       * 'RETRY_SEC'<~Integer>
+        #       * 'DOMAIN'<~String>
+        #       * 'STATUS'<~Integer>
+        #       * 'MASTER_IPS'<~String>
+        #       * 'REFRESH_SEC'<~Integer>
+        #       * 'TYPE'<~String>
+        def domain_list(domain_id = nil)
+          options = {}
+          if domain_id
+            options.merge!(:domainId => domain_id)
+          end
+          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.list' }.merge!(options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_create.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_create.rb
new file mode 100644
index 0000000..c649e5c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_create.rb
@@ -0,0 +1,44 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Creates a resource record in a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * type<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        # * options<~Hash>
+        #   * name<~String>: The hostname or FQDN. When Type=MX the subdomain to delegate to the 
+        #                    Target MX server
+        #   * target<~String> When Type=MX the hostname. When Type=CNAME the target of the alias.
+        #                    When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                    of '[remote_addr]' will be substituted with the IP address of the request. 
+        #   * priority<~Integer>: priority for MX and SRV records, 0-255 - default: 10 
+        #   * weight<~Integer>: default: 5
+        #   * port<~Integer>: default: 80 
+        #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+        #                        types. default: udp 
+        #   * ttl_sec<~Integer>: note, Linode will round the input to set values (300, 3600, 7200, etc)
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'ResourceID'<~Integer>: ID of the resource record created
+        def domain_resource_create(domain_id, type, options = {})
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.resource.create',
+              :domainID => domain_id,
+              :type  => type
+            }.merge!( options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_delete.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_delete.rb
new file mode 100644
index 0000000..ea619a4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_delete.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Delete the given resource from a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: id of domain resource belongs to
+        # * resource_id<~Integer>: id of resouce to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * resource_id<~Integer>:  resource id that was deleted
+        def domain_resource_delete(domain_id, resource_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.resource.delete', :domainId => domain_id, :resourceID => resource_id }
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_list.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_list.rb
new file mode 100644
index 0000000..627262d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_list.rb
@@ -0,0 +1,43 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # List of resource records for a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * resource_id<~Integer>: optional.  use if want only a specific resource record
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * DATA<~Array>
+        #       * 'PROTOCOL'<~String>:  for SRV records. default is UDP 
+        #       * 'TTL_SEC'<~Interger>: 
+        #       * 'PRIORITY'<~Interger>: for MX and SRV records
+        #       * 'TYPE'<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        #       * 'TARGET'<~String>: When Type=MX the hostname. When Type=CNAME the target of the alias. 
+        #                           When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                           of '[remote_addr]' will be substituted with the IP address of the request.
+        #       * 'WEIGHT'<~Interger>: 
+        #       * 'RESOURCEID'<~Interger>: ID of the resource record
+        #       * 'PORT'<~Interger>: 
+        #       * 'DOMAINID'<~Interger>: ID of the domain that this record belongs to
+        #       * 'NAME'<~Interger>: The hostname or FQDN. When Type=MX, the subdomain to delegate to        
+        def domain_resource_list(domain_id, resource_id = nil)
+          query = { :api_action => 'domain.resource.list', :domainID => domain_id }
+          if resource_id
+            query[:resourceID] = resource_id
+          end
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => query
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_update.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_update.rb
new file mode 100644
index 0000000..cc8e8eb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_resource_update.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Updates a resource record in a domain
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: limit the list to the domain ID specified
+        # * resource_id<~Integer>: id of resouce to delete
+        # * options<~Hash>
+        #   * type<~String>: One of: NS, MX, A, AAAA, CNAME, TXT, or SRV 
+        #   * name<~String>: The hostname or FQDN. When Type=MX the subdomain to delegate to the 
+        #                    Target MX server
+        #   * target<~String> When Type=MX the hostname. When Type=CNAME the target of the alias. 
+        #                    When Type=TXT the value of the record. When Type=A or AAAA the token 
+        #                    of '[remote_addr]' will be substituted with the IP address of the request. 
+        #   * priority<~Integer>: priority for MX and SRV records, 0-255 - default: 10 
+        #   * weight<~Integer>: default: 5
+        #   * port<~Integer>: default: 80 
+        #   * protocol<~String>: The protocol to append to an SRV record. Ignored on other record 
+        #                        types. default: udp 
+        #   * ttl_sec<~Integer>: note, Linode will round the input to set values (300, 3600, 7200, etc)
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'ResourceID'<~Integer>: ID of the resource record updated
+        def domain_resource_update(domain_id, resource_id, options = {})
+
+          query= {}
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => {
+              :api_action   => 'domain.resource.update',
+              :domainID => domain_id,
+              :resourceID => resource_id,
+            }.merge!( options)
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_update.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_update.rb
new file mode 100644
index 0000000..c679923
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/linode/domain_update.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Linode
+    class DNS
+      class Real
+
+        # Update a domain record
+        #
+        # ==== Parameters
+        # * domain_id<~Integer>: The ID to identify the zone
+        # * options<~Hash>
+        #   * domain<~String>: The zone's name.  
+        #   * type<~String>: master or slave 
+        #   * description<~String> Currently undisplayed
+        #   * SOA_email<~String> Required when type=master
+        #   * refresh_sec<~Integer> numeric, default: '0'
+        #   * retry_sec<~Integer> numeric, default: '0'
+        #   * expire_sec<~Integer> numeric, default: '0'
+        #   * ttl_sec<~String> numeric, default: '0'
+        #   * status<~Integer> 0, 1, or 2 (disabled, active, edit mode), default: 1 
+        #   * master_ips<~String> When type=slave, the zone's master DNS servers list, semicolon separated 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * DATA<~Hash>:
+        #       * 'DomainID'<~Integer>: domain ID
+        def domain_update(domain_id, options = {})
+          
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :query    => { :api_action => 'domain.update', :domainId => domain_id }.merge!(options)
+          )
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_record.rb
new file mode 100644
index 0000000..7c9fdbf
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_record.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/create_record'
+
+        # Create a new record in a DNS zone - or update an existing one
+        # ==== Parameters
+        # * record_type<~String> - type of DNS record to create (A, CNAME, etc)
+        # * zone_id<~Integer> - ID of the zone to update
+        # * name<~String> - host name this DNS record is for 
+        # * data<~String> - data for the DNS record (ie for an A record, the IP address)
+        # * options<~Hash> - extra parameters that are not mandatory
+        #   * ttl<~Integer> - time to live in seconds
+        #   * active<~String> - whether this record is active or not ('Y' or 'N')
+        #   * aux<~String> - extra data required by the record
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'name'<~String> - as above
+        #     * 'id'<~Integer> - Id of zone/domain - used in future API calls for this zone
+        #     * 'ttl'<~Integer> - as above
+        #     * 'data'<~String> - as above
+        #     * 'active'<~String> - as above
+        #     * 'aux'<~String> - as above
+        def create_record(record_type, zone_id, name, data, options = {})
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ttl
+              optional_tags+= "<ttl type='integer'>#{value}</ttl>"
+            when :active
+              optional_tags+= "<active>#{value}</active>"
+            when :aux
+              optional_tags+= "<aux>#{value}</aux>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><record><record_type>#{record_type}</record_type><zone_id type="integer">#{zone_id}</zone_id><name>#{name}</name><data>#{data}</data>#{optional_tags}</record>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::DNS::CreateRecord.new,
+            :path     => 'records.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_zone.rb
new file mode 100644
index 0000000..ed8966d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/create_zone.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/create_zone'
+
+        # Create a new zone for Slicehost's DNS servers to serve/host
+        # ==== Parameters
+        # * origin<~String> - domain name to host (ie example.com)
+        # * options<~Hash> - optional paramaters
+        #   * ttl<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #   * active<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'origin'<~String> - as above
+        #     * 'id'<~Integer> - Id of zone/domain - used in future API calls
+        #     * 'ttl'<~Integer> - as above
+        #     * 'active'<~String> - as above
+        def create_zone(origin, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ttl
+              optional_tags+= "<ttl type='interger'>#{value}</ttl>"
+            when :active
+              optional_tags+= "<active>#{value}</active>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone><origin>#{origin}</origin>#{optional_tags}</zone>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Slicehost::DNS::CreateZone.new,
+            :path     => 'zones.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_record.rb
new file mode 100644
index 0000000..dd16552
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_record.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        # Delete a record from the specified DNS zone
+        # ==== Parameters
+        # * record_id<~Integer> - Id of DNS record to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_record(record_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "records/#{record_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_zone.rb
new file mode 100644
index 0000000..2be847d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/delete_zone.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        # Delete a zone from Slicehost's DNS
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: - HTTP status code will be result
+        def delete_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_record.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_record.rb
new file mode 100644
index 0000000..bb366d9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_record.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/get_record'
+
+        # Get an individual DNS record from the specified zone 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'record_type'<~String> - type of DNS record to create (A, CNAME, etc)
+        #     * 'zone_id'<~Integer> - ID of the zone to update
+        #     * 'name'<~String> - host name this DNS record is for 
+        #     * 'data'<~String> - data for the DNS record (ie for an A record, the IP address)
+        #     * 'ttl'<~Integer> - time to live in seconds
+        #     * 'active'<~String> - whether this record is active or not ('Y' or 'N')
+        #     * 'aux'<~String> - extra data required by the record
+        def get_record(record_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetRecords.new,
+            :path     => "records/#{record_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_records.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_records.rb
new file mode 100644
index 0000000..092eb8e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_records.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/get_records'
+
+        # Get all the DNS records across all the DNS zones for this account 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'addresses'<~Array> - Ip addresses for the slice
+        #     * 'backup-id'<~Integer> - Id of backup slice was booted from
+        #     * 'flavor_id'<~Integer> - Id of flavor slice was booted from
+        #     * 'id'<~Integer> - Id of the slice
+        #     * 'image-id'<~Integer> - Id of image slice was booted from
+        #     * 'name'<~String> - Name of the slice
+        #     * 'progress'<~Integer> - Progress of current action, in percentage
+        #     * 'status'<~String> - Current status of the slice
+        def get_records
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetRecords.new,
+            :path     => "records.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zone.rb
new file mode 100644
index 0000000..aafada1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zone.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/get_zone'
+
+        # Get details of a DNS zone
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'origin'<~String> - domain name to host (ie example.com)
+        #     * 'id'<~Integer> - Id of the zone
+        #     * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #     * 'active'<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        def get_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetZone.new,
+            :path     => "/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zones.rb
new file mode 100644
index 0000000..0ece445
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/slicehost/get_zones.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Slicehost
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/slicehost/get_zones'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'zones'<~Array>
+        #       * 'origin'<~String> - domain name to host (ie example.com)
+        #       * 'id'<~Integer> - Id of the zone
+        #       * 'ttl'<~Integer> - TimeToLive (ttl) for the domain, in seconds (> 60)
+        #       * 'active'<~String> - whether zone is active in Slicehost DNS server - 'Y' or 'N'
+        def get_zones
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Slicehost::DNS::GetZones.new,
+            :path     => 'zones.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_hosts.rb
new file mode 100644
index 0000000..dca1c7f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_hosts.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/count_hosts'
+
+        # total number of hosts available for the specified zone. It is the same value as provided 
+        # in the X-Query-Count header in the list_hosts API method
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'count'<~Integer> 
+        #   * 'status'<~Integer> - 200 indicates success
+        def count_hosts( zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::CountHosts.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts/count.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_zones.rb
new file mode 100644
index 0000000..4412d6a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/count_zones.rb
@@ -0,0 +1,28 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/count_zones'
+
+        # Total number of zones hosted Zerigo for this account. It is the same value as provided 
+        # in the X-Query-Count header in the list_zones API method
+        #
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'count'<~Integer> 
+        #   * 'status'<~Integer> - 200 indicates success
+        def count_zones()
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::CountZones.new,
+            :path     => "/api/1.1/zones/count.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_host.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_host.rb
new file mode 100644
index 0000000..181373c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_host.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/create_host'
+
+        # Create a new host in the specified zone
+        #
+        # ==== Parameters
+        # * zone_id<~Integer>
+        # * host_type<~String>
+        # * data<~String>
+        # * options<~Hash> - optional paramaters
+        #   * hostname<~String> - Note: normally this is set/required!!
+        #   * notes<~String>
+        #   * priority<~Integer> - Note: required for MX or SRV records
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>
+        #     * 'created-at'<~String>
+        #     * 'data'<~String>
+        #     * 'fqdn'<~String>
+        #     * 'host-type'<~String>
+        #     * 'hostname'<~String>
+        #     * 'id'<~Integer>
+        #     * 'notes'<~String>
+        #     * 'priority'<~Integer>
+        #     * 'ttl'<~Integer>
+        #     * 'updated-at'<~String>
+        #     * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 201 if successful        
+        def create_host(zone_id, host_type, data, options = {})
+          
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :hostname
+              optional_tags+= "<hostname>#{value}</hostname>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :priority
+              optional_tags+= "<priority>#{value}</priority>"
+            when :ttl
+              optional_tags+= "<ttl>#{value}</ttl>"
+            end
+          }
+            
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><host><host-type>#{host_type}</host-type><data>#{data}</data>#{optional_tags}</host>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Zerigo::DNS::CreateHost.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_zone.rb
new file mode 100644
index 0000000..59af112
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/create_zone.rb
@@ -0,0 +1,89 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/create_zone'
+
+        # Create a new zone for Zerigo's DNS servers to serve/host
+        # ==== Parameters
+        #
+        # * domain<~String>
+        # * default_ttl<~Integer>
+        # * ns_type<~String>
+        # * options<~Hash> - optional paramaters
+        #   * ns1<~String> - required if ns_type == sec
+        #   * nx_ttl<~Integer> -
+        #   * slave_nameservers<~String> - required if ns_type == pri
+        #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+        #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+        #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+        #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+        #   * notes<~String> - notes about the domain
+        #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+        #   * tag_list<~String> - List of all tags associated with this domain
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'id'<~Integer> - zone ID to use for future calls
+        #     * 'default-ttl'<~Integer>
+        #     * 'nx-ttl'<~Integer>
+        #     * 'hosts-count'<~Integer>
+        #     * 'created-at'<~String>
+        #     * 'custom-nameservers'<~String>
+        #     * 'custom-ns'<~String>
+        #     * 'domain'<~String>
+        #     * 'hostmaster'<~String>
+        #     * 'notes'<~String>
+        #     * 'ns1'<~String>
+        #     * 'ns-type'<~String>
+        #     * 'slave-nameservers'<~String>
+        #     * 'tag-list'<~String>
+        #     * 'updated-at'<~String>
+        #     * 'hosts'<~String>
+        #     * 'axfr-ips'<~String>
+        #     * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 201 if successful        
+        
+        def create_zone( domain, default_ttl, ns_type, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :ns1
+              optional_tags+= "<ns1>#{value}</ns1>"
+            when :nx_ttl
+              optional_tags+= "<nx-ttl type='interger'>#{value}</nx-ttl>"
+            when :slave_nameservers
+              optional_tags+= "<slave-nameservers>#{value}</slave-nameservers>"
+            when :axfr_ips
+              optional_tags+= "<axfr-ips>#{value}</axfr-ips>"
+            when :custom_nameservers
+              optional_tags+= "<custom-nameservers>#{value}</custom-nameservers>"
+            when :custom_ns
+              optional_tags+= "<custom-ns>#{value}</custom-ns>"
+            when :hostmaster
+              optional_tags+= "<hostmaster>#{value}</hostmaster>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :restrict_axfr
+              optional_tags+= "<restrict-axfr>#{value}</restrict-axfr>"
+            when :tag_list
+              optional_tags+= "<tag-list>#{value}</tag-list>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone><domain>#{domain}</domain><default-ttl type="integer">#{default_ttl}</default-ttl><ns-type>#{ns_type}</ns-type>#{optional_tags}</zone>},
+            :expects  => 201,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Zerigo::DNS::CreateZone.new,
+            :path     => '/api/1.1/zones.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_host.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_host.rb
new file mode 100644
index 0000000..685ec29
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_host.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Delete a host record 
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - Id of host record to delete
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * 'status'<~Integer> - 200 indicates success
+        def delete_host(host_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_zone.rb
new file mode 100644
index 0000000..c070470
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/delete_zone.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Delete a zone from Zerigo
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - Id of zone to delete
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def delete_zone(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "/api/1.1/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/find_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/find_hosts.rb
new file mode 100644
index 0000000..6180435
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/find_hosts.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/find_hosts'
+
+        # Get list of all the host records that match the FQDN.  If desired, can limit
+        # search to a specific zone
+        #
+        #
+        # ==== Parameters
+        # * fqdn<~String> - domain to look for
+        # * zone_id<~Integer> - if want to limit search to specific zone
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'hosts'<~Hash>
+        #       * 'created-at'<~String>
+        #       * 'data'<~String>
+        #       * 'fqdn'<~String>
+        #       * 'host-type'<~String>
+        #       * 'hostname'<~String>
+        #       * 'id'<~Integer>
+        #       * 'notes'<~String>
+        #       * 'priority'<~Integer>
+        #       * 'ttl'<~Integer>
+        #       * 'updated-at'<~String>
+        #       * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 200 indicated success
+        #
+        def find_hosts( fqdn, zone_id = nil)
+          if zone_id.nil?
+            #look for matching host across all zones
+            request(
+              :expects  => 200,
+              :method   => 'GET',
+              :parser   => Fog::Parsers::Zerigo::DNS::FindHosts.new,
+              :path     => "/api/1.1/hosts.xml?fqdn=#{fqdn}"
+            )
+          else
+            #look for hosts in a specific zone
+            request(
+              :expects  => 200,
+              :method   => 'GET',
+              :parser   => Fog::Parsers::Zerigo::DNS::FindHosts.new,
+              :path     => "/api/1.1/zones/#{zone_id}/hosts.xml?fqdn=#{fqdn}"
+            )
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_host.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_host.rb
new file mode 100644
index 0000000..c5334e4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_host.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/get_host'
+
+        # get details about a given host record
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - ID of the host record to retrieve
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * body<~Hash>:
+        #     * 'created-at'<~String>
+        #     * 'data'<~String>
+        #     * 'fqdn'<~String>
+        #     * 'host-type'<~String>
+        #     * 'hostname'<~String>
+        #     * 'id'<~Integer>
+        #     * 'notes'<~String>
+        #     * 'priority'<~Integer>
+        #     * 'ttl'<~Integer>
+        #     * 'updated-at'<~String>
+        #     * 'zone-id'<~String>
+        #   * 'status'<~Integer> - 200 indicates success
+        def get_host( host_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetHost.new,
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone.rb
new file mode 100644
index 0000000..999eacc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/get_zone'
+
+        # Get details of a DNS zone. The response is similar to list_zones, with the 
+        # addition of hosts-count and possibly hosts.
+        #
+        # ==== Parameters
+        # * zone<~String> - Either the zone ID or the zone name (ie sample-domain.com)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'default-ttl'<~Integer>
+        #     * 'id'<~Integer>
+        #     * 'nx-ttl'<~Integer>
+        #     * 'hosts-count'<~Integer>
+        #     * 'created-at'<~String>
+        #     * 'custom-nameservers'<~String>
+        #     * 'custom-ns'<~String>
+        #     * 'domain'<~String>
+        #     * 'hostmaster'<~String>
+        #     * 'notes'<~String>
+        #     * 'ns1'<~String>
+        #     * 'ns-type'<~String>
+        #     * 'slave-nameservers'<~String>
+        #     * 'tag-list'<~String>
+        #     * 'updated-at'<~String>
+        #     * 'hosts'<~Array> - a list of all host records. For the format of host info, see get_host() 
+        #     * 'axfr-ips'<~String>
+        #     * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def get_zone(zone)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetZone.new,
+            :path     => "/api/1.1/zones/#{zone}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone_stats.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone_stats.rb
new file mode 100644
index 0000000..7eac687
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/get_zone_stats.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/get_zone_stats'
+
+        # returns current traffic statistics about this zone. Queries is measured from the 
+        # beginning of the current period through the time of the API call.
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - the zone ID 
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'domain'<~String> - domain name  (ie example.com)
+        #     * 'id'<~Integer> - Id of the zone
+        #     * 'period-being'<~String> - date in following format 2010-07-01
+        #     * 'period-end'<~String> - date
+        #     * 'queries'<~Integer> - # of queries for the zone during period
+        #   * 'status'<~Integer> - 200 indicates success
+        
+        def get_zone_stats(zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::GetZoneStats.new,
+            :path     => "/api/1.1/zones/#{zone_id}/stats.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_hosts.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_hosts.rb
new file mode 100644
index 0000000..00a9a67
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_hosts.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/list_hosts'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Parameters
+        # * zone_id<~Integer> - the zone ID of the zone from which to get the host records for
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'hosts'<~Array>
+        #       * 'created-at'<~String>
+        #       * 'data'<~String>
+        #       * 'fqdn'<~String>
+        #       * 'host-type'<~String>
+        #       * 'hostname'<~String>
+        #       * 'id'<~Integer>
+        #       * 'notes'<~String>
+        #       * 'priority'<~Integer>
+        #       * 'ttl'<~Integer>
+        #       * 'updated-at'<~String>
+        #       * 'zone-id'<~String>
+        # * 'status'<~Integer> - 200 indicates success
+        def list_hosts( zone_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::ListHosts.new,
+            :path     => "/api/1.1/zones/#{zone_id}/hosts.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_zones.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_zones.rb
new file mode 100644
index 0000000..245452e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/list_zones.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        require 'fog/dns/parsers/zerigo/list_zones'
+
+        # Get list of all DNS zones hosted on Slicehost (for this account)
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'zones'<~Array>
+        #       * 'default-ttl'<~Integer>
+        #       * 'id'<~Integer>
+        #       * 'nx-ttl'<~Integer>
+        #       * 'hosts-count'<~Integer>
+        #       * 'created-at'<~String>
+        #       * 'custom-nameservers'<~String>
+        #       * 'custom-ns'<~String>
+        #       * 'domain'<~String>
+        #       * 'hostmaster'<~String>
+        #       * 'notes'<~String>
+        #       * 'ns1'<~String>
+        #       * 'ns-type'<~String>
+        #       * 'slave-nameservers'<~String>
+        #       * 'tag-list'<~String>
+        #       * 'updated-at'<~String>
+        #       * 'hosts'<~String>
+        #       * 'axfr-ips'<~String>
+        #       * 'restrict-axfr'<~String>    
+        #   * 'status'<~Integer> - 200 indicates success
+        def list_zones
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Zerigo::DNS::ListZones.new,
+            :path     => '/api/1.1/zones.xml'
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_host.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_host.rb
new file mode 100644
index 0000000..75358b3
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_host.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Update a host record
+        #
+        # ==== Parameters
+        # * host_id<~Integer> - host ID of the record to update
+        # * options<~Hash> - optional paramaters
+        #   * host_type<~String>
+        #   * data<~String>
+        #   * hostname<~String> - Note: normally this is set/required!!
+        #   * notes<~String>
+        #   * priority<~Integer> - Note: required for MX or SRV records
+        #   * ttl<~Integer>
+        # ==== Returns
+        # * response<~Excon::Response>: 
+        #   * 'status'<~Integer> - 200 for success
+        #
+        def update_host( host_id, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :host_type
+              optional_tags+= "<host-type>#{host_type}</host-type>"
+            when :data
+              optional_tags+= "<data>#{data}</data>"
+            when :hostname
+              optional_tags+= "<hostname>#{value}</hostname>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :priority
+              optional_tags+= "<priority>#{value}</priority>"
+            when :ttl
+              optional_tags+= "<ttl>#{value}</ttl>"
+            end
+          }
+
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><host>#{optional_tags}</host>},
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "/api/1.1/hosts/#{host_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_zone.rb b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_zone.rb
new file mode 100644
index 0000000..a6da777
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/requests/zerigo/update_zone.rb
@@ -0,0 +1,70 @@
+module Fog
+  module Zerigo
+    class DNS
+      class Real
+
+        # Update the parameters of a zone
+        # ==== Parameters
+        #
+        # * zone_id<~Integer>
+        # * options<~Hash> - optional paramaters
+        #   * default_ttl<~Integer>
+        #   * ns_type<~String>
+        #   * ns1<~String> - required if ns_type == sec
+        #   * nx_ttl<~Integer> -
+        #   * slave_nameservers<~String> - required if ns_type == pri
+        #   * axfr_ips<~String> - comma-separated list of IPs or IP blocks allowed to perform AXFRs
+        #   * custom_nameservers<~String> - comma-separated list of custom nameservers
+        #   * custom_ns<~String> - indicates if vanity (custom) nameservers are enabled for this domain
+        #   * hostmaster<~String> - email of the DNS administrator or hostmaster
+        #   * notes<~String> - notes about the domain
+        #   * restrict_axfr<~String> - indicates if AXFR transfers should be restricted to IPs in axfr-ips
+        #   * tag_list<~String> - List of all tags associated with this domain
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * 'status'<~Integer> - 200 for success
+        def update_zone( zone_id, options = {})
+
+          optional_tags= ''
+          options.each { |option, value|
+            case option
+            when :default_ttl
+              optional_tags+= "<default-ttl>#{value}</default-ttl>"
+            when :ns_type
+              optional_tags+= "<ns-type>#{value}</ns-type>"
+            when :ns1
+              optional_tags+= "<ns1>#{value}</ns1>"
+            when :nx_ttl
+              optional_tags+= "<nx-ttl type='interger'>#{value}</nx-ttl>"
+            when :slave_nameservers
+              optional_tags+= "<slave-nameservers>#{value}</slave-nameservers>"
+            when :axfr_ips
+              optional_tags+= "<axfr-ips>#{value}</axfr-ips>"
+            when :custom_nameservers
+              optional_tags+= "<custom-nameservers>#{value}</custom-nameservers>"
+            when :custom_ns
+              optional_tags+= "<custom-ns>#{value}</custom-ns>"
+            when :hostmaster
+              optional_tags+= "<hostmaster>#{value}</hostmaster>"
+            when :notes
+              optional_tags+= "<notes>#{value}</notes>"
+            when :restrict_axfr
+              optional_tags+= "<restrict-axfr>#{value}</restrict-axfr>"
+            when :tag_list
+              optional_tags+= "<tag-list>#{value}</tag-list>"
+            end
+          }
+          
+          request(
+            :body     => %Q{<?xml version="1.0" encoding="UTF-8"?><zone>#{optional_tags}</zone>},
+            :expects  => 200,
+            :method   => 'PUT',
+            :path     => "/api/1.1/zones/#{zone_id}.xml"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/slicehost.rb b/vendor/fog-0.8.2/lib/fog/dns/slicehost.rb
new file mode 100644
index 0000000..de35e2f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/slicehost.rb
@@ -0,0 +1,110 @@
+module Fog
+  module Slicehost
+    class DNS < Fog::Service
+
+      requires :slicehost_password
+      recognizes :host, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/slicehost'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/slicehost'
+      request :create_record
+      request :create_zone
+      request :delete_record
+      request :delete_zone
+      request :get_record
+      request :get_records
+      request :get_zone
+      request :get_zones
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Slicehost::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Slicehost') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @slicehost_password = options[:slicehost_password]
+        end
+
+        def data
+          self.class.data[@slicehost_password]
+        end
+
+        def reset_data
+          self.class.data.delete(@slicehost_password)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Slicehost::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Slicehost') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @slicehost_password = options[:slicehost_password]
+          @host   = options[:host]    || "api.slicehost.com"
+          @port   = options[:port]    || 443
+          @scheme = options[:scheme]  || 'https'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(@slicehost_password).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Slicehost::DNS::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/dns/zerigo.rb b/vendor/fog-0.8.2/lib/fog/dns/zerigo.rb
new file mode 100644
index 0000000..61eb28f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/dns/zerigo.rb
@@ -0,0 +1,119 @@
+module Fog
+  module Zerigo
+    class DNS < Fog::Service
+
+      requires :zerigo_email, :zerigo_token
+      recognizes :timeout, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/dns/models/zerigo'
+      model       :record
+      collection  :records
+      model       :zone
+      collection  :zones
+
+      request_path 'fog/dns/requests/zerigo'
+      request :count_hosts
+      request :count_zones
+      request :create_host
+      request :create_zone
+      request :delete_host
+      request :delete_zone
+      request :find_hosts
+      request :get_host
+      request :get_zone
+      request :get_zone_stats
+      request :list_zones
+      request :list_hosts
+      request :update_host
+      request :update_zone
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Zerigo::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Zerigo') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @zerigo_email = options[:zerigo_email]
+          @zerigo_token = options[:zerigo_token]
+        end
+
+        def data
+          self.class.data[@zerigo_email]
+        end
+
+        def reset_data
+          self.class.data.delete(@zerigo_email)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Zerigo::DNS.new is deprecated, use Fog::DNS.new(:provider => 'Zerigo') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+
+          @zerigo_email  = options[:zerigo_email]
+          @zerigo_token  = options[:zerigo_token]
+          @host   = options[:host]    || "ns.zerigo.com"
+          @port   = options[:port]    || 80
+          @scheme = options[:scheme]  || 'http'
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          params[:headers] ||= {}
+          key= "#{@zerigo_email}:#{@zerigo_token}"
+          params[:headers].merge!({
+            'Authorization' => "Basic #{Base64.encode64(key).delete("\r\n")}"
+          })
+          case params[:method]
+          when 'DELETE', 'GET', 'HEAD'
+            params[:headers]['Accept'] = 'application/xml'
+          when 'POST', 'PUT'
+            params[:headers]['Content-Type'] = 'application/xml'
+          end
+
+          begin
+            response = @connection.request(params.merge!({:host => @host}))
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Zerigo::DNS::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers.rb b/vendor/fog-0.8.2/lib/fog/providers.rb
new file mode 100644
index 0000000..cfb564a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers.rb
@@ -0,0 +1,24 @@
+module Fog
+
+  def self.providers
+    @providers ||= []
+  end
+
+end
+
+require 'fog/providers/aws'
+require 'fog/providers/bluebox'
+require 'fog/providers/brightbox'
+require 'fog/providers/dnsimple'
+require 'fog/providers/ecloud'
+require 'fog/providers/go_grid'
+require 'fog/providers/google'
+require 'fog/providers/linode'
+require 'fog/providers/local'
+require 'fog/providers/new_servers'
+require 'fog/providers/rackspace'
+require 'fog/providers/slicehost'
+require 'fog/providers/storm_on_demand'
+require 'fog/providers/virtual_box'
+require 'fog/providers/voxel'
+require 'fog/providers/zerigo'
diff --git a/vendor/fog-0.8.2/lib/fog/providers/aws.rb b/vendor/fog-0.8.2/lib/fog/providers/aws.rb
new file mode 100644
index 0000000..8ec5bb6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/aws.rb
@@ -0,0 +1,179 @@
+require 'fog/core'
+require 'fog/core/parser'
+require 'openssl' # For RSA key pairs
+
+module Fog
+  module AWS
+
+    extend Fog::Provider
+
+    service(:cdn,             'cdn/aws')
+    service(:compute,         'compute/aws')
+    service(:cloud_formation, 'aws/cloud_formation')
+    service(:dns,             'dns/aws')
+    service(:elb,             'aws/elb')
+    service(:iam,             'aws/iam')
+    service(:rds,             'aws/rds')
+    service(:ses,             'aws/ses')
+    service(:simpledb,        'aws/simpledb')
+    service(:storage,         'storage/aws')
+
+    def self.indexed_param(key, values)
+      params = {}
+      unless key.include?('%d')
+        key << '.%d'
+      end
+      [*values].each_with_index do |value, index|
+        params[format(key, index + 1)] = value
+      end
+      params
+    end
+
+    def self.indexed_filters(filters)
+      params = {}
+      filters.keys.each_with_index do |key, key_index|
+        key_index += 1
+        params[format('Filter.%d.Name', key_index)] = key
+        [*filters[key]].each_with_index do |value, value_index|
+          value_index += 1
+          params[format('Filter.%d.Value.%d', key_index, value_index)] = value
+        end
+      end
+      params
+    end
+
+    def self.escape(string)
+      string.gsub( /([^-a-zA-Z0-9_.~]+)/n ) { |match| '%' + match.unpack( 'H2' * match.size ).join( '%' ).upcase }
+    end
+
+    def self.signed_params(params, options = {})
+      params.merge!({
+        'AWSAccessKeyId'    => options[:aws_access_key_id],
+        'SignatureMethod'   => 'HmacSHA256',
+        'SignatureVersion'  => '2',
+        'Timestamp'         => Time.now.utc.strftime("%Y-%m-%dT%H:%M:%SZ"),
+        'Version'           => options[:version]
+      })
+
+      body = ''
+      for key in params.keys.sort
+        unless (value = params[key]).nil?
+          body << "#{key}=#{escape(value.to_s)}&"
+        end
+      end
+      string_to_sign = "POST\n#{options[:host]}:#{options[:port]}\n#{options[:path]}\n" << body.chop
+      signed_string = options[:hmac].sign(string_to_sign)
+      body << "Signature=#{CGI.escape(Base64.encode64(signed_string).chomp!).gsub(/\+/, '%20')}"
+
+      body
+    end
+
+    class Mock
+
+      def self.availability_zone(region)
+        "#{region}#{Fog::Mock.random_selection('abcd', 1)}"
+      end
+
+      def self.box_usage
+        sprintf("%0.10f", rand / 100).to_f
+      end
+
+      def self.dns_name_for(ip_address)
+        "ec2-#{ip_address.gsub('.','-')}.compute-1.amazonaws.com"
+      end
+
+      def self.private_dns_name_for(ip_address)
+        "ip-#{ip_address.gsub('.','-')}.ec2.internal"
+      end
+
+      def self.etag
+        Fog::Mock.random_hex(32)
+      end
+
+      def self.image
+        path = []
+        (rand(3) + 2).times do
+          path << Fog::Mock.random_letters(rand(9) + 8)
+        end
+        {
+          "imageOwnerId"   => Fog::Mock.random_letters(rand(5) + 4),
+          "blockDeviceMapping" => [],
+          "productCodes"   => [],
+          "kernelId"       => kernel_id,
+          "ramdiskId"      => ramdisk_id,
+          "imageState"     => "available",
+          "imageId"        => image_id,
+          "architecture"   => "i386",
+          "isPublic"       => true,
+          "imageLocation"  => path.join('/'),
+          "imageType"      => "machine",
+          "rootDeviceType" => ["ebs","instance-store"][rand(2)],
+          "rootDeviceName" => "/dev/sda1"
+        }
+      end
+
+      def self.image_id
+        "ami-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.key_fingerprint
+        fingerprint = []
+        20.times do
+          fingerprint << Fog::Mock.random_hex(2)
+        end
+        fingerprint.join(':')
+      end
+
+      def self.instance_id
+        "i-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.ip_address
+        ip = []
+        4.times do
+          ip << Fog::Mock.random_numbers(rand(3) + 1).to_i.to_s # remove leading 0
+        end
+        ip.join('.')
+      end
+
+      def self.kernel_id
+        "aki-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.key_material
+        OpenSSL::PKey::RSA.generate(1024).to_s
+      end
+
+      def self.owner_id
+        Fog::Mock.random_numbers(12)
+      end
+
+      def self.ramdisk_id
+        "ari-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.request_id
+        request_id = []
+        request_id << Fog::Mock.random_hex(8)
+        3.times do
+          request_id << Fog::Mock.random_hex(4)
+        end
+        request_id << Fog::Mock.random_hex(12)
+        request_id.join('-')
+      end
+
+      def self.reservation_id
+        "r-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.snapshot_id
+        "snap-#{Fog::Mock.random_hex(8)}"
+      end
+
+      def self.volume_id
+        "vol-#{Fog::Mock.random_hex(8)}"
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/bluebox.rb b/vendor/fog-0.8.2/lib/fog/providers/bluebox.rb
new file mode 100644
index 0000000..41b9079
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/bluebox.rb
@@ -0,0 +1,12 @@
+require 'fog/core'
+
+module Fog
+  module Bluebox
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/bluebox')
+    service(:dns, 'dns/bluebox')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/brightbox.rb b/vendor/fog-0.8.2/lib/fog/providers/brightbox.rb
new file mode 100644
index 0000000..7279c6c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/brightbox.rb
@@ -0,0 +1,9 @@
+require 'fog/core'
+
+module Fog
+  module Brightbox
+    extend Fog::Provider
+
+    service(:compute, 'compute/brightbox')
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/dnsimple.rb b/vendor/fog-0.8.2/lib/fog/providers/dnsimple.rb
new file mode 100644
index 0000000..0ca60aa
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/dnsimple.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module DNSimple
+
+    extend Fog::Provider
+
+    service(:dns, 'dns/dnsimple')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/ecloud.rb b/vendor/fog-0.8.2/lib/fog/providers/ecloud.rb
new file mode 100644
index 0000000..212de9f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/ecloud.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module Ecloud
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/ecloud')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/go_grid.rb b/vendor/fog-0.8.2/lib/fog/providers/go_grid.rb
new file mode 100644
index 0000000..dfa9e97
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/go_grid.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module GoGrid
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/go_grid')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/google.rb b/vendor/fog-0.8.2/lib/fog/providers/google.rb
new file mode 100644
index 0000000..3efa783
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/google.rb
@@ -0,0 +1,23 @@
+require 'fog/core'
+
+module Fog
+  module Google
+
+    extend Fog::Provider
+
+    service(:storage, 'storage/google')
+
+    class Mock
+
+      def self.etag
+        hex(32)
+      end
+
+      def self.hex(length)
+        max = ('f' * length).to_i(16)
+        rand(max).to_s(16)
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/linode.rb b/vendor/fog-0.8.2/lib/fog/providers/linode.rb
new file mode 100644
index 0000000..29f273a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/linode.rb
@@ -0,0 +1,10 @@
+require 'fog/core'
+
+module Fog
+  module Linode
+    extend Fog::Provider
+    service(:compute, 'compute/linode')
+    service(:dns,     'dns/linode')
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/providers/local.rb b/vendor/fog-0.8.2/lib/fog/providers/local.rb
new file mode 100644
index 0000000..d0f96d9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/local.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module Local
+
+    extend Fog::Provider
+
+    service(:storage, 'storage/local')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/new_servers.rb b/vendor/fog-0.8.2/lib/fog/providers/new_servers.rb
new file mode 100644
index 0000000..c805d2d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/new_servers.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module NewServers
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/new_servers')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/rackspace.rb b/vendor/fog-0.8.2/lib/fog/providers/rackspace.rb
new file mode 100644
index 0000000..4d86e4a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/rackspace.rb
@@ -0,0 +1,33 @@
+require 'fog/core'
+
+module Fog
+  module Rackspace
+
+    extend Fog::Provider
+
+    service(:cdn,     'cdn/rackspace')
+    service(:compute, 'compute/rackspace')
+    service(:storage, 'storage/rackspace')
+
+    def self.authenticate(options)
+      rackspace_auth_url = options[:rackspace_auth_url] || "auth.api.rackspacecloud.com"
+      connection = Fog::Connection.new("https://" + rackspace_auth_url)
+      @rackspace_api_key  = options[:rackspace_api_key]
+      @rackspace_username = options[:rackspace_username]
+      response = connection.request({
+        :expects  => 204,
+        :headers  => {
+          'X-Auth-Key'  => @rackspace_api_key,
+          'X-Auth-User' => @rackspace_username
+        },
+        :host     => rackspace_auth_url,
+        :method   => 'GET',
+        :path     => 'v1.0'
+      })
+      response.headers.reject do |key, value|
+        !['X-Server-Management-Url', 'X-Storage-Url', 'X-CDN-Management-Url', 'X-Auth-Token'].include?(key)
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/slicehost.rb b/vendor/fog-0.8.2/lib/fog/providers/slicehost.rb
new file mode 100644
index 0000000..2e6763d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/slicehost.rb
@@ -0,0 +1,12 @@
+require 'fog/core'
+
+module Fog
+  module Slicehost
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/slicehost')
+    service(:dns,     'dns/slicehost')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/storm_on_demand.rb b/vendor/fog-0.8.2/lib/fog/providers/storm_on_demand.rb
new file mode 100644
index 0000000..e6d9706
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/storm_on_demand.rb
@@ -0,0 +1,12 @@
+require 'fog/core'
+
+module Fog
+  module StormOnDemand
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/storm_on_demand')
+
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/providers/virtual_box.rb b/vendor/fog-0.8.2/lib/fog/providers/virtual_box.rb
new file mode 100644
index 0000000..75683b7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/virtual_box.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module VirtualBox
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/virtual_box')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/voxel.rb b/vendor/fog-0.8.2/lib/fog/providers/voxel.rb
new file mode 100644
index 0000000..9e81448
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/voxel.rb
@@ -0,0 +1,16 @@
+require 'fog/core'
+require 'digest/md5'
+
+module Fog
+  module Voxel
+
+    extend Fog::Provider
+
+    service(:compute, 'compute/voxel')
+
+    def self.create_signature(secret, options)
+      to_sign = options.keys.map { |k| k.to_s }.sort.map { |k| "#{k}#{options[k.to_sym]}" }.join("")
+      Digest::MD7.hexdigest( secret + to_sign )
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/providers/zerigo.rb b/vendor/fog-0.8.2/lib/fog/providers/zerigo.rb
new file mode 100644
index 0000000..09ac79c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/providers/zerigo.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+module Fog
+  module Zerigo
+
+    extend Fog::Provider
+
+    service(:dns, 'dns/zerigo')
+
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage.rb b/vendor/fog-0.8.2/lib/fog/storage.rb
new file mode 100644
index 0000000..f29fcf9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage.rb
@@ -0,0 +1,59 @@
+module Fog
+  class Storage
+
+    def self.new(attributes)
+      attributes = attributes.dup # prevent delete from having side effects
+      case provider = attributes[:provider] # attributes.delete(:provider)
+      when 'AWS'
+        require 'fog/storage/aws'
+        Fog::AWS::Storage.new(attributes)
+      when 'Google'
+        require 'fog/storage/google'
+        Fog::Google::Storage.new(attributes)
+      when 'Local'
+        require 'fog/storage/local'
+        Fog::Local::Storage.new(attributes)
+      when 'Rackspace'
+        require 'fog/storage/rackspace'
+        Fog::Rackspace::Storage.new(attributes)
+      else
+        raise ArgumentError.new("#{provider} is not a recognized storage provider")
+      end
+    end
+
+    def self.get_body_size(body)
+      if body.respond_to?(:force_encoding)
+        body.force_encoding('BINARY')
+      end
+      if body.respond_to?(:bytesize)
+        body.bytesize
+      elsif body.respond_to?(:size)
+        body.size
+      elsif body.respond_to?(:stat)
+        body.stat.size
+      else
+        0
+      end
+    end
+    
+    def self.parse_data(data)
+      metadata = {
+        :body => nil,
+        :headers => {}
+      }
+      
+      metadata[:body] = data
+      metadata[:headers]['Content-Length'] = get_body_size(data)
+      
+      if data.respond_to?(:path)
+        filename = ::File.basename(data.path)
+        unless (mime_types = MIME::Types.of(filename)).empty?
+          metadata[:headers]['Content-Type'] = mime_types.first.content_type
+        end
+      end
+      # metadata[:headers]['Content-MD5'] = Base64.encode64(Digest::MD5.digest(metadata[:body])).strip
+      metadata
+    end
+    
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/aws.rb b/vendor/fog-0.8.2/lib/fog/storage/aws.rb
new file mode 100644
index 0000000..1a84c12
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/aws.rb
@@ -0,0 +1,341 @@
+module Fog
+  module AWS
+    class Storage < Fog::Service
+
+      requires :aws_access_key_id, :aws_secret_access_key
+      recognizes :endpoint, :region, :host, :path, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/storage/models/aws'
+      collection  :directories
+      model       :directory
+      collection  :files
+      model       :file
+
+      request_path 'fog/storage/requests/aws'
+      request :abort_multipart_upload
+      request :complete_multipart_upload
+      request :copy_object
+      request :delete_bucket
+      request :delete_bucket_website
+      request :delete_object
+      request :get_bucket
+      request :get_bucket_acl
+      request :get_bucket_location
+      request :get_bucket_logging
+      request :get_bucket_object_versions
+      request :get_bucket_versioning
+      request :get_bucket_website
+      request :get_object
+      request :get_object_acl
+      request :get_object_torrent
+      request :get_object_url
+      request :get_request_payment
+      request :get_service
+      request :head_object
+      request :initiate_multipart_upload
+      request :list_multipart_uploads
+      request :list_parts
+      request :post_object_hidden_fields
+      request :put_bucket
+      request :put_bucket_acl
+      request :put_bucket_logging
+      request :put_bucket_versioning
+      request :put_bucket_website
+      request :put_object
+      request :put_object_acl
+      request :put_object_url
+      request :put_request_payment
+      request :sync_clock
+      request :upload_part
+
+      module Utils
+
+        def cdn
+          @cdn ||= Fog::AWS::CDN.new(
+            :aws_access_key_id => @aws_access_key_id,
+            :aws_secret_access_key => @aws_secret_access_key
+          )
+        end
+
+        def url(params, expires)
+          params[:headers]['Date'] = expires.to_i
+          params[:path] = CGI.escape(params[:path]).gsub('%2F', '/')
+          query = [params[:query]].compact
+          query << "AWSAccessKeyId=#{@aws_access_key_id}"
+          query << "Signature=#{CGI.escape(signature(params))}"
+          query << "Expires=#{params[:headers]['Date']}"
+          "https://#{@host}/#{params[:path]}?#{query.join('&')}"
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.acls(type)
+          case type
+          when 'private'
+            {
+              "AccessControlList" => [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Grantee" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+                }
+              ],
+              "Owner" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read'
+            {
+              "AccessControlList" => [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Grantee" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AllUsers"}
+                }
+              ],
+              "Owner" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read-write'
+            {
+              "AccessControlList" => [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Grantee" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AllUsers"}
+                },
+                {
+                  "Permission" => "WRITE",
+                  "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AllUsers"}
+                }
+              ],
+              "Owner" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'authenticated-read'
+            {
+              "AccessControlList" => [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Grantee" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Grantee" => {"URI" => "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"}
+                }
+              ],
+              "Owner" => {"DisplayName" => "me", "ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          end
+        end
+
+        def self.data
+          @data ||= Hash.new do |hash, region|
+            hash[region] = Hash.new do |region_hash, key|
+              region_hash[key] = {
+                :acls => {
+                  :bucket => {},
+                  :object => {}
+                },
+                :buckets => {}
+              }
+            end
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Storage.new is deprecated, use Fog::Storage.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          options[:region] ||= 'us-east-1'
+          @host = options[:host] || case options[:region]
+          when 'ap-northeast-1'
+            's3-ap-northeast-1.amazonaws.com'
+          when 'ap-southeast-1'
+            's3-ap-southeast-1.amazonaws.com'
+          when 'eu-west-1'
+            's3-eu-west-1.amazonaws.com'
+          when 'us-east-1'
+            's3.amazonaws.com'
+          when 'us-west-1'
+            's3-us-west-1.amazonaws.com'
+          else
+            raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+          end
+          @region = options[:region]
+        end
+
+        def data
+          self.class.data[@region][@aws_access_key_id]
+        end
+
+        def reset_data
+          self.class.data[@region].delete(@aws_access_key_id)
+        end
+
+        def signature(params)
+          "foo"
+        end
+
+      end
+
+      class Real
+        include Utils
+
+        # Initialize connection to S3
+        #
+        # ==== Notes
+        # options parameter must include values for :aws_access_key_id and
+        # :aws_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   s3 = S3.new(
+        #     :aws_access_key_id => your_aws_access_key_id,
+        #     :aws_secret_access_key => your_aws_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * S3 object with connection to aws.
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::AWS::Storage.new is deprecated, use Fog::Storage.new(:provider => 'AWS') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+          require 'mime/types'
+
+          @aws_access_key_id = options[:aws_access_key_id]
+          @aws_secret_access_key = options[:aws_secret_access_key]
+          @hmac = Fog::HMAC.new('sha1', @aws_secret_access_key)
+          if @endpoint = options[:endpoint]
+            endpoint = URI.parse(@endpoint)
+            @host = endpoint.host
+            @path = endpoint.path
+            @port = endpoint.port
+            @scheme = endpoint.scheme
+          else
+            options[:region] ||= 'us-east-1'
+            @host = options[:host] || case options[:region]
+            when 'ap-northeast-1'
+              's3-ap-northeast-1.amazonaws.com'
+            when 'ap-southeast-1'
+              's3-ap-southeast-1.amazonaws.com'
+            when 'eu-west-1'
+              's3-eu-west-1.amazonaws.com'
+            when 'us-east-1'
+              's3.amazonaws.com'
+            when 'us-west-1'
+              's3-us-west-1.amazonaws.com'
+            else
+              raise ArgumentError, "Unknown region: #{options[:region].inspect}"
+            end
+            @path   = options[:path]      || '/'
+            @port   = options[:port]      || 443
+            @scheme = options[:scheme]    || 'https'
+            unless options.has_key?(:persistent)
+              options[:persistent] = true
+            end
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}#{@path}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def signature(params)
+          string_to_sign =
+<<-DATA
+#{params[:method]}
+#{params[:headers]['Content-MD5']}
+#{params[:headers]['Content-Type']}
+#{params[:headers]['Date']}
+DATA
+
+          amz_headers, canonical_amz_headers = {}, ''
+          for key, value in params[:headers]
+            if key[0..5] == 'x-amz-'
+              amz_headers[key] = value
+            end
+          end
+          amz_headers = amz_headers.sort {|x, y| x[0] <=> y[0]}
+          for key, value in amz_headers
+            canonical_amz_headers << "#{key}:#{value}\n"
+          end
+          string_to_sign << canonical_amz_headers
+
+          subdomain = params[:host].split(".#{@host}").first
+          unless subdomain =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+            Formatador.display_line("[yellow][WARN] fog: the specified s3 bucket name(#{subdomain}) is not a valid dns name, which will negatively impact performance.  For details see: http://docs.amazonwebservices.com/AmazonS3/latest/dev/BucketRestrictions.html[/]")
+            params[:host] = params[:host].split("#{subdomain}.")[-1]
+            if params[:path]
+              params[:path] = "#{subdomain}/#{params[:path]}"
+            else
+              params[:path] = subdomain
+            end
+            subdomain = nil
+          end
+
+          canonical_resource  = @path.dup
+          unless subdomain.nil? || subdomain == @host
+            canonical_resource << "#{CGI.escape(subdomain).downcase}/"
+          end
+          canonical_resource << params[:path].to_s
+          canonical_resource << '?'
+          for key in (params[:query] || {}).keys.sort
+            if %w{acl location logging notification partNumber policy requestPayment torrent uploadId uploads versionId versioning versions website}.include?(key)
+              canonical_resource << "#{key}#{"=#{params[:query][key]}" unless params[:query][key].nil?}&"
+            end
+          end
+          canonical_resource.chop!
+          string_to_sign << canonical_resource
+
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+
+        private
+
+        def request(params, &block)
+          params[:headers]['Date'] = Fog::Time.now.to_date_header
+          params[:headers]['Authorization'] = "AWS #{@aws_access_key_id}:#{signature(params)}"
+
+          # FIXME: ToHashParser should make this not needed
+          original_params = params.dup
+
+          begin
+            response = @connection.request(params, &block)
+          rescue Excon::Errors::TemporaryRedirect => error
+            uri = URI.parse(error.response.headers['Location'])
+            Formatador.display_line("[yellow][WARN] fog: followed redirect to #{uri.host}, connecting to the matching region will be more performant[/]")
+            response = Fog::Connection.new("#{@scheme}://#{uri.host}:#{@port}", false).request(original_params, &block)
+          end
+
+          response
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/google.rb b/vendor/fog-0.8.2/lib/fog/storage/google.rb
new file mode 100644
index 0000000..fbffd29
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/google.rb
@@ -0,0 +1,266 @@
+module Fog
+  module Google
+    class Storage < Fog::Service
+
+      requires :google_storage_access_key_id, :google_storage_secret_access_key
+      recognizes :host, :port, :scheme, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/storage/models/google'
+      collection  :directories
+      model       :directory
+      collection  :files
+      model       :file
+
+      request_path 'fog/storage/requests/google'
+      request :copy_object
+      request :delete_bucket
+      request :delete_object
+      request :get_bucket
+      request :get_bucket_acl
+      request :get_object
+      request :get_object_acl
+      request :get_object_torrent
+      request :get_object_url
+      request :get_service
+      request :head_object
+      request :put_bucket
+      request :put_bucket_acl
+      request :put_object
+      request :put_object_url
+
+      module Utils
+
+        def url(params, expires)
+          params[:headers]['Date'] = expires.to_i
+          params[:path] = CGI.escape(params[:path]).gsub('%2F', '/')
+          query = [params[:query]].compact
+          query << "GoogleAccessKeyId=#{@google_storage_access_key_id}"
+          query << "Signature=#{CGI.escape(signature(params))}"
+          query << "Expires=#{params[:headers]['Date']}"
+          "http://#{params[:host]}/#{params[:path]}?#{query.join('&')}"
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.acls(type)
+          case type
+          when 'private'
+            {
+              "AccessControlList"=> [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Scope" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0", "type" => "UserById"}
+                }
+              ],
+              "Owner" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read'
+            {
+              "AccessControlList"=> [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Scope" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0", "type" => "UserById"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Scope" => {"type" => "AllUsers"}
+                }
+              ],
+              "Owner" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'public-read-write'
+            {
+              "AccessControlList"=> [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Scope" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0", "type" => "UserById"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Scope" => {"type" => "AllUsers"}
+                },
+                {
+                  "Permission" => "WRITE",
+                  "Scope" => {"type" => "AllUsers"}
+                }
+              ],
+              "Owner" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          when 'authenticated-read'
+            {
+              "AccessControlList"=> [
+                {
+                  "Permission" => "FULL_CONTROL",
+                  "Scope" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0", "type" => "UserById"}
+                },
+                {
+                  "Permission" => "READ",
+                  "Scope" => {"type" => "AllAuthenticatedUsers"}
+                }
+              ],
+              "Owner" => {"ID" => "2744ccd10c7533bd736ad890f9dd5cab2adb27b07d500b9493f29cdc420cb2e0"}
+            }
+          end
+        end
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {
+              :acls => {
+                :bucket => {},
+                :object => {}
+              },
+              :buckets => {}
+            }
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Google::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Google') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @google_storage_access_key_id = options[:google_storage_access_key_id]
+        end
+
+        def data
+          self.class.data[@google_storage_access_key_id]
+        end
+
+        def reset_data
+          self.class.data.delete(@google_storage_access_key_id)
+        end
+
+        def signature(params)
+          "foo"
+        end
+
+      end
+
+    
+      class Real
+        include Utils
+
+        # Initialize connection to Google Storage
+        #
+        # ==== Notes
+        # options parameter must include values for :google_storage_access_key_id and
+        # :google_storage_secret_access_key in order to create a connection
+        #
+        # ==== Examples
+        #   google_storage = Storage.new(
+        #     :google_storage_access_key_id => your_google_storage_access_key_id,
+        #     :google_storage_secret_access_key => your_google_storage_secret_access_key
+        #   )
+        #
+        # ==== Parameters
+        # * options<~Hash> - config arguments for connection.  Defaults to {}.
+        #
+        # ==== Returns
+        # * Storage object with connection to google.
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Google::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Google') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'fog/core/parser'
+          require 'mime/types'
+
+          @google_storage_access_key_id = options[:google_storage_access_key_id]
+          @google_storage_secret_access_key = options[:google_storage_secret_access_key]
+          @hmac = Fog::HMAC.new('sha1', @google_storage_secret_access_key)
+          @host = options[:host] || 'commondatastorage.googleapis.com'
+          @port   = options[:port]      || 443
+          @scheme = options[:scheme]    || 'https'
+          unless options.has_key?(:persistent)
+            options[:persistent] = true
+          end
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def signature(params)
+          string_to_sign =
+<<-DATA
+#{params[:method]}
+#{params[:headers]['Content-MD5']}
+#{params[:headers]['Content-Type']}
+#{params[:headers]['Date']}
+DATA
+
+          google_headers, canonical_google_headers = {}, ''
+          for key, value in params[:headers]
+            if key[0..6] == 'x-goog-'
+              google_headers[key] = value
+            end
+          end
+
+          google_headers = google_headers.sort {|x, y| x[0] <=> y[0]}
+          for key, value in google_headers
+            canonical_google_headers << "#{key}:#{value}\n"
+          end
+          string_to_sign << "#{canonical_google_headers}"
+
+          subdomain = params[:host].split(".#{@host}").first
+          unless subdomain =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+            Formatador.display_line("[yellow][WARN] fog: the specified google storage bucket name(#{subdomain}) is not a valid dns name.  See: http://code.google.com/apis/storage/docs/developer-guide.html#naming[/]")
+            params[:host] = params[:host].split("#{subdomain}.")[-1]
+            if params[:path]
+              params[:path] = "#{subdomain}/#{params[:path]}"
+            else
+              params[:path] = "#{subdomain}"
+            end
+            subdomain = nil
+          end
+
+          canonical_resource  = "/"
+          unless subdomain.nil? || subdomain == @host
+            canonical_resource << "#{CGI.escape(subdomain).downcase}/"
+          end
+          canonical_resource << "#{params[:path]}"
+          canonical_resource << '?'
+          for key in (params[:query] || {}).keys
+            if ['acl', 'location', 'logging', 'requestPayment', 'torrent', 'versions', 'versioning'].include?(key)
+              canonical_resource << "#{key}&"
+            end
+          end
+          canonical_resource.chop!
+          string_to_sign << "#{canonical_resource}"
+
+          signed_string = @hmac.sign(string_to_sign)
+          signature = Base64.encode64(signed_string).chomp!
+        end
+
+
+        private
+
+        def request(params, &block)
+          params[:headers]['Date'] = Fog::Time.now.to_date_header
+          params[:headers]['Authorization'] = "GOOG1 #{@google_storage_access_key_id}:#{signature(params)}"
+
+          response = @connection.request(params, &block)
+
+          response
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/local.rb b/vendor/fog-0.8.2/lib/fog/storage/local.rb
new file mode 100644
index 0000000..511d922
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/local.rb
@@ -0,0 +1,83 @@
+module Fog
+  module Local
+    class Storage < Fog::Service
+
+      requires :local_root
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/storage/models/local'
+      collection  :directories
+      model       :directory
+      model       :file
+      collection  :files
+
+      class Mock
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          Fog::Mock.not_implemented
+
+          require 'mime/types'
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Local::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Local') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          @local_root = ::File.expand_path(options[:local_root])
+        end
+
+        def data
+          self.class.data[@local_root]
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path_to(partial)
+          ::File.join(@local_root, partial)
+        end
+
+        def reset_data
+          self.class.data.delete(@local_root)
+        end
+
+      end
+
+      class Real
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Local::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Local') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @local_root = ::File.expand_path(options[:local_root])
+        end
+
+        def local_root
+          @local_root
+        end
+
+        def path_to(partial)
+          ::File.join(@local_root, partial)
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/aws/directories.rb b/vendor/fog-0.8.2/lib/fog/storage/models/aws/directories.rb
new file mode 100644
index 0000000..7c2183d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/aws/directories.rb
@@ -0,0 +1,43 @@
+require 'fog/core/collection'
+require 'fog/storage/models/aws/directory'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::AWS::Storage::Directory
+
+        def all
+          data = connection.get_service.body['Buckets']
+          load(data)
+        end
+
+        def get(key, options = {})
+          remap_attributes(options, {
+            :delimiter  => 'delimiter',
+            :marker     => 'marker',
+            :max_keys   => 'max-keys',
+            :prefix     => 'prefix'
+          })
+          data = connection.get_bucket(key, options).body
+          directory = new(:key => data['Name'])
+          options = {}
+          for k, v in data
+            if ['CommonPrefixes', 'Delimiter', 'IsTruncated', 'Marker', 'MaxKeys', 'Prefix'].include?(k)
+              options[k] = v
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.load(data['Contents'])
+          directory
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/aws/directory.rb b/vendor/fog-0.8.2/lib/fog/storage/models/aws/directory.rb
new file mode 100644
index 0000000..902cb4a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/aws/directory.rb
@@ -0,0 +1,100 @@
+require 'fog/core/model'
+require 'fog/storage/models/aws/files'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Directory < Fog::Model
+
+        identity  :key,           :aliases => ['Name', 'name']
+
+        attribute :creation_date, :aliases => 'CreationDate'
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def destroy
+          requires :key
+          connection.delete_bucket(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def location
+          requires :key
+          data = connection.get_bucket_location(key)
+          data.body['LocationConstraint']
+        end
+
+        def location=(new_location)
+          @location = new_location
+        end
+
+        def files
+          @files ||= begin
+            Fog::AWS::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def payer
+          requires :key
+          data = connection.get_request_payment(key)
+          data.body['Payer']
+        end
+
+        def payer=(new_payer)
+          requires :key
+          connection.put_request_payment(key, new_payer)
+          @payer = new_payer
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :key
+          if connection.get_bucket_acl(key).body['AccessControlList'].detect {|grant| grant['Grantee']['URI'] == 'http://acs.amazonaws.com/groups/global/AllUsers' && grant['Permission'] == 'READ'}
+            if key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{key}.s3.amazonaws.com"
+            else
+              "https://s3.amazonaws.com/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save
+          requires :key
+          options = {}
+          if @acl
+            options['x-amz-acl'] = @acl
+          end
+          if @location
+            options['LocationConstraint'] = @location
+          end
+          connection.put_bucket(key, options)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/aws/file.rb b/vendor/fog-0.8.2/lib/fog/storage/models/aws/file.rb
new file mode 100644
index 0000000..da1a94e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/aws/file.rb
@@ -0,0 +1,141 @@
+require 'fog/core/model'
+
+module Fog
+  module AWS
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attr_writer :body
+        attribute :cache_control,       :aliases => 'Cache-Control'
+        attribute :content_disposition, :aliases => 'Content-Disposition'
+        attribute :content_encoding,    :aliases => 'Content-Encoding'
+        attribute :content_length,      :aliases => ['Content-Length', 'Size'], :type => :integer
+        attribute :content_md5,         :aliases => 'Content-MD5'
+        attribute :content_type,        :aliases => 'Content-Type'
+        attribute :etag,                :aliases => ['Etag', 'ETag']
+        attribute :expires,             :aliases => 'Expires'
+        attribute :last_modified,       :aliases => ['Last-Modified', 'LastModified']
+        attribute :metadata
+        attribute :owner,               :aliases => 'Owner'
+        attribute :storage_class,       :aliases => ['x-amz-storage-class', 'StorageClass']
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def body
+          attributes[:body] ||= if last_modified && (file = collection.get(identity))
+            file.body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def copy(target_directory_key, target_file_key)
+          requires :directory, :key
+          connection.copy_object(directory.key, key, target_directory_key, target_file_key)
+          target_directory = connection.directories.new(:key => target_directory_key)
+          target_directory.files.get(target_file_key)
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.key, key)
+          true
+        end
+
+        remove_method :metadata
+        def metadata
+          attributes.reject {|key, value| !(key.to_s =~ /^x-amz-meta-/)}
+        end
+
+        remove_method :metadata=
+        def metadata=(new_metadata)
+          merge_attributes(new_metadata)
+        end
+
+        remove_method :owner=
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if connection.get_object_acl(directory.key, key).body['AccessControlList'].detect {|grant| grant['Grantee']['URI'] == 'http://acs.amazonaws.com/groups/global/AllUsers' && grant['Permission'] == 'READ'}
+            if directory.key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{directory.key}.s3.amazonaws.com/#{key}"
+            else
+              "https://s3.amazonaws.com/#{directory.key}/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          if options != {}
+            Formatador.display_line("[yellow][WARN] options param is deprecated, use acl= instead[/] [light_black](#{caller.first})[/]")
+          end
+          options['x-amz-acl'] ||= @acl if @acl
+          options['Cache-Control'] = cache_control if cache_control
+          options['Content-Disposition'] = content_disposition if content_disposition
+          options['Content-Encoding'] = content_encoding if content_encoding
+          options['Content-MD5'] = content_md5 if content_md5
+          options['Content-Type'] = content_type if content_type
+          options['Expires'] = expires if expires
+          options.merge(metadata)
+          options['x-amz-storage-class'] = storage_class if storage_class
+
+          data = connection.put_object(directory.key, key, body, options)
+          data.headers['ETag'].gsub!('"','')
+          merge_attributes(data.headers)
+          self.content_length = Fog::Storage.get_body_size(body)
+          true
+        end
+
+        def url(expires)
+          requires :key
+          collection.get_url(key, expires)
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/aws/files.rb b/vendor/fog-0.8.2/lib/fog/storage/models/aws/files.rb
new file mode 100644
index 0000000..4e4b4ea
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/aws/files.rb
@@ -0,0 +1,103 @@
+require 'fog/core/collection'
+require 'fog/storage/models/aws/file'
+
+module Fog
+  module AWS
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :common_prefixes, :aliases => 'CommonPrefixes'
+        attribute :delimiter,       :aliases => 'Delimiter'
+        attribute :directory
+        attribute :is_truncated,    :aliases => 'IsTruncated'
+        attribute :marker,          :aliases => 'Marker'
+        attribute :max_keys,        :aliases => ['MaxKeys', 'max-keys']
+        attribute :prefix,          :aliases => 'Prefix'
+
+        model Fog::AWS::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'delimiter'   => delimiter,
+            'marker'      => marker,
+            'max-keys'    => max_keys,
+            'prefix'      => prefix
+          }.merge!(options)
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            merge_attributes(parent.files.attributes)
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        alias :each_file_this_page :each
+        def each
+          if !block_given?
+            self
+          else
+            subset = dup.all
+
+            subset.each_file_this_page {|f| yield f}
+            while subset.is_truncated
+              subset = subset.all(:marker => subset.last.key)
+              subset.each_file_this_page {|f| yield f}
+            end
+
+            self
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, options, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          normalise_headers(file_data)
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key, options)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          normalise_headers(file_data)
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+        def normalise_headers(headers)
+          headers['Last-Modified'] = Time.parse(headers['Last-Modified'])
+          headers['ETag'].gsub!('"','')
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/google/directories.rb b/vendor/fog-0.8.2/lib/fog/storage/models/google/directories.rb
new file mode 100644
index 0000000..d5a81ac
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/google/directories.rb
@@ -0,0 +1,43 @@
+require 'fog/core/collection'
+require 'fog/storage/models/google/directory'
+
+module Fog
+  module Google
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Google::Storage::Directory
+
+        def all
+         data = connection.get_service.body['Buckets']
+         load(data)
+        end
+
+        def get(key, options = {})
+          remap_attributes(options, {
+            :delimiter  => 'delimiter',
+            :marker     => 'marker',
+            :max_keys   => 'max-keys',
+            :prefix     => 'prefix'
+          })
+          data = connection.get_bucket(key, options).body
+          directory = new(:key => data['Name'])
+          options = {}
+          for k, v in data
+            if ['CommonPrefixes', 'Delimiter', 'IsTruncated', 'Marker', 'MaxKeys', 'Prefix'].include?(k)
+              options[k] = v
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.load(data['Contents'])
+          directory
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/google/directory.rb b/vendor/fog-0.8.2/lib/fog/storage/models/google/directory.rb
new file mode 100644
index 0000000..4ba4931
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/google/directory.rb
@@ -0,0 +1,78 @@
+require 'fog/core/model'
+require 'fog/storage/models/google/files'
+
+module Fog
+  module Google
+    class Storage
+
+      class Directory < Fog::Model
+
+        identity  :key,           :aliases => ['Name', 'name']
+
+        attribute :creation_date, :aliases => 'CreationDate'
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def destroy
+          requires :key
+          connection.delete_bucket(key)
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def files
+          @files ||= begin
+            Fog::Google::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :key
+          if connection.get_bucket_acl(key).body['AccessControlList'].detect {|entry| entry['Scope']['type'] == 'AllUsers' && entry['Permission'] == 'READ'}
+            if key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{key}.commondatastorage.googleapis.com"
+            else
+              "https://commondatastorage.googleapis.com/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save
+          requires :key
+          options = {}
+          if @acl
+            options['x-goog-acl'] = @acl
+          end
+          if @location
+            options['LocationConstraint'] = @location
+          end
+          connection.put_bucket(key, options)
+          true
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/google/file.rb b/vendor/fog-0.8.2/lib/fog/storage/models/google/file.rb
new file mode 100644
index 0000000..1883909
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/google/file.rb
@@ -0,0 +1,141 @@
+require 'fog/core/model'
+
+module Fog
+  module Google
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attribute :cache_control,       :aliases => 'Cache-Control'
+        attribute :content_disposition, :aliases => 'Content-Disposition'
+        attribute :content_encoding,    :aliases => 'Content-Encoding'
+        attribute :content_length,      :aliases => ['Content-Length', 'Size'], :type => :integer
+        attribute :content_md5,         :aliases => 'Content-MD5'
+        attribute :content_type,        :aliases => 'Content-Type'
+        attribute :etag,                :aliases => ['Etag', 'ETag']
+        attribute :expires,             :aliases => 'Expires'
+        attribute :last_modified,       :aliases => ['Last-Modified', 'LastModified']
+        attribute :metadata
+        attribute :owner,               :aliases => 'Owner'
+        attribute :storage_class,       :aliases => ['x-goog-storage-class', 'StorageClass']
+
+        def acl=(new_acl)
+          valid_acls = ['private', 'public-read', 'public-read-write', 'authenticated-read']
+          unless valid_acls.include?(new_acl)
+            raise ArgumentError.new("acl must be one of [#{valid_acls.join(', ')}]")
+          end
+          @acl = new_acl
+        end
+
+        def body
+          attributes[:body] ||= if last_modified && (file = collection.get(identity))
+            file.body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def copy(target_directory_key, target_file_key)
+          requires :directory, :key
+          connection.copy_object(directory.key, key, target_directory_key, target_file_key)
+          target_directory = connection.directories.new(:key => target_directory_key)
+          target_directory.files.get(target_file_key)
+        end
+
+        def destroy
+          requires :directory, :key
+          begin
+            connection.delete_object(directory.key, key)
+          rescue Excon::Errors::NotFound
+          end
+          true
+        end
+
+        remove_method :metadata
+        def metadata
+          attributes.reject {|key, value| !(key.to_s =~ /^x-goog-meta-/)}
+        end
+
+        remove_method :metadata=
+        def metadata=(new_metadata)
+          merge_attributes(new_metadata)
+        end
+
+        remove_method :owner=
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          if new_public
+            @acl = 'public-read'
+          else
+            @acl = 'private'
+          end
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if connection.get_object_acl(directory.key, key).body['AccessControlList'].detect {|entry| entry['Scope']['type'] == 'AllUsers' && entry['Permission'] == 'READ'}
+            if directory.key.to_s =~ /^(?:[a-z]|\d(?!\d{0,2}(?:\.\d{1,3}){3}$))(?:[a-z0-9]|\.(?![\.\-])|\-(?![\.])){1,61}[a-z0-9]$/
+              "https://#{directory.key}.commondatastorage.googleapis.com/#{key}"
+            else
+              "https://commondatastorage.googleapis.com/#{directory.key}/#{key}"
+            end
+          else
+            nil
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          if options != {}
+            Formatador.display_line("[yellow][WARN] options param is deprecated, use acl= instead[/] [light_black](#{caller.first})[/]")
+          end
+          options['x-goog-acl'] ||= @acl if @acl
+          options['Cache-Control'] = cache_control if cache_control
+          options['Content-Disposition'] = content_disposition if content_disposition
+          options['Content-Encoding'] = content_encoding if content_encoding
+          options['Content-MD5'] = content_md5 if content_md5
+          options['Content-Type'] = content_type if content_type
+          options['Expires'] = expires if expires
+          options.merge(metadata)
+
+          data = connection.put_object(directory.key, key, body, options)
+          merge_attributes(data.headers)
+          self.content_length = Fog::Storage.get_body_size(body)
+          true
+        end
+
+        def url(expires)
+          requires :key
+          collection.get_url(key, expires)
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/google/files.rb b/vendor/fog-0.8.2/lib/fog/storage/models/google/files.rb
new file mode 100644
index 0000000..64a309c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/google/files.rb
@@ -0,0 +1,96 @@
+require 'fog/core/collection'
+require 'fog/storage/models/google/file'
+
+module Fog
+  module Google
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :common_prefixes, :aliases => 'CommonPrefixes'
+        attribute :delimiter,       :aliases => 'Delimiter'
+        attribute :directory
+        attribute :is_truncated,    :aliases => 'IsTruncated'
+        attribute :marker,          :aliases => 'Marker'
+        attribute :max_keys,        :aliases => ['MaxKeys', 'max-keys']
+        attribute :prefix,          :aliases => 'Prefix'
+
+        model Fog::Google::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'delimiter'   => delimiter,
+            'marker'      => marker,
+            'max-keys'    => max_keys,
+            'prefix'      => prefix
+          }.merge!(options)
+          options = options.reject {|key,value| value.nil? || value.to_s.empty?}
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            merge_attributes(parent.files.attributes)
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        alias :each_file_this_page :each
+        def each
+          if !block_given?
+            self
+          else
+            subset = dup.all
+
+            subset.each_file_this_page {|f| yield f}
+            while subset.is_truncated
+              subset = subset.all(:marker => subset.last.key)
+              subset.each_file_this_page {|f| yield f}
+            end
+
+            self
+          end
+        end
+
+        def get(key, options = {}, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, options, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key, options)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          new(file_data)
+        rescue Excon::Errors::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/local/directories.rb b/vendor/fog-0.8.2/lib/fog/storage/models/local/directories.rb
new file mode 100644
index 0000000..8389209
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/local/directories.rb
@@ -0,0 +1,33 @@
+require 'fog/core/collection'
+require 'fog/storage/models/local/directory'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Local::Storage::Directory
+
+        def all
+          data = Dir.entries(connection.local_root).select do |entry|
+            entry[0...1] != '.' && ::File.directory?(connection.path_to(entry))
+          end.map do |entry|
+            {:key => entry}
+          end
+          load(data)
+        end
+
+        def get(key)
+          if ::File.directory?(connection.path_to(key))
+            new(:key => key)
+          else
+            nil
+          end
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/local/directory.rb b/vendor/fog-0.8.2/lib/fog/storage/models/local/directory.rb
new file mode 100644
index 0000000..a3204a2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/local/directory.rb
@@ -0,0 +1,57 @@
+require 'fog/core/model'
+require 'fog/storage/models/local/files'
+
+module Fog
+  module Local
+    class Storage
+
+      class Directory < Fog::Model
+
+        identity  :key
+
+        def destroy
+          requires :key
+
+          if ::File.directory?(path)
+            Dir.rmdir(path)
+            true
+          else
+            false
+          end
+        end
+
+        def files
+          @files ||= begin
+            Fog::Local::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          nil
+        end
+
+        def save
+          requires :key
+
+          Dir.mkdir(path)
+          true
+        end
+
+        private
+
+        def path
+          connection.path_to(key)
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/local/file.rb b/vendor/fog-0.8.2/lib/fog/storage/models/local/file.rb
new file mode 100644
index 0000000..7e4da99
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/local/file.rb
@@ -0,0 +1,111 @@
+require 'fog/core/model'
+
+module Fog
+  module Local
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'Key'
+
+        attribute :content_length,  :aliases => 'Content-Length', :type => :integer
+        # attribute :content_type,    :aliases => 'Content-Type'
+        attribute :last_modified,   :aliases => 'Last-Modified'
+
+        def body
+          attributes[:body] ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def content_type
+          @content_type ||= begin
+            unless (mime_types = ::MIME::Types.of(key)).empty?
+              mime_types.first.content_type
+            end
+          end
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          ::File.delete(path)
+          dirs = path.split(::File::SEPARATOR)[0...-1]
+          dirs.length.times do |index|
+            dir_path = dirs[0..-index].join(::File::SEPARATOR)
+            if dir_path.empty? # path starts with ::File::SEPARATOR
+              next
+            end
+            # don't delete the containing directory or higher
+            if dir_path == connection.path_to(directory.key)
+              break
+            end
+            pwd = Dir.pwd
+            Dir.chdir(dir_path)
+            if Dir.glob('*').empty?
+              Dir.rmdir(dir_path)
+            end
+            Dir.chdir(pwd)
+          end
+          true
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          nil
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          dirs = path.split(::File::SEPARATOR)[0...-1]
+          dirs.length.times do |index|
+            dir_path = dirs[0..index].join(::File::SEPARATOR)
+            if dir_path.empty? # path starts with ::File::SEPARATOR
+              next
+            end
+            # create directory if it doesn't already exist
+            unless ::File.directory?(dir_path)
+              Dir.mkdir(dir_path)
+            end
+          end
+          file = ::File.new(path, 'w')
+          if body.is_a?(String)
+            file.write(body)
+          else
+            file.write(body.read)
+          end
+          file.close
+          merge_attributes(
+            :content_length => Fog::Storage.get_body_size(body),
+            :last_modified  => ::File.mtime(path)
+          )
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+        def path
+          connection.path_to(::File.join(directory.key, key))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/local/files.rb b/vendor/fog-0.8.2/lib/fog/storage/models/local/files.rb
new file mode 100644
index 0000000..558a667
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/local/files.rb
@@ -0,0 +1,87 @@
+require 'fog/core/collection'
+require 'fog/storage/models/local/file'
+
+module Fog
+  module Local
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+
+        model Fog::Local::Storage::File
+
+        def all
+          requires :directory
+          if directory.collection.get(directory.key)
+            pwd = Dir.pwd
+            Dir.chdir(connection.path_to(directory.key))
+            data = Dir.glob('**/*').reject do |file|
+              ::File.directory?(file)
+            end.map do |key|
+              path = file_path(key)
+              {
+                :content_length => ::File.size(path),
+                :key            => key,
+                :last_modified  => ::File.mtime(path)
+              }
+            end
+            Dir.chdir(pwd)
+            load(data)
+          else
+            nil
+          end
+        end
+
+        def get(key, &block)
+          requires :directory
+          path = file_path(key)
+          if ::File.exists?(path)
+            data = {
+              :content_length => ::File.size(path),
+              :key            => key,
+              :last_modified  => ::File.mtime(path)
+            }
+            if block_given?
+              file = ::File.open(path)
+              while (chunk = file.read(Excon::CHUNK_SIZE)) && yield(chunk); end
+              file.close
+              new(data)
+            else
+              body = ::File.read(path)
+              new(data.merge!(:body => body))
+            end
+          else
+            nil
+          end
+        end
+
+        def head(key)
+          requires :directory
+          path = file_path(key)
+          if ::File.exists?(path)
+            new({
+              :content_length => ::File.size(path),
+              :key            => key,
+              :last_modified  => ::File.mtime(path)
+            })
+          else
+            nil
+          end
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+        private
+
+        def file_path(key)
+          connection.path_to(::File.join(directory.key, key))
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directories.rb b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directories.rb
new file mode 100644
index 0000000..0fb2f23
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directories.rb
@@ -0,0 +1,39 @@
+require 'fog/core/collection'
+require 'fog/storage/models/rackspace/directory'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directories < Fog::Collection
+
+        model Fog::Rackspace::Storage::Directory
+
+        def all
+          data = connection.get_containers.body
+          load(data)
+        end
+
+        def get(key, options = {})
+          data = connection.get_container(key, options)
+          directory = new(:key => key)
+          for key, value in data.headers
+            if ['X-Container-Bytes-Used', 'X-Container-Object-Count'].include?(key)
+              directory.merge_attributes(key => value)
+            end
+          end
+          directory.files.merge_attributes(options)
+          directory.files.instance_variable_set(:@loaded, true)
+          data.body.each do |file|
+            directory.files << directory.files.new(file)
+          end
+          directory
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directory.rb b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directory.rb
new file mode 100644
index 0000000..d96e7bd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/directory.rb
@@ -0,0 +1,70 @@
+require 'fog/core/model'
+require 'fog/storage/models/rackspace/files'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Directory < Fog::Model
+
+        identity  :key, :aliases => 'name'
+
+        attribute :bytes, :aliases => 'X-Container-Bytes-Used'
+        attribute :count, :aliases => 'X-Container-Object-Count'
+
+        def destroy
+          requires :key
+          connection.delete_container(key)
+          connection.cdn.post_container(key, 'X-CDN-Enabled' => 'False')
+          true
+        rescue Excon::Errors::NotFound
+          false
+        end
+
+        def files
+          @files ||= begin
+            Fog::Rackspace::Storage::Files.new(
+              :directory    => self,
+              :connection   => connection
+            )
+          end
+        end
+
+        def public=(new_public)
+          @public = new_public
+        end
+
+        def public_url
+          requires :key
+          @public_url ||= begin
+            begin response = connection.cdn.head_container(key)
+              if response.headers['X-CDN-Enabled'] == 'True'
+                if connection.rackspace_cdn_ssl == true
+                  response.headers['X-CDN-SSL-URI']
+                else
+                  response.headers['X-CDN-URI']
+                end
+              end
+            rescue Fog::Service::NotFound
+              nil
+            end
+          end
+        end
+
+        def save
+          requires :key
+          connection.put_container(key)
+          if @public
+            @public_url = connection.cdn.put_container(key, 'X-CDN-Enabled' => 'True').headers['X-CDN-URI']
+          else
+            connection.cdn.put_container(key, 'X-CDN-Enabled' => 'False')
+            @public_url = nil
+          end
+          true
+        end
+        
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/file.rb b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/file.rb
new file mode 100644
index 0000000..4ffbf05
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/file.rb
@@ -0,0 +1,77 @@
+require 'fog/core/model'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class File < Fog::Model
+
+        identity  :key,             :aliases => 'name'
+
+        attribute :content_length,  :aliases => ['bytes', 'Content-Length'], :type => :integer
+        attribute :content_type,    :aliases => ['content_type', 'Content-Type']
+        attribute :etag,            :aliases => ['hash', 'Etag']
+        attribute :last_modified,   :aliases => ['last_modified', 'Last-Modified'], :type => :time
+
+        def body
+          attributes[:body] ||= if last_modified
+            collection.get(identity).body
+          else
+            ''
+          end
+        end
+
+        def body=(new_body)
+          attributes[:body] = new_body
+        end
+
+        def directory
+          @directory
+        end
+
+        def destroy
+          requires :directory, :key
+          connection.delete_object(directory.key, key)
+          true
+        end
+
+        def owner=(new_owner)
+          if new_owner
+            attributes[:owner] = {
+              :display_name => new_owner['DisplayName'],
+              :id           => new_owner['ID']
+            }
+          end
+        end
+
+        def public=(new_public)
+          new_public
+        end
+
+        def public_url
+          requires :directory, :key
+          if @directory.public_url
+            "#{@directory.public_url}/#{key}"
+          end
+        end
+
+        def save(options = {})
+          requires :body, :directory, :key
+          options['Content-Type'] = content_type if content_type
+          data = connection.put_object(directory.key, key, body, options)
+          merge_attributes(data.headers)
+          self.content_length = Fog::Storage.get_body_size(body)
+          true
+        end
+
+        private
+
+        def directory=(new_directory)
+          @directory = new_directory
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/files.rb b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/files.rb
new file mode 100644
index 0000000..5a8c759
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/models/rackspace/files.rb
@@ -0,0 +1,92 @@
+require 'fog/core/collection'
+require 'fog/storage/models/rackspace/file'
+
+module Fog
+  module Rackspace
+    class Storage
+
+      class Files < Fog::Collection
+
+        attribute :directory
+        attribute :limit
+        attribute :marker
+        attribute :path
+        attribute :prefix
+
+        model Fog::Rackspace::Storage::File
+
+        def all(options = {})
+          requires :directory
+          options = {
+            'limit'   => limit,
+            'marker'  => marker,
+            'path'    => path,
+            'prefix'  => prefix
+          }.merge!(options)
+          merge_attributes(options)
+          parent = directory.collection.get(
+            directory.key,
+            options
+          )
+          if parent
+            load(parent.files.map {|file| file.attributes})
+          else
+            nil
+          end
+        end
+
+        alias :each_file_this_page :each
+        def each
+          if !block_given?
+            self
+          else
+            subset = dup.all
+
+            subset.each_file_this_page {|f| yield f}
+            until subset.empty? || subset.length == (subset.limit || 10000)
+              subset = subset.all(:marker => subset.last.key)
+              subset.each_file_this_page {|f| yield f}
+            end
+
+            self
+          end
+        end
+
+        def get(key, &block)
+          requires :directory
+          data = connection.get_object(directory.key, key, &block)
+          file_data = data.headers.merge({
+            :body => data.body,
+            :key  => key
+          })
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def get_url(key, expires)
+          requires :directory
+          connection.get_object_url(directory.key, key, expires)
+        end
+
+        def head(key, options = {})
+          requires :directory
+          data = connection.head_object(directory.key, key)
+          file_data = data.headers.merge({
+            :key => key
+          })
+          new(file_data)
+        rescue Fog::Rackspace::Storage::NotFound
+          nil
+        end
+
+        def new(attributes = {})
+          requires :directory
+          super({ :directory => directory }.merge!(attributes))
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/access_control_list.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/access_control_list.rb
new file mode 100644
index 0000000..0ff3d76
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/access_control_list.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @in_access_control_list = false
+            @grant = { 'Grantee' => {} }
+            @response = { 'Owner' => {}, 'AccessControlList' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            if name == 'AccessControlList'
+              @in_access_control_list = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'AccessControlList'
+              @in_access_control_list = false
+            when 'Grant'
+              @response['AccessControlList'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = value
+              else
+                @response['Owner'][name] = value
+              end
+            when 'Permission'
+              @grant[name] = value
+            when 'URI'
+              @grant['Grantee'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/complete_multipart_upload.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/complete_multipart_upload.rb
new file mode 100644
index 0000000..33eca47
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/complete_multipart_upload.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class CompleteMultipartUpload < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'ETag', 'Key', 'Location'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/copy_object.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/copy_object.rb
new file mode 100644
index 0000000..6e6930d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/copy_object.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class CopyObject < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'ETag'
+              @response[name] = value.gsub('"', '')
+            when 'LastModified'
+              @response[name] = Time.parse(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket.rb
new file mode 100644
index 0000000..3f05153
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucket < Fog::Parsers::Base
+
+          def reset
+            @object = { 'Owner' => {} }
+            @response = { 'Contents' => [], 'CommonPrefixes' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = false
+            when 'Contents'
+              @response['Contents'] << @object
+              @object = { 'Owner' => {} }
+            when 'DisplayName', 'ID'
+              @object['Owner'][name] = value
+            when 'ETag'
+              @object[name] = value.gsub('"', '')
+            when 'IsTruncated'
+              if value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              @object['LastModified'] = Time.parse(value)
+            when 'Marker', 'Name'
+              @response[name] = value
+            when 'MaxKeys'
+              @response['MaxKeys'] = value.to_i
+            when 'Prefix'
+              if @in_common_prefixes
+                @response['CommonPrefixes'] << value
+              else
+                @response[name] = value
+              end
+            when 'Size'
+              @object['Size'] = value.to_i
+            when 'Delimiter', 'Key', 'StorageClass'
+              @object[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_location.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_location.rb
new file mode 100644
index 0000000..d1bba6c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_location.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketLocation < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'LocationConstraint'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_logging.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_logging.rb
new file mode 100644
index 0000000..322b110
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_logging.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketLogging < Fog::Parsers::Base
+
+          def reset
+            @grant = { 'Grantee' => {} }
+            @response = { 'BucketLoggingStatus' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = value
+              else
+                @response['Owner'][name] = value
+              end
+            when 'Grant'
+              @response['BucketLoggingStatus']['LoggingEnabled']['TargetGrants'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'LoggingEnabled'
+              @response['BucketLoggingStatus']['LoggingEnabled'] = { 'TargetGrants' => [] }
+            when 'Permission'
+              @grant[name] = value
+            when 'TargetBucket', 'TargetPrefix'
+              @response['BucketLoggingStatus'][name] = value
+            when 'URI'
+              @grant['Grantee'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_object_versions.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_object_versions.rb
new file mode 100644
index 0000000..2618e9f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_object_versions.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketObjectVersions < Fog::Parsers::Base
+
+          def reset
+            @delete_marker = { 'Owner' => {} }
+            @version = { 'Owner' => {} }
+
+            @in_delete_marke = false
+            @in_version = false
+
+            @response = { 'Versions' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'DeleteMarker'
+              @in_delete_marker = true
+            when 'Version'
+              @in_version = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DeleteMarker'
+              @response['Versions'] << {'DeleteMarker' => @delete_marker }
+              @delete_marker = { 'Owner' => {} }
+              @in_delete_marker = false
+            when 'Version'
+              @response['Versions'] << {'Version' => @version }
+              @version = { 'Owner' => {} }
+              @in_version = false
+            when 'DisplayName', 'ID'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['Owner'][name] = value
+            when 'ETag'
+              @version[name] = value.gsub('"', '')
+            when 'IsLatest'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['IsLatest'] = if value == 'true'
+                true
+              else
+                false
+              end
+            when 'IsTruncated'
+              if value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['LastModified'] = Time.parse(value)
+            when 'MaxKeys'
+              @response['MaxKeys'] = value.to_i
+            when 'Size'
+              @version['Size'] = value.to_i
+            when 'Key', 'KeyMarker', 'Name', 'Prefix', 'StorageClass', 'VersionId', 'VersionIdMarker'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              else
+                @response
+              end[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_versioning.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_versioning.rb
new file mode 100644
index 0000000..ebf2e75
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_versioning.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketVersioning < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VersioningConfiguration' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Status'
+              @response['VersioningConfiguration'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_website.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_website.rb
new file mode 100644
index 0000000..7998a84
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_bucket_website.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetBucketWebsite < Fog::Parsers::Base
+
+          def reset
+            @response = { 'ErrorDocument' => {}, 'IndexDocument' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Key'
+              @response['ErrorDocument'][name] = value
+            when 'Suffix'
+              @response['IndexDocument'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_request_payment.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_request_payment.rb
new file mode 100644
index 0000000..a8cad9e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_request_payment.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetRequestPayment < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'Payer'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_service.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_service.rb
new file mode 100644
index 0000000..f1c7626
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/get_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class GetService < Fog::Parsers::Base
+
+          def reset
+            @bucket = {}
+            @response = { 'Owner' => {}, 'Buckets' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket'
+              @response['Buckets'] << @bucket
+              @bucket = {}
+            when 'CreationDate'
+              @bucket['CreationDate'] = Time.parse(value)
+            when 'DisplayName', 'ID'
+              @response['Owner'][name] = value
+            when 'Name'
+              @bucket[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/initiate_multipart_upload.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/initiate_multipart_upload.rb
new file mode 100644
index 0000000..05d1689
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/initiate_multipart_upload.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class InitiateMultipartUpload < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'Key', 'UploadId'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_multipart_uploads.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_multipart_uploads.rb
new file mode 100644
index 0000000..17ca6fe
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_multipart_uploads.rb
@@ -0,0 +1,56 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class ListMultipartUploads < Fog::Parsers::Base
+
+          def reset
+            @upload = { 'Initiator' => {}, 'Owner' => {} }
+            @response = { 'Upload' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Initiator'
+              @in_initiator = true
+            when 'Owner'
+              @in_owner = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'KeyMarker', 'NextKeyMarker', 'NextUploadIdMarker', 'UploadIdMarker'
+              @response[name] = value
+            when 'DisplayName', 'ID'
+              if @in_initiator
+                @upload['Initiator'][name] = value
+              elsif @in_owner
+                @upload['Owner'][name] = value
+              end
+            when 'Initiated'
+              @upload[name] = Time.parse(value)
+            when 'Initiator'
+              @in_initiator = false
+            when 'IsTruncated'
+              @response[name] = value == 'true'
+            when 'Key', 'StorageClass', 'UploadId'
+              @upload[name] = value
+            when 'MaxUploads'
+              @response[name] = value.to_i
+            when 'Owner'
+              @in_owner = false
+            when 'Upload'
+              @response['Upload'] << @upload
+              @upload = { 'Initiator' => {}, 'Owner' => {} }
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_parts.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_parts.rb
new file mode 100644
index 0000000..11055a7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/aws/list_parts.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module AWS
+      module Storage
+
+        class ListParts < Fog::Parsers::Base
+
+          def reset
+            @part = {}
+            @response = { 'Initiator' => {}, 'Part' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket', 'Key', 'NextPartNumberMarker', 'PartNumberMarker', 'StorageClass', 'UploadId'
+              @response[name] = value
+            when 'DisplayName', 'ID'
+              @response['Initiator'][name] = value
+            when 'ETag'
+              @part[name] = value
+            when 'IsTruncated'
+              @response[name] = value == 'true'
+            when 'LastModified'
+              @part[name] = Time.parse(value)
+            when 'MaxParts'
+              @response[name] = value.to_i
+            when 'Part'
+              @response['Part'] << @part
+              @part = {}
+            when 'PartNumber', 'Size'
+              @part[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/access_control_list.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/access_control_list.rb
new file mode 100644
index 0000000..61e2539
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/access_control_list.rb
@@ -0,0 +1,48 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @in_entries = false
+            @entry = { 'Scope' => {} }
+            @response = { 'Owner' => {}, 'AccessControlList' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'Entries'
+              @in_entries = true
+            when 'Scope'
+              key, value = attrs.first
+              @entry['Scope'][key] = value
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Entries'
+              @in_entries = false
+            when 'Entry'
+              @response['AccessControlList'] << @entry
+              @entry = { 'Scope' => {} }
+            when 'DisplayName', 'ID'
+              if @in_entries
+                @entry['Scope'][name] = value
+              else
+                @response['Owner'][name] = value
+              end
+            when 'Permission'
+              @entry[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/copy_object.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/copy_object.rb
new file mode 100644
index 0000000..cbc9ca4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/copy_object.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class CopyObject < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'ETag'
+              @response[name] = value.gsub('"', '')
+            when 'LastModified'
+              @response[name] = Time.parse(value)
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket.rb
new file mode 100644
index 0000000..ed05cca
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket.rb
@@ -0,0 +1,62 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucket < Fog::Parsers::Base
+
+          def reset
+            @object = { 'Owner' => {} }
+            @response = { 'Contents' => [], 'CommonPrefixes' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'CommonPrefixes'
+              @in_common_prefixes = false
+            when 'Contents'
+              @response['Contents'] << @object
+              @object = { 'Owner' => {} }
+            when 'DisplayName', 'ID'
+              @object['Owner'][name] = value
+            when 'ETag'
+              @object[name] = value.gsub('"', '')
+            when 'IsTruncated'
+              if value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              @object['LastModified'] = Time.parse(value)
+            when 'Marker', 'Name'
+              @response[name] = value
+            when 'MaxKeys'
+              @response['MaxKeys'] = value.to_i
+            when 'Prefix'
+              if @in_common_prefixes
+                @response['CommonPrefixes'] << value
+              else
+                @response[name] = value
+              end
+            when 'Size'
+              @object['Size'] = value.to_i
+            when 'Delimiter', 'Key', 'StorageClass'
+              @object[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_logging.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_logging.rb
new file mode 100644
index 0000000..be85482
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_logging.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class AccessControlList < Fog::Parsers::Base
+
+          def reset
+            @grant = { 'Grantee' => {} }
+            @response = { 'BucketLoggingStatus' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'DisplayName', 'ID'
+              if @in_access_control_list
+                @grant['Grantee'][name] = value
+              else
+                @response['Owner'][name] = value
+              end
+            when 'Grant'
+              @response['BucketLoggingStatus']['LoggingEnabled']['TargetGrants'] << @grant
+              @grant = { 'Grantee' => {} }
+            when 'LoggingEnabled'
+              @response['BucketLoggingStatus']['LoggingEnabled'] = { 'TargetGrants' => [] }
+            when 'Permission'
+              @grant[name] = value
+            when 'TargetBucket', 'TargetPrefix'
+              @response['BucketLoggingStatus'][name] = value
+            when 'URI'
+              @grant['Grantee'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_object_versions.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_object_versions.rb
new file mode 100644
index 0000000..b96439e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_object_versions.rb
@@ -0,0 +1,88 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucketObjectVersions < Fog::Parsers::Base
+
+          def reset
+            @delete_marker = { 'Owner' => {} }
+            @version = { 'Owner' => {} }
+
+            @in_delete_marke = false
+            @in_version = false
+
+            @response = { 'Versions' => [] }
+          end
+
+          def start_element(name, attrs = [])
+            super
+            case name
+            when 'DeleteMarker'
+              @in_delete_marker = true
+            when 'Version'
+              @in_version = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'DeleteMarker'
+              @response['Versions'] << {'DeleteMarker' => @delete_marker }
+              @delete_marker = { 'Owner' => {} }
+              @in_delete_marker = false
+            when 'Version'
+              @response['Versions'] << {'Version' => @version }
+              @version = { 'Owner' => {} }
+              @in_version = false
+            when 'DisplayName', 'ID'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['Owner'][name] = value
+            when 'ETag'
+              @version[name] = value.gsub('"', '')
+            when 'IsLatest'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['IsLatest'] = if value == 'true'
+                true
+              else
+                false
+              end
+            when 'IsTruncated'
+              if value == 'true'
+                @response['IsTruncated'] = true
+              else
+                @response['IsTruncated'] = false
+              end
+            when 'LastModified'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end['LastModified'] = Time.parse(value)
+            when 'KeyMarker', 'Name', 'Prefix', 'VersionIdMarker'
+              @response[name] = value
+            when 'MaxKeys'
+              @response['MaxKeys'] = value.to_i
+            when 'Size'
+              @version['Size'] = value.to_i
+            when 'Key', 'Name', 'StorageClass', 'VersionId'
+              if @in_delete_marker
+                @delete_marker
+              elsif @in_version
+                @version
+              end[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_versioning.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_versioning.rb
new file mode 100644
index 0000000..48cfb96
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_bucket_versioning.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetBucketVersioning < Fog::Parsers::Base
+
+          def reset
+            @response = { 'VersioningConfiguration' => {} }
+          end
+
+          def end_element(name)
+            case name
+            when 'Status'
+              @response['VersioningConfiguration'][name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_request_payment.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_request_payment.rb
new file mode 100644
index 0000000..058ee8c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_request_payment.rb
@@ -0,0 +1,20 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetRequestPayment < Fog::Parsers::Base
+
+          def end_element(name)
+            case name
+            when 'Payer'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_service.rb b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_service.rb
new file mode 100644
index 0000000..4b8a8b0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/parsers/google/get_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Google
+      module Storage
+
+        class GetService < Fog::Parsers::Base
+
+          def reset
+            @bucket = {}
+            @response = { 'Owner' => {}, 'Buckets' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Bucket'
+              @response['Buckets'] << @bucket
+              @bucket = {}
+            when 'CreationDate'
+              @bucket['CreationDate'] = Time.parse(value)
+            when 'DisplayName', 'ID'
+              @response['Owner'][name] = value
+            when 'Name'
+              @bucket[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/rackspace.rb b/vendor/fog-0.8.2/lib/fog/storage/rackspace.rb
new file mode 100644
index 0000000..b862411
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/rackspace.rb
@@ -0,0 +1,135 @@
+module Fog
+  module Rackspace
+    class Storage < Fog::Service
+
+      requires :rackspace_api_key, :rackspace_username
+      recognizes :rackspace_auth_url, :rackspace_servicenet, :rackspace_cdn_ssl, :persistent
+      recognizes :provider # remove post deprecation
+
+      model_path 'fog/storage/models/rackspace'
+      model       :directory
+      collection  :directories
+      model       :file
+      collection  :files
+
+      request_path 'fog/storage/requests/rackspace'
+      request :delete_container
+      request :delete_object
+      request :get_container
+      request :get_containers
+      request :get_object
+      request :head_container
+      request :head_containers
+      request :head_object
+      request :put_container
+      request :put_object
+
+      module Utils
+
+        def cdn
+          @cdn ||= Fog::CDN.new(
+            :provider           => 'Rackspace',
+            :rackspace_api_key  => @rackspace_api_key,
+            :rackspace_username => @rackspace_username
+          )
+        end
+
+      end
+
+      class Mock
+        include Utils
+
+        def self.data
+          @data ||= Hash.new do |hash, key|
+            hash[key] = {}
+          end
+        end
+
+        def self.reset
+          @data = nil
+        end
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          @rackspace_api_key = options[:rackspace_api_key]
+          @rackspace_username = options[:rackspace_username]
+        end
+
+        def data
+          self.class.data[@rackspace_username]
+        end
+
+        def reset_data
+          self.class.data.delete(@rackspace_username)
+        end
+
+      end
+
+      class Real
+        include Utils
+        attr_reader :rackspace_cdn_ssl
+
+        def initialize(options={})
+          unless options.delete(:provider)
+            location = caller.first
+            warning = "[yellow][WARN] Fog::Rackspace::Storage.new is deprecated, use Fog::Storage.new(:provider => 'Rackspace') instead[/]"
+            warning << " [light_black](" << location << ")[/] "
+            Formatador.display_line(warning)
+          end
+
+          require 'mime/types'
+          require 'json'
+          @rackspace_api_key = options[:rackspace_api_key]
+          @rackspace_username = options[:rackspace_username]
+          @rackspace_cdn_ssl = options[:rackspace_cdn_ssl]
+          credentials = Fog::Rackspace.authenticate(options)
+          @auth_token = credentials['X-Auth-Token']
+
+          uri = URI.parse(credentials['X-Storage-Url'])
+          @host   = options[:rackspace_servicenet] == true ? "snet-#{uri.host}" : uri.host
+          @path   = uri.path
+          @port   = uri.port
+          @scheme = uri.scheme
+          Excon.ssl_verify_peer = false if options[:rackspace_servicenet] == true
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def reload
+          @storage_connection.reset
+        end
+
+        def request(params, parse_json = true, &block)
+          begin
+            response = @connection.request(params.merge!({
+              :headers  => {
+                'Content-Type' => 'application/json',
+                'X-Auth-Token' => @auth_token
+              }.merge!(params[:headers] || {}),
+              :host     => @host,
+              :path     => "#{@path}/#{params[:path]}",
+            }), &block)
+          rescue Excon::Errors::HTTPStatusError => error
+            raise case error
+            when Excon::Errors::NotFound
+              Fog::Rackspace::Storage::NotFound.slurp(error)
+            else
+              error
+            end
+          end
+          if !response.body.empty? && parse_json && response.headers['Content-Type'] =~ %r{application/json}
+            response.body = JSON.parse(response.body)
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/abort_multipart_upload.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/abort_multipart_upload.rb
new file mode 100644
index 0000000..3cf9bda
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/abort_multipart_upload.rb
@@ -0,0 +1,30 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Abort a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to abort multipart upload on
+        # * object_name<~String> - Name of object to abort multipart upload on
+        # * upload_id<~String> - Id of upload to add part to
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadAbort.html
+        #
+        def abort_multipart_upload(bucket_name, object_name, upload_id)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id}
+          })
+        end
+
+      end # Real
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/complete_multipart_upload.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/complete_multipart_upload.rb
new file mode 100644
index 0000000..4570b2b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/complete_multipart_upload.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/complete_multipart_upload'
+
+        # Complete a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to complete multipart upload for
+        # * object_name<~String> - Name of object to complete multipart upload for
+        # * upload_id<~String> - Id of upload to add part to
+        # * parts<~Array>: Array of etags for parts
+        #   * :etag<~String> - Etag for this part
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'Bucket'<~String> - bucket of new object
+        #     * 'ETag'<~String> - etag of new object (will be needed to complete upload)
+        #     * 'Key'<~String> - key of new object
+        #     * 'Location'<~String> - location of new object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadComplete.html
+        #
+        def complete_multipart_upload(bucket_name, object_name, upload_id, parts)
+          data = "<CompleteMultipartUpload>"
+          parts.each_with_index do |part, index|
+            data << "<Part>"
+            data << "<PartNumber>#{index + 1}</PartNumber>"
+            data << "<ETag>#{part}</ETag>"
+            data << "</Part>"
+          end
+          data << "</CompleteMultipartUpload>"
+          request({
+            :body       => data,
+            :expects    => 200,
+            :headers    => { 'Content-Length' => data.length },
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::Storage::CompleteMultipartUpload.new,
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id}
+          })
+        end
+
+      end # Real
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/copy_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/copy_object.rb
new file mode 100644
index 0000000..3c842db
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/copy_object.rb
@@ -0,0 +1,76 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/copy_object'
+
+        # Copy an object from one S3 bucket to another
+        #
+        # ==== Parameters
+        # * source_bucket_name<~String> - Name of source bucket
+        # * source_object_name<~String> - Name of source object
+        # * target_bucket_name<~String> - Name of bucket to create copy in
+        # * target_object_name<~String> - Name for new copy of object
+        # * options<~Hash>:
+        #   * 'x-amz-metadata-directive'<~String> - Specifies whether to copy metadata from source or replace with data in request.  Must be in ['COPY', 'REPLACE']
+        #   * 'x-amz-copy_source-if-match'<~String> - Copies object if its etag matches this value
+        #   * 'x-amz-copy_source-if-modified_since'<~Time> - Copies object it it has been modified since this time
+        #   * 'x-amz-copy_source-if-none-match'<~String> - Copies object if its etag does not match this value
+        #   * 'x-amz-copy_source-if-unmodified-since'<~Time> - Copies object it it has not been modified since this time
+        #   * 'x-amz-storage-class'<~String> - Default is 'STANDARD', set to 'REDUCED_REDUNDANCY' for non-critical, reproducable data
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #     * 'LastModified'<~Time> - date object was last modified
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectCOPY.html
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          headers = { 'x-amz-copy-source' => "/#{source_bucket_name}/#{source_object_name}" }.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{target_bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::AWS::Storage::CopyObject.new,
+            :path     => CGI.escape(target_object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          response = Excon::Response.new
+          source_bucket = self.data[:buckets][source_bucket_name]
+          source_object = source_bucket && source_bucket[:objects][source_object_name]
+          target_bucket = self.data[:buckets][target_bucket_name]
+
+          if source_object && target_bucket
+            response.status = 200
+            target_object = source_object.dup
+            target_object.merge!({
+              'Name' => target_object_name
+            })
+            target_bucket[:objects][target_object_name] = target_object
+            response.body = {
+              'ETag'          => target_object['ETag'],
+              'LastModified'  => Time.parse(target_object['Last-Modified'])
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket.rb
new file mode 100644
index 0000000..696c1c9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketDELETE.html
+
+        def delete_bucket(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE'
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def delete_bucket(bucket_name)
+          response = Excon::Response.new
+          if self.data[:buckets][bucket_name].nil?
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          elsif self.data[:buckets][bucket_name] && !self.data[:buckets][bucket_name][:objects].empty?
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          else
+            self.data[:buckets].delete(bucket_name)
+            response.status = 204
+          end
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket_website.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket_website.rb
new file mode 100644
index 0000000..b27d366
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_bucket_website.rb
@@ -0,0 +1,32 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete website configuration for a bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete website configuration from
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketDELETEwebsite.html
+
+        def delete_bucket_website(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE',
+            :query    => {'website' => nil}
+          })
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_object.rb
new file mode 100644
index 0000000..831490a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/delete_object.rb
@@ -0,0 +1,49 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Delete an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object to delete
+        # * object_name<~String> - Name of object to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectDELETE.html
+
+        def delete_object(bucket_name, object_name)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def delete_object(bucket_name, object_name)
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            response.status = 204
+            bucket[:objects].delete(object_name)
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket.rb
new file mode 100644
index 0000000..222456f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket.rb
@@ -0,0 +1,111 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket'
+
+        # List information about objects in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'CommonPrefixes'<~Array> - Array of strings for common prefixes
+        #     * 'Contents'<~Array>:
+        #       * 'ETag'<~String>: Etag of object
+        #       * 'Key'<~String>: Name of object
+        #       * 'LastModified'<~String>: Timestamp of last modification of object
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'Size'<~Integer> - Size of object
+        #       * 'StorageClass'<~String> - Storage class of object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGET.html
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucket.new,
+            :query    => options
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          if options['delimiter']
+            Fog::Mock.not_implemented
+          end
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            contents = bucket[:objects].values.sort {|x,y| x['Key'] <=> y['Key']}.reject do |object|
+                (options['prefix'] && object['Key'][0...options['prefix'].length] != options['prefix']) ||
+                (options['marker'] && object['Key'] <= options['marker'])
+              end.map do |object|
+                data = object.reject {|key, value| !['ETag', 'Key', 'StorageClass'].include?(key)}
+                data.merge!({
+                  'LastModified' => Time.parse(object['Last-Modified']),
+                  'Owner'        => bucket['Owner'],
+                  'Size'         => object['Content-Length'].to_i
+                })
+              data
+            end
+            max_keys = options['max-keys'] || 1000
+            size = [max_keys, 1000].min
+            truncated_contents = contents[0...size]
+
+            response.status = 200
+            response.body = {
+              'CommonPrefixes'  => [],
+              'Contents'        => truncated_contents,
+              'IsTruncated'     => truncated_contents.size != contents.size,
+              'Marker'          => options['marker'],
+              'MaxKeys'         => max_keys,
+              'Name'            => bucket['Name'],
+              'Prefix'          => options['prefix']
+            }
+            if options['max-keys'] && options['max-keys'] < response.body['Contents'].length
+                response.body['IsTruncated'] = true
+                response.body['Contents'] = response.body['Contents'][0...options['max-keys']]
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_acl.rb
new file mode 100644
index 0000000..117fe7c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_acl.rb
@@ -0,0 +1,66 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/access_control_list'
+
+        # Get access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get access control list for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETacl.html
+
+        def get_bucket_acl(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :query      => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_acl(bucket_name)
+          response = Excon::Response.new
+          if acl = self.data[:acls][:bucket][bucket_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_location.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_location.rb
new file mode 100644
index 0000000..170d785
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_location.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket_location'
+
+        # Get location constraint for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get location constraint for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'LocationConstraint'<~String> - Location constraint of the bucket
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETlocation.html
+
+        def get_bucket_location(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketLocation.new,
+            :query    => {'location' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_bucket_location(bucket_name)
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            response.status = 200
+            response.body = {'LocationConstraint' => bucket['LocationConstraint'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_logging.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_logging.rb
new file mode 100644
index 0000000..a1b30be
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_logging.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket_logging'
+
+        # Get logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get logging status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'BucketLoggingStatus'<~Hash>: (will be empty if logging is disabled)
+        #       * 'LoggingEnabled'<~Hash>:
+        #         * 'TargetBucket'<~String> - bucket where logs are stored
+        #         * 'TargetPrefix'<~String> - prefix logs are stored with
+        #         * 'TargetGrants'<~Array>:
+        #           * 'Grant'<~Hash>:
+        #             * 'Grantee'<~Hash>:
+        #                 * 'DisplayName'<~String> - Display name of grantee
+        #                 * 'ID'<~String> - Id of grantee
+        #               or
+        #                 * 'URI'<~String> - URI of group to grant access for
+        #             * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETlogging.html
+
+        def get_bucket_logging(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketLogging.new,
+            :query      => {'logging' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_object_versions.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_object_versions.rb
new file mode 100644
index 0000000..cda7e19
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_object_versions.rb
@@ -0,0 +1,75 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket_object_versions'
+
+        # List information about object versions in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'key-marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #   * 'version-id-marker'<~String> - limits object versions to only those that
+        #     appear lexicographically after its value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'KeyMarker'<~String> - Key marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'VersionIdMarker'<~String> - Version id marker specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not this is the totality of the bucket
+        #     * 'Versions'<~Array>:
+        #         * 'DeleteMarker'<~Hash>:
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'VersionId'<~String> - The id of this version
+        #       or
+        #         * 'Version'<~Hash>:
+        #           * 'ETag'<~String>: Etag of object
+        #           * 'IsLatest'<~Boolean> - Whether or not this is the latest version
+        #           * 'Key'<~String> - Name of object
+        #           * 'LastModified'<~String>: Timestamp of last modification of object
+        #           * 'Owner'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of object owner
+        #             * 'ID'<~String> - Id of object owner
+        #           * 'Size'<~Integer> - Size of object
+        #           * 'StorageClass'<~String> - Storage class of object
+        #           * 'VersionId'<~String> - The id of this version
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETVersion.html
+
+        def get_bucket_object_versions(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetBucketObjectVersions.new,
+            :query    => {'versions' => nil}.merge!(options)
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_versioning.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_versioning.rb
new file mode 100644
index 0000000..fb7ff9a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_versioning.rb
@@ -0,0 +1,40 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket_versioning'
+
+        # Get versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get versioning status for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'VersioningConfiguration'<~Hash>
+        #         * Status<~String>: Versioning status in ['Enabled', 'Suspended', nil]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETversioningStatus.html
+
+        def get_bucket_versioning(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketVersioning.new,
+            :query      => {'versioning' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_website.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_website.rb
new file mode 100644
index 0000000..1135b22
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_bucket_website.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_bucket_website'
+
+        # Get website configuration for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get website configuration for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * IndexDocument<~Hash>
+        #       * Suffix<~String> - Suffix appended when directory is requested
+        #     * ErrorDocument<~Hash>
+        #       * Key<~String> - Object key to return for 4XX class errors
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketGETwebsite.html
+
+        def get_bucket_website(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::GetBucketWebsite.new,
+            :query      => {'website' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object.rb
new file mode 100644
index 0000000..f33ba6c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object.rb
@@ -0,0 +1,107 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGET.html
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = Fog::Time.at(options['If-Modified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = Fog::Time.at(options['If-Unmodified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => [ 200, 206 ],
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          }, &block)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          response = Excon::Response.new
+          if (bucket = self.data[:buckets][bucket_name]) && (object = bucket[:objects][object_name])
+            if options['If-Match'] && options['If-Match'] != object['ETag']
+              response.status = 412
+            elsif options['If-Modified-Since'] && options['If-Modified-Since'] > Time.parse(object['Last-Modified'])
+              response.status = 304
+            elsif options['If-None-Match'] && options['If-None-Match'] == object['ETag']
+              response.status = 304
+            elsif options['If-Unmodified-Since'] && options['If-Unmodified-Since'] < Time.parse(object['Last-Modified'])
+              response.status = 412
+            else
+              response.status = 200
+              for key, value in object
+                case key
+                when 'Cache-Control', 'Content-Disposition', 'Content-Encoding', 'Content-Length', 'Content-MD5', 'Content-Type', 'ETag', 'Expires', 'Last-Modified', /^x-amz-meta-/
+                  response.headers[key] = value
+                end
+              end
+              unless block_given?
+                response.body = object[:body]
+              else
+                data = StringIO.new(object[:body])
+                remaining = data.length
+                while remaining > 0
+                  chunk = data.read([remaining, Excon::CHUNK_SIZE].min)
+                  block.call(chunk)
+                  remaining -= Excon::CHUNK_SIZE
+                end
+              end
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_acl.rb
new file mode 100644
index 0000000..7df015e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_acl.rb
@@ -0,0 +1,77 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/access_control_list'
+
+        # Get access control list for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get access control list for
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGETacl.html
+
+        def get_object_acl(bucket_name, object_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::AWS::Storage::AccessControlList.new,
+            :path       => CGI.escape(object_name),
+            :query      => query
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object_acl(bucket_name, object_name)
+          response = Excon::Response.new
+          if acl = self.data[:acls][:object][bucket_name] && self.data[:acls][:object][bucket_name][object_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_torrent.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_torrent.rb
new file mode 100644
index 0000000..d3f9461
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_torrent.rb
@@ -0,0 +1,50 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get torrent for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get torrent for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of grantee
+        #             * 'ID'<~String> - Id of grantee
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectGETtorrent.html
+
+        def get_object_torrent(bucket_name, object_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :path       => CGI.escape(object_name),
+            :query      => {'torrent' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_url.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_url.rb
new file mode 100644
index 0000000..3b1f223
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_object_url.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/S3_QSAuth.html
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_request_payment.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_request_payment.rb
new file mode 100644
index 0000000..6bdb26c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_request_payment.rb
@@ -0,0 +1,52 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_request_payment'
+
+        # Get configured payer for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get payer for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Payer'<~String> - Specifies who pays for download and requests
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTrequestPaymentGET.html
+
+        def get_request_payment(bucket_name)
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetRequestPayment.new,
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_request_payment(bucket_name)
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            response.status = 200
+            response.body = { 'Payer' => bucket['Payer'] }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_service.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_service.rb
new file mode 100644
index 0000000..9b5f55c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/get_service.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/get_service'
+
+        # List information about S3 buckets for authorized user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Buckets'<~Hash>:
+        #       * 'Name'<~String> - Name of bucket
+        #       * 'CreationTime'<~Time> - Timestamp of bucket creation
+        #     * 'Owner'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of bucket owner
+        #       * 'ID'<~String> - Id of bucket owner
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTServiceGET.html
+        #
+        def get_service
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => @host,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::GetService.new,
+            :url      => @host
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def get_service
+          response = Excon::Response.new
+          response.headers['Status'] = 200
+          buckets = self.data[:buckets].values.map do |bucket|
+            bucket.reject do |key, value|
+              !['CreationDate', 'Name'].include?(key)
+            end
+          end
+          response.body = {
+            'Buckets' => buckets,
+            'Owner'   => { 'DisplayName' => 'owner', 'ID' => 'some_id'}
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/head_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/head_object.rb
new file mode 100644
index 0000000..ff044e8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/head_object.rb
@@ -0,0 +1,68 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get headers for an object from S3
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectHEAD.html
+
+        def head_object(bucket_name, object_name, options={})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = Fog::Time.at(options['If-Modified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = Fog::Time.at(options['If-Unmodified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'HEAD',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def head_object(bucket_name, object_name, options = {})
+          response = get_object(bucket_name, object_name, options)
+          response.body = nil
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/initiate_multipart_upload.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/initiate_multipart_upload.rb
new file mode 100644
index 0000000..c339256
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/initiate_multipart_upload.rb
@@ -0,0 +1,47 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/initiate_multipart_upload'
+
+        # Initiate a multipart upload to an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message (defaults to Base64 encoded MD5 of object.read)
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-amz-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~String> - Bucket where upload was initiated
+        #     * 'Key'<~String> - Object key where the upload was initiated
+        #     * 'UploadId'<~String> - Id for initiated multipart upload
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadInitiate.html
+        #
+        def initiate_multipart_upload(bucket_name, object_name, options = {})
+          request({
+            :expects    => 200,
+            :headers    => options,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'POST',
+            :parser     => Fog::Parsers::AWS::Storage::InitiateMultipartUpload.new,
+            :path       => CGI.escape(object_name),
+            :query      => {'uploads' => nil}
+          })
+        end
+
+      end # Real
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_multipart_uploads.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_multipart_uploads.rb
new file mode 100644
index 0000000..a7529ca
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_multipart_uploads.rb
@@ -0,0 +1,60 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/list_multipart_uploads'
+
+        # List multipart uploads for a bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to list multipart uploads for
+        # * upload_id<~String> - upload id to list objects for
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'key-marker'<~String> - limits parts to only those that appear
+        #     lexicographically after this key.
+        #   * 'max-uploads'<~Integer> - limits number of uploads returned
+        #   * 'upload-id-marker'<~String> - limits uploads to only those that appear
+        #     lexicographically after this upload id.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~string> - Bucket where the multipart upload was initiated
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'KeyMarker'<~String> - first key in list, only upload ids after this lexographically will appear
+        #     * 'MaxUploads'<~Integer> - Maximum results to return
+        #     * 'NextKeyMarker'<~String> - last key in list, for further pagination
+        #     * 'NextUploadIdMarker'<~String> - last key in list, for further pagination
+        #     * 'Upload'<~Hash>:
+        #       * 'Initiated'<~Time> - Time when upload was initiated
+        #       * 'Initiator'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of upload initiator
+        #         * 'ID'<~String> - Id of upload initiator
+        #       * 'Key'<~String> - Key where multipart upload was initiated
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of upload owner
+        #         * 'ID'<~String> - Id of upload owner
+        #       * 'StorageClass'<~String> - Storage class of object
+        #       * 'UploadId'<~String> - upload id of upload containing part
+        #     * 'UploadIdMarker'<String> - first key in list, only upload ids after this lexographically will appear
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadListMPUpload.html
+        #
+        def list_multipart_uploads(bucket_name, options = {})
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::ListMultipartUploads.new,
+            :query    => options.merge!({'uploads' => nil})
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_parts.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_parts.rb
new file mode 100644
index 0000000..c059731
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/list_parts.rb
@@ -0,0 +1,59 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/aws/list_parts'
+
+        # List parts for a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to list parts for
+        # * object_name<~String> - Name of object to list parts for
+        # * upload_id<~String> - upload id to list objects for
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'max-parts'<~Integer> - limits number of parts returned
+        #   * 'part-number-marker'<~String> - limits parts to only those that appear
+        #     lexicographically after this part number.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Bucket'<~string> - Bucket where the multipart upload was initiated
+        #     * 'Initiator'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of upload initiator
+        #       * 'ID'<~String> - Id of upload initiator
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Key'<~String> - Key where multipart upload was initiated
+        #     * 'MaxParts'<~String> - maximum number of replies alllowed in response
+        #     * 'NextPartNumberMarker'<~String> - last item in list, for further pagination
+        #     * 'Part'<~Array>:
+        #       * 'ETag'<~String> - ETag of part
+        #       * 'LastModified'<~Timestamp> - Last modified for part
+        #       * 'PartNumber'<~String> - Part number for part
+        #       * 'Size'<~Integer> - Size of part
+        #     * 'PartNumberMarker'<~String> - Part number after which listing begins
+        #     * 'StorageClass'<~String> - Storage class of object
+        #     * 'UploadId'<~String> - upload id of upload containing part
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadListParts.html
+        #
+        def list_parts(bucket_name, object_name, upload_id, options = {})
+          options['uploadId'] = upload_id
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::AWS::Storage::ListParts.new,
+            :path     => CGI.escape(object_name),
+            :query    => options.merge!({'uploadId' => upload_id})
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/post_object_hidden_fields.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/post_object_hidden_fields.rb
new file mode 100644
index 0000000..1612780
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/post_object_hidden_fields.rb
@@ -0,0 +1,42 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get a hash of hidden fields for form uploading to S3, in the form {:field_name => :field_value}
+        # Form should look like: <form action="http://#{bucket_name}.s3.amazonaws.com/" method="post" enctype="multipart/form-data">
+        # These hidden fields should then appear, followed by a field named 'file' which is either a textarea or file input.
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * acl<~String> - access control list, in ['private', 'public-read', 'public-read-write', 'authenticated-read', 'bucket-owner-read', 'bucket-owner-full-control']
+        #   * Cache-Control - same as REST header
+        #   * Content-Type - same as REST header
+        #   * Content-Disposition - same as REST header
+        #   * Content-Encoding - same as REST header
+        #   * Expires - same as REST header
+        #   * key - key for object, set to '${filename}' to use filename provided by user
+        #   * policy - security policy for upload
+        #   * success_action_redirect - url to redirct to upon success
+        #   * success_action_status - status code to return on success, in [200, 201, 204]
+        #   * x-amz-security-token - devpay security token
+        #   * x-amz-meta-... - meta data tags
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/HTTPPOSTForms.html
+
+        def post_object_hidden_fields(options = {})
+          if options['policy']
+            options['policy'] = options['policy'].to_json
+            options['AWSAccessKeyId'] = @aws_access_key_id
+            string_to_sign = Base64.encode64(options['policy']).chomp!
+            signed_string = @hmac.sign(string_to_sign)
+            options['Signature'] = Base64.encode64(signed_string).chomp!
+          end
+          options
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket.rb
new file mode 100644
index 0000000..8ca6b40
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket.rb
@@ -0,0 +1,77 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to create
+        # * options<~Hash> - config arguments for bucket.  Defaults to {}.
+        #   * 'LocationConstraint'<~Symbol> - sets the location for the bucket
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 200
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUT.html
+
+        def put_bucket(bucket_name, options = {})
+          if location_constraint = options.delete('LocationConstraint')
+            data =
+<<-DATA
+  <CreateBucketConfiguration>
+    <LocationConstraint>#{location_constraint}</LocationConstraint>
+  </CreateBucketConfiguration>
+DATA
+          else
+            data = nil
+          end
+          request({
+            :expects    => 200,
+            :body       => data,
+            :headers    => options,
+            :idempotent => true,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT'
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_bucket(bucket_name, options = {})
+          acl = options['x-amz-acl'] || 'private'
+          if !['private', 'public-read', 'public-read-write', 'authenticated-read'].include?(acl)
+            raise Excon::Errors::BadRequest.new('invalid x-amz-acl')
+          else
+            self.data[:acls][:bucket][bucket_name] = self.class.acls(acl)
+          end
+
+          response = Excon::Response.new
+          response.status = 200
+          bucket = {
+            :objects        => {},
+            'Name'          => bucket_name,
+            'CreationDate'  => Time.now,
+            'Owner'         => { 'DisplayName' => 'owner', 'ID' => 'some_id'},
+            'Payer'         => 'BucketOwner'
+          }
+          if options['LocationConstraint']
+            bucket['LocationConstraint'] = options['LocationConstraint']
+          else
+            bucket['LocationConstraint'] = nil
+          end
+          unless self.data[:buckets][bucket_name]
+            self.data[:buckets][bucket_name] = bucket
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_acl.rb
new file mode 100644
index 0000000..293f97b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_acl.rb
@@ -0,0 +1,76 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change access control list for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTacl.html
+
+        def put_bucket_acl(bucket_name, acl)
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'acl' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_logging.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_logging.rb
new file mode 100644
index 0000000..af45a5c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_logging.rb
@@ -0,0 +1,83 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change logging status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * logging_status<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTlogging.html
+
+        def put_bucket_logging(bucket_name, logging_status)
+          if logging_status['LoggingEnabled'].empty?
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01" />
+DATA
+          else
+            data =
+<<-DATA
+<BucketLoggingStatus xmlns="http://doc.s3.amazonaws.com/2006-03-01">
+  <LoggingEnabled>
+    <TargetBucket>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetBucket>
+    <TargetPrefix>#{logging_status['LoggingEnabled']['TargetBucket']}</TargetPrefix>
+    <TargetGrants>
+DATA
+
+            acl['AccessControlList'].each do |grant|
+              data << "      <Grant>"
+              type = case grant['Grantee'].keys.sort
+              when ['DisplayName', 'ID']
+                'CanonicalUser'
+              when ['EmailAddress']
+                'AmazonCustomerByEmail'
+              when ['URI']
+                'Group'
+              end
+              data << "        <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+              for key, value in grant['Grantee']
+                data << "          <#{key}>#{value}</#{key}>"
+              end
+              data << "        </Grantee>"
+              data << "        <Permission>#{grant['Permission']}</Permission>"
+              data << "      </Grant>"
+            end
+
+            data <<
+<<-DATA
+    </TargetGrants>
+  </LoggingEnabled>
+</BucketLoggingStatus>
+DATA
+          end
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'logging' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_versioning.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_versioning.rb
new file mode 100644
index 0000000..767da5e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_versioning.rb
@@ -0,0 +1,36 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change versioning status for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * status<~String> - Status to change to in ['Enabled', 'Suspended']
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html
+
+        def put_bucket_versioning(bucket_name, status)
+          data =
+<<-DATA
+<VersioningConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Status>#{status}</Status>
+</VersioningConfiguration>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'versioning' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_website.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_website.rb
new file mode 100644
index 0000000..4bd45ac
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_bucket_website.rb
@@ -0,0 +1,49 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change website configuration for an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * suffix<~String> - suffix to append to requests for the bucket
+        # * options<~Hash>
+        #   * key<~String> - key to use for 4XX class errors
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTBucketPUTwebsite.html
+
+        def put_bucket_website(bucket_name, suffix, options = {})
+          data =
+<<-DATA
+<WebsiteConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+    <IndexDocument>
+        <Suffix>#{suffix}</Suffix>
+    </IndexDocument>
+DATA
+
+          if options[:key]
+            data <<
+<<-DATA
+<ErrorDocument>
+    <Key>#{options[:key]}</Key>
+</ErrorDocument>
+DATA
+          end
+
+          data << '</WebsiteConfiguration>'
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'website' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object.rb
new file mode 100644
index 0000000..d92b13d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object.rb
@@ -0,0 +1,100 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Create an object in an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * data<~File||String> - File or String to create object from
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-Length'<~String> - Size of object in bytes (defaults to object.read.length)
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'Expires'<~String> - Cache expiry
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * 'x-amz-storage-class'<~String> - Default is 'STANDARD', set to 'REDUCED_REDUNDANCY' for non-critical, reproducable data
+        #   * "x-amz-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectPUT.html
+        #
+        def put_object(bucket_name, object_name, data, options = {})
+          data = Fog::Storage.parse_data(data)
+          headers = data[:headers].merge!(options)
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_object(bucket_name, object_name, data, options = {})
+          acl = options['x-amz-acl'] || 'private'
+          if !['private', 'public-read', 'public-read-write', 'authenticated-read'].include?(acl)
+            raise Excon::Errors::BadRequest.new('invalid x-amz-acl')
+          else
+            self.data[:acls][:object][bucket_name] ||= {}
+            self.data[:acls][:object][bucket_name][object_name] = self.class.acls(acl)
+          end
+
+          data = Fog::Storage.parse_data(data)
+          unless data[:body].is_a?(String)
+            data[:body] = data[:body].read
+          end
+          response = Excon::Response.new
+          if (bucket = self.data[:buckets][bucket_name])
+            response.status = 200
+            object = {
+              :body             => data[:body],
+              'Content-Type'    => options['Content-Type'] || data[:headers]['Content-Type'],
+              'ETag'            => Fog::AWS::Mock.etag,
+              'Key'             => object_name,
+              'Last-Modified'   => Fog::Time.now.to_date_header,
+              'Content-Length'  => options['Content-Length'] || data[:headers]['Content-Length'],
+              'StorageClass'    => options['x-amz-storage-class'] || 'STANDARD'
+            }
+
+            for key, value in options
+              case key
+              when 'Cache-Control', 'Content-Disposition', 'Content-Encoding', 'Content-MD5', 'Expires', /^x-amz-meta-/
+                object[key] = value
+              end
+            end
+
+            bucket[:objects][object_name] = object
+            response.headers = {
+              'Content-Length'  => object['Content-Length'],
+              'Content-Type'    => object['Content-Type'],
+              'ETag'            => object['ETag'],
+              'Last-Modified'   => object['Last-Modified']
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_acl.rb
new file mode 100644
index 0000000..0369d0c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_acl.rb
@@ -0,0 +1,85 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change access control list for an S3 object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * object_name<~String> - name of object to get access control list for
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * Grantee<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of grantee
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'URI'<~String> - URI of group to grant access for
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectPUTacl.html
+
+        def put_object_acl(bucket_name, object_name, acl, options = {})
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :path       => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_url.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_url.rb
new file mode 100644
index 0000000..3a28946
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_object_url.rb
@@ -0,0 +1,57 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Get an expiring object url from S3 for putting an object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/dev/S3_QSAuth.html
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_request_payment.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_request_payment.rb
new file mode 100644
index 0000000..7e8dc12
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/put_request_payment.rb
@@ -0,0 +1,51 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Change who pays for requests to an S3 bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * payer<~String> - valid values are BucketOwner or Requester
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTrequestPaymentPUT.html
+
+        def put_request_payment(bucket_name, payer)
+          data =
+<<-DATA
+<RequestPaymentConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
+  <Payer>#{payer}</Payer>
+</RequestPaymentConfiguration>
+DATA
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'requestPayment' => nil}
+          })
+        end
+
+      end
+
+      class Mock # :nodoc:all
+
+        def put_request_payment(bucket_name, payer)
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            response.status = 200
+            bucket['Payer'] = payer
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/sync_clock.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/sync_clock.rb
new file mode 100644
index 0000000..986af7d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/sync_clock.rb
@@ -0,0 +1,28 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Sync clock against S3 to avoid skew errors
+        #
+        def sync_clock
+          response = begin
+            get_service
+          rescue => error
+            error.response
+          end
+          Fog::Time.now = Time.parse(response.headers['Date'])
+        end
+
+      end # Real
+
+      class Mock # :nodoc:all
+
+        def sync_clock
+          true
+        end
+
+      end # Mock
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/aws/upload_part.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/upload_part.rb
new file mode 100644
index 0000000..b454c9e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/aws/upload_part.rb
@@ -0,0 +1,43 @@
+module Fog
+  module AWS
+    class Storage
+      class Real
+
+        # Upload a part for a multipart upload
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to add part to
+        # * object_name<~String> - Name of object to add part to
+        # * upload_id<~String> - Id of upload to add part to
+        # * part_number<~String> - Index of part in upload
+        # * data<~File||String> - Content for part
+        # * options<~Hash>:
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object (will be needed to complete upload)
+        #
+        # ==== See Also
+        # http://docs.amazonwebservices.com/AmazonS3/latest/API/mpUploadUploadPart.html
+        #
+        def upload_part(bucket_name, object_name, upload_id, part_number, data, options = {})
+          data = Fog::Storage.parse_data(data)
+          headers = options
+          headers['Content-Length'] = data[:headers]['Content-Length']
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name),
+            :query      => {'uploadId' => upload_id, 'partNumber' => part_number}
+          })
+        end
+
+      end # Real
+    end # Storage
+  end # AWS
+end # Fog
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/copy_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/copy_object.rb
new file mode 100644
index 0000000..c2b5247
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/copy_object.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/google/copy_object'
+
+        # Copy an object from one Google Storage bucket to another
+        #
+        # ==== Parameters
+        # * source_bucket_name<~String> - Name of source bucket
+        # * source_object_name<~String> - Name of source object
+        # * target_bucket_name<~String> - Name of bucket to create copy in
+        # * target_object_name<~String> - Name for new copy of object
+        # * options<~Hash>:
+        #   * 'x-goog-metadata-directive'<~String> - Specifies whether to copy metadata from source or replace with data in request.  Must be in ['COPY', 'REPLACE']
+        #   * 'x-goog-copy_source-if-match'<~String> - Copies object if its etag matches this value
+        #   * 'x-goog-copy_source-if-modified_since'<~Time> - Copies object it it has been modified since this time
+        #   * 'x-goog-copy_source-if-none-match'<~String> - Copies object if its etag does not match this value
+        #   * 'x-goog-copy_source-if-unmodified-since'<~Time> - Copies object it it has not been modified since this time
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        #     * 'LastModified'<~Time> - date object was last modified
+        #
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          headers = { 'x-goog-copy-source' => "/#{source_bucket_name}/#{source_object_name}" }.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{target_bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :parser   => Fog::Parsers::Google::Storage::CopyObject.new,
+            :path     => CGI.escape(target_object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def copy_object(source_bucket_name, source_object_name, target_bucket_name, target_object_name, options = {})
+          response = Excon::Response.new
+          source_bucket = self.data[:buckets][source_bucket_name]
+          source_object = source_bucket && source_bucket[:objects][source_object_name]
+          target_bucket = self.data[:buckets][target_bucket_name]
+
+          if source_object && target_bucket
+            response.status = 200
+            target_object = source_object.dup
+            target_object.merge!({
+              'Name' => target_object_name
+            })
+            target_bucket[:objects][target_object_name] = target_object
+            response.body = {
+              'ETag'          => target_object['ETag'],
+              'LastModified'  => Time.parse(target_object['Last-Modified'])
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_bucket.rb
new file mode 100644
index 0000000..7ee73d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_bucket.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Delete an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_bucket(bucket_name)
+          request({
+            :expects  => 204,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'DELETE'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_bucket(bucket_name)
+          response = Excon::Response.new
+          if self.data[:buckets][bucket_name].nil?
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          elsif self.data[:buckets][bucket_name] && !self.data[:buckets][bucket_name][:objects].empty?
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          else
+            self.data[:buckets].delete(bucket_name)
+            response.status = 204
+          end
+          response
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_object.rb
new file mode 100644
index 0000000..9067efd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/delete_object.rb
@@ -0,0 +1,50 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Delete an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object to delete
+        # * object_name<~String> - Name of object to delete
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 204
+        def delete_object(bucket_name, object_name)
+          request({
+            :expects    => 204,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'DELETE',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def delete_object(bucket_name, object_name)
+          response = Excon::Response.new
+          if bucket = self.data[:buckets][bucket_name]
+            if object = bucket[:objects][object_name]
+              response.status = 204
+              bucket[:objects].delete(object_name)
+            else
+              response.status = 404
+              raise(Excon::Errors.status_error({:expects => 204}, response))
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 204}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket.rb
new file mode 100644
index 0000000..158671e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket.rb
@@ -0,0 +1,111 @@
+require 'pp'
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/google/get_bucket'
+
+        # List information about objects in an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to list object keys from
+        # * options<~Hash> - config arguments for list.  Defaults to {}.
+        #   * 'delimiter'<~String> - causes keys with the same string between the prefix
+        #     value and the first occurence of delimiter to be rolled up
+        #   * 'marker'<~String> - limits object keys to only those that appear
+        #     lexicographically after its value.
+        #   * 'max-keys'<~Integer> - limits number of object keys returned
+        #   * 'prefix'<~String> - limits object keys to those beginning with its value.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Delimeter'<~String> - Delimiter specified for query
+        #     * 'IsTruncated'<~Boolean> - Whether or not the listing is truncated
+        #     * 'Marker'<~String> - Marker specified for query
+        #     * 'MaxKeys'<~Integer> - Maximum number of keys specified for query
+        #     * 'Name'<~String> - Name of the bucket
+        #     * 'Prefix'<~String> - Prefix specified for query
+        #     * 'CommonPrefixes'<~Array> - Array of strings for common prefixes
+        #     * 'Contents'<~Array>:
+        #       * 'ETag'<~String>: Etag of object
+        #       * 'Key'<~String>: Name of object
+        #       * 'LastModified'<~String>: Timestamp of last modification of object
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'Size'<~Integer> - Size of object
+        #       * 'StorageClass'<~String> - Storage class of object
+        #
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Google::Storage::GetBucket.new,
+            :query    => options
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket(bucket_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          response = Excon::Response.new
+          name = /(\w+\.?)*/.match(bucket_name)
+          if bucket_name == name.to_s
+            if bucket = self.data[:buckets][bucket_name]
+              contents = bucket[:objects].values.sort {|x,y| x['Key'] <=> y['Key']}.reject do |object|
+                  (options['prefix'] && object['Key'][0...options['prefix'].length] != options['prefix']) ||
+                  (options['marker'] && object['Key'] <= options['marker'])
+                end.map do |object|
+                  data = object.reject {|key, value| !['ETag', 'Key', 'StorageClass'].include?(key)}
+                  data.merge!({
+                    'LastModified' => Time.parse(object['Last-Modified']),
+                    'Owner'        => bucket['Owner'],
+                    'Size'         => object['Content-Length'].to_i
+                  })
+                data
+              end
+              max_keys = options['max-keys'] || 1000
+              size = [max_keys, 1000].min
+              truncated_contents = contents[0...size]
+
+              response.status = 200
+              response.body = {
+                'CommonPrefixes'  => [],
+                'Contents'        => truncated_contents,
+                'IsTruncated'     => truncated_contents.size != contents.size,
+                'Marker'          => options['marker'],
+                'Name'            => bucket['Name'],
+                'Prefix'          => options['prefix']
+              }
+              if options['max-keys'] && options['max-keys'] < response.body['Contents'].length
+                  response.body['IsTruncated'] = true
+                  response.body['Contents'] = response.body['Contents'][0...options['max-keys']]
+              end
+            else
+              response.status = 404
+              raise(Excon::Errors.status_error({:expects => 200}, response))
+            end
+          else
+              response.status = 400
+              raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket_acl.rb
new file mode 100644
index 0000000..c1dc4ae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_bucket_acl.rb
@@ -0,0 +1,63 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/google/access_control_list'
+
+        # Get access control list for an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to get access control list for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_bucket_acl(bucket_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::Google::Storage::AccessControlList.new,
+            :query      => {'acl' => nil}
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_bucket_acl(bucket_name)
+          response = Excon::Response.new
+          if acl = self.data[:acls][:bucket][bucket_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object.rb
new file mode 100644
index 0000000..d7eed08
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object.rb
@@ -0,0 +1,104 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        #
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = Fog::Time.at(options['If-Modified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = Fog::Time.at(options['If-Unmodified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method   => 'GET',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          }, &block)
+        end
+
+      end
+
+      class Mock
+
+        def get_object(bucket_name, object_name, options = {}, &block)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          response = Excon::Response.new
+          if (bucket = self.data[:buckets][bucket_name]) && (object = bucket[:objects][object_name])
+            if options['If-Match'] && options['If-Match'] != object['ETag']
+              response.status = 412
+            elsif options['If-Modified-Since'] && options['If-Modified-Since'] > Time.parse(object['Last-Modified'])
+              response.status = 304
+            elsif options['If-None-Match'] && options['If-None-Match'] == object['ETag']
+              response.status = 304
+            elsif options['If-Unmodified-Since'] && options['If-Unmodified-Since'] < Time.parse(object['Last-Modified'])
+              response.status = 412
+            else
+              response.status = 200
+              for key, value in object
+                case key
+                when 'Cache-Control', 'Content-Disposition', 'Content-Encoding', 'Content-Length', 'Content-MD5', 'Content-Type', 'ETag', 'Expires', 'Last-Modified', /^x-goog-meta-/
+                  response.headers[key] = value
+                end
+              end
+              unless block_given?
+                response.body = object[:body]
+              else
+                data = StringIO.new(object[:body])
+                remaining = data.length
+                while remaining > 0
+                  chunk = data.read([remaining, Excon::CHUNK_SIZE].min)
+                  block.call(chunk)
+                  remaining -= Excon::CHUNK_SIZE
+                end
+              end
+            end
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_acl.rb
new file mode 100644
index 0000000..286d9dd
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_acl.rb
@@ -0,0 +1,74 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/google/access_control_list'
+
+        # Get access control list for an Google Storage object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get access control list for
+        # * options<~Hash>:
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #              * 'DisplayName'<~String> - Display name of grantee
+        #              * 'ID'<~String> - Id of grantee
+        #             or
+        #              * 'URI'<~String> - URI of group to grant access for
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_acl(bucket_name, object_name, options = {})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          query = {'acl' => nil}
+          if version_id = options.delete('versionId')
+            query['versionId'] = version_id
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :parser     => Fog::Parsers::Google::Storage::AccessControlList.new,
+            :path       => CGI.escape(object_name),
+            :query      => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_object_acl(bucket_name, object_name)
+          response = Excon::Response.new
+          if acl = self.data[:acls][:object][bucket_name] && self.data[:acls][:object][bucket_name][object_name]
+            response.status = 200
+            response.body = acl
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_torrent.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_torrent.rb
new file mode 100644
index 0000000..47d0d7b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_torrent.rb
@@ -0,0 +1,47 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get torrent for an Google Storage object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket containing object
+        # * object_name<~String> - name of object to get torrent for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'AccessControlPolicy'<~Hash>
+        #       * 'Owner'<~Hash>:
+        #         * 'DisplayName'<~String> - Display name of object owner
+        #         * 'ID'<~String> - Id of object owner
+        #       * 'AccessControlList'<~Array>:
+        #         * 'Grant'<~Hash>:
+        #           * 'Grantee'<~Hash>:
+        #             * 'DisplayName'<~String> - Display name of grantee
+        #             * 'ID'<~String> - Id of grantee
+        #           * 'Permission'<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        #
+        def get_object_torrent(bucket_name, object_name)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          request({
+            :expects    => 200,
+            :headers    => {},
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'GET',
+            :path       => CGI.escape(object_name),
+            :query      => {'torrent' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_url.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_url.rb
new file mode 100644
index 0000000..e755bea
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an expiring object url from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def get_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'GET',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_service.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_service.rb
new file mode 100644
index 0000000..00541b0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/get_service.rb
@@ -0,0 +1,53 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        require 'fog/storage/parsers/google/get_service'
+
+        # List information about Google Storage buckets for authorized user
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'Buckets'<~Hash>:
+        #       * 'Name'<~String> - Name of bucket
+        #       * 'CreationTime'<~Time> - Timestamp of bucket creation
+        #     * 'Owner'<~Hash>:
+        #       * 'DisplayName'<~String> - Display name of bucket owner
+        #       * 'ID'<~String> - Id of bucket owner
+        def get_service
+          request({
+            :expects  => 200,
+            :headers  => {},
+            :host     => @host,
+            :idempotent => true,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Google::Storage::GetService.new,
+            :url      => @host
+          })
+        end
+
+      end
+
+      class Mock
+
+        def get_service
+          response = Excon::Response.new
+          response.headers['Status'] = 200
+          buckets = self.data[:buckets].values.map do |bucket|
+            bucket.reject do |key, value|
+              !['CreationDate', 'Name'].include?(key)
+            end
+          end
+          response.body = {
+            'Buckets' => buckets,
+            'Owner'   => { 'ID' => 'some_id'}
+          }
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/head_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/head_object.rb
new file mode 100644
index 0000000..26edd51
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/head_object.rb
@@ -0,0 +1,64 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get headers for an object from Google Storage
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to read from
+        # * object_name<~String> - Name of object to read
+        # * options<~Hash>:
+        #   * 'If-Match'<~String> - Returns object only if its etag matches this value, otherwise returns 412 (Precondition Failed).
+        #   * 'If-Modified-Since'<~Time> - Returns object only if it has been modified since this time, otherwise returns 304 (Not Modified).
+        #   * 'If-None-Match'<~String> - Returns object only if its etag differs from this value, otherwise returns 304 (Not Modified)
+        #   * 'If-Unmodified-Since'<~Time> - Returns object only if it has not been modified since this time, otherwise returns 412 (Precodition Failed).
+        #   * 'Range'<~String> - Range of object to download
+        #   * 'versionId'<~String> - specify a particular version to retrieve
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - Contents of object
+        #   * headers<~Hash>:
+        #     * 'Content-Length'<~String> - Size of object contents
+        #     * 'Content-Type'<~String> - MIME type of object
+        #     * 'ETag'<~String> - Etag of object
+        #     * 'Last-Modified'<~String> - Last modified timestamp for object
+        def head_object(bucket_name, object_name, options={})
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          if version_id = options.delete('versionId')
+            query = {'versionId' => version_id}
+          end
+          headers = {}
+          headers['If-Modified-Since'] = Fog::Time.at(options['If-Modified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers['If-Unmodified-Since'] = Fog::Time.at(options['If-Unmodified-Since'].to_i).to_date_header if options['If-Modified-Since']
+          headers.merge!(options)
+          request({
+            :expects  => 200,
+            :headers  => headers,
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'HEAD',
+            :path     => CGI.escape(object_name),
+            :query    => query
+          })
+        end
+
+      end
+
+      class Mock
+
+        def head_object(bucket_name, object_name, options = {})
+          response = get_object(bucket_name, object_name, options)
+          response.body = nil
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket.rb
new file mode 100644
index 0000000..e84ec1b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket.rb
@@ -0,0 +1,75 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Create an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to create
+        # * options<~Hash> - config arguments for bucket.  Defaults to {}.
+        #   * 'LocationConstraint'<~Symbol> - sets the location for the bucket
+        #   * 'x-amz-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * status<~Integer> - 200
+        def put_bucket(bucket_name, options = {})
+          if location_constraint = options.delete('LocationConstraint')
+            data =
+<<-DATA
+  <CreateBucketConfiguration>
+    <LocationConstraint>#{location_constraint}</LocationConstraint>
+  </CreateBucketConfiguration>
+DATA
+          else
+            data = nil
+          end
+          request({
+            :expects    => 200,
+            :body       => data,
+            :headers    => options,
+            :idempotent => true,
+            :host       => "#{bucket_name}.#{@host}",
+            :method     => 'PUT'
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_bucket(bucket_name, options = {})
+          acl = options['x-goog-acl'] || 'private'
+          if !['private', 'public-read', 'public-read-write', 'authenticated-read'].include?(acl)
+            raise Excon::Errors::BadRequest.new('invalid x-goog-acl')
+          else
+            self.data[:acls][:bucket][bucket_name] = self.class.acls(options[acl])
+          end
+          response = Excon::Response.new
+          response.status = 200
+          bucket = {
+            :objects        => {},
+            'Name'          => bucket_name,
+            'CreationDate'  => Time.now,
+            'Owner'         => { 'DisplayName' => 'owner', 'ID' => 'some_id'},
+            'Payer'         => 'BucketOwner'
+          }
+          if options['LocationConstraint']
+            bucket['LocationConstraint'] = options['LocationConstraint']
+          else
+            bucket['LocationConstraint'] = ''
+          end
+          if self.data[:buckets][bucket_name].nil?
+            self.data[:buckets][bucket_name] = bucket
+          else
+            response.status = 409
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket_acl.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket_acl.rb
new file mode 100644
index 0000000..a3b1498
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_bucket_acl.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Change access control list for an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - name of bucket to modify
+        # * acl<~Hash>:
+        #   * Owner<~Hash>:
+        #     * ID<~String>: id of owner
+        #     * DisplayName<~String>: display name of owner
+        #   * AccessControlList<~Array>:
+        #     * scope<~Hash>:
+        #         * 'type'<~String> - 'UserById'
+        #         * 'ID'<~String> - Id of grantee
+        #       or
+        #         * 'type'<~String> - 'UserByEmail'
+        #         * 'EmailAddress'<~String> - Email address of grantee
+        #       or
+        #         * 'type'<~String> - type of user to grant permission to
+        #     * Permission<~String> - Permission, in [FULL_CONTROL, WRITE, WRITE_ACP, READ, READ_ACP]
+        def put_bucket_acl(bucket_name, acl)
+          data =
+<<-DATA
+<AccessControlPolicy>
+  <Owner>
+    <ID>#{acl['Owner']['ID']}</ID>
+    <DisplayName>#{acl['Owner']['DisplayName']}</DisplayName>
+  </Owner>
+  <AccessControlList>
+DATA
+
+          acl['AccessControlList'].each do |grant|
+            data << "    <Grant>"
+            type = case grant['Grantee'].keys.sort
+            when ['DisplayName', 'ID']
+              'CanonicalUser'
+            when ['EmailAddress']
+              'AmazonCustomerByEmail'
+            when ['URI']
+              'Group'
+            end
+            data << "      <Grantee xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:type=\"#{type}\">"
+            for key, value in grant['Grantee']
+              data << "        <#{key}>#{value}</#{key}>"
+            end
+            data << "      </Grantee>"
+            data << "      <Permission>#{grant['Permission']}</Permission>"
+            data << "    </Grant>"
+          end
+
+          data <<
+<<-DATA
+  </AccessControlList>
+</AccessControlPolicy>
+DATA
+
+          request({
+            :body     => data,
+            :expects  => 200,
+            :headers  => {},
+            :host     => "#{bucket_name}.#{@host}",
+            :method   => 'PUT',
+            :query    => {'acl' => nil}
+          })
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object.rb
new file mode 100644
index 0000000..0a22797
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object.rb
@@ -0,0 +1,94 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Create an object in an Google Storage bucket
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket to create object in
+        # * object_name<~String> - Name of object to create
+        # * data<~File> - File or String to create object from
+        # * options<~Hash>:
+        #   * 'Cache-Control'<~String> - Caching behaviour
+        #   * 'Content-Disposition'<~String> - Presentational information for the object
+        #   * 'Content-Encoding'<~String> - Encoding of object data
+        #   * 'Content-Length'<~String> - Size of object in bytes (defaults to object.read.length)
+        #   * 'Content-MD5'<~String> - Base64 encoded 128-bit MD5 digest of message (defaults to Base64 encoded MD5 of object.read)
+        #   * 'Content-Type'<~String> - Standard MIME type describing contents (defaults to MIME::Types.of.first)
+        #   * 'x-goog-acl'<~String> - Permissions, must be in ['private', 'public-read', 'public-read-write', 'authenticated-read']
+        #   * "x-goog-meta-#{name}" - Headers to be returned with object, note total size of request without body must be less than 8 KB.
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'ETag'<~String> - etag of new object
+        def put_object(bucket_name, object_name, data, options = {})
+          data = Fog::Storage.parse_data(data)
+          headers = data[:headers].merge!(options)
+          request({
+            :body       => data[:body],
+            :expects    => 200,
+            :headers    => headers,
+            :host       => "#{bucket_name}.#{@host}",
+            :idempotent => true,
+            :method     => 'PUT',
+            :path       => CGI.escape(object_name)
+          })
+        end
+
+      end
+
+      class Mock
+
+        def put_object(bucket_name, object_name, data, options = {})
+          acl = options['x-goog-acl'] || 'private'
+          if !['private', 'public-read', 'public-read-write', 'authenticated-read'].include?(acl)
+            raise Excon::Errors::BadRequest.new('invalid x-goog-acl')
+          else
+            self.data[:acls][:object][bucket_name] ||= {}
+            self.data[:acls][:object][bucket_name][object_name] = self.class.acls(acl)
+          end
+
+          data = Fog::Storage.parse_data(data)
+          unless data[:body].is_a?(String)
+            data[:body] = data[:body].read
+          end
+          response = Excon::Response.new
+          if (bucket = self.data[:buckets][bucket_name])
+            response.status = 200
+            object = {
+              :body             => data[:body],
+              'Content-Type'    => options['Content-Type'] || data[:headers]['Content-Type'],
+              'ETag'            => Fog::Google::Mock.etag,
+              'Key'             => object_name,
+              'Last-Modified'   => Fog::Time.now.to_date_header,
+              'Content-Length'  => options['Content-Length'] || data[:headers]['Content-Length'],
+              'StorageClass'    => 'STANDARD'
+            }
+
+            for key, value in options
+              case key
+              when 'Cache-Control', 'Content-Disposition', 'Content-Encoding', 'Content-MD5', 'Expires', /^x-goog-meta-/
+                object[key] = value
+              end
+            end
+
+            bucket[:objects][object_name] = object
+            response.headers = {
+              'Content-Length'  => object['Content-Length'],
+              'Content-Type'    => object['Content-Type'],
+              'ETag'            => object['ETag'],
+              'Last-Modified'   => object['Last-Modified']
+            }
+          else
+            response.status = 404
+            raise(Excon::Errors.status_error({:expects => 200}, response))
+          end
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object_url.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object_url.rb
new file mode 100644
index 0000000..bdc4c6b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/google/put_object_url.rb
@@ -0,0 +1,54 @@
+module Fog
+  module Google
+    class Storage
+      class Real
+
+        # Get an expiring object url from Google Storage for putting an object
+        #
+        # ==== Parameters
+        # * bucket_name<~String> - Name of bucket containing object
+        # * object_name<~String> - Name of object to get expiring url for
+        # * expires<~Time> - An expiry time for this url
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~String> - url for object
+        #
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+
+      class Mock
+
+        def put_object_url(bucket_name, object_name, expires)
+          unless bucket_name
+            raise ArgumentError.new('bucket_name is required')
+          end
+          unless object_name
+            raise ArgumentError.new('object_name is required')
+          end
+          url({
+            :headers  => {},
+            :host     => @host,
+            :method   => 'PUT',
+            :path     => "#{bucket_name}/#{object_name}"
+          }, expires)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_container.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_container.rb
new file mode 100644
index 0000000..da161a2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_container.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * name<~String> - Name of container to delete
+        #
+        def delete_container(name)
+          response = request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => URI.escape(name)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_object.rb
new file mode 100644
index 0000000..55df1e2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/delete_object.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Delete an existing container
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to delete
+        # * object<~String> - Name of object to delete
+        #
+        def delete_object(container, object)
+          response = request(
+            :expects  => 204,
+            :method   => 'DELETE',
+            :path     => "#{URI.escape(container)}/#{URI.escape(object)}"
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_container.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_container.rb
new file mode 100644
index 0000000..9aad616
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_container.rb
@@ -0,0 +1,45 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for container and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        # * options<~String>:
+        #   * 'limit'<~String> - Maximum number of objects to return
+        #   * 'marker'<~String> - Only return objects whose name is greater than marker
+        #   * 'prefix'<~String> - Limits results to those starting with prefix
+        #   * 'path'<~String> - Return objects nested in the pseudo path
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        #   * body<~Array>:
+        #     * 'bytes'<~Integer> - Number of bytes used by container
+        #     * 'count'<~Integer> - Number of items in container
+        #     * 'name'<~String> - Name of container
+        #     * item<~Hash>:
+        #       * 'bytes'<~String> - Size of object
+        #       * 'content_type'<~String> Content-Type of object
+        #       * 'hash'<~String> - Hash of object (etag?)
+        #       * 'last_modified'<~String> - Last modified timestamp
+        #       * 'name'<~String> - Name of object
+        def get_container(container, options = {})
+          options = options.reject {|key, value| value.nil?}
+          response = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => URI.escape(container),
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_containers.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_containers.rb
new file mode 100644
index 0000000..3efcc59
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_containers.rb
@@ -0,0 +1,34 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List existing storage containers
+        #
+        # ==== Parameters
+        # * options<~Hash>:
+        #   * 'limit'<~Integer> - Upper limit to number of results returned
+        #   * 'marker'<~String> - Only return objects with name greater than this value
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * container<~Hash>:
+        #       * 'bytes'<~Integer>: - Number of bytes used by container
+        #       * 'count'<~Integer>: - Number of items in container
+        #       * 'name'<~String>: - Name of container
+        def get_containers(options = {})
+          options = options.reject {|key, value| value.nil?}
+          response = request(
+            :expects  => [200, 204],
+            :method   => 'GET',
+            :path     => '',
+            :query    => {'format' => 'json'}.merge!(options)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_object.rb
new file mode 100644
index 0000000..daa3292
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/get_object.rb
@@ -0,0 +1,25 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get details for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def get_object(container, object, &block)
+          response = request({
+            :block    => block,
+            :expects  => 200,
+            :method   => 'GET',
+            :path     => "#{URI.escape(container)}/#{URI.escape(object)}"
+          }, false, &block)
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_container.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_container.rb
new file mode 100644
index 0000000..993ae81
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_container.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of objects and total bytes stored
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to retrieve info for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Container-Object-Count'<~String> - Count of containers
+        #     * 'X-Container-Bytes-Used'<~String>   - Bytes used
+        def head_container(container)
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => URI.escape(container),
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_containers.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_containers.rb
new file mode 100644
index 0000000..109e244
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_containers.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # List number of containers and total bytes stored
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * headers<~Hash>:
+        #     * 'X-Account-Container-Count'<~String> - Count of containers
+        #     * 'X-Account-Bytes-Used'<~String> - Bytes used
+        def head_containers
+          response = request(
+            :expects  => 204,
+            :method   => 'HEAD',
+            :path     => '',
+            :query    => {'format' => 'json'}
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_object.rb
new file mode 100644
index 0000000..5c84166
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/head_object.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Get headers for object
+        #
+        # ==== Parameters
+        # * container<~String> - Name of container to look in
+        # * object<~String> - Name of object to look for
+        #
+        def head_object(container, object)
+          response = request({
+            :expects  => 200,
+            :method   => 'HEAD',
+            :path     => "#{URI.escape(container)}/#{URI.escape(object)}"
+          }, false)
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_container.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_container.rb
new file mode 100644
index 0000000..1033bfe
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_container.rb
@@ -0,0 +1,23 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new container
+        #
+        # ==== Parameters
+        # * name<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_container(name)
+          response = request(
+            :expects  => [201, 202],
+            :method   => 'PUT',
+            :path     => URI.escape(name)
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_object.rb b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_object.rb
new file mode 100644
index 0000000..128c24d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/storage/requests/rackspace/put_object.rb
@@ -0,0 +1,27 @@
+module Fog
+  module Rackspace
+    class Storage
+      class Real
+
+        # Create a new object
+        #
+        # ==== Parameters
+        # * container<~String> - Name for container, should be < 256 bytes and must not contain '/'
+        #
+        def put_object(container, object, data, options = {})
+          data = Fog::Storage.parse_data(data)
+          headers = data[:headers].merge!(options)
+          response = request(
+            :body     => data[:body],
+            :expects  => 201,
+            :headers  => headers,
+            :method   => 'PUT',
+            :path     => "#{URI.escape(container)}/#{URI.escape(object)}"
+          )
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark.rb b/vendor/fog-0.8.2/lib/fog/terremark.rb
new file mode 100644
index 0000000..80d5eee
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark.rb
@@ -0,0 +1,11 @@
+require 'fog/core'
+
+require 'fog/terremark/shared'
+require 'fog/terremark/parser'
+require 'fog/terremark/vcloud'
+
+module Fog
+  module Terremark
+    VCLOUD_OPTIONS = [:terremark_vcloud_username, :terremark_vcloud_password]
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/address.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/address.rb
new file mode 100644
index 0000000..70e4ac9
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/address.rb
@@ -0,0 +1,29 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Address < Fog::Model
+
+        identity :id
+
+        attribute :ip, :aliases => 'name'
+
+        def destroy
+         requires :id
+         connection.delete_public_ip(id)
+         true
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/addresses.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/addresses.rb
new file mode 100644
index 0000000..decc67a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/addresses.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def addresses(options = {})
+          Fog::Terremark::Shared::Addresses.new(options.merge(:connection => self))
+        end
+      end
+
+      class Addresses < Fog::Collection
+
+        model Fog::Terremark::Shared::Address
+
+        def all
+          load(connection.get_public_ips(vdc_id).body['PublicIpAddresses'])
+        end
+
+        def get(ip_id)
+          if ip_id && ip = connection.get_public_ip(ip_id).body
+            new(ip)
+          elsif !ip_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/network.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/network.rb
new file mode 100644
index 0000000..96aefae
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/network.rb
@@ -0,0 +1,35 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Network < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :subnet
+        attribute :gateway
+        attribute :netmask
+        attribute :fencemode
+        attribute :links
+
+        def ips
+          #Until there is a real model for these ?
+          connection.get_network_ips(id).body['IpAddresses']
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/networks.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/networks.rb
new file mode 100644
index 0000000..6e39c30
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/networks.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def networks(options = {})
+          Fog::Terremark::Shared::Networks.new(options.merge(:connection => self))
+        end
+      end
+
+      class Networks < Fog::Collection
+
+        model Fog::Terremark::Shared::Network
+
+        def all
+          data = connection.get_vdc(vdc_id).body['AvailableNetworks'].map do |network|
+            connection.get_network(network["href"].split("/").last).body
+          end
+          load(data)
+        end
+
+        def get(network_id)
+          if network_id && network = connection.get_network(network_id).body
+            new(network)
+          elsif !network_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/server.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/server.rb
new file mode 100644
index 0000000..aeccc60
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/server.rb
@@ -0,0 +1,110 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Server < Fog::Model
+
+        identity :id
+
+        attribute :name
+        attribute :status
+        attribute :OperatingSystem
+        attribute :VirtualHardware
+
+        def destroy
+          requires :id
+          data = connection.power_off(id).body
+          task = connection.tasks.new(data)
+          task.wait_for { ready? }
+          connection.delete_vapp(id)
+          true
+        end
+
+        # { '0' => 'Being created', '2' => 'Powered Off', '4' => 'Powered On'}
+        def ready?
+          status == '2'
+        end
+
+        def on?
+          status == '4'
+        end
+
+        def off?
+          status == '2'
+        end
+
+        def power_on(options = {})
+          requires :id
+          begin
+            connection.power_on(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered on/
+          end
+          true
+        end
+
+        def power_off
+          requires :id
+          begin
+            connection.power_off(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def shutdown
+          requires :id
+          begin
+            connection.power_shutdown(id)
+          rescue Excon::Errors::InternalServerError => e
+            #Frankly we shouldn't get here ...
+            raise e unless e.to_s =~ /because it is already powered off/
+          end
+          true
+        end
+
+        def power_reset
+          requires :id
+          connection.power_reset(id)
+          true
+        end
+
+        def graceful_restart
+          requires :id
+          shutdown
+          wait_for { off? }
+          power_on
+        end
+
+        def save
+          requires :name
+          data = connection.instantiate_vapp(name)
+          merge_attributes(data.body)
+          task = connection.deploy_vapp(id)
+          task.wait_for { ready? }
+          task = connection.power_on(id)
+          task.wait_for { ready? }
+          true
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); @type = new_type; end
+        def size=(new_size); @size = new_size; end
+        def IpAddress=(new_ipaddress); @IpAddress = new_ipaddress; end
+        def Links=(new_links); @Links = new_links; end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/servers.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/servers.rb
new file mode 100644
index 0000000..2668d30
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/servers.rb
@@ -0,0 +1,55 @@
+require 'fog/core/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def servers(options = {})
+          Fog::Terremark::Shared::Servers.new(options.merge(:connection => self))
+        end
+      end
+
+      class Servers < Fog::Collection
+
+        model Fog::Terremark::Shared::Server
+
+        def all
+          data = connection.get_vdc(vdc_id).body['ResourceEntities'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vApp+xml'
+          end
+          load(data)
+        end
+
+        def get(server_id)
+          if server_id && server = connection.get_vapp(server_id).body
+            new(server)
+          elsif !server_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def vdc_id
+          @vdc_id ||= connection.default_vdc_id
+        end
+
+        private
+
+        def vdc_id=(new_vdc_id)
+          @vdc_id = new_vdc_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/task.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/task.rb
new file mode 100644
index 0000000..31307cb
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/task.rb
@@ -0,0 +1,50 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Task < Fog::Model
+
+        identity :id
+
+        attribute :end_time,    :aliases => 'endTime'
+        attribute :owner,       :aliases => 'Owner'
+        attribute :result,      :aliases => 'Result'
+        attribute :start_time,  :aliases => 'startTime'
+        attribute :status
+        attribute :link,        :aliases => 'Link'
+        attribute :error,       :aliases => 'Error'
+
+        def initialize(attributes = {})
+          new_owner  = attributes.delete('Owner')
+          new_result = attributes.delete('Result')
+          new_error = attributes.delete('Error')
+          new_cancel_link = attributes.delete('Link')
+
+          super
+          self.owner = connection.parse(new_owner)
+          if new_result
+            self.result = connection.parse(new_result)
+          end
+          self.error = connection.parse(new_error) if new_error
+          @cancel_link = connection.parse(new_cancel_link) if new_cancel_link
+        end
+
+        def ready?
+          @status == 'success'
+        end
+
+        private
+
+        def href=(new_href)
+          @id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/tasks.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/tasks.rb
new file mode 100644
index 0000000..9083a6e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/tasks.rb
@@ -0,0 +1,58 @@
+require 'fog/core/collection'
+require 'fog/terremark/models/shared/server'
+
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      module Real
+        def tasks
+          Fog::Terremark::Shared::Tasks.new(:connection => self)
+        end
+      end
+
+      class Tasks < Fog::Collection
+
+        model Fog::Terremark::Shared::Task
+
+        def all
+          data = connection.get_tasks_list(task_list_id).body['Tasks']
+          load(data)
+        end
+
+        def get(task_id)
+          if task_id && task = connection.get_task(task_id).body
+            new(task)
+          elsif !task_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def task_list_id
+          @task_list_id ||=
+            if connection.default_organization_id && organization = connection.get_organization(connection.default_organization_id).body
+              organization['Links'].detect {|link| link['type'] == 'application/vnd.vmware.vcloud.tasksList+xml'}['href'].split('/').last.to_i
+            else
+              nil
+            end
+        end
+
+        private
+
+        def task_list_id=(new_task_list_id)
+          @task_list_id = new_task_list_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdc.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdc.rb
new file mode 100644
index 0000000..1a4788f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdc.rb
@@ -0,0 +1,39 @@
+require 'fog/core/model'
+
+module Fog
+  module Terremark
+    module Shared
+
+      class Vdc < Fog::Model
+
+        identity :id
+
+        attribute :name
+
+        def networks
+          connection.networks(:vdc_id => id)
+        end
+
+        def addresses
+          connection.addresses(:vdc_id => id)
+        end
+
+        def servers
+          connection.servers(:vdc_id => id)
+        end
+
+        private
+
+        def href=(new_href)
+          self.id = new_href.split('/').last.to_i
+        end
+
+        def type=(new_type); end
+
+        def rel=(new_rel); end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdcs.rb b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdcs.rb
new file mode 100644
index 0000000..d47793f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/models/shared/vdcs.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Terremark
+    module Shared
+
+      module Mock
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      module Real
+        def vdcs(options = {})
+          Fog::Terremark::Shared::Vdcs.new(options.merge(:connection => self))
+        end
+      end
+
+      class Vdcs < Fog::Collection
+
+        model Fog::Terremark::Shared::Vdc
+
+        def all
+          data = connection.get_organization(organization_id).body['Links'].select do |entity|
+            entity['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+          end
+          load(data)
+        end
+
+        def get(vdc_id)
+          if vdc_id && vdc = connection.get_vdc(vdc_id).body
+            new(vdc)
+          elsif !vdc_id
+            nil
+          end
+        rescue Excon::Errors::Forbidden
+          nil
+        end
+
+        def organization_id
+          @vdc_id ||= connection.default_organization_id
+        end
+
+        private
+
+        def organization_id=(new_organization_id)
+          @organization_id = new_organization_id
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parser.rb b/vendor/fog-0.8.2/lib/fog/terremark/parser.rb
new file mode 100644
index 0000000..14325c1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parser.rb
@@ -0,0 +1,19 @@
+module Fog
+  module Terremark
+    module Shared
+      module Parser
+
+        remove_method :parse
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog.rb
new file mode 100644
index 0000000..6a0780d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalog < Fog::Parsers::Base
+
+          def reset
+            @response = { 'CatalogItems' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                catalog_item[attributes.shift] = attributes.shift
+              end            
+              @response['CatalogItems'] << catalog_item
+            when 'Catalog'
+              catalog = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog[attribute.first] = attribute.last
+                else
+                  catalog[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog_item.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog_item.rb
new file mode 100644
index 0000000..d0249a8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_catalog_item.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetCatalogItem < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Entity' => {}, 'Properties' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Entity'
+              until attributes.empty?
+                @response['Entity'][attributes.shift] = attributes.shift
+              end
+            when 'CatalogItem'
+              catalog_item = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  catalog_item[attribute.first] = attribute.last
+                else
+                  catalog_item[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = catalog_item['name']
+            when 'Property'
+              @property_key = attributes.last
+            end
+          end
+
+          def end_element(name)
+            if name == 'Property'
+              @response['Properties'][@property_key] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_internet_services.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_internet_services.rb
new file mode 100644
index 0000000..450ab5f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_internet_services.rb
@@ -0,0 +1,60 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetInternetServices < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @internet_service = {}
+            @response = { 'InternetServices' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @internet_service[name] = value
+            when 'Enabled'
+              if value == 'true'
+                @internet_service[name] = true
+              else
+                @internet_service[name] = false
+              end
+            when 'Href', 'Name'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = value
+              else
+                @internet_service[name] = value
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @internet_service['PublicIpAddress'] ||= {}
+                @internet_service['PublicIpAddress'][name] = value.to_i
+              else
+                @internet_service[name] = value.to_i
+              end
+            when 'InternetService'
+              @response['InternetServices'] << @internet_service
+              @internet_service = {}
+            when 'Port', 'Timeout'
+              @internet_service[name] = value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_network_ips.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_network_ips.rb
new file mode 100644
index 0000000..bc7de10
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_network_ips.rb
@@ -0,0 +1,29 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNetworkIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'IpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Name', 'Status', 'Server'
+              @ip_address[name.downcase] = value
+            when 'IpAddress'
+              @response['IpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_node_services.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_node_services.rb
new file mode 100644
index 0000000..e0f83e0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_node_services.rb
@@ -0,0 +1,36 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetNodeServices < Fog::Parsers::Base
+
+          def reset
+            @node_service = {}
+            @response = { 'NodeServices' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'Name', 'IpAddress'
+              @node_service[name] = value
+            when 'Enabled'
+              if value == 'true'
+                @node_service[name] = true
+              else
+                @node_service[name] = false
+              end
+            when 'Id', 'Port'
+              @node_service[name] = value.to_i
+            when 'NodeService'
+              @response['NodeServices'] << @node_service
+              @node_service = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organization.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organization.rb
new file mode 100644
index 0000000..4d15169
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organization.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganization < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  link[attribute.first] = attribute.last
+                else
+                  link[attributes.shift] = attributes.shift
+                end
+              end
+              @response['Links'] << link
+            when 'Org'
+              org = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  org[attribute.first] = attribute.last
+                else
+                  org[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = org['href']
+              @response['name'] = org['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organizations.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organizations.rb
new file mode 100644
index 0000000..6216f3c
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_organizations.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetOrganizations < Fog::Parsers::Base
+
+          def reset
+            @response = { 'OrgList' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            if name == 'Org'
+              organization = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  organization[attribute.first] = attribute.last
+                else
+                  organization[attributes.shift] = attributes.shift
+                end
+              end
+              @response['OrgList'] << organization
+            end
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_public_ips.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_public_ips.rb
new file mode 100644
index 0000000..2a7b55d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_public_ips.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetPublicIps< Fog::Parsers::Base
+
+          def reset
+            @ip_address = {}
+            @response = { 'PublicIpAddresses' => [] }
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @ip_address[name.downcase] = value
+            when 'Id'
+              @ip_address['id'] = value.to_i
+            when 'PublicIPAddress'
+              @response['PublicIpAddresses'] << @ip_address
+              @ip_address = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_tasks_list.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_tasks_list.rb
new file mode 100644
index 0000000..4cffd45
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_tasks_list.rb
@@ -0,0 +1,52 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetTasksList < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Tasks' => [] }
+            @task = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @task[name] = data
+            when 'Task'
+              until attributes.empty?
+                @task[attributes.shift] = attributes.shift
+              end
+            when 'TasksList'
+              tasks_list = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  tasks_list[attribute.first] = attribute.last
+                else
+                  tasks_list[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = tasks_list['href']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Task'
+              @response['Tasks'] << @task
+              @task = {}
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vapp_template.rb
new file mode 100644
index 0000000..ef86909
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vapp_template.rb
@@ -0,0 +1,46 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end            
+              @response['Links'] << link
+            when 'VAppTemplate'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response['name'] = vapp_template['name']
+            end
+          end
+
+          def end_element(name)
+            if name == 'Description'
+              @response['Description'] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vdc.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vdc.rb
new file mode 100644
index 0000000..10aca1e
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/get_vdc.rb
@@ -0,0 +1,123 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class GetVdc < Fog::Parsers::Base
+
+          def reset
+            @in_storage_capacity = false
+            @in_cpu = false
+            @in_memory = false
+            @in_instantiated_vms_quota = false
+            @in_deployed_vms_quota = false
+            @response = { 
+              'links' => [],
+              'AvailableNetworks' => [],
+              'ComputeCapacity'   => {
+                'Cpu' => {},
+                'DeployedVmsQuota' => {},
+                'InstantiatedVmsQuota' => {},
+                'Memory' => {}
+              },
+              'StorageCapacity'  => {},
+              'ResourceEntities' => []
+            }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Cpu'
+              @in_cpu = true
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = true
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = true
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  link[attribute.first] = attribute.last
+                else
+                  link[attributes.shift] = attributes.shift
+                end
+              end
+              @response['links'] << link
+            when 'Memory'
+              @in_memory = true
+            when 'Network'
+              network = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  network[attribute.first] = attribute.last
+                else
+                  network[attributes.shift] = attributes.shift
+                end
+              end
+              @response['AvailableNetworks'] << network
+            when 'ResourceEntity'
+              resource_entity = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  resource_entity[attribute.first] = attribute.last
+                else
+                  resource_entity[attributes.shift] = attributes.shift
+                end
+              end
+              @response['ResourceEntities'] << resource_entity
+            when 'StorageCapacity'
+              @in_storage_capacity = true
+            when 'Vdc'
+              vdc = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vdc[attribute.first] = attribute.last
+                else
+                  vdc[attributes.shift] = attributes.shift
+                end
+              end
+              @response['href'] = vdc['href']
+              @response['name'] = vdc['name']
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Allocated', 'Limit', 'Units', 'Used'
+              if @in_cpu
+                @response['ComputeCapacity']['Cpu'][name] = value
+              elsif @in_deployed_vms_quota
+                @response['ComputeCapacity']['DeployedVmsQuota'][name] = value
+              elsif @in_instantiated_vms_quota
+                @response['ComputeCapacity']['InstantiatedVmsQuota'][name] = value
+              elsif @in_memory
+                @response['ComputeCapacity']['Memory'][name] = value
+              elsif @in_storage_capacity
+                @response['StorageCapacity'][name] = value
+              end
+            when 'Cpu'
+              @in_cpu = false
+            when 'DeployedVmsQuota'
+              @in_deployed_vms_quota = false
+            when 'InstantiatedVmsQuota'
+              @in_instantiated_vms_quota = false
+            when 'Memory'
+              @in_memory = false
+            when 'StorageCapacity'
+              @in_storage_capacity = false
+            when 'Type'
+              @response[name] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..1f27a60
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/instantiate_vapp_template.rb
@@ -0,0 +1,41 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InstantiateVappTemplate < Fog::Parsers::Base
+
+          def reset
+            @property_key
+            @response = { 'Links' => [] }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Link'
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response['Links'] << link
+            when 'VApp'
+              vapp_template = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  vapp_template[attribute.first] = attribute.last
+                else
+                  vapp_template[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(vapp_template.reject {|key, value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/internet_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/internet_service.rb
new file mode 100644
index 0000000..e3d4b52
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/internet_service.rb
@@ -0,0 +1,65 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class InternetService < Fog::Parsers::Base
+
+          def reset
+            @in_public_ip_address = false
+            @response = { 'PublicIpAddress' => {} }
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Href'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = data
+              else
+                @response[name] = data
+              end
+            when 'PublicIpAddress'
+              @in_public_ip_address = true
+            end
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Protocol'
+              @response[name] = value
+            when 'Enabled'
+              if value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = value.to_i
+              else
+                @response[name] = value.to_i
+              end
+            when 'Name'
+              if @in_public_ip_address
+                @response['PublicIpAddress'][name] = value
+              else
+                @response[name] = value
+              end
+            when 'Port', 'Timeout'
+              @response[name] = value.to_i
+            when 'PublicIpAddress'
+              @in_public_ip_address = false
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/network.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/network.rb
new file mode 100644
index 0000000..3282239
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/network.rb
@@ -0,0 +1,51 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Network < Fog::Parsers::Base
+
+          def reset
+            @response = {
+              "links" => []
+            }
+          end
+
+          def start_element(name,attributes=[])
+            super
+            case name
+            when "Network"
+              until attributes.empty?
+                val = attributes.shift
+                if val.is_a?(String)
+                  @response[val] = attributes.shift
+                end
+              end
+              if @response.has_key?("name")
+                @response["subnet"] = @response["name"]
+              end
+              if @response.has_key?("href")
+                @response["id"] = @response["href"].split("/").last
+              end
+            when "Link"
+              link = {}
+              until attributes.empty?
+                link[attributes.shift] = attributes.shift
+              end
+              @response["links"] << link
+            end
+          end
+
+          def end_element(name)
+            case name
+            when "Gateway", "Netmask", "FenceMode"
+              @response[name.downcase] = value
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/node_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/node_service.rb
new file mode 100644
index 0000000..5396384
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/node_service.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class NodeService < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Description', 'Href', 'IpAddress', 'Name', 'Protocol'
+              @response[name] = value
+            when 'Enabled'
+              if value == 'false'
+                @response[name] = false
+              else
+                @response[name] = true
+              end
+            when 'Id', 'Port'
+              @response[name] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/public_ip.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/public_ip.rb
new file mode 100644
index 0000000..ac869c1
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/public_ip.rb
@@ -0,0 +1,26 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class PublicIp < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def end_element(name)
+            case name
+            when 'Href', 'Name'
+              @response[name.downcase] = value
+            when 'Id'
+              @response['id'] = value.to_i
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/task.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/task.rb
new file mode 100644
index 0000000..23f5987
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/task.rb
@@ -0,0 +1,40 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Task < Fog::Parsers::Base
+
+          def reset
+            @response = {}
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+            when 'Owner', 'Result', 'Link', 'Error'
+              data = {}
+              until attributes.empty?
+                data[attributes.shift] = attributes.shift
+              end
+              @response[name] = data
+            when 'Task'
+              task = {}
+              until attributes.empty?
+                if attributes.first.is_a?(Array)
+                  attribute = attributes.shift
+                  task[attribute.first] = attribute.last
+                else
+                  task[attributes.shift] = attributes.shift
+                end
+              end
+              @response.merge!(task.reject {|key,value| !['endTime', 'href', 'startTime', 'status', 'type'].include?(key)})
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/vapp.rb b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/vapp.rb
new file mode 100644
index 0000000..f6adca0
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/parsers/shared/vapp.rb
@@ -0,0 +1,77 @@
+module Fog
+  module Parsers
+    module Terremark
+      module Shared
+
+        class Vapp < Fog::Parsers::Base
+
+          def reset
+            @response = { 'Links' => [], 'VirtualHardware' => {}, 'OperatingSystem' => {} }
+            @in_operating_system = false
+            @resource_type = nil
+          end
+
+          def start_element(name, attributes)
+            super
+            case name
+              when 'Link'
+                link = {}
+                until attributes.empty?
+                  link[attributes.shift] = attributes.shift
+                end
+                @response['Links'] << link
+              when 'OperatingSystemSection'
+                @in_operating_system = true
+             when 'VApp'
+                vapp = {}
+                until attributes.empty?
+                  if attributes.first.is_a?(Array)
+                    attribute = attributes.shift
+                    vapp[attribute.first] = attribute.last
+                  else
+                    vapp[attributes.shift] = attributes.shift
+                  end
+                end
+                @response.merge!(vapp.reject {|key,value| !['href', 'name', 'size', 'status', 'type'].include?(key)})
+             end
+          end
+
+          def end_element(name)
+            case name
+            when 'IpAddress'
+              @response['IpAddress'] = value
+            when 'Description'
+              if @in_operating_system
+                @response['OperatingSystem'][name] = value
+                @in_operating_system = false
+              end
+            when 'ResourceType'
+              @resource_type = value
+              case value
+              when '3'
+                @get_cpu = true # cpu
+              when '4'  # memory
+                @get_ram = true
+              when '17' # disks
+                @get_disks = true
+              end
+            when 'VirtualQuantity'
+              case @resource_type
+              when '3'
+                @response['VirtualHardware']['cpu'] = value
+              when '4'
+                @response['VirtualHardware']['ram'] = value
+              when '17'
+                @response['VirtualHardware']['disks'] ||= []
+                @response['VirtualHardware']['disks'] << value
+              end
+            end
+          end
+
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_internet_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_internet_service.rb
new file mode 100644
index 0000000..251589f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_internet_service.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * ip_id<~Integer> - Id of ip to add service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_internet_service(ip_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "publicIps/#{ip_id}/internetServices"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_node_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_node_service.rb
new file mode 100644
index 0000000..718c4c8
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/add_node_service.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * service_id<~String> - Id of service to add node to
+        # * ip<~String> - Private ip of server to add to node
+        # * name<~String> - Name of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def add_node_service(service_id, ip, name, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <NodeService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createNodeService">
+    <IpAddress>#{ip}</IpAddress>
+    <Name>#{name}</Name>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </NodeService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "internetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/create_internet_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/create_internet_service.rb
new file mode 100644
index 0000000..b97cffc
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/create_internet_service.rb
@@ -0,0 +1,55 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to add internet service to
+        # * name<~String> - Name of service
+        # * protocol<~String> - Protocol of service
+        # * port<~Integer> - Port of service
+        # * options<~Hash>:
+        #   * Enabled<~Boolean>: defaults to true
+        #   * Description<~String>: optional description
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def create_internet_service(vdc_id, name, protocol, port, options = {})
+          unless options.has_key?('Enabled')
+            options['Enabled'] = true
+          end
+          data = <<-DATA
+  <InternetService xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:tmrk:vCloudExpress-1.0:request:createInternetService">
+    <Name>#{name}</Name>
+    <Protocol>#{protocol.upcase}</Protocol>
+    <Port>#{port}</Port>
+    <Enabled>#{options['Enabled']}</Enabled>
+    <Description>#{options['Description']}</Description>
+  </InternetService>
+  DATA
+          request(
+            :body     => data,
+            :expects  => 200,
+            :headers  => {'Content-Type' => 'application/xml'},
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::InternetService.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_internet_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_internet_service.rb
new file mode 100644
index 0000000..db980ed
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_internet_service.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy an internet service
+        #
+        # ==== Parameters
+        # * internet_service_id<~Integer> - Id of service to destroy
+        #
+        def delete_internet_service(internet_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "InternetServices/#{internet_service_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_node_service.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_node_service.rb
new file mode 100644
index 0000000..5fda1ad
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_node_service.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a node
+        #
+        # ==== Parameters
+        # * node_service_id<~Integer> - Id of node to destroy
+        #
+        def delete_node_service(node_service_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "nodeServices/#{node_service_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_public_ip.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_public_ip.rb
new file mode 100644
index 0000000..5338d3d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_public_ip.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to destroy
+        #
+        def delete_public_ip(public_ip_id)
+          request(
+            :expects  => 200,
+            :method   => 'DELETE',
+            :path     => "publicIps/#{public_ip_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_vapp.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_vapp.rb
new file mode 100644
index 0000000..e7cf048
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/delete_vapp.rb
@@ -0,0 +1,22 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Destroy a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to destroy
+        #
+        def delete_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'DELETE',
+            :path     => "vApp/#{vapp_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/deploy_vapp.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/deploy_vapp.rb
new file mode 100644
index 0000000..0150193
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/deploy_vapp.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reserve requested resources and deploy vApp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vApp to deploy
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def deploy_vapp(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/action/deploy"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog.rb
new file mode 100644
index 0000000..370d4d6
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to view catalog for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalog.new,
+            :path     => "vdc/#{vdc_id}/catalog"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog_item.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog_item.rb
new file mode 100644
index 0000000..4ed3e28
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_catalog_item.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a catalog item
+        #
+        # ==== Parameters
+        # * catalog_item_id<~Integer> - Id of catalog item to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_catalog_item(catalog_item_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetCatalogItem.new,
+            :path     => "catalogItem/#{catalog_item_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_internet_services.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_internet_services.rb
new file mode 100644
index 0000000..25cf384
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_internet_services.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_internet_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vDc to get list of internet services for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'InternetServices'<~Array>
+        #       * 'id'<~String> => id of the internet service
+        #       * 'name'<~String> => name of service
+        #       * 'PublicIPAddress'<~Hash>
+        #       *   'Id'<~String> => id of the public IP
+        #       *   'name'<~String> => actual ip address
+        #
+        def get_internet_services(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetInternetServices.new,
+            :path     => "vdc/#{vdc_id}/internetServices"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network.rb
new file mode 100644
index 0000000..f86dc8d
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network.rb
@@ -0,0 +1,73 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network(network_id)
+         request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Network.new,
+            :path     => "network/#{network_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_network(network_id)
+          network_id = network_id.to_i
+          response = Excon::Response.new
+          if network = self.data[:organizations].map { |org| org[:vdcs].map { |vdc| vdc[:networks] } }.flatten.detect { |network| network[:id] == network_id }
+
+            body = { "links" => [],
+                     "type" => "application/vnd.vmware.vcloud.network+xml",
+                     "href" => "#{@base_url}/network/#{network_id}" }
+
+            network.each_key do |key|
+              body[key.to_s] = network[key]
+            end
+
+            link = { "name" => "IP Addresses",
+                     "rel"  => "down",
+                     "type" => "application/xml" }
+            link["href"] = case self
+            when Fog::Terremark::Ecloud::Mock
+              "#{@base_url}/extensions/network/#{network_id}/ips"
+            when Fog::Terremark::Vcloud::Mock
+              "#{@base_url}/network/#{network_id}/ipAddresses"
+            end
+            body["links"] << link
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, 
+              case self
+              when Fog::Terremark::Ecloud::Mock
+                "application/vnd.vmware.vcloud.network+xml"
+              when Fog::Terremark::Vcloud::Mock
+                "application/xml; charset=utf-8"
+              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network_ips.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network_ips.rb
new file mode 100644
index 0000000..fe649e4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_network_ips.rb
@@ -0,0 +1,32 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a Network
+        #
+        # ==== Parameters
+        # * network_id<~Integer> - Id of the network to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #   FIXME
+        def get_network_ips(network_id)
+          opts =  {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNetworkIps.new,
+            :path     => "network/#{network_id}/ipAddresses"
+          }
+          if self.is_a?(Fog::Terremark::Ecloud::Real)
+            opts[:path] = "/extensions/network/#{network_id}/ips"
+          end
+          request(opts)
+        end
+
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_node_services.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_node_services.rb
new file mode 100644
index 0000000..8010c79
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_node_services.rb
@@ -0,0 +1,30 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        require 'fog/terremark/parsers/shared/get_node_services'
+
+        # Get a list of all internet services for a vdc
+        #
+        # ==== Parameters
+        # * service_id<~Integer> - Id of internet service that we want a list of nodes for
+         #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+       
+        #       
+        def get_node_services(service_id)
+           request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetNodeServices.new,
+            :path     => "InternetServices/#{service_id}/nodes"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organization.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organization.rb
new file mode 100644
index 0000000..8d21805
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organization.rb
@@ -0,0 +1,86 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of an organization
+        #
+        # ==== Parameters
+        # * organization_id<~Integer> - Id of organization to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #       * 'href'<~String> - location of link
+        #       * 'name'<~String> - name of link
+        #       * 'rel'<~String> - action to perform
+        #       * 'type'<~String> - type of link
+        #     * 'name'<~String> - Name of organization
+        def get_organization(organization_id)
+          response = request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganization.new,
+            :path     => "org/#{organization_id}"
+          )
+          response
+        end
+
+      end
+
+      module Mock
+
+        def get_organization(organization_id)
+          organization_id = organization_id.to_i
+          response = Excon::Response.new
+
+          if org = self.data[:organizations].detect { |org| org[:info][:id] == organization_id }
+
+            body = { "name" => org[:info][:name],
+                     "href" => "#{@base_url}/org/#{org[:info][:id]}",
+                     "Links" => [] }
+
+            body["Links"] = case self
+            when Fog::Terremark::Vcloud::Mock
+              _vdc_links(org[:vdcs][0])
+            when Fog::Terremark::Ecloud::Mock
+              org[:vdcs].map do |vdc|
+                _vdc_links(vdc)
+              end.flatten
+            end
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+        private
+
+        def _vdc_links(vdc)
+          [{ "name" => vdc[:name],
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.vdc+xml" },
+           { "name" => "#{vdc[:name]} Catalog",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.catalog+xml" },
+           { "name" => "#{vdc[:name]} Tasks List",
+             "href" => "#{@base_url}/vdc/#{vdc[:id]}/taskslist",
+             "rel" => "down",
+             "type" => "application/vnd.vmware.vcloud.tasksList+xml" }
+          ]
+        end
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organizations.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organizations.rb
new file mode 100644
index 0000000..4fc2f9b
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_organizations.rb
@@ -0,0 +1,49 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of organizations
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Array>:
+        #     * 'description'<~String> - Description of organization
+        #     * 'links'<~Array> - An array of links to entities in the organization
+        #     * 'name'<~String> - Name of organization
+        def get_organizations
+          request({
+            :expects  => 200,
+            :headers  => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              # Terremark said they're going to remove passing in the Content-Type to login in a future release
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path     => 'login'
+          })
+        end
+
+      end
+
+      module Mock
+
+        def get_organizations
+          response = Excon::Response.new
+          org_list = self.data[:organizations].map do |organization|
+            { "name" => organization[:info][:name],
+              "href" => "#{@base_url}/org/#{organization[:info][:id]}",
+              "type" => "application/vnd.vmware.vcloud.org+xml"
+            }
+          end
+          response.body = { "OrgList" => org_list }
+          response.status = 200
+          response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.orgList+xml")
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ip.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ip.rb
new file mode 100644
index 0000000..aed5ec4
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ip.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details for a public ip
+        #
+        # ==== Parameters
+        # * public_ip_id<~Integer> - Id of public ip to look up
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        def get_public_ip(public_ip_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::PublicIp.new,
+            :path     => "publicIps/#{public_ip_id}"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/publicIp/#{public_ip_id}"
+          end
+          request(opts)
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ips.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ips.rb
new file mode 100644
index 0000000..6815320
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_public_ips.rb
@@ -0,0 +1,72 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of public ips
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to find public ips for
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'PublicIpAddresses'<~Array>
+        #       * 'href'<~String> - link to item
+        #       * 'name'<~String> - name of item
+        def get_public_ips(vdc_id)
+          opts = {
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetPublicIps.new,
+            :path     => "vdc/#{vdc_id}/publicIps"
+          }
+          if self.class == Fog::Terremark::Ecloud::Real
+            opts[:path] = "extensions/vdc/#{vdc_id}/publicIps"
+          end
+          request(opts)
+        end
+
+      end
+
+      module Mock
+
+        def get_public_ips(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = self.data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+            body = { "PublicIpAddresses" => [] }
+            vdc[:public_ips].each do |ip|
+              ip = { "name" => ip[:name],
+                     "href" => case self
+                                when Fog::Terremark::Ecloud::Mock
+                                  "#{@base_url}/extensions/publicIp/#{ip[:id]}"
+                                when Fog::Terremark::Vcloud::Mock
+                                  "#{@base_url}/PublicIps/#{ip[:id]}"
+                                end,
+                     "id"   => ip[:id].to_s }
+              body["PublicIpAddresses"] << ip
+            end
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body,
+                              case self
+                              when Fog::Terremark::Ecloud::Mock
+                                "application/vnd.tmrk.ecloud.publicIpsList+xml"
+                              when Fog::Terremark::Vcloud::Mock
+                                "application/xml; charset=utf-8"
+                              end
+            )
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_task.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_task.rb
new file mode 100644
index 0000000..d3e2f9a
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_task.rb
@@ -0,0 +1,39 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a task
+        #
+        # ==== Parameters
+        # * task_id<~Integer> - Id of task to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_task(task_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "task/#{task_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_tasks_list.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_tasks_list.rb
new file mode 100644
index 0000000..e96fd71
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_tasks_list.rb
@@ -0,0 +1,33 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get list of tasks
+        #
+        # ==== Parameters
+        # * tasks_list_id<~Integer> - Id of tasks lists to view
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_tasks_list(tasks_list_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetTasksList.new,
+            :path     => "tasksList/#{tasks_list_id}"
+          )
+        end
+
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp.rb
new file mode 100644
index 0000000..7a7d477
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp.rb
@@ -0,0 +1,42 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        #     * 'Result'<~String> -
+        #       * 'href'<~String> - href of result
+        #       * 'name'<~String> - name of result
+        #       * 'type'<~String> - type of result
+        def get_vapp(vapp_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::Vapp.new,
+            :path     => "vapp/#{vapp_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp_template.rb
new file mode 100644
index 0000000..734316f
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vapp_template.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vapp template
+        #
+        # ==== Parameters
+        # * vapp_template_id<~Integer> - Id of vapp template to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vapp_template(vapp_template_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVappTemplate.new,
+            :path     => "vAppTemplate/#{vapp_template_id}"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vdc.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vdc.rb
new file mode 100644
index 0000000..46fcfa2
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/get_vdc.rb
@@ -0,0 +1,125 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Get details of a vdc
+        #
+        # ==== Parameters
+        # * vdc_id<~Integer> - Id of vdc to lookup
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+
+        # FIXME
+
+        #     * 'CatalogItems'<~Array>
+        #       * 'href'<~String> - linke to item
+        #       * 'name'<~String> - name of item
+        #       * 'type'<~String> - type of item
+        #     * 'description'<~String> - Description of catalog
+        #     * 'name'<~String> - Name of catalog
+        def get_vdc(vdc_id)
+          request(
+            :expects  => 200,
+            :method   => 'GET',
+            :parser   => Fog::Parsers::Terremark::Shared::GetVdc.new,
+            :path     => "vdc/#{vdc_id}"
+          )
+        end
+
+      end
+
+      module Mock
+
+        def get_vdc(vdc_id)
+          vdc_id = vdc_id.to_i
+          response = Excon::Response.new
+
+          if vdc = self.data[:organizations].map { |org| org[:vdcs] }.flatten.detect { |vdc| vdc[:id] == vdc_id }
+
+            body = { "name" => vdc[:name],
+                     "href" => "#{@base_url}/vdc/#{vdc[:id]}",
+                     "StorageCapacity" => {},
+                     "ComputeCapacity" => { "InstantiatedVmsQuota" => {},
+                                            "DeployedVmsQuota" => {},
+                                            "Cpu" => {},
+                                            "Memory" => {} },
+                     "ResourceEntities" => [],
+                     "AvailableNetworks" => [],
+                     "links" => [] }
+
+            case self
+            when Fog::Terremark::Ecloud::Mock
+              body["StorageCapacity"] = { "Units" => "bytes * 10^9" }
+              vdc[:storage].each { |k,v| body["StorageCapacity"][k.to_s.capitalize] = v.to_s }
+
+              body["ComputeCapacity"] = { "InstantiatedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "DeployedVmsQuota" => {"Limit" => "-1", "Used" => "-1"},
+                                           "Cpu" => { "Units" => "hz * 10^6" },
+                                           "Memory" => { "Units" => "bytes * 2^20" } }
+
+              [:cpu, :memory].each do |key|
+                vdc[key].each { |k,v| body["ComputeCapacity"][key.to_s.capitalize][k.to_s.capitalize] = v.to_s }
+              end
+
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.publicIpsList+xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.internetServicesList+xml" }
+
+              body["links"] << { "name" => "Firewall Access List",
+                                 "href" => "#{@base_url}/extensions/vdc/#{vdc[:id]}/firewallAcls",
+                                 "rel"  => "down",
+                                 "type" => "application/vnd.tmrk.ecloud.firewallAclsList+xml" }
+
+            when Fog::Terremark::Vcloud::Mock
+              body["links"] << { "name" => "Public IPs",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/publicIps",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+
+              body["links"] << { "name" => "Internet Services",
+                                 "href" => "#{@base_url}/vdc/#{vdc[:id]}/internetServices",
+                                 "rel"  => "down",
+                                 "type" => "application/xml" }
+            end
+
+            vdc[:vms].each do |vm|
+              body["ResourceEntities"] << { "name" => vm[:name],
+                                            "href" => "#{@base_url}/vapp/#{vm[:id]}",
+                                            "type" => "application/vnd.vmware.vcloud.vApp+xml" }
+            end
+
+            vdc[:networks].each do |network|
+              body["AvailableNetworks"] << { "name" => network[:name],
+                                             "href" => "#{@base_url}/network/#{network[:id]}",
+                                             "type" => "application/vnd.vmware.vcloud.network+xml" }
+            end
+
+            body["links"] << { "name" => vdc[:name],
+                               "href" => "#{@base_url}/vdc/#{vdc[:id]}/catalog",
+                               "rel"  => "down",
+                               "type" => "application/vnd.vmware.vcloud.catalog+xml" }
+
+            response.status = 200
+            response.body = body
+            response.headers = Fog::Terremark::Shared::Mock.headers(response.body, "application/vnd.vmware.vcloud.org+xml")
+          else
+            response.status = Fog::Terremark::Shared::Mock.unathorized_status
+            response.headers = Fog::Terremark::Shared::Mock.error_headers
+          end
+
+          response
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
new file mode 100644
index 0000000..eb4ef88
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/instantiate_vapp_template.rb
@@ -0,0 +1,71 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Instatiate a vapp template
+        #
+        # ==== Parameters
+        # * name<~String>: Name of the resulting vapp .. must start with letter, up to 15 chars alphanumeric.
+        # * options<~Hash>:
+        # * cpus<~Integer>: Number of cpus in [1, 2, 4, 8], defaults to 1
+        # * memory<~Integer>: Amount of memory either 512 or a multiple of 1024, defaults to 512
+        # * vapp_template<~String>: id of the vapp template to be instantiated
+        # ==== Returns
+        # * response<~Excon::Response>:
+        # * body<~Hash>:
+        # * 'Links;<~Array> (e.g. up to vdc)
+        # * 'href'<~String> Link to the resulting vapp
+        # * 'name'<~String> - name of item
+        # * 'type'<~String> - type of item
+        # * 'status'<~String> - 0(pending) --> 2(off) -->4(on)
+        def instantiate_vapp_template(name, vapp_template, options = {})
+          unless name.length < 15
+            raise ArgumentError.new('Name must be fewer than 15 characters')
+          end
+          options['cpus'] ||= 1
+          options['memory'] ||= 512
+          options['network_id'] ||= default_network_id
+          options['vdc_id'] ||= default_vdc_id
+
+          data = <<-DATA
+<?xml version="1.0" encoding="UTF-8"?>
+<InstantiateVAppTemplateParams name="#{name}" xmlns="http://www.vmware.com/vcloud/v0.8" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.vmware.com/vcloud/v0.8 http://services.vcloudexpress.terremark.com/api/v0.8/ns/vcloud.xsd">
+  <VAppTemplate href="#{@scheme}://#{@host}/#{@path}/vAppTemplate/#{vapp_template}" />
+  <InstantiationParams xmlns:vmw="http://www.vmware.com/schema/ovf">
+    <ProductSection xmlns:ovf="http://schemas.dmtf.org/ovf/envelope/1" xmlns:q1="http://www.vmware.com/vcloud/v0.8"/>
+    <VirtualHardwareSection xmlns:q1="http://www.vmware.com/vcloud/v0.8">
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">1</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">3</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['cpus']}</VirtualQuantity>
+      </Item>
+      <Item xmlns="http://schemas.dmtf.org/ovf/envelope/1">
+        <InstanceID xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">2</InstanceID>
+        <ResourceType xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">4</ResourceType>
+        <VirtualQuantity xmlns="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ResourceAllocationSettingData">#{options['memory']}</VirtualQuantity>
+      </Item>
+    </VirtualHardwareSection>
+    <NetworkConfigSection>
+      <NetworkConfig>
+        <NetworkAssociation href="#{@scheme}://#{@host}/#{@path}/network/#{options['network_id']}"/>
+      </NetworkConfig>
+    </NetworkConfigSection>
+  </InstantiationParams>
+</InstantiateVAppTemplateParams>
+DATA
+
+          request(
+            :body => data,
+            :expects => 200,
+            :headers => { 'Content-Type' => 'application/vnd.vmware.vcloud.instantiateVAppTemplateParams+xml' },
+            :method => 'POST',
+            :parser => Fog::Parsers::Terremark::Shared::InstantiateVappTemplate.new,
+            :path => "vdc/#{options['vdc_id']}/action/instantiatevAppTemplate"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_off.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_off.rb
new file mode 100644
index 0000000..d82e1af
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_off.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power off a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power off
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_off(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOff"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_on.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_on.rb
new file mode 100644
index 0000000..18d98a7
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_on.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Power on a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to power on
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_on(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/powerOn"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_reset.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_reset.rb
new file mode 100644
index 0000000..e4e7476
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_reset.rb
@@ -0,0 +1,35 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Reset a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to reset
+        #
+        # ==== Returns
+        # * response<~Excon::Response>:
+        #   * body<~Hash>:
+        #     * 'endTime'<~String> - endTime of task
+        #     * 'href'<~String> - link to task
+        #     * 'startTime'<~String> - startTime of task
+        #     * 'status'<~String> - status of task
+        #     * 'type'<~String> - type of task
+        #     * 'Owner'<~String> -
+        #       * 'href'<~String> - href of owner
+        #       * 'name'<~String> - name of owner
+        #       * 'type'<~String> - type of owner
+        def power_reset(vapp_id)
+          request(
+            :expects  => 202,
+            :method   => 'POST',
+            :parser   => Fog::Parsers::Terremark::Shared::Task.new,
+            :path     => "vApp/#{vapp_id}/power/action/reset"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_shutdown.rb b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_shutdown.rb
new file mode 100644
index 0000000..ecfa978
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/requests/shared/power_shutdown.rb
@@ -0,0 +1,24 @@
+module Fog
+  module Terremark
+    module Shared
+      module Real
+
+        # Shutdown a vapp
+        #
+        # ==== Parameters
+        # * vapp_id<~Integer> - Id of vapp to shutdown
+        #
+        # ==== Returns
+        # Nothing
+        def power_shutdown(vapp_id)
+          request(
+            :expects  => 204,
+            :method   => 'POST',
+            :path     => "vApp/#{vapp_id}/power/action/shutdown"
+          )
+        end
+
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/shared.rb b/vendor/fog-0.8.2/lib/fog/terremark/shared.rb
new file mode 100644
index 0000000..c068c02
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/shared.rb
@@ -0,0 +1,293 @@
+module Fog
+  module Terremark
+    module Shared
+
+      # Commond methods shared by Real and Mock
+      module Common
+
+        def default_organization_id
+          @default_organization_id ||= begin
+            org_list = get_organizations.body['OrgList']
+            if org_list.length == 1
+              org_list.first['href'].split('/').last.to_i
+            else
+              nil
+            end
+          end
+        end
+
+      end
+
+      module Parser
+
+        def parse(data)
+          case data['type']
+          when 'application/vnd.vmware.vcloud.vApp+xml'
+            servers.new(data.merge!(:connection => self))
+          else
+            data
+          end
+        end
+
+      end
+
+      module Real
+        include Common
+
+        private
+
+        def auth_token
+          response = @connection.request({
+            :expects   => 200,
+            :headers   => {
+              'Authorization' => "Basic #{Base64.encode64("#{@terremark_username}:#{@terremark_password}").chomp!}",
+              'Content-Type'  => "application/vnd.vmware.vcloud.orgList+xml"
+            },
+            :host      => @host,
+            :method    => 'POST',
+            :parser    => Fog::Parsers::Terremark::Shared::GetOrganizations.new,
+            :path      => "#{@path}/login"
+          })
+          response.headers['Set-Cookie']
+        end
+
+        def reload
+          @connection.reset
+        end
+
+        def request(params)
+          unless @cookie
+            @cookie = auth_token
+          end
+          begin
+            do_request(params)
+          rescue Excon::Errors::Unauthorized => e
+            @cookie = auth_token
+            do_request(params)
+          end
+        end
+
+        def do_request(params)
+          headers = {}
+          if @cookie
+            headers.merge!('Cookie' => @cookie)
+          end
+          @connection.request({
+            :body     => params[:body],
+            :expects  => params[:expects],
+            :headers  => headers.merge!(params[:headers] || {}),
+            :host     => @host,
+            :method   => params[:method],
+            :parser   => params[:parser],
+            :path     => "#{@path}/#{params[:path]}"
+          })
+        end
+
+      end
+
+      module Mock
+        include Common
+
+        def self.mock_data
+        {
+          :organizations =>
+          [
+            {
+              :info => {
+                :name => "Boom Inc.",
+                :id => 1
+              },
+              :vdcs => [
+                { :id => 21,
+                  :name => "Boomstick",
+                  :storage => { :used => 105, :allocated => 200 },
+                  :cpu => { :allocated => 10000 },
+                  :memory => { :allocated => 20480 },
+                  :networks => [
+                    { :id => 31,
+                      :name => "1.2.3.0/24",
+                      :subnet => "1.2.3.0/24",
+                      :gateway => "1.2.3.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                    { :id => 32,
+                      :name => "4.5.6.0/24",
+                      :subnet => "4.5.6.0/24",
+                      :gateway => "4.5.6.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    },
+                  ],
+                  :vms => [
+                    { :id => 41,
+                      :name => "Broom 1"
+                    },
+                    { :id => 42,
+                      :name => "Broom 2"
+                    },
+                    { :id => 43,
+                      :name => "Email!"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 51,
+                      :name => "99.1.2.3"
+                    },
+                    { :id => 52,
+                      :name => "99.1.2.4"
+                    },
+                    { :id => 53,
+                      :name => "99.1.9.7"
+                    }
+                  ]
+                },
+                { :id => 22,
+                  :storage => { :used => 40, :allocated => 150 },
+                  :cpu => { :allocated => 1000 },
+                  :memory => { :allocated => 2048 },
+                  :name => "Rock-n-Roll",
+                  :networks => [
+                    { :id => 33,
+                      :name => "7.8.9.0/24",
+                      :subnet => "7.8.9.0/24",
+                      :gateway => "7.8.9.1",
+                      :netmask => "255.255.255.0",
+                      :fencemode => "isolated"
+                    }
+                  ],
+                  :vms => [
+                    { :id => 44,
+                      :name => "Master Blaster"
+                    }
+                  ],
+                  :public_ips => [
+                    { :id => 54,
+                      :name => "99.99.99.99"
+                    }
+                  ]
+                }
+              ]
+            }
+          ]
+        }
+        end
+
+        def self.error_headers
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=>"text/html",
+           "Content-Length"=>"0",
+           "Server"=>"Microsoft-IIS/7.0",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.unathorized_status
+          401
+        end
+
+        def self.headers(body, content_type)
+          {"X-Powered-By"=>"ASP.NET",
+           "Date"=> Time.now.to_s,
+           "Content-Type"=> content_type,
+           "Content-Length"=> body.to_s.length,
+           "Server"=>"Microsoft-IIS/7.0",
+           "Set-Cookie"=>"vcloud-token=ecb37bfc-56f0-421d-97e5-bf2gdf789457; path=/",
+           "Cache-Control"=>"private"}
+        end
+
+        def self.status
+          200
+        end
+
+        def initialize(options={})
+          self.class.instance_eval '
+            def self.data
+              @data ||= Hash.new do |hash, key|
+                hash[key] = Fog::Terremark::Shared::Mock.mock_data
+              end
+            end'
+          self.class.instance_eval '
+            def self.reset
+              @data = nil
+            end
+
+            def self.reset_data(keys=data.keys)
+              for key in [*keys]
+                data.delete(key)
+              end
+            end'
+        end
+      end
+
+      def check_shared_options(options)
+        %w{ecloud vcloud}.each do |cloud|
+          cloud_option_keys = options.keys.select { |key| key.to_s =~ /^terremark_#{cloud}_.*/ }
+          unless cloud_option_keys.length == 0 || cloud_option_keys.length == 2
+            raise ArgumentError.new("terremark_#{cloud}_username and terremark_#{cloud}_password required to access teremark")
+          end
+        end
+      end
+
+      def shared_requires
+        require 'fog/terremark/models/shared/address'
+        require 'fog/terremark/models/shared/addresses'
+        require 'fog/terremark/models/shared/network'
+        require 'fog/terremark/models/shared/networks'
+        require 'fog/terremark/models/shared/server'
+        require 'fog/terremark/models/shared/servers'
+        require 'fog/terremark/models/shared/task'
+        require 'fog/terremark/models/shared/tasks'
+        require 'fog/terremark/models/shared/vdc'
+        require 'fog/terremark/models/shared/vdcs'
+        require 'fog/terremark/parsers/shared/get_catalog'
+        require 'fog/terremark/parsers/shared/get_catalog_item'
+        require 'fog/terremark/parsers/shared/get_internet_services'
+        require 'fog/terremark/parsers/shared/get_network_ips'
+        require 'fog/terremark/parsers/shared/get_node_services'
+        require 'fog/terremark/parsers/shared/get_organization'
+        require 'fog/terremark/parsers/shared/get_organizations'
+        require 'fog/terremark/parsers/shared/get_public_ips'
+        require 'fog/terremark/parsers/shared/get_tasks_list'
+        require 'fog/terremark/parsers/shared/get_vapp_template'
+        require 'fog/terremark/parsers/shared/get_vdc'
+        require 'fog/terremark/parsers/shared/instantiate_vapp_template'
+        require 'fog/terremark/parsers/shared/internet_service'
+        require 'fog/terremark/parsers/shared/network'
+        require 'fog/terremark/parsers/shared/node_service'
+        require 'fog/terremark/parsers/shared/public_ip'
+        require 'fog/terremark/parsers/shared/task'
+        require 'fog/terremark/parsers/shared/vapp'
+        require 'fog/terremark/requests/shared/add_internet_service'
+        require 'fog/terremark/requests/shared/add_node_service'
+        require 'fog/terremark/requests/shared/create_internet_service'
+        require 'fog/terremark/requests/shared/delete_internet_service'
+        require 'fog/terremark/requests/shared/delete_public_ip'
+        require 'fog/terremark/requests/shared/delete_node_service'
+        require 'fog/terremark/requests/shared/delete_vapp'
+        require 'fog/terremark/requests/shared/deploy_vapp'
+        require 'fog/terremark/requests/shared/get_catalog'
+        require 'fog/terremark/requests/shared/get_catalog_item'
+        require 'fog/terremark/requests/shared/get_internet_services'
+        require 'fog/terremark/requests/shared/get_network'
+        require 'fog/terremark/requests/shared/get_network_ips'
+        require 'fog/terremark/requests/shared/get_node_services'
+        require 'fog/terremark/requests/shared/get_organization'
+        require 'fog/terremark/requests/shared/get_organizations'
+        require 'fog/terremark/requests/shared/get_public_ip'
+        require 'fog/terremark/requests/shared/get_public_ips'
+        require 'fog/terremark/requests/shared/get_task'
+        require 'fog/terremark/requests/shared/get_tasks_list'
+        require 'fog/terremark/requests/shared/get_vapp'
+        require 'fog/terremark/requests/shared/get_vapp_template'
+        require 'fog/terremark/requests/shared/get_vdc'
+        require 'fog/terremark/requests/shared/instantiate_vapp_template'
+        require 'fog/terremark/requests/shared/power_off'
+        require 'fog/terremark/requests/shared/power_on'
+        require 'fog/terremark/requests/shared/power_reset'
+        require 'fog/terremark/requests/shared/power_shutdown'
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/lib/fog/terremark/vcloud.rb b/vendor/fog-0.8.2/lib/fog/terremark/vcloud.rb
new file mode 100644
index 0000000..94c7c67
--- /dev/null
+++ b/vendor/fog-0.8.2/lib/fog/terremark/vcloud.rb
@@ -0,0 +1,127 @@
+module Fog
+  module Terremark
+   module Vcloud
+
+     module Bin
+     end
+
+     module Defaults
+       HOST   = 'services.vcloudexpress.terremark.com'
+       PATH   = '/api/v0.8'
+       PORT   = 443
+       SCHEME = 'https'
+     end
+
+     extend Fog::Terremark::Shared
+
+     def self.new(options={})
+       location = caller.first
+       warning = "[yellow][WARN] Fog::Terremark::Vcloud is deprecated, to be replaced with Vcloud 1.0 someday/maybe[/]"
+       warning << " [light_black](" << location << ")[/] "
+       Formatador.display_line(warning)
+
+       unless @required
+         shared_requires
+         @required = true
+       end
+
+       check_shared_options(options)
+
+       if Fog.mocking?
+          Fog::Terremark::Vcloud::Mock.new(options)
+       else
+          Fog::Terremark::Vcloud::Real.new(options)
+       end
+     end
+
+     class Real
+
+       include Fog::Terremark::Shared::Real
+       include Fog::Terremark::Shared::Parser
+
+        def initialize(options={})
+          @terremark_password = options[:terremark_vcloud_password]
+          @terremark_username = options[:terremark_vcloud_username]
+          @host   = options[:host]   || Fog::Terremark::Vcloud::Defaults::HOST
+          @path   = options[:path]   || Fog::Terremark::Vcloud::Defaults::PATH
+          @port   = options[:port]   || Fog::Terremark::Vcloud::Defaults::PORT
+          @scheme = options[:scheme] || Fog::Terremark::Vcloud::Defaults::SCHEME
+          @connection = Fog::Connection.new("#{@scheme}://#{@host}:#{@port}", options[:persistent])
+        end
+
+        def default_vdc_id
+          if default_organization_id
+            @default_vdc_id ||= begin
+              vdcs = get_organization(default_organization_id).body['Links'].select {|link|
+                link['type'] == 'application/vnd.vmware.vcloud.vdc+xml'
+              }
+              if vdcs.length == 1
+                vdcs.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_network_id
+          if default_vdc_id
+            @default_network_id ||= begin
+              networks = get_vdc(default_vdc_id).body['AvailableNetworks']
+              if networks.length == 1
+                networks.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+
+        def default_public_ip_id
+          if default_vdc_id
+            @default_public_ip_id ||= begin
+              ips = get_public_ips(default_vdc_id).body['PublicIpAddresses']
+              if ips.length == 1
+                ips.first['href'].split('/').last.to_i
+              else
+                nil
+              end
+            end
+          else
+            nil
+          end
+        end
+     end
+
+     class Mock
+       include Fog::Terremark::Shared::Mock
+       include Fog::Terremark::Shared::Parser
+
+       def initialize(option = {})
+         super
+         @base_url = Fog::Terremark::Vcloud::Defaults::SCHEME + "://" +
+                     Fog::Terremark::Vcloud::Defaults::HOST +
+                     Fog::Terremark::Vcloud::Defaults::PATH
+
+         @terremark_username = options[:terremark_vcloud_username]
+       end
+
+       def data
+         self.class.data[@terremark_username]
+       end
+
+       def reset_data
+         self.class.data.delete(@terremark_username)
+       end
+
+     end
+
+   end
+  end
+end
+
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/bin_spec.rb b/vendor/fog-0.8.2/spec/ecloud/bin_spec.rb
new file mode 100644
index 0000000..3a3754d
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/bin_spec.rb
@@ -0,0 +1,28 @@
+require 'ecloud/spec_helper'
+
+describe 'Ecloud' do
+
+  it do
+    pending unless Ecloud.available?
+    Ecloud.should have_at_least(1).services
+  end
+
+  describe "when indexing it like an array" do
+
+
+    describe "with a service that exists" do
+      it "should return something when indexed with a configured service" do
+        pending unless Ecloud.available?
+        Ecloud[:compute].should_not be_nil
+      end
+    end
+
+    describe "with a service that does not exist" do
+      it "should raise an ArgumentError" do
+        pending unless Ecloud.available?
+        lambda {Ecloud[:foozle]}.should raise_error(ArgumentError)
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_service_spec.rb
new file mode 100644
index 0000000..7055683
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_service_spec.rb
@@ -0,0 +1,48 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::BackupInternetService", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud.vdcs[0].backup_internet_services[0] }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::BackupInternetService }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :name, :id, :protocol, :enabled, :description, :timeout, :redirect_url, :monitor]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::BackupInternetService.new() }
+      it { should have_all_attributes_be_nil }
+
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].backup_internet_services[0].reload }
+
+      let(:composed_service_data) { @vcloud.vdcs[0].backup_internet_services[0].send(:_compose_service_data) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::BackupInternetService) }
+
+      its(:href)                  { should == @mock_backup_service.href }
+      its(:identity)              { should == @mock_backup_service.href }
+      its(:name)                  { should == @mock_backup_service.name }
+      its(:id)                    { should == @mock_backup_service.object_id.to_s }
+      its(:protocol)              { should == @mock_backup_service.protocol }
+      its(:enabled)               { should == @mock_backup_service.enabled.to_s }
+      its(:description)           { should == @mock_backup_service.description }
+      its(:timeout)               { should == @mock_backup_service.timeout.to_s }
+      its(:redirect_url)          { should == (@mock_backup_service.redirect_url || "") }
+      its(:monitor)               { should == nil }
+
+      specify { composed_service_data[:href].should == subject.href.to_s }
+      specify { composed_service_data[:name].should == subject.name }
+      specify { composed_service_data[:id].should == subject.id.to_s }
+      specify { composed_service_data[:protocol].should == subject.protocol }
+      specify { composed_service_data[:enabled].should == subject.enabled.to_s }
+      specify { composed_service_data[:description].should == subject.description }
+      specify { composed_service_data[:timeout].should == subject.timeout.to_s }
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_services_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_services_spec.rb
new file mode 100644
index 0000000..40de52f
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/backup_internet_services_spec.rb
@@ -0,0 +1,28 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::InternetServices", :type => :mock_tmrk_ecloud_model do
+    context "as an attribute of a VDC" do
+      subject { @vcloud.vdcs[0] }
+
+      it { should respond_to(:backup_internet_services) }
+
+      describe :class do
+        subject { @vcloud.vdcs[0].backup_internet_services.class }
+        its(:model)       { should == Fog::Ecloud::Compute::BackupInternetService }
+      end
+
+      describe :backup_internet_services do
+        subject { @vcloud.vdcs[0].backup_internet_services }
+
+        it { should respond_to(:create) }
+
+        it { should be_an_instance_of(Fog::Ecloud::Compute::BackupInternetServices) }
+
+        its(:length) { should == 1 }
+
+        it { should(have_members_of_the_right_model) }
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/internet_service_spec.rb
new file mode 100644
index 0000000..90267fa
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/internet_service_spec.rb
@@ -0,0 +1,104 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::InternetService", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud.vdcs[0].public_ips[0].internet_services[0] }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::InternetService }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :name, :id, :protocol, :port, :enabled, :description, :public_ip, :timeout, :redirect_url, :monitor, :backup_service_data]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::InternetService.new() }
+      it { should have_all_attributes_be_nil }
+
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].public_ips[0].internet_services[0].reload; @vcloud.vdcs[0].public_ips[0].internet_services[0] }
+
+      let(:public_ip) {
+        pip = @vcloud.get_public_ip(@vcloud.vdcs[0].public_ips[0].internet_services[0].public_ip[:Href]).body
+        pip.delete_if{ |k,v| [:xmlns, :xmlns_i].include?(k)}
+        pip
+      }
+      let(:composed_public_ip_data) { @vcloud.vdcs[0].public_ips[0].internet_services[0].send(:_compose_ip_data) }
+      let(:composed_service_data) { @vcloud.vdcs[0].public_ips[0].internet_services[0].send(:_compose_service_data) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::InternetService) }
+
+      its(:href)               { should == @mock_service.href }
+      its(:identity)           { should == @mock_service.href }
+      its(:name)               { should == @mock_service.name }
+      its(:id)                 { should == @mock_service.object_id.to_s }
+      its(:protocol)           { should == @mock_service.protocol }
+      its(:port)               { should == @mock_service.port.to_s }
+      its(:enabled)            { should == @mock_service.enabled.to_s }
+      its(:description)        { should == @mock_service.description }
+      its(:public_ip)          { should == public_ip }
+      its(:timeout)            { should == @mock_service.timeout.to_s }
+      its(:redirect_url)       { should == @mock_service.redirect_url }
+      its(:monitor)            { should == nil }
+      its(:backup_service_uri) { should be_nil }
+
+      specify { composed_public_ip_data[:href].should == public_ip[:Href].to_s }
+      specify { composed_public_ip_data[:name].should == public_ip[:Name] }
+      specify { composed_public_ip_data[:id].should == public_ip[:Id] }
+
+      specify { composed_service_data[:href].should == subject.href.to_s }
+      specify { composed_service_data[:name].should == subject.name }
+      specify { composed_service_data[:id].should == subject.id.to_s }
+      specify { composed_service_data[:protocol].should == subject.protocol }
+      specify { composed_service_data[:port].should == subject.port.to_s }
+      specify { composed_service_data[:enabled].should == subject.enabled.to_s }
+      specify { composed_service_data[:description].should == subject.description }
+      specify { composed_service_data[:timeout].should == subject.timeout.to_s }
+
+      context "with a backup internet service" do
+        before { @mock_service[:backup_service] = @mock_backup_service }
+
+        its(:backup_service_uri) { should == @mock_backup_service.href }
+      end
+
+      describe "#backup_service_uri=" do
+        specify do
+          expect { subject.backup_service_uri = @mock_backup_service.href }.
+            to change { subject.backup_service_uri }.from(nil).to(@mock_backup_service.href)
+        end
+
+        specify do
+          expect { subject.backup_service_uri = @mock_backup_service.href }.
+            to change { subject.send(:_compose_service_data)[:backup_service_uri] }.from(nil).to(@mock_backup_service.href)
+        end
+      end
+
+      describe "disable monitoring via #monitor=" do
+        specify do
+          expect { subject.monitor = {:type => "Disabled", :is_enabled => "true" }; subject.save }.to change {subject.monitor}.from(nil).to(ecloud_disabled_default_monitor)
+        end
+
+      end
+
+      describe "disable monitoring via #disable_monitor" do
+        specify do
+          expect { subject.disable_monitor }.to change {subject.monitor}.from(nil).to(ecloud_disabled_default_monitor)
+        end
+      end
+
+      context "with a disabled monitor" do
+        before { subject.disable_monitor }
+
+        describe "enable ping monitoring via #enable_ping_monitor" do
+          specify do
+            expect { subject.enable_ping_monitor }.to change {subject.monitor}.from(ecloud_disabled_default_monitor).to(nil)
+          end
+        end
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/internet_services_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/internet_services_spec.rb
new file mode 100644
index 0000000..6728441
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/internet_services_spec.rb
@@ -0,0 +1,29 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::InternetServices", :type => :mock_tmrk_ecloud_model do
+    context "as an attribute of a VDC" do
+      subject { @vcloud.vdcs[0] }
+
+      it { should respond_to(:internet_services) }
+
+      describe :class do
+        subject { @vcloud.vdcs[0].internet_services.class }
+        its(:model)       { should == Fog::Ecloud::Compute::InternetService }
+      end
+
+      describe :internet_services do
+        subject { @vcloud.vdcs[0].internet_services }
+
+        it { should respond_to(:create) }
+
+        it { should be_an_instance_of(Fog::Ecloud::Compute::InternetServices) }
+
+        its(:length) { should == 4 }
+
+        it { should have_members_of_the_right_model }
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/ip_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/ip_spec.rb
new file mode 100644
index 0000000..3d3cf0e
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/ip_spec.rb
@@ -0,0 +1,33 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Ip", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::Ip }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :name, :status, :server, :rnat, :id]) }
+    end
+
+    context "with no uri" do
+      subject { Fog::Ecloud::Compute::Ip.new() }
+
+      it { should have_all_attributes_be_nil }
+    end
+
+    context "as a collection member" do
+      subject { @ip = @vcloud.vdcs[0].networks[0].ips[0] }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Ip) }
+
+      its(:name) { should == @mock_data.network_ip_from_href(@ip.href).name }
+      its(:status) { should == @mock_data.network_ip_from_href(@ip.href).status }
+      its(:server) { should == @mock_data.network_ip_from_href(@ip.href).used_by.name }
+
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/ips_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/ips_spec.rb
new file mode 100644
index 0000000..8ee243c
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/ips_spec.rb
@@ -0,0 +1,28 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Ips", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    it { should respond_to(:ips) }
+
+    describe :class do
+      subject { @vcloud.vdcs[0].networks[0].ips.class }
+      its(:model)       { should == Fog::Ecloud::Compute::Ip }
+    end
+
+    describe :ips do
+      subject { @vcloud.vdcs[0].networks[0].ips.reload }
+      it { should_not respond_to(:create) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Ips) }
+
+      its(:length) { should == 252 }
+
+      it { should have_members_of_the_right_model }
+    end
+  end
+else
+end
+
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/network_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/network_spec.rb
new file mode 100644
index 0000000..4c42c5d
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/network_spec.rb
@@ -0,0 +1,71 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Network", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::Network }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :name, :features, :links, :type, :gateway, :broadcast, :address, :rnat, :extension_href, :network_type, :vlan, :friendly_name]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::Network.new() }
+
+      it { should have_all_attributes_be_nil }
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].networks[0].reload }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Network) }
+
+      its(:href)                  { should == @mock_network.href }
+      its(:identity)              { should == @mock_network.href }
+      its(:name)                  { should == @mock_network.name }
+      its(:type)                  { should == "application/vnd.vmware.vcloud.network+xml" }
+      its(:gateway)               { should == @mock_network.gateway }
+      its(:broadcast)             { should == @mock_network.broadcast }
+      its(:address)               { should == @mock_network.address }
+      its(:rnat)                  { should == @mock_network.rnat }
+      its(:extension_href)        { should == @mock_network.extensions.href }
+      its(:network_type)          { should == @mock_network.extensions.type }
+      its(:vlan)                  { should == @mock_network.extensions.vlan }
+      its(:friendly_name)         { should == @mock_network.extensions.friendly_name }
+
+      it { should have(1).features }
+
+      describe :features do
+        let(:feature) { subject.features.first }
+        specify { feature.should be_an_instance_of(Array) }
+        specify { feature.last.should == @mock_network.features[0][:value] }
+      end
+
+      it { should have(2).links }
+
+      describe :links do
+        context "[0]" do
+          let(:link) { subject.links[0] }
+          specify { link[:rel].should == "down" }
+          specify { link[:href].should == @mock_network_ip_collection.href }
+          specify { link[:type].should == "application/xml" }
+          specify { link[:name].should == @mock_network_ip_collection.name }
+        end
+
+        context "[1]" do
+          let(:link) { subject.links[1] }
+          specify { link[:rel].should == "down" }
+          specify { link[:href].should == @mock_network.extensions.href }
+          specify { link[:type].should == "application/xml" }
+          specify { link[:name].should == @mock_network.name }
+        end
+      end
+
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/networks_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/networks_spec.rb
new file mode 100644
index 0000000..48d8295
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/networks_spec.rb
@@ -0,0 +1,27 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Networks", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    it { should respond_to(:networks) }
+
+    describe :class do
+      subject { @vcloud.networks.class }
+      its(:model)       { should == Fog::Ecloud::Compute::Network }
+    end
+
+    describe :networks do
+      subject { @vcloud.vdcs[0].networks }
+      it { should_not respond_to(:create) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Networks) }
+
+      its(:length) { should == 2 }
+
+      it { should have_members_of_the_right_model }
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/node_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/node_spec.rb
new file mode 100644
index 0000000..ee25340
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/node_spec.rb
@@ -0,0 +1,38 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Node", :type => :mock_tmrk_ecloud_model do
+
+    subject { @vcloud.vdcs.first.public_ips.first.internet_services.first.nodes.first }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::Node }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :ip_address, :description, :name, :port, :enabled, :id]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::Node.new() }
+      it { should have_all_attributes_be_nil }
+
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs.first.public_ips.first.internet_services.first.nodes.first.reload }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Node) }
+
+      its(:href)                  { should == @mock_node.href }
+      its(:identity)              { should == @mock_node.href }
+      its(:name)                  { should == @mock_node.name }
+      its(:id)                    { should == @mock_node.object_id.to_s }
+      its(:port)                  { should == @mock_node.port.to_s }
+      its(:enabled)               { should == @mock_node.enabled.to_s }
+      its(:description)           { should == @mock_node.description }
+
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/nodes_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/nodes_spec.rb
new file mode 100644
index 0000000..7e748d9
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/nodes_spec.rb
@@ -0,0 +1,28 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::InternetServices", :type => :mock_tmrk_ecloud_model do
+    context "as an attribute of an internet_service" do
+      subject { @vcloud.vdcs.first.public_ips.first.internet_services.first }
+
+      it { should respond_to(:nodes) }
+
+      describe :class do
+        subject { @vcloud.vdcs.first.public_ips.first.internet_services.first.nodes.class }
+        its(:model)       { should == Fog::Ecloud::Compute::Node }
+      end
+
+      describe :nodes do
+        subject { @vcloud.vdcs.first.public_ips.first.internet_services.first.nodes }
+
+        it { should respond_to(:create) }
+
+        it { should be_an_instance_of(Fog::Ecloud::Compute::Nodes) }
+
+        its(:length) { should == 3 }
+
+        it { should have_members_of_the_right_model }
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/public_ip_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/public_ip_spec.rb
new file mode 100644
index 0000000..7e55bb1
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/public_ip_spec.rb
@@ -0,0 +1,36 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::PublicIp", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::PublicIp }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:name, :id, :href]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::PublicIp.new() }
+
+      it { should have_all_attributes_be_nil }
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].public_ips[0].reload; @vcloud.vdcs[0].public_ips[0] }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::PublicIp) }
+
+      its(:href)                  { should == @mock_public_ip.href }
+      its(:identity)              { should == @mock_public_ip.href }
+      its(:name)                  { should == @mock_public_ip.name }
+      its(:id)                    { should == @mock_public_ip.object_id.to_s }
+
+      its(:internet_services)     { should have(2).services }
+
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/public_ips_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/public_ips_spec.rb
new file mode 100644
index 0000000..38b906c
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/public_ips_spec.rb
@@ -0,0 +1,27 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::PublicIps", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    it { should respond_to(:public_ips) }
+
+    describe :class do
+      subject { @vcloud.public_ips.class }
+      its(:model)       { should == Fog::Ecloud::Compute::PublicIp }
+    end
+
+    describe :public_ips do
+      subject { @vcloud.vdcs[0].public_ips }
+      it { should_not respond_to(:create) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::PublicIps) }
+
+      its(:length) { should == 3 }
+
+      it { should have_members_of_the_right_model }
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/server_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/server_spec.rb
new file mode 100644
index 0000000..a347a61
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/server_spec.rb
@@ -0,0 +1,62 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Vdc", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::Server }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :type, :name, :status, :network_connections, :os, :virtual_hardware, :storage_size, :links]) }
+    end
+
+    context "with no uri" do
+      subject { Fog::Ecloud::Compute::Server.new() }
+
+      it { should have_all_attributes_be_nil }
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].servers.first }
+
+      its(:href)                  { should == @mock_vm.href }
+      its(:identity)              { should == @mock_vm.href }
+      its(:name)                  { should == @mock_vm.name }
+      its(:cpus)                  { should == { :count => @mock_vm.cpus, :units => nil } }
+      its(:memory)                { should == { :amount => @mock_vm.memory, :units => nil } }
+      its(:disks)                 { should == @mock_vm.to_configure_vapp_hash[:disks] }
+
+      describe "question methods" do
+        describe "#ready?" do
+          before { subject.power_off }
+
+          it { should be_ready }
+        end
+
+        describe "#on?" do
+          before { subject.power_on }
+
+          it { should be_on }
+        end
+
+        describe "#off?" do
+          before { subject.power_off }
+
+          it { should be_off }
+        end
+      end
+    end
+
+    context "as a new server without all info" do
+      before { @vcloud.return_vapp_as_creating! "test123" }
+
+      subject { @vcloud.vdcs[0].servers.create(@mock_catalog_item.href, { :name => "test123", :row => "foo", :group => "bar", :network_uri => @mock_network.href }) }
+
+      its(:cpus)                  { should be_nil }
+      its(:memory)                { should be_nil }
+      its(:disks)                 { should == [] }
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/vdc_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/vdc_spec.rb
new file mode 100644
index 0000000..72a953f
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/vdc_spec.rb
@@ -0,0 +1,63 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Vdc", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    it { should respond_to(:get_vdc) }
+
+    describe :class do
+      subject { Fog::Ecloud::Compute::Vdc }
+
+      it { should have_identity(:href) }
+      it { should have_only_these_attributes([:href, :name, :type, :description, :other_links, :compute_capacity, :storage_capacity, :available_networks,
+                                              :resource_entities, :deployed_vm_quota, :instantiated_vm_quota]) }
+    end
+
+    context "with no uri" do
+
+      subject { Fog::Ecloud::Compute::Vdc.new() }
+
+      it { should have_all_attributes_be_nil }
+    end
+
+    context "as a collection member" do
+      subject { @vcloud.vdcs[0].reload }
+
+      its(:href)                  { should == @mock_vdc.href }
+      its(:identity)              { should == @mock_vdc.href }
+      its(:name)                  { should == @mock_vdc.name }
+      its(:public_ips)            { should be_an_instance_of(Fog::Ecloud::Compute::PublicIps) }
+      its(:other_links)           { should have(4).items }
+      its(:resource_entities)     { should have(3).items }
+      its(:available_networks)    { should have(2).items }
+
+      its(:compute_capacity)      { should == {:Memory =>
+                                                {:Allocated => @mock_vdc.memory_allocated.to_s, :Units => "bytes * 2^20"}, 
+                                               :DeployedVmsQuota =>
+                                                {:Limit => "-1", :Used => "-1"},
+                                               :InstantiatedVmsQuota =>
+                                                {:Limit => "-1", :Used => "-1"}, 
+                                               :Cpu =>
+                                                {:Allocated => @mock_vdc.cpu_allocated.to_s, :Units => "hz * 10^6"}} }
+
+      its(:storage_capacity)      { should == {:Allocated => @mock_vdc.storage_allocated.to_s, :Used => @mock_vdc.storage_used.to_s, :Units => "bytes * 10^9"} }
+
+      its(:deployed_vm_quota)     { should == nil }
+      its(:instantiated_vm_quota) { should == nil }
+
+      its(:public_ips)            { should have(3).public_ips }
+      its(:internet_services)     { should have(4).services }
+      its(:networks)              { should have(2).networks }
+      its(:servers)               { should have(3).servers }
+
+      #FIXME: need to mock tasks related requests first
+      #its(:tasks)                 { should have(0).tasks }
+
+      #FIXME: need to mock catalog related requests first
+      #its(:catalog)               { should have(0).entries }
+
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/models/vdcs_spec.rb b/vendor/fog-0.8.2/spec/ecloud/models/vdcs_spec.rb
new file mode 100644
index 0000000..951f9a0
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/models/vdcs_spec.rb
@@ -0,0 +1,28 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud::Compute::Vdcs", :type => :mock_tmrk_ecloud_model do
+    subject { @vcloud }
+
+    it { should respond_to(:vdcs) }
+
+    describe :class do
+      subject { @vcloud.vdcs.class }
+      its(:model)       { should == Fog::Ecloud::Compute::Vdc }
+    end
+
+    describe :vdcs do
+      subject { @vcloud.vdcs }
+      it { should_not respond_to(:create) }
+
+      it { should be_an_instance_of(Fog::Ecloud::Compute::Vdcs) }
+
+      its(:length) { should == 2 }
+
+      it { should have_members_of_the_right_model }
+
+      its(:organization_uri) { should == @mock_organization.href }
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/add_backup_internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/add_backup_internet_service_spec.rb
new file mode 100644
index 0000000..3446107
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/add_backup_internet_service_spec.rb
@@ -0,0 +1,60 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:add_backup_internet_service) }
+
+    describe "#add_backup_internet_service" do
+      before do
+        @new_backup_service_data = {
+          :name => "Test Service",
+          :protocol => "HTTP",
+          :enabled => "true",
+          :description => "this is a test",
+          :redirect_url => ""
+        }
+      end
+
+      context "with a valid vdc uri" do
+        subject { @vcloud.add_backup_internet_service(@mock_vdc.internet_service_collection.href, @new_backup_service_data ) }
+
+        it "has the right number of Internet Services after" do
+          expect { subject }.to change { @vcloud.get_internet_services(@mock_vdc.internet_service_collection.href).body[:InternetService].size }.by(1)
+        end
+
+        it_should_behave_like "all responses"
+
+        let(:body) { subject.body }
+
+        its(:body) { should be_an_instance_of(Hash) }
+        specify { body[:Href].should_not be_empty }
+        specify { body[:Name].should == @new_backup_service_data[:name] }
+        specify { body[:Protocol].should == @new_backup_service_data[:protocol] }
+        specify { body[:Enabled].should == @new_backup_service_data[:enabled] }
+        specify { body[:Description].should == @new_backup_service_data[:description] }
+        specify { body[:RedirectURL].should == @new_backup_service_data[:redirect_url] }
+        specify { body[:Monitor].should == nil }
+        # so broken
+        specify { body[:IsBackupService].should == "false" }
+
+        it "should update the mock object properly" do
+          subject
+
+          backup_internet_service = @vcloud.mock_data.backup_internet_service_from_href(body[:Href])
+          backup_internet_service.object_id.to_s.should == body[:Id]
+          backup_internet_service.node_collection.items.should be_empty
+        end
+      end
+
+      context "with a vdc uri that doesn't exist" do
+        subject { lambda { @vcloud.add_backup_internet_service(URI.parse('https://www.fakey.c/piv8vc99'), @new_backup_service_data ) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/add_internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/add_internet_service_spec.rb
new file mode 100644
index 0000000..71bda22
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/add_internet_service_spec.rb
@@ -0,0 +1,65 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:add_internet_service) }
+
+    describe "#add_internet_service" do
+      before do
+        @public_ip = @vcloud.vdcs.first.public_ips.detect {|p| p.name == @mock_public_ip.name }
+
+        @new_service_data = { :name => "Test Service",
+                              :protocol => "HTTP",
+                              :port => "80",
+                              :enabled => "true",
+                              :description => "this is a test",
+                              :redirect_url => "" }
+      end
+
+      context "with a valid Public IP uri" do
+        subject { @vcloud.add_internet_service(@public_ip.internet_services.href, @new_service_data ) }
+
+        it "has the right number of Internet Services after" do
+          expect { subject }.to change { @vcloud.get_internet_services(@public_ip.internet_services.href).body[:InternetService].size }.by(1)
+        end
+
+        it_should_behave_like "all responses"
+
+        let(:body) { subject.body }
+
+        its(:body) { should be_an_instance_of(Hash) }
+        specify { body[:Href].should_not be_empty }
+        specify { body[:Name].should == @new_service_data[:name] }
+        specify { body[:Protocol].should == @new_service_data[:protocol] }
+        specify { body[:Enabled].should == @new_service_data[:enabled] }
+        specify { body[:Description].should == @new_service_data[:description] }
+        specify { body[:RedirectURL].should == @new_service_data[:redirect_url] }
+        specify { body[:Monitor].should == nil }
+
+        let(:referenced_public_ip) { subject.body[:PublicIpAddress] }
+        specify { referenced_public_ip.should be_an_instance_of(Hash) }
+        specify { referenced_public_ip[:Name].should == @public_ip.name }
+        specify { referenced_public_ip[:Id].should == @public_ip.id }
+
+        it "should update the mock object properly" do
+          subject
+
+          public_ip_internet_service = @vcloud.mock_data.public_ip_internet_service_from_href(body[:Href])
+
+          public_ip_internet_service.object_id.to_s.should == body[:Id]
+          public_ip_internet_service.node_collection.items.should be_empty
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.add_internet_service(URI.parse('https://www.fakey.c/piv8vc99'), @new_service_data ) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/add_node_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/add_node_spec.rb
new file mode 100644
index 0000000..b358184
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/add_node_spec.rb
@@ -0,0 +1,56 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  #FIXME: with rspec2
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:add_node) }
+
+    describe "#add_node" do
+
+      let(:new_node_data) { { :ip_address  => '1.2.3.4',
+                              :name        => 'Foo',
+                              :port        => '9090',
+                              :enabled     => 'true',
+                              :description => 'Foo Service'
+                            } }
+
+      context "with a valid node services uri" do
+
+        subject { @vcloud.add_node(@mock_service.node_collection.href, new_node_data) }
+
+        it_should_behave_like "all responses"
+
+        let(:service) { @vcloud.vdcs.first.public_ips.first.internet_services.first }
+
+        it "should change the count by 1" do
+          expect { subject }.to change { @vcloud.get_nodes(@mock_service.node_collection.href).body[:NodeService].length}.by(1)
+        end
+
+        describe "#body" do
+          subject { @vcloud.add_node(@mock_service.node_collection.href, new_node_data).body }
+          its(:Enabled) { should == new_node_data[:enabled] }
+          its(:Port) { should == new_node_data[:port] }
+          its(:IpAddress) { should == new_node_data[:ip_address] }
+          its(:Name) { should == new_node_data[:name] }
+          its(:Description) { should == new_node_data[:description] }
+        end
+
+        describe "added mock data" do
+          let(:added_mock_node) { @vcloud.mock_data.public_ip_internet_service_node_from_href(subject.body[:Href]) }
+
+          specify { added_mock_node._parent.should == @mock_service.node_collection }
+        end
+      end
+
+      context "with a nodes uri that doesn't exist" do
+        subject { lambda { @vcloud.add_node(URI.parse('https://www.fakey.c/piv8vc99'), new_node_data ) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/configure_internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/configure_internet_service_spec.rb
new file mode 100644
index 0000000..11d54d7
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/configure_internet_service_spec.rb
@@ -0,0 +1,61 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:configure_internet_service) }
+
+    describe "#configure_internet_service" do
+      before do
+        @original_service = @vcloud.get_internet_services(@mock_public_ip.internet_service_collection.href).body[:InternetService].first
+        @ip_data = { :id => @mock_public_ip.object_id, :name => @mock_public_ip.name, :href => @mock_public_ip.href.to_s }
+        @service_data = { :name => @original_service[:Name], :protocol => @original_service[:Protocol],
+                          :port => @original_service[:Port], :description => @original_service[:Description],
+                          :enabled => @original_service[:Enabled], :redirect_url => @original_service[:RedirectURL],
+                          :id => @original_service[:Id], :href => @original_service[:Href], :timeout => @original_service[:Timeout] }
+      end
+
+      context "with a valid Internet Service uri and valid data" do
+        subject { @vcloud.configure_internet_service(@original_service[:Href], @service_data, @ip_data) }
+
+        it_should_behave_like "all responses"
+
+        context "with some changed data" do
+          before do
+            @service_data[:description] = "TEST BOOM"
+            @service_data[:redirect_url] = "http://google.com"
+            @service_data[:port] = "80"
+            @service_data[:backup_service_uri] = @mock_backup_service.href
+          end
+
+          it "should change data" do
+            @original_service[:Description].should == @mock_service[:description]
+            @original_service[:RedirectURL].should == @mock_service[:redirect_url]
+            @original_service[:Port].should == @mock_service[:port].to_s
+            result = subject
+            result.body[:Description].should == @service_data[:description]
+            result.body[:RedirectURL].should == @service_data[:redirect_url]
+            result.body[:Port].should        == @service_data[:port]
+            result.body[:BackupService][:Href].should == @service_data[:backup_service_uri]
+
+            new_result = @vcloud.get_internet_services(@mock_public_ip.internet_service_collection.href).body[:InternetService].first
+
+            new_result[:Description].should == @service_data[:description]
+            new_result[:RedirectURL].should == @service_data[:redirect_url]
+            new_result[:Port].should        == @service_data[:port]
+            new_result[:BackupService][:Href].should == @service_data[:backup_service_uri]
+          end
+        end
+      end
+
+      context "with an internet_services_uri that doesn't exist" do
+        subject { lambda { @vcloud.configure_internet_service(URI.parse('https://www.fakey.c/piv8vc99'), @service_data, @ip_data ) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/configure_network_ip_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/configure_network_ip_spec.rb
new file mode 100644
index 0000000..720d793
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/configure_network_ip_spec.rb
@@ -0,0 +1,55 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:configure_network_ip) }
+
+    describe "#configure_network_ip" do
+      let(:original_network_ip) { @vcloud.get_network_ip(@mock_network_ip.href).body }
+      let(:network_ip_data) do
+        {
+          :id => original_network_ip[:Id],
+          :href => original_network_ip[:Href],
+          :name => original_network_ip[:Name],
+          :status => original_network_ip[:Status],
+          :server => original_network_ip[:Server],
+          :rnat => "1.2.3.4"
+        }
+      end
+
+      context "with a valid network ip uri" do
+
+        subject { @vcloud.configure_network_ip(@mock_network_ip.href, network_ip_data) }
+
+        it_should_behave_like "all responses"
+
+        describe "#body" do
+          subject { @vcloud.configure_network_ip(@mock_network_ip.href, network_ip_data).body }
+
+          #Stuff that shouldn't change
+          its(:Href) { should == @mock_network_ip.href }
+          its(:Id) { should == @mock_network_ip.object_id.to_s }
+          its(:Name) { should == @mock_network_ip.ip }
+          its(:Status) { should == @mock_network_ip.status }
+
+          #Stuff that should change
+          it "should change the rnat" do
+            expect { subject }.to change { @vcloud.get_network_ip(@mock_network_ip.href).body[:RnatAddress] }.
+              from(@mock_network.rnat).
+              to(network_ip_data[:rnat])
+          end
+        end
+
+      end
+
+      context "with a nodes uri that doesn't exist" do
+        subject { lambda { @vcloud.configure_network_ip(URI.parse('https://www.fakey.c/piv8vc99'), network_ip_data) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/configure_node_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/configure_node_spec.rb
new file mode 100644
index 0000000..a599d06
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/configure_node_spec.rb
@@ -0,0 +1,52 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:configure_node) }
+
+    describe "#configure_node" do
+      let(:original_node) { @vcloud.get_node(@mock_node.href).body }
+      let(:node_data) { { :name => "TEST BOOM", :enabled => "false", :description => "TEST BOOM DESC" } }
+
+      context "with a valid node service uri" do
+
+        subject { @vcloud.configure_node(@mock_node.href,node_data) }
+
+        it_should_behave_like "all responses"
+
+        describe "#body" do
+          subject { @vcloud.configure_node(@mock_node.href,node_data).body }
+
+          #Stuff that shouldn't change
+          its(:Href) { should == @mock_node.href }
+          its(:Id) { should == @mock_node.object_id.to_s }
+          its(:Port) { should == @mock_node.port.to_s }
+          its(:IpAddress) { should == @mock_node.ip_address }
+
+          #Stuff that should change
+          it "should change the name" do
+            expect { subject }.to change { @vcloud.get_node(@mock_node.href).body[:Name] }.to(node_data[:name])
+          end
+
+          it "should change enabled" do
+            expect { subject }.to change { @vcloud.get_node(@mock_node.href).body[:Enabled] }.to(node_data[:enabled])
+          end
+
+          it "should change the description" do
+            expect { subject }.to change { @vcloud.get_node(@mock_node.href).body[:Description] }.to(node_data[:description])
+          end
+        end
+
+      end
+
+      context "with a nodes uri that doesn't exist" do
+        subject { lambda { @vcloud.configure_node(URI.parse('https://www.fakey.c/piv8vc99'), node_data) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/configure_vapp_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/configure_vapp_spec.rb
new file mode 100644
index 0000000..98069eb
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/configure_vapp_spec.rb
@@ -0,0 +1,71 @@
+require 'ecloud/spec_helper'
+
+shared_examples_for "a successful configure vapp" do
+  specify { after_vapp_data.should == new_vapp_data }
+
+  describe "#body" do
+    its(:body) { should == '' }
+  end
+
+  describe "#headers" do
+    its(:headers) { should include("Location") }
+  end
+end
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:configure_vapp) }
+
+    let(:original_vapp_data) { vapp_data.dup }
+    let(:vapp_data)          { @mock_vm.to_configure_vapp_hash }
+    let(:changed_vapp_data)  { {} }
+    let(:new_vapp_data)      { vapp_data.update(changed_vapp_data) }
+    let(:after_vapp_data)    { @mock_vm.to_configure_vapp_hash }
+
+    describe "#configure_vapp" do
+      context "with a valid vapp uri" do
+        before { original_vapp_data; subject }
+
+        subject { @vcloud.configure_vapp(@mock_vm.href, new_vapp_data) }
+
+        context "when changing nothing" do
+          it_should_behave_like "a successful configure vapp"
+        end
+
+        context "when changing CPUs" do
+          let(:changed_vapp_data) { { :cpus => @mock_vm.cpus * 2 } }
+
+          it_should_behave_like "a successful configure vapp"
+        end
+
+        context "when changing memory" do
+          let(:changed_vapp_data) { { :memory => @mock_vm.memory * 2 } }
+
+          it_should_behave_like "a successful configure vapp"
+        end
+
+        context "when removing a disk" do
+          let(:changed_vapp_data) { { :disks => original_vapp_data[:disks][0...1] } }
+
+          it_should_behave_like "a successful configure vapp"
+        end
+
+        context "when adding a disk" do
+          let(:changed_vapp_data) { { :disks => original_vapp_data[:disks] + [{ :number => "5", :size => 10 * 1024 * 1024, :resource => (10 * 1024 * 1024).to_s }] } }
+
+          it_should_behave_like "a successful configure vapp"
+        end
+      end
+
+      context "with an internet_services_uri that doesn't exist" do
+        subject { lambda { @vcloud.configure_vapp(URI.parse('https://www.fakey.c/piv8vc99'), new_vapp_data) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/delete_internet_service_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/delete_internet_service_spec.rb
new file mode 100644
index 0000000..3a39696
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/delete_internet_service_spec.rb
@@ -0,0 +1,34 @@
+require 'ecloud/spec_helper'
+
+#FIXME: Make this more sane with rspec2
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:delete_internet_service) }
+
+    describe "#delete_internet_service" do
+      context "with a valid internet service uri" do
+        subject { @vcloud.delete_internet_service(@mock_service.href) }
+
+        it_should_behave_like "all delete responses"
+
+        let(:public_ip) { @vcloud.vdcs.first.public_ips.detect {|i| i.name == @mock_public_ip.name } }
+
+        it "should change the mock data" do
+          expect { subject }.to change { @mock_public_ip.internet_service_collection.items.count }.by(-1)
+        end
+
+        it "should change the count by -1" do
+          expect { subject }.to change { public_ip.reload.internet_services.reload.length }.by(-1)
+        end
+
+        describe "#body" do
+          its(:body) { should == '' }
+        end
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/delete_node_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/delete_node_spec.rb
new file mode 100644
index 0000000..72fb799
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/delete_node_spec.rb
@@ -0,0 +1,30 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  #FIXME: with rspec2
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:delete_node) }
+
+    describe "#delete_node" do
+      context "with a valid node service uri" do
+        subject { @vcloud.delete_node(@mock_node.href) }
+
+        it_should_behave_like "all delete responses"
+
+        it "should change the count by -1" do
+          expect { subject }.to change { @vcloud.get_nodes(@mock_node_collection.href).body[:NodeService].length }.by(-1)
+        end
+      end
+
+      context "with a nodes uri that doesn't exist" do
+        subject { lambda { @vcloud.delete_node(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/delete_vapp_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/delete_vapp_spec.rb
new file mode 100644
index 0000000..b9d2d70
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/delete_vapp_spec.rb
@@ -0,0 +1,92 @@
+require 'ecloud/spec_helper'
+
+shared_examples_for "a failed vapp deletion" do
+  it "should not change the mock data" do
+    expect { subject }.to change { @mock_vdc.virtual_machines.count }.by(0)
+  end
+
+  it "should not change the model data" do
+    expect { subject }.to change { vdc.reload.servers.reload.count }.by(0)
+  end
+
+  describe "#body" do
+    its(:body) { should == '' }
+  end
+
+  describe "#headers" do
+    its(:headers) { should_not include("Location") }
+  end
+end
+
+#FIXME: Make this more sane with rspec2
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:delete_vapp) }
+
+    describe "#delete_vapp" do
+      context "with a valid vapp uri" do
+        subject { @vcloud.delete_vapp(@mock_vm.href) }
+        let(:vdc) { @vcloud.vdcs.first }
+
+        context "when there are no internet service nodes attached" do
+          it_should_behave_like("all delete responses")
+
+          it "should change the mock data" do
+            expect { subject }.to change { @mock_vdc.virtual_machines.count }.by(-1)
+          end
+
+          it "should change the model data" do
+            expect { subject }.to change { vdc.reload.servers.reload.count }.by(-1)
+          end
+
+          describe "#body" do
+            its(:body) { should == '' }
+          end
+
+          describe "#headers" do
+            its(:headers) { should include("Location") }
+          end
+        end
+
+        context "when there are internet service nodes attached" do
+          before do
+            vdc.public_ips.first.internet_services.create(:name => "#{@mock_vm.name} service", :port => 1231, :protocol => "TCP", :description => "", :enabled => true).tap do |internet_service|
+              internet_service.nodes.create(:name => "#{@mock_vm.name} node", :port => 1231, :description => "", :enabled => true, :ip_address => @mock_vm.ip)
+            end
+          end
+
+          it_should_behave_like "all delete responses"
+          it_should_behave_like "a failed vapp deletion"
+        end
+
+        context "when the VM is powered on" do
+          before do
+            @mock_vm.power_on!
+          end
+
+          it_should_behave_like "all delete responses"
+          it_should_behave_like "a failed vapp deletion"
+        end
+
+        context "when the VM's IP has an rnat set" do
+          before do
+            @mock_vm.network_ip[:rnat] = "1.2.3.4"
+          end
+
+          it_should_behave_like "all delete responses"
+          it_should_behave_like "a failed vapp deletion"
+        end
+      end
+
+      context "with a vapp uri that doesn't exist" do
+        subject { lambda { @vcloud.delete_vapp(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_item_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_item_spec.rb
new file mode 100644
index 0000000..afc6115
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_item_spec.rb
@@ -0,0 +1,62 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_catalog_item) }
+
+    describe "#get_catalog_item" do
+      context "with a valid catalog_item_uri" do
+        before { @catalog_item = @vcloud.get_catalog_item(@vcloud.vdcs.first.catalog.first.href) }
+        subject { @catalog_item }
+        let(:mock_data_catalog_item) { @mock_data.catalog_item_from_href(@catalog_item.body[:href]) }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.catalogItem+xml") }
+
+        describe "#body" do
+          subject { @catalog_item.body }
+
+          it { should have(8).items }
+
+          it_should_behave_like("it has the standard vcloud v0.8 xmlns attributes")   # 3 keys
+
+          its(:name) { should == "Item 0" }
+
+          it { should include(:Entity) }
+          it { should include(:Link) }
+          it { should include(:Property) }
+
+          describe "Entity" do
+            subject { @catalog_item.body[:Entity] }
+            let(:mock_data_catalog_item) { @mock_data.catalog_item_from_href(@catalog_item.body[:href]) }
+
+            it { should have(3).items }
+
+            its(:name) { should == mock_data_catalog_item.name }
+            its(:type) { should == "application/vnd.vmware.vcloud.vAppTemplate+xml" }
+            its(:href) { should == mock_data_catalog_item.vapp_template.href }
+          end
+
+          describe "Link" do
+            subject { @catalog_item.body[:Link] }
+
+            it { should have(4).items }
+
+            its(:rel)  { should == "down" }
+            its(:href) { should == mock_data_catalog_item.customization.href }
+            its(:name) { should == mock_data_catalog_item.customization.name }
+            its(:type) { should == "application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml" }
+          end
+        end
+      end
+
+      context "with a catalog uri that doesn't exist" do
+        subject { lambda { @vcloud.get_catalog(URI.parse('https://www.fakey.com/api/v0.8/vdc/999/catalog')) } }
+
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_spec.rb
new file mode 100644
index 0000000..7831429
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_catalog_spec.rb
@@ -0,0 +1,44 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_catalog) }
+
+    describe "#get_catalog" do
+      context "with a valid vdc catalog_uri" do
+        before { @catalog = @vcloud.get_catalog(@mock_vdc.catalog.href) }
+        subject { @catalog }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.catalog+xml") }
+
+        describe "#body" do
+          subject { @catalog.body }
+
+          it { should have(7).items }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+
+          its(:name) { should == @mock_vdc.catalog.name }
+
+          it { should include(:CatalogItems) }
+
+          describe "CatalogItems" do
+            subject { @catalog.body[:CatalogItems] }
+
+            it { should have(1).items }
+          end
+        end
+      end
+
+      context "with a catalog uri that doesn't exist" do
+        subject { lambda { @vcloud.get_catalog(URI.parse('https://www.fakey.com/api/v0.8/vdc/999/catalog')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_customization_options_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_customization_options_spec.rb
new file mode 100644
index 0000000..9114565
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_customization_options_spec.rb
@@ -0,0 +1,39 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_customization_options) }
+
+    describe "#get_customization_options" do
+      context "with a valid catalog_item customizations uri" do
+        let(:catalog_item) { @vcloud.get_catalog_item(@vcloud.vdcs.first.catalog.first.href) }
+
+        before { @customization_options = @vcloud.get_customization_options(catalog_item.body[:Link][:href]) }
+        subject { @customization_options }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.catalogItemCustomizationParameters+xml") }
+
+        describe "#body" do
+          subject { @customization_options.body }
+
+          it { should have(5).items }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+
+          specify { subject[:CustomizeNetwork].should == "true" }
+          specify { subject[:CustomizePassword].should == "false" }
+        end
+      end
+
+      context "with a catalog uri that doesn't exist" do
+        subject { lambda { @vcloud.get_catalog(URI.parse('https://www.fakey.com/api/v0.8/vdc/999/catalog')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_internet_services_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_internet_services_spec.rb
new file mode 100644
index 0000000..8fe9319
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_internet_services_spec.rb
@@ -0,0 +1,150 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  shared_examples_for "a basic internet service" do
+    specify { service.should be_an_instance_of(Hash) }
+    specify { service.should have(14).attributes }
+    specify { service[:Name].should == mock_service.name }
+    specify { service[:Id].should == mock_service.object_id.to_s }
+    specify { service[:Href].should == mock_service.href }
+
+    specify { service[:PublicIpAddress].should be_an_instance_of(Hash) }
+    specify { service[:PublicIpAddress].should have(3).attributes }
+    specify { service[:PublicIpAddress][:Name].should == mock_ip.name }
+    specify { service[:PublicIpAddress][:Href].should == mock_ip.href }
+    specify { service[:PublicIpAddress][:Id].should == mock_ip.object_id.to_s }
+
+    specify { service[:Port].should == mock_service.port.to_s }
+    specify { service[:Protocol].should == mock_service.protocol }
+    specify { service[:Enabled].should == mock_service.enabled.to_s }
+    specify { service[:Timeout].should == mock_service.timeout.to_s }
+    specify { service[:Description].should == mock_service.description }
+    specify { service[:RedirectURL].should == (mock_service.redirect_url || "") }
+    specify { service[:Monitor].should == "" }
+    specify { service[:IsBackupService].should == "false" }
+    specify { service[:BackupOf].should == "" }
+  end
+
+  shared_examples_for "an internet service without a backup internet service set" do
+    specify { service[:BackupService].should be_nil }
+  end
+
+  shared_examples_for "an internet service with a backup internet service set" do
+    specify { service[:BackupService].should be_an_instance_of(Hash) }
+    specify { service[:BackupService].should include(:Href) }
+    specify { service[:BackupService][:Href].should == @mock_backup_service.href }
+  end
+
+  shared_examples_for "a backup internet service" do
+    specify { service.should be_an_instance_of(Hash) }
+    specify { service.should have(14).attributes }
+    specify { service[:Name].should == mock_service.name }
+    specify { service[:Id].should == mock_service.object_id.to_s }
+    specify { service[:Href].should == mock_service.href }
+
+    specify { service[:PublicIpAddress].should be_nil }
+
+    specify { service[:Port].should == mock_service.port.to_s }
+    specify { service[:Protocol].should == mock_service.protocol }
+    specify { service[:Enabled].should == mock_service.enabled.to_s }
+    specify { service[:Timeout].should == mock_service.timeout.to_s }
+    specify { service[:Description].should == mock_service.description }
+    specify { service[:RedirectURL].should == (mock_service.redirect_url || "") }
+    specify { service[:Monitor].should be_nil }
+    specify { service[:IsBackupService].should == "true" }
+    specify { service[:BackupService].should be_nil }
+    specify { service[:BackupOf].should == "" }
+  end
+
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_internet_services) }
+
+    describe "#get_internet_services" do
+      context "with a valid VDC internet_services_uri" do
+        before do
+          @mock_vdc.internet_service_collection.items[3][:backup_service] = @mock_backup_service
+          @services = @vcloud.get_internet_services(@mock_vdc_service_collection.href)
+        end
+
+        subject { @services }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.internetServicesList+xml") }
+
+        describe "#body" do
+          subject { @services.body }
+
+          it { should have(3).items }
+
+          context "[:InternetService]" do
+            subject { @services.body[:InternetService] }
+
+            it { should have(5).items }
+
+            [0,1,2].each do |idx|
+              let(:service) { subject[idx] }
+              let(:mock_service) { @mock_vdc.internet_service_collection.items[idx] }
+              let(:mock_ip) { mock_service._parent._parent }
+
+              it_should_behave_like "an internet service without a backup internet service set"
+            end
+
+            context "for a service with a backup internet service" do
+              let(:service) { subject[3] }
+              let(:mock_service) { @mock_vdc.internet_service_collection.items[3] }
+              let(:mock_ip) { mock_service._parent._parent }
+
+              it_should_behave_like("an internet service with a backup internet service set")
+            end
+
+            context "for a backup internet service" do
+              let(:service) { subject[4] }
+              let(:mock_service) { @mock_vdc.internet_service_collection.backup_internet_services.first }
+
+              it_should_behave_like("a backup internet service")
+            end
+          end
+        end
+      end
+
+      context "with a valid Public IP uri" do
+        before do
+          @services = @vcloud.get_internet_services(@mock_service_collection.href)
+        end
+        subject { @services }
+
+        it_should_behave_like("all responses")
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.internetServicesList+xml") }
+
+        describe "#body" do
+          subject { @services.body }
+
+          it { should have(3).items }
+
+          context "[:InternetService]" do
+            subject { @services.body[:InternetService] }
+
+            it { should have(2).items }
+
+            [0,1].each do |idx|
+              let(:service) { subject[idx] }
+              let(:mock_service) { @mock_service_collection.items[idx] }
+              let(:mock_ip) { @mock_public_ip }
+
+              it_should_behave_like("an internet service without a backup internet service set")
+            end
+          end
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_internet_services(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ip_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ip_spec.rb
new file mode 100644
index 0000000..08a8c12
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ip_spec.rb
@@ -0,0 +1,40 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_network_ip) }
+
+    describe "#get_network_ip" do
+      context "with a valid ip_uri" do
+        before do
+          @ip = @vcloud.get_network_ip(@mock_network_ip.href)
+        end
+
+        subject { @ip }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.ip+xml") }
+
+        describe "#body" do
+          subject { @ip.body }
+
+          its(:Name) { should == @mock_network_ip.name }
+          its(:Href) { should == @mock_network_ip.href }
+          its(:Id)   { should == @mock_network_ip.object_id.to_s }
+          its(:RnatAddress) { should == @mock_network_ip.rnat }
+          its(:Status) { should == @mock_network_ip.status }
+
+        end
+      end
+
+      context "with an ip_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_network_ip('https://www.fakey.c/piv89') } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ips_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ips_spec.rb
new file mode 100644
index 0000000..ead5d8c
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_ips_spec.rb
@@ -0,0 +1,58 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_network_ips) }
+
+    describe "#get_network_ips" do
+      context "with a valid VDC network ips_uri" do
+        before { @ips = @vcloud.get_network_ips(@mock_network_ip_collection.href) }
+        subject { @ips }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.ipAddressesList+xml") }
+
+        describe "#body" do
+          subject { @ips.body }
+
+          it { should have(1).item }
+
+          context "[:IpAddress]" do
+            subject { @ips.body[:IpAddress] }
+
+            # Note the real TMRK API returns only "assigned" ips currently
+            # This is a bug they've slated to fix in the next release.
+            it { should have(252).addresses }
+
+          end
+
+          context "one we know is assigned" do
+            let(:address) { @ips.body[:IpAddress][0] }
+            specify { address.should have(6).keys }
+            specify { address[:Status].should == "Assigned" }
+            specify { address[:Server].should == "Broom 1" }
+            specify { address[:Name].should == "1.2.3.3" }
+            specify { address[:RnatAddress].should == "99.1.2.3" }
+          end
+
+          context "one we know is not assigned" do
+            let(:address) { @ips.body[:IpAddress][100] }
+            specify { address.should have(5).keys }
+            specify { address[:Status].should == "Available" }
+            specify { address.has_key?(:Server).should be_false }
+            specify { address[:Name].should == "1.2.3.103" }
+            specify { address[:RnatAddress].should == "99.1.2.3" }
+          end
+        end
+      end
+
+      context "with a network ips uri that doesn't exist" do
+        subject { lambda { @vcloud.get_network_ips(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_network_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_spec.rb
new file mode 100644
index 0000000..afcd396
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_network_spec.rb
@@ -0,0 +1,49 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_network) }
+
+    describe "#get_network" do
+      context "with a valid network uri" do
+        before { @network = @vcloud.get_network(@mock_network.href) }
+        subject { @network }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.network+xml") }
+
+        describe "#body" do
+          subject { @network.body }
+
+          it { should have(9).keys }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+
+          its(:type) { should == "application/vnd.vmware.vcloud.network+xml" }
+          its(:Features) { should == @mock_network.features.map {|f| { f[:type] => f[:value] } }.first }
+          its(:href) { should == @mock_network.href }
+          its(:name) { should == @mock_network.name }
+          its(:Configuration) { should == { :Gateway => @mock_network.gateway, :Netmask => @mock_network.netmask } }
+          its(:Link) { should ==
+                         [{:type => "application/xml",
+                            :rel => "down",
+                            :href => @mock_network_ip_collection.href,
+                            :name => "IP Addresses"},
+                           {:type => "application/xml",
+                            :rel => "down",
+                            :href => @mock_network_extensions.href,
+                            :name => @mock_network_extensions.name}]}
+        end
+      end
+
+      context "with a network uri that doesn't exist" do
+        subject { lambda { @vcloud.get_network(URI.parse('https://www.fakey.com/api/v0.8/network/999')) } }
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_node_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_node_spec.rb
new file mode 100644
index 0000000..0626d0f
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_node_spec.rb
@@ -0,0 +1,41 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_node) }
+
+    describe "#get_node" do
+      context "with a valid nodes_uri" do
+        before { @node = @vcloud.get_node(@mock_node.href) }
+        subject { @node }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.nodeService+xml") }
+
+        describe "#body" do
+          subject { @node.body }
+
+          it { should have(9).keys }
+
+          its(:Href) { should == @mock_node.href }
+          its(:Id) { should == @mock_node.object_id.to_s }
+          its(:Name) { should == @mock_node.name }
+          its(:Enabled) { should == @mock_node.enabled.to_s }
+          its(:Port) { should == @mock_node.port.to_s }
+          its(:Description) { should == @mock_node.description }
+          its(:IpAddress) { should == @mock_node.ip_address }
+
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_node(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_nodes_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_nodes_spec.rb
new file mode 100644
index 0000000..d1735ae
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_nodes_spec.rb
@@ -0,0 +1,58 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_nodes) }
+
+    describe "#get_nodes" do
+      context "with a valid nodes_uri" do
+        before { @nodes = @vcloud.get_nodes(@mock_node_collection.href) }
+        subject { @nodes }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.nodeService+xml") }
+
+        describe "#body" do
+          subject { @nodes.body }
+
+          it { should have(3).items }
+
+          describe "[:NodeService]" do
+            subject { @nodes.body[:NodeService] }
+
+            it { should have(@mock_node_collection.items.length).nodes }
+
+            [0,1].each do |idx|
+
+              context "[#{idx}]" do
+                subject { @nodes.body[:NodeService][idx] }
+                let(:mock_node) { @mock_node_collection.items[idx] }
+                let(:keys) { subject.keys.sort_by(&:to_s) }
+                specify { keys.should == [:Description, :Enabled, :Href, :Id, :IpAddress, :Name, :Port] }
+                its(:Href) { should == mock_node.href }
+                its(:Id) { should == mock_node.object_id.to_s }
+                its(:Name) { should == mock_node.name }
+                its(:Enabled) { should == mock_node.enabled.to_s }
+                its(:Port) { should == mock_node.port.to_s }
+                its(:IpAddress) { should == mock_node.ip_address }
+                its(:Description) { should == mock_node.description }
+              end
+
+            end
+
+          end
+
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_nodes(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_organization_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_organization_spec.rb
new file mode 100644
index 0000000..d255653
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_organization_spec.rb
@@ -0,0 +1,52 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_organization) }
+
+    describe "#get_organization" do
+      context "with a valid organization uri" do
+        before { @organization = @vcloud.get_organization(@vcloud.default_organization_uri) }
+        subject { @organization }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.org+xml") }
+
+        describe "#body" do
+          subject { @organization.body }
+
+
+          let(:links) { subject[:Link] }
+
+          it { should have(6).keys }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+          it { should have_key_with_value(:href, @mock_organization.href)}
+          it { should have_key_with_value(:name, @mock_organization.name) }
+          it { should have_key_with_array(:Link, @mock_organization.vdcs.map { |vdc|
+                                                 [{ :type => "application/vnd.vmware.vcloud.vdc+xml",
+                                                    :href => vdc.href,
+                                                    :name => vdc.name,
+                                                    :rel => "down" },
+                                                  { :type => "application/vnd.vmware.vcloud.catalog+xml",
+                                                    :href => vdc.catalog.href,
+                                                    :name => vdc.catalog.name,
+                                                    :rel => "down" },
+                                                  { :type => "application/vnd.vmware.vcloud.tasksList+xml",
+                                                    :href => vdc.task_list.href,
+                                                    :name => vdc.task_list.name,
+                                                    :rel => "down" }]
+                                                  }.flatten) }
+
+        end
+      end
+      context "with an organization uri that doesn't exist" do
+        subject { lambda { @vcloud.get_organization(URI.parse('https://www.fakey.com/api/v0.8/org/999')) } }
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ip_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ip_spec.rb
new file mode 100644
index 0000000..9f2797c
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ip_spec.rb
@@ -0,0 +1,38 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_public_ip) }
+
+    describe "#get_public_ip" do
+      context "with a valid public_ip_uri" do
+        before do
+          @public_ip = @vcloud.get_public_ip(@mock_public_ip.href)
+        end
+
+        subject { @public_ip }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.publicIp+xml") }
+
+        describe "#body" do
+          subject { @public_ip.body }
+
+          its(:Name) { should == @mock_public_ip.name }
+          its(:Href) { should == @mock_public_ip.href }
+          its(:Id)   { should == @mock_public_ip.object_id.to_s }
+
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_public_ip(URI.parse('https://www.fakey.c/piv89')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ips_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ips_spec.rb
new file mode 100644
index 0000000..051a881
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_public_ips_spec.rb
@@ -0,0 +1,52 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_public_ips) }
+
+    describe "#get_public_ips" do
+      context "with a valid public_ips_uri" do
+        before { @public_ips = @vcloud.get_public_ips(@mock_public_ip_collection.href) }
+        subject { @public_ips }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.tmrk.ecloud.publicIpsList+xml") }
+
+        describe "#body" do
+          subject { @public_ips.body }
+
+          it { should have(1).item }
+
+          describe "[:PublicIPAddress]" do
+            subject { @public_ips.body[:PublicIPAddress] }
+
+            it { should have(@mock_public_ip_collection.items.length).addresses }
+
+            [0,1,2].each do |idx|
+
+              context "[#{idx}]" do
+                subject { @public_ips.body[:PublicIPAddress][idx] }
+                let(:public_ip) { @mock_public_ip_collection.items[idx] }
+                its(:Href) { should == public_ip.href }
+                its(:Id) { should == public_ip.object_id.to_s }
+                its(:Name) { should == public_ip.name }
+              end
+
+            end
+
+          end
+
+        end
+      end
+
+      context "with a public_ips_uri that doesn't exist" do
+        subject { lambda { @vcloud.get_public_ips(URI.parse('https://www.fakey.c/piv8vc99')) } }
+
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_vapp_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_vapp_spec.rb
new file mode 100644
index 0000000..4c03767
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_vapp_spec.rb
@@ -0,0 +1,125 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_vapp) }
+
+    describe "#get_vapp" do
+      context "with a valid vapp_uri" do
+        before { @vapp = @vcloud.get_vapp(@mock_vm.href) }
+        subject { @vapp }
+        let(:vapp_id) { @vapp.body[:href].split("/").last }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.vApp+xml") }
+
+        describe "#body" do
+          subject { @vapp.body }
+
+          specify { subject.keys.sort_by(&:to_s).should == [:Link,                         :NetworkConnectionSection,
+                                                            :OperatingSystemSection,       :VirtualHardwareSection,
+                                                            :href,                         :name,
+                                                            :size,                         :status,
+                                                            :type,                         :xmlns,
+                                                            :xmlns_xsd,                    :xmlns_xsi] }
+
+          it_should_behave_like("it has the standard vcloud v0.8 xmlns attributes")   # 3 keys
+
+          its(:href)   { should == @mock_vm.href }
+          its(:name)   { should == @mock_vm.name }
+          its(:status) { should == @mock_vm.status.to_s }
+          its(:size)   { should == (@mock_vm.disks.inject(0) {|s, d| s += d[:size].to_i } * 1024).to_s }
+
+          describe "Link" do
+            subject { @vapp.body[:Link] }
+
+            its(:rel)  { should == "up" }
+            its(:type) { should == "application/vnd.vmware.vcloud.vdc+xml" }
+            its(:href) { should == @mock_vdc.href }
+          end
+
+          describe "NetworkConnectionSection" do
+            subject { @vapp.body[:NetworkConnectionSection] }
+
+            it { should include(:NetworkConnection) }
+
+            describe "NetworkConnection" do
+              subject { @vapp.body[:NetworkConnectionSection][:NetworkConnection] }
+
+              its(:IpAddress) { should == @mock_vm.ip }
+            end
+          end
+
+          describe "OperatingSystemSection" do
+            subject { @vapp.body[:OperatingSystemSection] }
+
+            its(:Info) { should == "The kind of installed guest operating system" }
+            its(:Description) { should == "Red Hat Enterprise Linux 5 (64-bit)" }
+          end
+
+          describe "VirtualHardwareSection" do
+            subject { @vapp.body[:VirtualHardwareSection] }
+
+            specify { subject.keys.sort_by(&:to_s).should == [:Info, :Item, :System, :xmlns] }
+
+            describe "Item" do
+              subject { @vapp.body[:VirtualHardwareSection][:Item] }
+
+              it { should have(5).items }
+
+              specify { subject.map {|i| i[:ResourceType] }.uniq.sort.should == %w(3 4 6 17).sort }
+
+              describe "CPU" do
+                subject { @vapp.body[:VirtualHardwareSection][:Item].detect {|i| i[:ResourceType] == "3" } }
+
+                its(:VirtualQuantity) { should == @mock_vm.cpus.to_s }
+              end
+
+              describe "memory" do
+                subject { @vapp.body[:VirtualHardwareSection][:Item].detect {|i| i[:ResourceType] == "4" } }
+
+                its(:VirtualQuantity) { should == @mock_vm.memory.to_s }
+              end
+
+              describe "SCSI controller" do
+                subject { @vapp.body[:VirtualHardwareSection][:Item].detect {|i| i[:ResourceType] == "6" } }
+
+                its(:Address) { should == "0" }
+              end
+
+              describe "Hard Disks" do
+                subject { @vapp.body[:VirtualHardwareSection][:Item].find_all {|i| i[:ResourceType] == "17" } }
+
+                it { should have(2).disks }
+
+                describe "#1" do
+                  subject { @vapp.body[:VirtualHardwareSection][:Item].find_all {|i| i[:ResourceType] == "17" }[0] }
+
+                  its(:AddressOnParent) { should == "0" }
+                  its(:VirtualQuantity) { should == (1024 * @mock_vm.disks[0][:size].to_i).to_s }
+                  its(:HostResource)    { should == (1024 * @mock_vm.disks[0][:size].to_i).to_s }
+                end
+
+                describe "#2" do
+                  subject { @vapp.body[:VirtualHardwareSection][:Item].find_all {|i| i[:ResourceType] == "17" }[1] }
+
+                  its(:AddressOnParent) { should == "1" }
+                  its(:VirtualQuantity) { should == (1024 * @mock_vm.disks[1][:size].to_i).to_s }
+                  its(:HostResource)    { should == (1024 * @mock_vm.disks[1][:size].to_i).to_s }
+                end
+              end
+            end
+          end
+        end
+      end
+
+      context "with a vapp uri that doesn't exist" do
+        subject { lambda { @vcloud.get_vapp(URI.parse('https://www.fakey.com/api/v0.8/vApp/99999')) } }
+
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_vdc_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_vdc_spec.rb
new file mode 100644
index 0000000..4f99380
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_vdc_spec.rb
@@ -0,0 +1,112 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:get_vdc) }
+
+    describe "#get_vdc" do
+      context "with a valid vdc uri" do
+        before { @vdc = @vcloud.get_vdc(URI.parse(@mock_vdc.href)) }
+        subject { @vdc }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/vnd.vmware.vcloud.vdc+xml") }
+
+        describe "#body" do
+          subject { @vdc.body }
+
+          it { should have(11).items }
+
+          it_should_behave_like("it has the standard vcloud v0.8 xmlns attributes")   # 3 keys
+
+          its(:href) { should == @mock_vdc.href }
+          its(:name) { should == @mock_vdc.name }
+
+          its(:Description) { should == "" }
+          its(:StorageCapacity) { should == {:Units => "bytes * 10^9", :Allocated => @mock_vdc.storage_allocated.to_s, :Used => @mock_vdc.storage_used.to_s } }
+          its(:ComputeCapacity) { should == {:InstantiatedVmsQuota => { :Limit => "-1", :Used => "-1" },
+                                             :Memory => { :Units => "bytes * 2^20", :Allocated => @mock_vdc.memory_allocated.to_s },
+                                             :Cpu => { :Units => "hz * 10^6", :Allocated => @mock_vdc.cpu_allocated.to_s },
+                                             :DeployedVmsQuota => { :Limit => "-1", :Used => "-1" } } }
+
+          its(:Link) { should have(4).links }
+
+          describe "link 0" do
+            subject { @vdc.body[:Link][0] }
+            it { should have(4).attributes }
+            its(:type) { should == "application/vnd.vmware.vcloud.catalog+xml" }
+            its(:rel)  { should == "down" }
+            its(:href) { should == @mock_vdc.catalog.href }
+            its(:name) { should == @mock_vdc.catalog.name }
+          end
+          describe "link 1" do
+            subject { @vdc.body[:Link][1] }
+            it { should have(4).attributes }
+            its(:type) { should == "application/vnd.tmrk.ecloud.publicIpsList+xml" }
+            its(:rel)  { should == "down" }
+            its(:href) { should == @mock_vdc.public_ip_collection.href }
+            its(:name) { should == @mock_vdc.public_ip_collection.name }
+          end
+          describe "link 2" do
+            subject { @vdc.body[:Link][2] }
+            it { should have(4).attributes }
+            its(:type) { should == "application/vnd.tmrk.ecloud.internetServicesList+xml" }
+            its(:rel)  { should == "down" }
+            its(:href) { should == @mock_vdc.internet_service_collection.href }
+            its(:name) { should == @mock_vdc.internet_service_collection.name }
+          end
+          describe "link 3" do
+            subject { @vdc.body[:Link][3] }
+            it { should have(4).attributes }
+            its(:type) { should == "application/vnd.tmrk.ecloud.firewallAclsList+xml" }
+            its(:rel)  { should == "down" }
+            its(:href) { should == @mock_vdc.firewall_acls.href }
+            its(:name) { should == @mock_vdc.firewall_acls.name }
+          end
+
+          let(:resource_entities) { subject[:ResourceEntities][:ResourceEntity] }
+          specify { resource_entities.should have(@mock_vdc.virtual_machines.length).vapps  }
+
+          describe "[:ResourceEntities][:ResourceEntity]" do
+            context "[0]" do
+              subject { @vdc.body[:ResourceEntities][:ResourceEntity][0] }
+              it { should be_a_vapp_link_to(@mock_vdc.virtual_machines[0]) }
+            end
+            context "[1]" do
+              subject { @vdc.body[:ResourceEntities][:ResourceEntity][1] }
+              it { should be_a_vapp_link_to(@mock_vdc.virtual_machines[1]) }
+            end
+            context "[2]" do
+              subject { @vdc.body[:ResourceEntities][:ResourceEntity][2] }
+              it { should be_a_vapp_link_to(@mock_vdc.virtual_machines[2]) }
+            end
+          end
+
+          its(:name)            { should == @mock_vdc[:name] }
+
+          let(:available_networks) { subject[:AvailableNetworks][:Network] }
+          specify { available_networks.should have(2).networks }
+
+          describe "[:AvailableNetworks][:Network]" do
+            context "[0]" do
+              subject { @vdc.body[:AvailableNetworks][:Network][0] }
+              it { should be_a_network_link_to(@mock_vdc.networks[0]) }
+            end
+            context "[1]" do
+              subject { @vdc.body[:AvailableNetworks][:Network][1] }
+              it { should be_a_network_link_to(@mock_vdc.networks[1]) }
+            end
+          end
+        end
+      end
+
+      context "with a vdc uri that doesn't exist" do
+        subject { lambda { @vcloud.get_vdc(URI.parse('https://www.fakey.com/api/v0.8/vdc/999')) } }
+
+        it_should_behave_like("a request for a resource that doesn't exist")
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/get_versions_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/get_versions_spec.rb
new file mode 100644
index 0000000..14f0104
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/get_versions_spec.rb
@@ -0,0 +1,57 @@
+require 'ecloud/spec_helper'
+
+shared_examples_for "real or mock get_versions requests" do
+  if Fog.mocking?
+
+    subject { @vcloud }
+
+    it { should respond_to(:get_versions) }
+
+    describe "#get_versions" do
+      subject { @vcloud.get_versions( @vcloud.versions_uri ) }
+
+      it_should_behave_like "all responses"
+
+      describe "body" do
+        subject { @vcloud.get_versions( @vcloud.versions_uri ).body }
+
+        it { should have(4).keys }
+        it_should_behave_like "it has the standard xmlns attributes"   # 2 keys
+
+        its(:xmlns) { should == "http://www.vmware.com/vcloud/versions" }
+
+        its(:VersionInfo) { should be_either_a_hash_or_array }
+
+        describe ":VersionInfo" do
+          subject { arrayify(@vcloud.get_versions( @vcloud.versions_uri ).body[:VersionInfo]) }
+
+          specify {
+            subject.each do |version_info|
+              version_info.should include(:LoginUrl)
+              version_info[:LoginUrl].should be_a_url
+              version_info.should include(:Version)
+              version_info[:Version].should be_an_instance_of(String)
+            end
+          }
+        end
+      end
+    end
+
+  end
+end
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+
+    it_should_behave_like "real or mock get_versions requests"
+
+    describe "body" do
+      subject { @vcloud.get_versions( @vcloud.versions_uri ).body }
+      its(:VersionInfo) { should == { :LoginUrl => @mock_version.login_url , :Version => @mock_version.version } }
+    end
+  end
+else
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    it_should_behave_like "real or mock get_versions requests"
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/instantiate_vapp_template_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/instantiate_vapp_template_spec.rb
new file mode 100644
index 0000000..bb1d702
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/instantiate_vapp_template_spec.rb
@@ -0,0 +1,95 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe "Fog::Ecloud, initialized w/ the TMRK Ecloud module", :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:instantiate_vapp_template) }
+
+    describe "#instantiate_vapp_template" do
+      let(:vdc) { @vcloud.vdcs.first }
+      let(:mock_vdc) { @mock_vdc }
+
+      let(:catalog_item) { vdc.catalog.first }
+      let(:mock_catalog_item) { @vcloud.mock_data.catalog_item_from_href(catalog_item.href) }
+
+      let(:new_vapp_data) do
+        {
+          :name => "foobar",
+          :network_uri => @mock_network.href,
+          :row => "test row",
+          :group => "test group",
+          :memory => 1024,
+          :cpus => 2,
+          :vdc_uri => @mock_vdc.href
+        }
+      end
+
+      let(:added_mock_data) { mock_vdc.virtual_machines.last }
+
+      context "with a valid data" do
+        let(:template_instantiation) { @vcloud.instantiate_vapp_template(catalog_item.href, new_vapp_data) }
+        subject { template_instantiation }
+
+        it_should_behave_like "all responses"
+        it { should have_headers_denoting_a_content_type_of("application/xml") }
+
+        it "updates the mock data properly" do
+          expect { subject }.to change { mock_vdc.virtual_machines.size }.by(1)
+        end
+
+        describe "added mock data" do
+          before  { template_instantiation }
+          subject { added_mock_data }
+
+          it { should be_an_instance_of(Fog::Ecloud::MockDataClasses::MockVirtualMachine) }
+
+          its(:name) { should == new_vapp_data[:name] }
+          its(:memory) { should == new_vapp_data[:memory] }
+          its(:cpus) { should == new_vapp_data[:cpus] }
+          # WHAT
+          specify { subject._parent.should == mock_vdc }
+          specify { subject.status.should == 2 }
+          specify { subject.disks.should == mock_catalog_item.disks }
+          # its(:_parent) { should == mock_vdc }
+          #its(:status) { should == 2 }
+          #its(:disks) { should == mock_catalog_item.disks }
+        end
+
+        describe "server based on added mock data" do
+          before  { template_instantiation }
+          subject { vdc.servers.reload.detect {|s| s.href == added_mock_data.href }.reload }
+
+          its(:name) { should == new_vapp_data[:name] }
+        end
+
+        describe "#body" do
+          subject { template_instantiation.body }
+
+          it { should have(9).items }
+
+          it_should_behave_like("it has the standard vcloud v0.8 xmlns attributes")   # 3 keys
+
+          its(:href) { should == added_mock_data.href }
+          its(:type) { should == "application/vnd.vmware.vcloud.vApp+xml" }
+          its(:name) { should == new_vapp_data[:name] }
+          its(:status) { should == "0" }
+          its(:size) { should == "4" }
+
+          it { should include(:Link) }
+
+          describe "Link" do
+            subject { template_instantiation.body[:Link] }
+
+            it { should have(3).keys }
+
+            its(:rel)  { should == "up" }
+            its(:type) { should == "application/vnd.vmware.vcloud.vdc+xml" }
+            # WHAT
+            its(:href) { blah = vdc.href; should == blah }
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/login_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/login_spec.rb
new file mode 100644
index 0000000..15c00de
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/login_spec.rb
@@ -0,0 +1,10 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it_should_behave_like "all login requests"
+  end
+else
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/power_off_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/power_off_spec.rb
new file mode 100644
index 0000000..3f7a9b4
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/power_off_spec.rb
@@ -0,0 +1,34 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:power_off) }
+
+    describe :power_off, :type => :vcloud_request do
+      context "with a valid vapp uri" do
+        before { @mock_vm.power_on!; @power_off = @vcloud.power_off(@mock_vm.href(:power_off)) }
+        subject { @power_off }
+
+        it_should_behave_like "all responses"
+        #it { should have_headers_denoting_a_content_type_of "application/vnd.vmware.vcloud.network+xml" }
+
+        specify { @mock_vm.status.should == 2 }
+
+        describe :body do
+          subject { @power_off.body }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+        end
+      end
+
+      context "with a vapp uri that doesn't exist" do
+        subject { lambda { @vcloud.power_off(URI.parse('https://www.fakey.com/api/v0.8/vapp/9999')) } }
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/requests/power_on_spec.rb b/vendor/fog-0.8.2/spec/ecloud/requests/power_on_spec.rb
new file mode 100644
index 0000000..e51d033
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/requests/power_on_spec.rb
@@ -0,0 +1,34 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should respond_to(:power_on) }
+
+    describe :power_on, :type => :vcloud_request do
+      context "with a valid vapp uri" do
+        before { @mock_vm.power_off!; @power_on = @vcloud.power_on(@mock_vm.href(:power_on)) }
+        subject { @power_on }
+
+        it_should_behave_like "all responses"
+        #it { should have_headers_denoting_a_content_type_of "application/vnd.vmware.vcloud.network+xml" }
+
+        specify { @mock_vm.status.should == 4 }
+
+        describe :body do
+          subject { @power_on.body }
+
+          it_should_behave_like "it has the standard vcloud v0.8 xmlns attributes"   # 3 keys
+        end
+      end
+
+      context "with a vapp uri that doesn't exist" do
+        subject { lambda { @vcloud.power_on(URI.parse('https://www.fakey.com/api/v0.8/vapp/9999')) } }
+        it_should_behave_like "a request for a resource that doesn't exist"
+      end
+    end
+  end
+else
+end
+
diff --git a/vendor/fog-0.8.2/spec/ecloud/spec_helper.rb b/vendor/fog-0.8.2/spec/ecloud/spec_helper.rb
new file mode 100644
index 0000000..f5aab6c
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/spec_helper.rb
@@ -0,0 +1,387 @@
+require 'spec'
+require 'pp'
+
+require 'fog'
+require 'fog/bin'
+require 'fog/bin/ecloud'
+
+module Spec
+  module Example
+    module Subject
+      module ExampleGroupMethods
+        def its(attribute, &block)
+          describe(attribute) do
+            define_method(:subject) { s = super(); s.is_a?(Hash) ? s[attribute] : s.send(attribute) }
+            it(&block)
+          end
+        end
+      end
+    end
+  end
+end
+
+#Initialize this to a known seed
+srand 1234
+
+Fog.mock! if ENV['FOG_MOCK']
+
+def arrayify(item)
+  item.is_a?(Array) ? item : [ item ]
+end
+
+def ecloud_disabled_default_monitor
+  {:url_send_string=>nil, :receive_string=>nil, :response_timeout=>2, :retries=>3, :is_enabled=>"true", :down_time=>30, :type=>"Disabled", :http_headers=>nil, :interval=>5, :downtime=>nil}
+end
+
+shared_examples_for "all responses" do
+  it { should be_an_instance_of(Excon::Response) }
+  it { should respond_to(:body) }
+  it { should respond_to(:headers) }
+  it { should have_at_least(1).body }
+  it { should have_at_least(0).headers }
+  its(:body) { should be_an_instance_of(Hash) }
+  its(:headers) { should be_an_instance_of(Hash) }
+end
+
+shared_examples_for "all delete responses" do
+  it { should be_an_instance_of(Excon::Response) }
+  it { should respond_to(:body) }
+  it { should respond_to(:headers) }
+  its(:headers) { should be_an_instance_of(Hash) }
+end
+
+shared_examples_for "it has a Content-Type header" do
+  its(:headers) { should include("Content-Type") }
+end
+
+shared_examples_for "all rel=down vcloud links" do
+  it { should be_an_instance_of(Struct::VcloudLink) }
+  specify { subject.rel.should == "down" }
+end
+
+shared_examples_for "all vcloud links w/o a rel" do
+  it { should be_an_instance_of(Struct::VcloudLink) }
+  specify { subject.rel.should == nil }
+end
+
+shared_examples_for "all vcloud catalog links" do
+  specify { subject.type.should == "application/vnd.vmware.vcloud.catalog+xml" }
+end
+
+shared_examples_for "all tmrk ecloud publicIpList links" do
+  specify { subject.type.should == "application/vnd.tmrk.ecloud.publicIpsList+xml" }
+end
+
+shared_examples_for "all tmrk ecloud firewallAclList links" do
+  specify { subject.type.should == "application/vnd.tmrk.ecloud.firewallAclsList+xml" }
+end
+
+shared_examples_for "all tmrk ecloud internetServicesList links" do
+  specify { subject.type.should == "application/vnd.tmrk.ecloud.internetServicesList+xml" }
+end
+
+shared_examples_for "all vcloud application/xml types" do
+  specify { subject.type.should == "application/xml" }
+end
+
+shared_examples_for "a vapp type" do
+  specify { subject.type.should == "application/vnd.vmware.vcloud.vApp+xml" }
+end
+
+shared_examples_for "all vcloud network types" do
+  specify { subject.type.should == "application/vnd.vmware.vcloud.network+xml" }
+end
+
+shared_examples_for "all login requests" do
+
+  it { should respond_to(:login) }
+
+  describe "#login" do
+    before { @login = @vcloud.login }
+    subject { @login }
+
+    it_should_behave_like("all responses")
+
+    its(:headers) { should include("Set-Cookie") }
+
+    describe "#body" do
+      subject { @login.body }
+
+      it { should have(4).items }
+      it_should_behave_like("it has the standard vcloud v0.8 xmlns attributes")   # 3 keys
+      it { should include(:Org) }
+
+      describe ":Org" do
+        subject { arrayify(@login.body[:Org]) }
+
+        specify do
+          subject.each do |org|
+            org.should include(:type)
+            org[:type].should be_of_type("application/vnd.vmware.vcloud.org+xml")
+            org.should include(:name)
+            org[:name].should be_an_instance_of(String)
+            org.should include(:href)
+            org[:href].should(be_a_url)
+          end
+        end
+      end
+    end
+  end
+end
+
+shared_examples_for "it has a vcloud v0.8 xmlns" do
+  its(:xmlns) { should == 'http://www.vmware.com/vcloud/v0.8' }
+end
+
+shared_examples_for "it has the proper xmlns_xsi" do
+  its(:xmlns_xsi) { should == "http://www.w3.org/2001/XMLSchema-instance" }
+end
+
+shared_examples_for "it has the proper xmlns_xsd" do
+  its(:xmlns_xsd) { should == "http://www.w3.org/2001/XMLSchema" }
+end
+
+shared_examples_for "it has the standard xmlns attributes" do
+  it_should_behave_like("it has the proper xmlns_xsi")
+  it_should_behave_like("it has the proper xmlns_xsd")
+end
+
+shared_examples_for "it has the standard vcloud v0.8 xmlns attributes" do
+  it_should_behave_like("it has a vcloud v0.8 xmlns")
+  it_should_behave_like("it has the standard xmlns attributes")
+end
+
+shared_examples_for "a request for a resource that doesn't exist" do
+  it { should raise_error(Excon::Errors::Unauthorized) }
+end
+
+shared_examples_for "a vdc catalog link" do
+  it_should_behave_like "all rel=down vcloud links"
+  it_should_behave_like "all vcloud catalog links"
+  its(:href) { should == URI.parse(@mock_vdc[:href] + "/catalog") }
+end
+
+shared_examples_for "a tmrk network link" do
+  it_should_behave_like("all vcloud links w/o a rel")
+  it_should_behave_like("all vcloud network types")
+end
+
+shared_examples_for "the mocked tmrk network links" do
+  it { should have(2).networks }
+
+  describe "[0]" do
+    subject { @vdc.body.networks[0] }
+    it_should_behave_like "a tmrk network link"
+    its(:href) { should == URI.parse(@mock_vdc[:networks][0][:href]) }
+    its(:name) { should == @mock_vdc[:networks][0][:name] }
+  end
+
+  describe "[1]" do
+    subject { @vdc.body.networks[1] }
+    it_should_behave_like "a tmrk network link"
+    its(:href) { should == URI.parse(@mock_vdc[:networks][1][:href]) }
+    its(:name) { should == @mock_vdc[:networks][1][:name] }
+  end
+end
+
+shared_examples_for "the mocked tmrk resource entity links" do
+  it { should have(3).resource_entities }
+
+  describe "[0]" do
+    subject { @vdc.body.resource_entities[0] }
+    it_should_behave_like("a vapp type")
+    it_should_behave_like("all vcloud links w/o a rel")
+    its(:href) { should == URI.parse(@mock_vdc[:vms][0][:href]) }
+    its(:name) { should == @mock_vdc[:vms][0][:name] }
+  end
+  describe "[1]" do
+    subject { @vdc.body.resource_entities[1] }
+    it_should_behave_like("a vapp type")
+    it_should_behave_like("all vcloud links w/o a rel")
+    its(:href) { should == URI.parse(@mock_vdc[:vms][1][:href]) }
+    its(:name) { should == @mock_vdc[:vms][1][:name] }
+  end
+  describe "[2]" do
+    subject { @vdc.body.resource_entities[2] }
+    it_should_behave_like("a vapp type")
+    it_should_behave_like("all vcloud links w/o a rel")
+    its(:href) { should == URI.parse(@mock_vdc[:vms][2][:href]) }
+    its(:name) { should == @mock_vdc[:vms][2][:name] }
+  end
+end
+
+Spec::Example::ExampleGroupFactory.register(:mock_vcloud_request, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:mock_vcloud_model, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:mock_tmrk_ecloud_request, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:mock_tmrk_ecloud_model, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:vcloud_request, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:tmrk_ecloud_request, Class.new(Spec::Example::ExampleGroup))
+Spec::Example::ExampleGroupFactory.register(:tmrk_vcloud_request, Class.new(Spec::Example::ExampleGroup))
+
+def setup_generic_mock_data
+  @mock_version = @mock_data.versions.first
+  @mock_organization = @mock_data.organizations.first
+  @mock_vdc = @mock_organization.vdcs.first
+  @mock_vm = @mock_vdc.virtual_machines.first
+  @mock_network = @mock_vdc.networks.first
+end
+
+def setup_ecloud_mock_data
+  @base_url = Fog::Ecloud::Compute::Mock.base_url
+  @mock_data = Fog::Ecloud::Compute::Mock.data
+  setup_generic_mock_data
+  @mock_vdc_service_collection = @mock_vdc.internet_service_collection
+  @mock_public_ip_collection = @mock_vdc.public_ip_collection
+  @mock_public_ip = @mock_public_ip_collection.items.first
+  @mock_service_collection = @mock_public_ip.internet_service_collection
+  @mock_service = @mock_service_collection.items.first
+  @mock_backup_service = @mock_vdc_service_collection.backup_internet_services.first
+  @mock_node_collection = @mock_service.node_collection
+  @mock_node = @mock_node_collection.items.first
+  @mock_catalog = @mock_vdc.catalog
+  @mock_catalog_item = @mock_catalog.items.first
+  @mock_network_ip_collection = @mock_network.ip_collection
+  @mock_network_ip = @mock_network_ip_collection.items.values.first
+  @mock_network_extensions = @mock_network.extensions
+end
+
+def setup_vcloud_mock_data
+  @base_url = Fog::Ecloud::Compute::Mock.base_url
+  @mock_data = Fog::Ecloud::Compute::Mock.data
+  setup_generic_mock_data
+end
+
+Spec::Runner.configure do |config|
+  config.after(:all) do
+    Fog::Ecloud::Compute::Mock.reset
+  end
+
+  config.before(:each, :type => :vcloud_request) do
+    @vcloud = Fog::Ecloud::Compute.new(Fog.credentials[:vcloud][:ecloud])
+  end
+
+  config.before(:each, :type => :mock_tmrk_ecloud_request) do
+    Fog::Ecloud::Compute::Mock.reset
+    setup_ecloud_mock_data
+    @vcloud = Fog::Ecloud::Compute.new(:ecloud_username => "foo", :ecloud_password => "bar", :ecloud_versions_uri => "http://fakey.com/api/versions")
+  end
+  config.before(:each, :type => :mock_tmrk_ecloud_model) do
+    Fog::Ecloud::Compute::Mock.reset
+    setup_ecloud_mock_data
+    @vcloud = Fog::Ecloud::Compute.new(:ecloud_username => "foo", :ecloud_password => "bar", :ecloud_versions_uri => "http://fakey.com/api/versions")
+  end
+end
+
+Spec::Matchers.define :have_only_these_attributes do |expected|
+  match do |actual|
+    attributes = actual.instance_variable_get('@attributes')
+    attributes.all? { |attribute| expected.include?(attribute) } && ( expected.length == attributes.length )
+  end
+
+  failure_message_for_should do |actual|
+    msg = "Expected: [#{expected.map{|e| ":#{e}"}.join(", ")}]\n"
+    msg += "Got: [#{actual.instance_variable_get('@attributes').map{|a| ":#{a}"}.join(", ")}]"
+    msg
+  end
+end
+
+Spec::Matchers.define :have_identity do |expected|
+  match do |actual|
+    actual.instance_variable_get('@identity').should == expected
+  end
+
+  failure_message_for_should do |actual|
+    "Expected: '#{expected}', but got: '#{actual.instance_variable_get('@identity')}'"
+  end
+end
+
+Spec::Matchers.define :have_members_of_the_right_model do
+  match do |actual|
+    actual.all? { |member| member.is_a?(actual.model) }
+  end
+end
+
+Spec::Matchers.define :have_key_with_value do |expected_key, expected_value|
+  match do |actual|
+    actual.has_key?(expected_key) && actual[expected_key] == expected_value
+  end
+end
+
+Spec::Matchers.define :have_key_with_array do |expected_key, expected_array|
+  match do |actual|
+    actual[expected_key].all? { |item| expected_array.include?(item) } && actual[expected_key].length == expected_array.length
+  end
+  failure_message_for_should do |actual|
+    "Items not found in array:\n#{expected_array.select { |expected_item| !actual[expected_key].include?(expected_item) }.map { |item| item.inspect }.join("\n")}\n"  +
+    "Original items:\n#{actual[expected_key].map { |item| item.inspect }.join("\n") }\n"+
+    "Length Difference: #{expected_array.length - actual[expected_key].length}"
+  end
+end
+
+Spec::Matchers.define :have_headers_denoting_a_content_type_of do |expected|
+  match do |actual|
+    actual.headers["Content-Type"] == expected
+  end
+end
+
+Spec::Matchers.define :have_keys_with_values do |expected|
+  match do |actual|
+    actual.each_pair.all? do |key, value|
+      expected.keys.include?(key) && expected[key] == value
+    end
+  end
+end
+
+Spec::Matchers.define :be_a_vapp_link_to do |expected|
+  match do |actual|
+    actual.is_a?(Hash) and
+    actual[:type] == "application/vnd.vmware.vcloud.vApp+xml" and
+    actual[:href] == expected.href and
+    actual[:name] == expected.name
+  end
+end
+
+Spec::Matchers.define :be_a_network_link_to do |expected|
+  match do |actual|
+    actual.is_a?(Hash) and
+    actual[:type] == "application/vnd.vmware.vcloud.network+xml" and
+    actual[:href] == expected.href and
+    actual[:name] == expected.name
+  end
+end
+
+Spec::Matchers.define :have_all_attributes_be_nil do
+  match do |actual|
+    actual.class.attributes.all? { |attribute| actual.send(attribute.to_sym) == nil }
+  end
+end
+
+Spec::Matchers.define :be_a_url do
+  match do |actual|
+    actual.match(/^(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?$/ix)
+  end
+end
+
+Spec::Matchers.define :be_either_a_hash_or_array  do
+  match do |actual|
+    actual.is_a?(Hash) || actual.is_a?(Array)
+  end
+end
+
+Spec::Matchers.define :be_a_known_vmware_type do
+  match do |actual|
+    ["application/vnd.vmware.vcloud.org+xml"].include?(actual)
+  end
+end
+
+Spec::Matchers.define :be_of_type do |type|
+  match do |actual|
+    actual == type ||
+      if actual.is_a?(Hash) && actual[:type]
+        actual[:type] == type
+      end ||
+      if actual.respond_to(:type)
+        actual.type == type
+      end
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/ecloud/vcloud_spec.rb b/vendor/fog-0.8.2/spec/ecloud/vcloud_spec.rb
new file mode 100644
index 0000000..275bb95
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/ecloud/vcloud_spec.rb
@@ -0,0 +1,18 @@
+require 'ecloud/spec_helper'
+
+if Fog.mocking?
+  describe Fog::Ecloud, :type => :mock_tmrk_ecloud_request do
+    subject { @vcloud }
+
+    it { should be_an_instance_of(Fog::Ecloud::Compute::Mock) }
+
+    it { should respond_to(:default_organization_uri) }
+
+    it { should respond_to(:supported_versions) }
+
+    it { should have_at_least(1).supported_versions }
+
+    its(:default_organization_uri) { should == @mock_organization.href }
+
+  end
+end
diff --git a/vendor/fog-0.8.2/spec/spec_helper.rb b/vendor/fog-0.8.2/spec/spec_helper.rb
new file mode 100644
index 0000000..1dcc0f3
--- /dev/null
+++ b/vendor/fog-0.8.2/spec/spec_helper.rb
@@ -0,0 +1,8 @@
+require 'spec'
+require 'open-uri'
+require 'fog'
+require 'fog/bin'
+
+if ENV["FOG_MOCK"] == "true"
+  Fog.mock!
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/cloud_formation/stack_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/cloud_formation/stack_tests.rb
new file mode 100644
index 0000000..c917197
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/cloud_formation/stack_tests.rb
@@ -0,0 +1,143 @@
+Shindo.tests('AWS::CloudFormation | stack requests', ['aws', 'cloudformation']) do
+
+  @validate_template_format = {
+    'Description' => String,
+    'Parameters'  => [
+      {
+        'DefaultValue'  => Fog::Nullable::String,
+        'Description'   => String,
+        'NoEcho'        => Fog::Boolean,
+        'ParameterKey'  => String,
+      }
+    ],
+    'RequestId'   => String
+  }
+
+  @create_stack_format = {
+    'RequestId' => String,
+    'StackId'   => String
+  }
+
+  @get_template_format = {
+    'RequestId'     => String,
+    'TemplateBody'  => String
+  }
+
+  @describe_stacks_format = {
+    'RequestId' => String,
+    'Stacks'    => [
+      {
+        'CreationTime'    => Time,
+        'DisableRollback' => Fog::Boolean,
+        'Outputs'         => [
+          {
+            'OutputKey'   => String,
+            'OutputValue' => String
+          }
+        ],
+        'Parameters'      => [
+          {
+            'ParameterKey'    => String,
+            'ParameterValue'  => String,
+          }
+        ],
+        'StackId'         => String,
+        'StackName'       => String,
+        'StackStatus'     => String,
+      }
+    ]
+  }
+
+  @describe_stack_events_format = {
+    'RequestId'   => String,
+    'StackEvents' => [
+      {
+        'EventId'               => String,
+        'LogicalResourceId'     => String,
+        'PhysicalResourceId'    => String,
+        'ResourceProperties'    => String,
+        'ResourceStatus'        => String,
+        'ResourceStatusReason'  => Fog::Nullable::String,
+        'ResourceType'          => String,
+        'StackId'               => String,
+        'StackName'             => String,
+        'Timestamp'             => Time
+      }
+    ]
+  }
+
+  @describe_stack_resources_format = {
+    'RequestId'       => String,
+    'StackResources'  => [
+      {
+        'LogicalResourceId'     => String,
+        'PhysicalResourceId'    => String,
+        'ResourceStatus'        => String,
+        'ResourceType'          => String,
+        'StackId'               => String,
+        'StackName'             => String,
+        'Timestamp'             => Time
+      }
+    ]
+  }
+
+  tests('success') do
+
+    unless Fog.mocking?
+      @stack_name = 'fogstack' << Time.now.to_i.to_s
+      @keypair = AWS[:compute].key_pairs.create(:name => 'cloudformation')
+      @template_url = 'https://s3.amazonaws.com/cloudformation-templates-us-east-1/EC2InstanceSample-1.0.0.template'
+    end
+
+    tests("validate_template('TemplateURL' => '#{@template_url}')").formats(@validate_template_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].validate_template('TemplateURL' => @template_url).body
+    end
+
+    tests("create_stack('#{@stack_name}', 'TemplateURL' => '#{@template_url}', Parameters => {'KeyName' => 'cloudformation'})").formats(@create_stack_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].create_stack(
+        @stack_name,
+        'TemplateURL' => @template_url,
+        'Parameters'  => {'KeyName' => 'cloudformation'}
+      ).body
+    end
+
+    tests("get_template('#{@stack_name})").formats(@get_template_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].get_template(@stack_name).body
+    end
+
+    tests("describe_stacks").formats(@describe_stacks_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].describe_stacks.body
+    end
+
+    sleep(1) # avoid throttling
+
+    tests("describe_stack_events('#{@stack_name}')").formats(@describe_stack_events_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].describe_stack_events(@stack_name).body
+    end
+
+    tests("describe_stack_resources('StackName' => '#{@stack_name}')").formats(@describe_stack_resources_format) do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].describe_stack_resources('StackName' => @stack_name).body
+    end
+
+    tests("delete_stack('#{@stack_name}')").succeeds do
+      pending if Fog.mocking?
+      AWS[:cloud_formation].delete_stack(@stack_name)
+    end
+
+    unless Fog.mocking?
+      @keypair.destroy
+    end
+
+  end
+
+  tests('failure') do
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/elb/helper.rb b/vendor/fog-0.8.2/tests/aws/requests/elb/helper.rb
new file mode 100644
index 0000000..6c24c4c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/elb/helper.rb
@@ -0,0 +1,44 @@
+class AWS
+  module ELB
+    module Formats
+
+      BASIC = {
+        'ResponseMetadata' => {'RequestId' => String}
+      }
+
+      LOAD_BALANCER = {
+        "CreatedTime" => Time,
+        "ListenerDescriptions" => Array,
+        "HealthCheck" => {"HealthyThreshold" => Integer, "Timeout" => Integer, "UnhealthyThreshold" => Integer, "Interval" => Integer, "Target" => String},
+        "Policies" => {"LBCookieStickinessPolicies" => Array, "AppCookieStickinessPolicies" => Array},
+        "AvailabilityZones" => Array,
+        "DNSName" => String,
+        "LoadBalancerName"=> String,
+        "Instances"=> Array
+      }
+
+      CREATE_LOAD_BALANCER = BASIC.merge({
+        'CreateLoadBalancerResult' => { 'DNSName' => String }
+      })
+
+      DESCRIBE_LOAD_BALANCERS = BASIC.merge({
+        'DescribeLoadBalancersResult' => {'LoadBalancerDescriptions' => [LOAD_BALANCER]}
+      })
+
+      CONFIGURE_HEALTH_CHECK = BASIC.merge({
+        'ConfigureHealthCheckResult' => {'HealthCheck' => {
+        'Target' => String,
+        'Interval' => Integer,
+        'Timeout' => Integer,
+        'UnhealthyThreshold' => Integer,
+        'HealthyThreshold' => Integer
+      }}
+      })
+
+      DELETE_LOAD_BALANCER = BASIC.merge({
+        'DeleteLoadBalancerResult' =>  NilClass
+      })
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/elb/load_balancer_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/elb/load_balancer_tests.rb
new file mode 100644
index 0000000..e720447
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/elb/load_balancer_tests.rb
@@ -0,0 +1,82 @@
+Shindo.tests('AWS::ELB | load_balancer_tests', ['aws', 'elb']) do
+  @load_balancer_id = 'fog-test-elb'
+
+  tests('success') do
+    pending if Fog.mocking?
+
+    tests("#create_load_balancer").formats(AWS::ELB::Formats::CREATE_LOAD_BALANCER) do
+      zones = ['us-east-1a']
+      listeners = [{'LoadBalancerPort' => 80, 'InstancePort' => 80, 'Protocol' => 'http'}]
+      AWS[:elb].create_load_balancer(zones, @load_balancer_id, listeners).body
+    end
+
+    tests("#describe_load_balancers").formats(AWS::ELB::Formats::DESCRIBE_LOAD_BALANCERS) do
+      AWS[:elb].describe_load_balancers.body
+    end
+
+    tests('#describe_load_balancers with bad lb') do
+      raises(Fog::AWS::ELB::NotFound) { AWS[:elb].describe_load_balancers('none-such-lb') }
+    end
+
+    tests("#configure_health_check").formats(AWS::ELB::Formats::CONFIGURE_HEALTH_CHECK) do
+      health_check = {
+        'Target' => 'HTTP:80/index.html',
+        'Interval' => 10,
+        'Timeout' => 5,
+        'UnhealthyThreshold' => 2,
+        'HealthyThreshold' => 3
+      }
+
+      AWS[:elb].configure_health_check(@load_balancer_id, health_check).body
+    end
+
+    tests("#create_app_cookie_stickiness_policy").formats(AWS::ELB::Formats::BASIC) do
+      cookie, policy = 'fog-app-cookie', 'fog-app-policy'
+      AWS[:elb].create_app_cookie_stickiness_policy(@load_balancer_id, policy, cookie).body
+    end
+
+    tests("#create_lb_cookie_stickiness_policy with expiry").formats(AWS::ELB::Formats::BASIC) do
+      policy = 'fog-lb-expiry'
+      expiry = 300
+      AWS[:elb].create_lb_cookie_stickiness_policy(@load_balancer_id, policy, expiry).body
+    end
+
+    tests("#create_lb_cookie_stickiness_policy without expiry").formats(AWS::ELB::Formats::BASIC) do
+      policy = 'fog-lb-no-expiry'
+      AWS[:elb].create_lb_cookie_stickiness_policy(@load_balancer_id, policy).body
+    end
+
+    tests("#delete_load_balancer_policy").formats(AWS::ELB::Formats::BASIC) do
+      policy = 'fog-lb-no-expiry'
+      AWS[:elb].delete_load_balancer_policy(@load_balancer_id, policy).body
+    end
+
+    tests("#create_load_balancer_listeners").formats(AWS::ELB::Formats::BASIC) do
+      listeners = [
+        {'Protocol' => 'tcp', 'LoadBalancerPort' => 443, 'InstancePort' => 443},
+        {'Protocol' => 'HTTP', 'LoadBalancerPort' => 80, 'InstancePort' => 80}
+      ]
+      AWS[:elb].create_load_balancer_listeners(@load_balancer_id, listeners).body
+    end
+
+    tests("#set_load_balancer_policies_of_listener adds policy").formats(AWS::ELB::Formats::BASIC) do
+      port, policies = 80, ['fog-lb-expiry']
+      body = AWS[:elb].set_load_balancer_policies_of_listener(@load_balancer_id, port, policies).body
+    end
+
+    tests("#set_load_balancer_policies_of_listener removes policy").formats(AWS::ELB::Formats::BASIC) do
+      port = 80
+      body = AWS[:elb].set_load_balancer_policies_of_listener(@load_balancer_id, port, []).body
+    end
+
+
+    tests("#delete_load_balancer_listeners").formats(AWS::ELB::Formats::BASIC) do
+      ports = [80, 443]
+      AWS[:elb].delete_load_balancer_listeners(@load_balancer_id, ports).body
+    end
+
+    tests("#delete_load_balancer").formats(AWS::ELB::Formats::DELETE_LOAD_BALANCER) do
+      AWS[:elb].delete_load_balancer(@load_balancer_id).body
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/elb/model_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/elb/model_tests.rb
new file mode 100644
index 0000000..792721c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/elb/model_tests.rb
@@ -0,0 +1,187 @@
+Shindo.tests('AWS::ELB | models', ['aws', 'elb']) do
+
+
+  tests('success') do
+    pending if Fog.mocking?
+
+    tests('load_balancers') do
+      tests('getting a missing elb') do
+        returns(nil) { AWS[:elb].load_balancers.get('no-such-elb') }
+      end
+    end
+
+    elb = nil
+    elb_id = 'fog-test'
+
+    tests('create') do
+      elb = AWS[:elb].load_balancers.create(:id => elb_id)
+      tests("dns names is set").returns(true) { elb.dns_name.is_a?(String) }
+      tests("created_at is set").returns(true) { (Time.now-10..Time.now).include? elb.created_at }
+      tests("policies is empty").returns([]) { elb.policies }
+    end
+
+    tests('all') do
+      elb_ids = AWS[:elb].load_balancers.all.map{|e| e.id}
+      tests("contains elb").returns(true) { elb_ids.include? elb_id }
+    end
+
+    tests('get') do
+      elb2 = AWS[:elb].load_balancers.get(elb_id)
+      tests('ids match').returns(elb_id) { elb2.id }
+    end
+
+    tests('createing a duplicate elb') do
+      raises(Fog::AWS::ELB::IdentifierTaken) do
+        AWS[:elb].load_balancers.create(:id => elb_id, :availability_zones => ['us-east-1d'])
+      end
+    end
+
+    tests('registering an invalid instance') do
+      raises(Fog::AWS::ELB::InvalidInstance) { elb.register_instances('i-00000000') }
+    end
+
+    tests('deregistering an invalid instance') do
+      raises(Fog::AWS::ELB::InvalidInstance) { elb.deregister_instances('i-00000000') }
+    end
+
+    server = AWS[:compute].servers.create
+    tests('register instance') do
+      begin
+        elb.register_instances(server.id)
+      rescue Fog::AWS::ELB::InvalidInstance
+        # It may take a moment for a newly created instances to be visible to ELB requests
+        raise if @retried_registered_instance
+        @retried_registered_instance = true
+        sleep 1
+        retry
+      end
+
+      returns([server.id]) { elb.instances }
+    end
+
+    tests('instance_health') do
+      returns('OutOfService') do
+        elb.instance_health.detect{|hash| hash['InstanceId'] == server.id}['State']
+      end
+
+      returns([server.id]) { elb.instances_out_of_service }
+    end
+
+    tests('deregister instance') do
+      elb.deregister_instances(server.id)
+      returns([]) { elb.instances }
+    end
+    server.destroy
+
+    tests('disable_availability_zones') do
+      elb.disable_availability_zones(%w{us-east-1c us-east-1d})
+      returns(%w{us-east-1a us-east-1b}) { elb.availability_zones.sort }
+    end
+
+    tests('enable_availability_zones') do
+      elb.enable_availability_zones(%w{us-east-1c us-east-1d})
+      returns(%w{us-east-1a us-east-1b us-east-1c us-east-1d}) { elb.availability_zones.sort }
+    end
+
+    tests('default health check') do
+      default_health_check = {
+        "HealthyThreshold"=>10,
+        "Timeout"=>5,
+        "UnhealthyThreshold"=>2,
+        "Interval"=>30,
+        "Target"=>"TCP:80"
+      }
+      returns(default_health_check) { elb.health_check }
+    end
+
+    tests('configure_health_check') do
+      new_health_check = {
+        "HealthyThreshold"=>5,
+        "Timeout"=>10,
+        "UnhealthyThreshold"=>3,
+        "Interval"=>15,
+        "Target"=>"HTTP:80/index.html"
+      }
+      elb.configure_health_check(new_health_check)
+      returns(new_health_check) { elb.health_check }
+    end
+
+    tests('listeners') do
+      default_listener_description = [{"Listener"=>{"InstancePort"=>80, "Protocol"=>"HTTP", "LoadBalancerPort"=>80}, "PolicyNames"=>[]}]
+      tests('default') do
+        returns(1) { elb.listeners.size }
+
+        listener = elb.listeners.first
+        returns([80,80,'HTTP', []]) { [listener.instance_port, listener.lb_port, listener.protocol, listener.policy_names] }
+
+      end
+
+      tests('#get') do
+        returns(80) { elb.listeners.get(80).lb_port }
+      end
+
+      tests('create') do
+        new_listener = { 'InstancePort' => 443, 'LoadBalancerPort' => 443, 'Protocol' => 'TCP'}
+        elb.listeners.create(:instance_port => 443, :lb_port => 443, :protocol => 'TCP')
+        returns(2) { elb.listeners.size }
+        returns(443) { elb.listeners.get(443).lb_port }
+      end
+
+      tests('destroy') do
+        elb.listeners.get(443).destroy
+        returns(nil) { elb.listeners.get(443) }
+      end
+    end
+
+    tests('policies') do
+      app_policy_id = 'my-app-policy'
+
+      tests 'are empty' do
+        returns([]) { elb.policies.to_a }
+      end
+
+      tests('#all') do
+        returns([]) { elb.policies.all.to_a }
+      end
+
+      tests('create app policy') do
+        elb.policies.create(:id => app_policy_id, :cookie => 'my-app-cookie', :cookie_stickiness => :app)
+        returns(app_policy_id) { elb.policies.first.id }
+      end
+
+      tests('get policy') do
+        returns(app_policy_id) { elb.policies.get(app_policy_id).id }
+      end
+
+      tests('destroy app policy') do
+        elb.policies.first.destroy
+        returns([]) { elb.policies.to_a }
+      end
+
+      lb_policy_id = 'my-lb-policy'
+      tests('create lb policy') do
+        elb.policies.create(:id => lb_policy_id, :expiration => 600, :cookie_stickiness => :lb)
+        returns(lb_policy_id) { elb.policies.first.id }
+      end
+
+      tests('setting a listener policy') do
+        elb.set_listener_policy(80, lb_policy_id)
+        returns([lb_policy_id]) { elb.listeners.get(80).policy_names }
+      end
+
+      tests('unsetting a listener policy') do
+        elb.unset_listener_policy(80)
+        returns([]) { elb.listeners.get(80).policy_names }
+      end
+
+      tests('a malformed policy') do
+        raises(ArgumentError) { elb.policies.create(:id => 'foo', :cookie_stickiness => 'invalid stickiness') }
+      end
+    end
+
+    tests('destroy') do
+      elb.destroy
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/access_key_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/access_key_tests.rb
new file mode 100644
index 0000000..3bf5976
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/access_key_tests.rb
@@ -0,0 +1,60 @@
+Shindo.tests('AWS::IAM | access key requests', ['aws']) do
+
+  unless Fog.mocking?
+    AWS[:iam].create_user('fog_access_key_tests')
+  end
+
+  tests('success') do
+
+    @access_key_format = {
+      'AccessKey' => {
+        'AccessKeyId'     => String,
+        'UserName'        => String,
+        'SecretAccessKey' => String,
+        'Status'          => String
+      },
+      'RequestId' => String
+    }
+
+    tests("#create_access_key('UserName' => 'fog_access_key_tests')").formats(@access_key_format) do
+      pending if Fog.mocking?
+      data = AWS[:iam].create_access_key('UserName' => 'fog_access_key_tests').body
+      @access_key_id = data['AccessKey']['AccessKeyId']
+      data
+    end
+
+    @access_keys_format = {
+      'AccessKeys' => [{
+        'AccessKeyId' => String,
+        'Status'      => String
+      }],
+      'IsTruncated' => Fog::Boolean,
+      'RequestId'   => String
+    }
+
+    tests("#list_access_keys('Username' => 'fog_access_key_tests')").formats(@access_keys_format) do
+      pending if Fog.mocking?
+      AWS[:iam].list_access_keys('UserName' => 'fog_access_key_tests').body
+    end
+
+    tests("#update_access_key('#{@access_key_id}', 'Inactive', 'UserName' => 'fog_access_key_tests')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].update_access_key(@access_key_id, 'Inactive', 'UserName' => 'fog_access_key_tests').body
+    end
+
+    tests("#delete_access_key('#{@access_key_id}', 'UserName' => 'fog_access_key_tests)").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_access_key(@access_key_id, 'UserName' => 'fog_access_key_tests').body
+    end
+
+  end
+
+  tests('failure') do
+    test('failing conditions')
+  end
+
+  unless Fog.mocking?
+    AWS[:iam].delete_user('fog_access_key_tests')
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/group_policy_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/group_policy_tests.rb
new file mode 100644
index 0000000..b265a56
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/group_policy_tests.rb
@@ -0,0 +1,42 @@
+Shindo.tests('AWS::IAM | group policy requests', ['aws']) do
+
+  unless Fog.mocking?
+    AWS[:iam].create_group('fog_group_policy_tests')
+  end
+
+  tests('success') do
+
+    @policy = {"Statement" => [{"Effect" => "Allow", "Action" => "*", "Resource" => "*"}]}
+
+    tests("#put_group_policy('fog_group_policy_tests', 'fog_policy', #{@policy.inspect})").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].put_group_policy('fog_group_policy_tests', 'fog_policy', @policy).body
+    end
+
+    @group_policies_format = {
+      'IsTruncated' => Fog::Boolean,
+      'PolicyNames' => [String],
+      'RequestId'   => String
+    }
+
+    tests("list_group_policies('fog_group_policy_tests')").formats(@group_policies_format) do
+      pending if Fog.mocking?
+      AWS[:iam].list_group_policies('fog_group_policy_tests').body
+    end
+
+    tests("#delete_group_policy('fog_group_policy_tests', 'fog_policy')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_group_policy('fog_group_policy_tests', 'fog_policy').body
+    end
+
+  end
+
+  tests('failure') do
+    test('failing conditions')
+  end
+
+  unless Fog.mocking?
+    AWS[:iam].delete_group('fog_group_policy_tests')
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/group_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/group_tests.rb
new file mode 100644
index 0000000..9fda645
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/group_tests.rb
@@ -0,0 +1,47 @@
+Shindo.tests('AWS::IAM | group requests', ['aws']) do
+
+  tests('success') do
+
+    @group_format = {
+      'Group' => {
+        'Arn'       => String,
+        'GroupId'   => String,
+        'GroupName' => String,
+        'Path'      => String
+      },
+      'RequestId' => String
+    }
+
+    tests("#create_group('fog_group')").formats(@group_format) do
+      pending if Fog.mocking?
+      AWS[:iam].create_group('fog_group').body
+    end
+
+    @groups_format = {
+      'Groups' => [{
+        'Arn'       => String,
+        'GroupId'   => String,
+        'GroupName' => String,
+        'Path'      => String
+      }],
+      'IsTruncated' => Fog::Boolean,
+      'RequestId'   => String
+    }
+
+    tests("#list_groups").formats(@groups_format) do
+      pending if Fog.mocking?
+      AWS[:iam].list_groups.body
+    end
+
+    tests("#delete_group('fog_group')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_group('fog_group').body
+    end
+
+  end
+
+  tests('failure') do
+    test('failing conditions')
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/helper.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/helper.rb
new file mode 100644
index 0000000..aeb31a9
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/helper.rb
@@ -0,0 +1,56 @@
+class AWS
+
+  module IAM
+    # A self-signed test keypair. Generated using the command:
+    # openssl req -new -newkey rsa:1024 -days 3650 -nodes -x509 -keyout server-private.key -out server-public.crt
+    # NB: Amazon returns an error on extraneous linebreaks
+    SERVER_CERT_PUBLIC_KEY = %{-----BEGIN CERTIFICATE-----
+MIIDQzCCAqygAwIBAgIJAJaZ8wH+19AtMA0GCSqGSIb3DQEBBQUAMHUxCzAJBgNV
+BAYTAlVTMREwDwYDVQQIEwhOZXcgWW9yazERMA8GA1UEBxMITmV3IFlvcmsxHzAd
+BgNVBAoTFkZvZyBUZXN0IFNuYWtlb2lsIENlcnQxHzAdBgNVBAsTFkZvZyBUZXN0
+IFNuYWtlb2lsIENlcnQwHhcNMTEwNTA3MTc0MDU5WhcNMjEwNTA0MTc0MDU5WjB1
+MQswCQYDVQQGEwJVUzERMA8GA1UECBMITmV3IFlvcmsxETAPBgNVBAcTCE5ldyBZ
+b3JrMR8wHQYDVQQKExZGb2cgVGVzdCBTbmFrZW9pbCBDZXJ0MR8wHQYDVQQLExZG
+b2cgVGVzdCBTbmFrZW9pbCBDZXJ0MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
+gQC0CR76sovjdmpWRmEaf8XaG+nGe7czhpdLKkau2b16VtSjkPctxPL5U4vaMxQU
+boLPr+9oL+9fSYN31VzDD4hyaeGoeI5fhnGeqk71kq5uHONBOQUMbZbBQ8PVd9Sd
+k+y9JJ6E5fC+GhLL5I+y2DK7syBzyymq1Wi6rPp1XXF7AQIDAQABo4HaMIHXMB0G
+A1UdDgQWBBRfqBkpU/jEV324748fq6GJM80iVTCBpwYDVR0jBIGfMIGcgBRfqBkp
+U/jEV324748fq6GJM80iVaF5pHcwdTELMAkGA1UEBhMCVVMxETAPBgNVBAgTCE5l
+dyBZb3JrMREwDwYDVQQHEwhOZXcgWW9yazEfMB0GA1UEChMWRm9nIFRlc3QgU25h
+a2VvaWwgQ2VydDEfMB0GA1UECxMWRm9nIFRlc3QgU25ha2VvaWwgQ2VydIIJAJaZ
+8wH+19AtMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAUV6NDdLHKNhl
+ACtzLycIhlMTmDr0xBeIBx3lpgw2K0+4oefMS8Z17eeZPeNodxnz56juJm81BZwt
+DF3qnnPyArLFx0HLB7wQdm9xYVIqQuLO+V6GRuOd+uSX//aDLDZhwbERf35hoyto
+Jfk4gX/qwuRFNy0vjQeTzdvhB1igG/w=
+-----END CERTIFICATE-----
+}
+
+    SERVER_CERT_PRIVATE_KEY = %{-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQC0CR76sovjdmpWRmEaf8XaG+nGe7czhpdLKkau2b16VtSjkPct
+xPL5U4vaMxQUboLPr+9oL+9fSYN31VzDD4hyaeGoeI5fhnGeqk71kq5uHONBOQUM
+bZbBQ8PVd9Sdk+y9JJ6E5fC+GhLL5I+y2DK7syBzyymq1Wi6rPp1XXF7AQIDAQAB
+AoGANjjRBbwkeXs+h4Fm2W5GDmx9ufOkt3X/tvmilCKr+F6SaDjO2RAKBaFt62ea
+0pR9/UMFnaFiPJaNa9fsuirBcwId+RizruEp+7FGziM9mC5kcE7WKZrXgGGnLtqg
+4x5twVLArgp0ji7TA18q/74uTrI4az8H5iTY4n29ORlLmmkCQQDsGMuLEgGHgN5Y
+1c9ax1DT/rUXKxnqsIrijRkgbiTncHAArFJ88c3yykWqGvYnSFwMS8DSWiPyPaAI
+nNNlb/fPAkEAwzZ4CfvJ+OlE++rTPH9jemC89dnxC7EFGuWJmwdadnev8EYguvve
+cdGdGttD7QsZKpcz5mDngOUghbVm8vBELwJAMHfOoVgq9DRicP5DuTEdyMeLSZxR
+j7p6aJPqypuR++k7NQgrTvcc/nDD6G3shpf2PZf3l7dllb9M8TewtixMRQJBAIdX
+c0AQtoYBTJePxiYyd8i32ypkkK83ar+sFoxKO9jYwD1IkZax2xZ0aoTdMindQPR7
+Yjs+QiLmOHcbPqX+GHcCQERsSn0RjzKmKirDntseMB59BB/cEN32+gMDVsZuCfb+
+fOy2ZavFl13afnhbh2/AjKeDhnb19x/uXjF7JCUtwpA=
+-----END RSA PRIVATE KEY-----
+}
+
+    module Formats
+
+      BASIC = {
+        'RequestId' => String
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/login_profile_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/login_profile_tests.rb
new file mode 100644
index 0000000..a351395
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/login_profile_tests.rb
@@ -0,0 +1,64 @@
+Shindo.tests('AWS::IAM | user requests', ['aws']) do
+
+  unless Fog.mocking?
+    AWS[:iam].create_user('fog_user')    
+  end
+
+
+  tests('success') do
+    @login_profile_format = {
+      'LoginProfile' => {
+        'UserName'  => String,
+        'CreateDate'  => Time
+        
+      },
+      'RequestId' => String
+    }
+    
+    tests("#create_login_profile('fog_user')").formats(@login_profile_format) do
+      pending if Fog.mocking?
+      AWS[:iam].create_login_profile('fog_user', 'somepassword').body
+    end
+
+    tests("#get_login_profile('fog_user')").formats(@login_profile_format) do
+      pending if Fog.mocking?
+      result = AWS[:iam].get_login_profile('fog_user').body
+      returns('fog_user') {result['LoginProfile']['UserName']}
+      result
+    end
+
+    tests("#update_login_profile('fog_user')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      begin
+        AWS[:iam].update_login_profile('fog_user', 'otherpassword').body
+      rescue Excon::Errors::Conflict #profile cannot be updated or deleted until it has finished creating; api provides no way of telling whether creation process complete
+        sleep 5
+        retry
+      end
+    end
+
+    tests("#delete_login_profile('fog_user')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_login_profile('fog_user').body
+    end
+
+    tests("#get_login_profile('fog_user')") do
+      pending if Fog.mocking?
+      raises(Excon::Errors::NotFound) {AWS[:iam].get_login_profile('fog_user')}
+    end
+
+  end
+
+  tests('failure') do
+    tests('get login profile for non existing user') do
+      pending if Fog.mocking?
+      raises(Excon::Errors::NotFound) { AWS[:iam].get_login_profile('idontexist')}
+      raises(Excon::Errors::NotFound) { AWS[:iam].delete_login_profile('fog_user')}
+    end
+  end
+
+
+  unless Fog.mocking?
+    AWS[:iam].delete_user('fog_user')
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/server_certificate_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/server_certificate_tests.rb
new file mode 100644
index 0000000..b5aae9b
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/server_certificate_tests.rb
@@ -0,0 +1,36 @@
+Shindo.tests('AWS::IAM | server certificate requests', ['aws']) do
+
+  pending if Fog.mocking?
+
+  @key_name = 'fog-test'
+
+  @certificate_format = {
+  'Arn' => String,
+  'Path' => String,
+  'ServerCertificateId' => String,
+  'ServerCertificateName' => String,
+  'UploadDate' => Time
+}
+  @upload_format = {
+    'Certificate' => @certificate_format,
+    'RequestId' => String
+  }
+  tests('#upload_server_certificate').formats(@upload_format) do
+    public_key  = AWS::IAM::SERVER_CERT_PUBLIC_KEY
+    private_key = AWS::IAM::SERVER_CERT_PRIVATE_KEY
+    AWS[:iam].upload_server_certificate(public_key, private_key, @key_name).body
+  end
+
+  @list_format = { 'Certificates' => [@certificate_format] }
+  tests('#list_server_certificates').formats(@list_format) do
+    result = AWS[:iam].list_server_certificates.body
+    tests('includes key name') do
+      returns(true) { result['Certificates'].any?{|c| c['ServerCertificateName'] == @key_name} }
+    end
+    result
+  end
+
+  tests('#delete_server_certificate').formats(AWS::IAM::Formats::BASIC) do
+    AWS[:iam].delete_server_certificate(@key_name).body
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/user_policy_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/user_policy_tests.rb
new file mode 100644
index 0000000..bbc34ca
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/user_policy_tests.rb
@@ -0,0 +1,42 @@
+Shindo.tests('AWS::IAM | user policy requests', ['aws']) do
+
+  unless Fog.mocking?
+    AWS[:iam].create_user('fog_user_policy_tests')
+  end
+
+  tests('success') do
+
+    @policy = {"Statement" => [{"Effect" => "Allow", "Action" => "*", "Resource" => "*"}]}
+
+    tests("#put_user_policy('fog_user_policy_tests', 'fog_policy', #{@policy.inspect})").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].put_user_policy('fog_user_policy_tests', 'fog_policy', @policy).body
+    end
+
+    @user_policies_format = {
+      'IsTruncated' => Fog::Boolean,
+      'PolicyNames' => [String],
+      'RequestId'   => String
+    }
+
+    tests("list_user_policies('fog_user_policy_tests')").formats(@user_policies_format) do
+      pending if Fog.mocking?
+      AWS[:iam].list_user_policies('fog_user_policy_tests').body
+    end
+
+    tests("#delete_user_policy('fog_user_policy_tests', 'fog_policy')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_user_policy('fog_user_policy_tests', 'fog_policy').body
+    end
+
+  end
+
+  tests('failure') do
+    test('failing conditions')
+  end
+
+  unless Fog.mocking?
+    AWS[:iam].delete_user('fog_user_policy_tests')
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/iam/user_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/iam/user_tests.rb
new file mode 100644
index 0000000..d3d8cce
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/iam/user_tests.rb
@@ -0,0 +1,65 @@
+Shindo.tests('AWS::IAM | user requests', ['aws']) do
+
+  unless Fog.mocking?
+    AWS[:iam].create_group('fog_user_tests')
+  end
+
+  tests('success') do
+
+    @user_format = {
+      'User' => {
+        'Arn'       => String,
+        'Path'      => String,
+        'UserId'    => String,
+        'UserName'  => String
+      },
+      'RequestId' => String
+    }
+
+    tests("#create_user('fog_user')").formats(@user_format) do
+      pending if Fog.mocking?
+      AWS[:iam].create_user('fog_user').body
+    end
+
+    @users_format = {
+      'Users' => [{
+        'Arn'       => String,
+        'Path'      => String,
+        'UserId'    => String,
+        'UserName'  => String
+      }],
+      'IsTruncated' => Fog::Boolean,
+      'RequestId'   => String
+    }
+
+    tests("#list_users").formats(@users_format) do
+      pending if Fog.mocking?
+      AWS[:iam].list_users.body
+    end
+
+    tests("#add_user_to_group('fog_user_tests', 'fog_user')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].add_user_to_group('fog_user_tests', 'fog_user').body
+    end
+
+    tests("#remove_user_from_group('fog_user_tests', 'fog_user')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].remove_user_from_group('fog_user_tests', 'fog_user').body
+    end
+
+    tests("#delete_user('fog_user')").formats(AWS::IAM::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:iam].delete_user('fog_user').body
+    end
+
+  end
+
+  tests('failure') do
+    test('failing conditions')
+  end
+
+  unless Fog.mocking?
+    AWS[:iam].delete_group('fog_user_tests')
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/rds/helper.rb b/vendor/fog-0.8.2/tests/aws/requests/rds/helper.rb
new file mode 100644
index 0000000..2cdd7ca
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/rds/helper.rb
@@ -0,0 +1,169 @@
+class AWS
+
+  module RDS
+
+    module Formats
+
+      BASIC = {
+        'ResponseMetadata' => {'RequestId' => String}
+      }
+      
+      DB_PARAMETER_GROUP = {
+          'DBParameterGroupFamily' => String,
+          'DBParameterGroupName'=> String,
+          'Description'=> String
+      }
+      CREATE_DB_PARAMETER_GROUP = {
+        'ResponseMetadata' => {'RequestId' => String},
+        'CreateDBParameterGroupResult' => {          
+          'DBParameterGroup' => DB_PARAMETER_GROUP
+        }
+      }
+
+      DESCRIBE_DB_PARAMETER_GROUP = {
+        'ResponseMetadata' => {'RequestId' => String},
+        'DescribeDBParameterGroupsResult' =>{
+          'DBParameterGroups' => [DB_PARAMETER_GROUP]
+        }
+      }
+      
+      MODIFY_PARAMETER_GROUP = BASIC.merge({
+        'ModifyDBParameterGroupResult' => {
+          'DBParameterGroupName' => String
+        }
+      })
+      
+      DB_PARAMETER = {
+        'ParameterValue' => Fog::Nullable::String,
+        'DataType' => String,
+        'AllowedValues' => Fog::Nullable::String,
+        'Source' => String,
+        'IsModifiable' => Fog::Boolean,
+        'Description' => String,
+        'ParameterName' => String,
+        'ApplyType' => String,
+      }
+      DESCRIBE_DB_PARAMETERS = BASIC.merge({
+        'DescribeDBParametersResult' => {
+          'Marker' => Fog::Nullable::String,
+          'Parameters' => [DB_PARAMETER]
+        }
+      
+      })
+      
+      
+      SNAPSHOT={
+        'AllocatedStorage' => Integer,
+        'AvailabilityZone' => String,
+        'DBInstanceIdentifier' => String,
+        'DBSnapshotIdentifier' => String,
+        'EngineVersion' => String,
+        'Engine' => String,
+        'InstanceCreateTime' => Time,
+        'MasterUsername' => String,
+        'Port' => Integer,
+        'SnapshotCreateTime' => Fog::Nullable::Time,
+        'Status' => String
+      }
+      INSTANCE = {
+        'AllocatedStorage' => Integer,
+        'AutoMinorVersionUpgrade' => Fog::Boolean,
+        'AvailabilityZone' => Fog::Nullable::String,
+        'BackupRetentionPeriod' => Integer,
+        'DBInstanceClass' => String,
+        'DBInstanceIdentifier' => String,
+        'DBInstanceStatus' => String,
+        'DBName' => Fog::Nullable::String,
+        'DBParameterGroups' => [{
+            'ParameterApplyStatus' => String,
+            'DBParameterGroupName' => String
+          }],
+        'DBSecurityGroups' => [{
+            'Status' => String,
+            'DBSecurityGroupName' => String
+          }],
+        'Endpoint' => {
+          'Address' => Fog::Nullable::String,
+          'Port' => Fog::Nullable::Integer
+        },
+        'Engine' => String,
+        'EngineVersion' => String,
+        'InstanceCreateTime' => Fog::Nullable::Time,
+        'LatestRestorableTime' => Fog::Nullable::Time,
+        'MasterUsername' => String,
+        'MultiAZ' => Fog::Boolean,
+        'PendingModifiedValues' => {
+          'BackupRetentionPeriod' => Fog::Nullable::Integer,
+          'DBInstanceClass'       => Fog::Nullable::String,
+          'EngineVersion'         => Fog::Nullable::String,
+          'MasterUserPassword'    => Fog::Nullable::String,
+          'MultiAZ'               => Fog::Nullable::String,
+          'AllocatedStorage'      => Fog::Nullable::Integer,
+          'Port'                  => Fog::Nullable::Integer
+        },
+        'PreferredBackupWindow'=> String,
+        'PreferredMaintenanceWindow'=> String,
+        'ReadReplicaDBInstanceIdentifiers'=> [String],
+        'ReadReplicaSourceDBInstanceIdentifier'=> Fog::Nullable::String
+      }
+      
+      CREATE_DB_INSTANCE = BASIC.merge({
+        'CreateDBInstanceResult' => {
+          'DBInstance' => INSTANCE
+        }
+      })
+
+      DESCRIBE_DB_INSTANCES = BASIC.merge({
+        'DescribeDBInstancesResult' =>  {
+          'Marker' => Fog::Nullable::String,
+          'DBInstances' => [INSTANCE]
+        }
+      })
+
+      MODIFY_DB_INSTANCE = BASIC.merge({
+        'ModifyDBInstanceResult' => {
+          'DBInstance' => INSTANCE
+        }
+      })
+
+      DELETE_DB_INSTANCE = BASIC.merge({
+        'DeleteDBInstanceResult' => {
+          'DBInstance' => INSTANCE
+        }
+      })
+      
+      REBOOT_DB_INSTANCE = BASIC.merge({
+        'RebootDBInstanceResult' => {
+          'DBInstance' => INSTANCE
+        }
+      })
+      
+      CREATE_READ_REPLICA = BASIC.merge({
+        'CreateDBInstanceReadReplicaResult' => {
+          'DBInstance' => INSTANCE
+        }
+      })
+
+      CREATE_DB_SNAPSHOT = BASIC.merge({
+        'CreateDBSnapshotResult' => {
+          'DBSnapshot' => SNAPSHOT
+        }
+      })
+
+      DESCRIBE_DB_SNAPSHOTS = BASIC.merge({
+        'DescribeDBSnapshotsResult' => {
+          'Marker' => Fog::Nullable::String,
+          'DBSnapshots' => [SNAPSHOT]
+        }
+      })
+      DELETE_DB_SNAPSHOT = BASIC.merge({
+        'DeleteDBSnapshotResult' => {
+          'DBSnapshot' => SNAPSHOT
+        }
+      })
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/rds/instance_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/rds/instance_tests.rb
new file mode 100644
index 0000000..c3e6aaa
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/rds/instance_tests.rb
@@ -0,0 +1,128 @@
+Shindo.tests('AWS::RDS | instance requests', ['aws', 'rds']) do
+  # random_differentiator
+  # Useful when rapidly re-running tests, so we don't have to wait
+  # serveral minutes for deleted servers to disappear
+  suffix = rand(65536).to_s(16)
+
+  @db_instance_id       = "fog-test-#{suffix}"
+  @db_replica_id        = "fog-replica-#{suffix}"
+  @db_snapshot_id       = "fog-snapshot"
+  @db_final_snapshot_id = "fog-final-snapshot"
+
+  tests('success') do
+    pending if Fog.mocking?
+
+    tests("#create_db_instance").formats(AWS::RDS::Formats::CREATE_DB_INSTANCE) do
+      result = AWS[:rds].create_db_instance(@db_instance_id, 'AllocatedStorage' => 5,
+                                            'DBInstanceClass' => 'db.m1.small',
+                                            'Engine' => 'mysql',
+                                            'EngineVersion' => '5.1.50',
+                                            'MasterUsername' => 'foguser',
+                                            'BackupRetentionPeriod' => 1,
+                                            'MasterUserPassword' => 'fogpassword').body
+
+      instance = result['CreateDBInstanceResult']['DBInstance']
+      returns('creating'){ instance['DBInstanceStatus']}
+      result
+    end
+
+    tests("#describe_db_instances").formats(AWS::RDS::Formats::DESCRIBE_DB_INSTANCES) do
+      AWS[:rds].describe_db_instances.body
+    end
+
+    server = AWS[:rds].servers.get(@db_instance_id)
+    server.wait_for {ready?}
+
+    new_storage = 6
+    tests("#modify_db_instance with immediate apply").formats(AWS::RDS::Formats::MODIFY_DB_INSTANCE) do
+      body = AWS[:rds].modify_db_instance(@db_instance_id, true, 'AllocatedStorage'=> new_storage).body
+      tests 'pending storage' do
+        instance = body['ModifyDBInstanceResult']['DBInstance']
+        returns(new_storage){instance['PendingModifiedValues']['AllocatedStorage']}
+      end
+      body
+    end
+
+    server.reload.wait_for { state == 'modifying' }
+    server.reload.wait_for { state == 'available' }
+
+    tests 'new storage' do
+      returns(new_storage){ server.allocated_storage}
+    end
+
+    tests("reboot db instance") do
+      tests("#reboot").formats(AWS::RDS::Formats::REBOOT_DB_INSTANCE) do
+        AWS[:rds].reboot_db_instance(@db_instance_id).body
+      end
+    end
+
+    server.reload.wait_for { state == 'rebooting' }
+    server.reload.wait_for { state == 'available'}
+
+    tests("#create_db_snapshot").formats(AWS::RDS::Formats::CREATE_DB_SNAPSHOT) do
+      body = AWS[:rds].create_db_snapshot(@db_instance_id, @db_snapshot_id).body
+      returns('creating'){ body['CreateDBSnapshotResult']['DBSnapshot']['Status']}
+      body
+    end
+
+    tests("#describe_db_snapshots").formats(AWS::RDS::Formats::DESCRIBE_DB_SNAPSHOTS) do
+      body = AWS[:rds].describe_db_snapshots.body
+    end
+
+    server.reload.wait_for { state == 'available' }
+
+    tests( "#create read replica").formats(AWS::RDS::Formats::CREATE_READ_REPLICA) do
+      AWS[:rds].create_db_instance_read_replica(@db_replica_id, @db_instance_id).body
+    end
+
+    replica = AWS[:rds].servers.get(@db_replica_id)
+    replica.wait_for {ready?}
+
+    tests("replica source") do
+      returns(@db_instance_id){replica.read_replica_source}
+    end
+    server.reload
+
+    tests("replica identifiers") do
+      returns([@db_replica_id]){server.read_replica_identifiers}
+    end
+
+    tests("#delete_db_instance").formats(AWS::RDS::Formats::DELETE_DB_INSTANCE) do
+      #server.wait_for { state == 'available'}
+      AWS[:rds].delete_db_instance(@db_replica_id, nil, true)
+      body = AWS[:rds].delete_db_instance(@db_instance_id, @db_final_snapshot_id).body
+
+      tests "final snapshot" do
+        returns('creating'){AWS[:rds].describe_db_snapshots(:snapshot_id => @db_final_snapshot_id).body['DescribeDBSnapshotsResult']['DBSnapshots'].first['Status']}
+      end
+      body
+    end
+
+    tests("#delete_db_snapshot").formats(AWS::RDS::Formats::DELETE_DB_SNAPSHOT) do
+      AWS[:rds].snapshots.get(@db_snapshot_id).wait_for { ready? }
+      AWS[:rds].delete_db_snapshot(@db_snapshot_id).body
+    end
+
+    tests("snapshot.destroy") do
+      snapshot = AWS[:rds].snapshots.get(@db_final_snapshot_id)
+      snapshot.wait_for { ready? }
+      snapshot.destroy
+      returns(nil) { AWS[:rds].snapshots.get(@db_final_snapshot_id) }
+    end
+
+  end
+
+  tests('failure') do
+    pending if Fog.mocking?
+
+    tests "deleting nonexisting instance" do
+      raises(Fog::AWS::RDS::NotFound) {AWS[:rds].delete_db_instance('doesnexist', 'irrelevant')}
+    end
+    tests "deleting non existing snapshot" do
+      raises(Fog::AWS::RDS::NotFound) {AWS[:rds].delete_db_snapshot('doesntexist')}
+    end
+    tests "modifying non existing instance" do
+      raises(Fog::AWS::RDS::NotFound) { AWS[:rds].modify_db_instance 'doesntexit', true, 'AllocatedStorage'=> 10}
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/rds/model_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/rds/model_tests.rb
new file mode 100644
index 0000000..9181045
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/rds/model_tests.rb
@@ -0,0 +1,98 @@
+Shindo.tests('AWS::RDS | models', ['aws', 'rds']) do
+  @db_instance_id='fog-test'
+  @db_replica_id='fog-replica'
+
+  tests('success') do
+    pending if Fog.mocking?
+    
+    tests('parametergroups') do
+      group = nil
+
+      tests('create') do
+        group = AWS[:rds].parameter_groups.create :id => 'testgroup', :family => 'mysql5.1', :description => 'test'
+      end
+
+      tests('#parameters') do
+        parameters = group.parameters
+        #search for a sample parameter
+        tests 'contains parameter' do
+          returns(true){ !!parameters.detect {|p| p.name == 'query_cache_size'}}
+        end
+      end
+      
+      tests('modify') do
+        group.modify([{:name => 'query_cache_size', :value => '6553600', :apply_method => 'immediate'}])
+
+        tests 'parameter has changed' do
+          returns('6553600'){group.parameters.detect {|p| p.name == 'query_cache_size'}.value}
+        end
+      end
+      
+      tests('destroy').succeeds do
+        group.destroy
+      end
+
+      returns(nil){AWS[:rds].parameter_groups.detect {|g| g.id == 'testgroup'}}      
+    end
+    
+    tests('servers') do
+      server = nil
+      tests('create').succeeds do
+        server = AWS[:rds].servers.create( :id => @db_instance_id, :allocated_storage => 5, :engine => 'mysql',
+                                                        :master_username => 'foguser', :password => 'fogpassword',
+                                                        :backup_retention_period => 0)
+      end
+    
+      server.wait_for {ready?}
+    
+      tests('snapshots') do
+        snapshot = nil
+      
+        tests('create').succeeds do
+          snapshot = server.snapshots.create(:id => 'testsnapshot')
+        end
+      
+        returns(@db_instance_id){snapshot.instance_id}
+        server.reload
+        server.wait_for {ready?}
+        snapshot.wait_for {ready?}
+        tests('all') do
+          returns(['testsnapshot']){server.snapshots.collect {|s| s.id}}
+        end
+      
+        tests('destroy').succeeds do
+          snapshot.destroy
+        end
+      
+        returns([]) {server.snapshots}
+      end
+    
+      group = AWS[:rds].parameter_groups.create :id => 'some-group', :family => 'mysql5.1', :description => 'test'
+      tests('modify') do
+        server.modify(true, 'DBParameterGroupName' => 'some-group')
+        server.reload
+        returns('some-group'){server.db_parameter_groups.first['DBParameterGroupName']}
+      end
+      
+      tests('reboot').succeeds do
+        server.reboot
+      end
+      server.wait_for {state == 'rebooting'}
+      server.wait_for {state == 'available'}
+        
+      tests('destroy').succeeds do
+        server.destroy('finalsnapshot')      
+      end
+      
+      Fog.wait_for do
+        AWS[:rds].servers.length == 0
+      end
+      
+      group.destroy
+
+      tests("final snapshot was created") do
+        AWS[:rds].snapshots.get('finalsnapshot').destroy
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_group_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_group_tests.rb
new file mode 100644
index 0000000..73526f0
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_group_tests.rb
@@ -0,0 +1,68 @@
+Shindo.tests('AWS::RDS | parameter group requests', ['aws', 'rds']) do
+  tests('success') do
+    pending if Fog.mocking?
+
+    tests("#create_db_parameter_groups").formats(AWS::RDS::Formats::CREATE_DB_PARAMETER_GROUP) do
+      pending if Fog.mocking?
+      body = AWS[:rds].create_db_parameter_group('fog-group', 'MySQL5.1', 'Some description').body
+
+      returns( 'mysql5.1') { body['CreateDBParameterGroupResult']['DBParameterGroup']['DBParameterGroupFamily']}
+      returns( 'fog-group') { body['CreateDBParameterGroupResult']['DBParameterGroup']['DBParameterGroupName']}
+      returns( 'Some description') { body['CreateDBParameterGroupResult']['DBParameterGroup']['Description']}
+      
+      body
+    end
+    
+    AWS[:rds].create_db_parameter_group('other-fog-group', 'MySQL5.1', 'Some description')
+
+    tests("#describe_db_parameter_groups").formats(AWS::RDS::Formats::DESCRIBE_DB_PARAMETER_GROUP) do
+      pending if Fog.mocking?
+
+      body = AWS[:rds].describe_db_parameter_groups().body
+      
+      returns(3) {body['DescribeDBParameterGroupsResult']['DBParameterGroups'].length}      
+      body
+    end
+
+    tests("#describe_db_parameter_groups('fog-group)").formats(AWS::RDS::Formats::DESCRIBE_DB_PARAMETER_GROUP) do
+      pending if Fog.mocking?
+
+      body = AWS[:rds].describe_db_parameter_groups('fog-group').body
+      
+      returns(1) {body['DescribeDBParameterGroupsResult']['DBParameterGroups'].length}      
+      
+      group = body['DescribeDBParameterGroupsResult']['DBParameterGroups'].first
+      returns( 'mysql5.1') { group['DBParameterGroupFamily']}
+      returns( 'fog-group') { group['DBParameterGroupName']}
+      returns( 'Some description') { group['Description']}
+
+      body
+    end
+    
+    tests("delete_db_parameter_group").formats(AWS::RDS::Formats::BASIC) do
+      pending if Fog.mocking?
+      body = AWS[:rds].delete_db_parameter_group('fog-group').body
+      
+      raises(Fog::AWS::RDS::NotFound) {AWS[:rds].describe_db_parameter_groups('fog-group')}      
+
+      body
+    end
+
+    AWS[:rds].delete_db_parameter_group('other-fog-group')
+  end
+
+  tests("failures") do
+    pending if Fog.mocking?
+    raises(Fog::AWS::RDS::NotFound) {AWS[:rds].describe_db_parameter_groups('doesntexist')}      
+    raises(Fog::AWS::RDS::NotFound) {AWS[:rds].delete_db_parameter_group('doesntexist')}      
+
+    tests "creating second group with same id" do
+      AWS[:rds].create_db_parameter_group('fog-group', 'MySQL5.1', 'Some description')
+      raises(Fog::AWS::RDS::IdentifierTaken) {AWS[:rds].create_db_parameter_group('fog-group', 'MySQL5.1', 'Some description')}      
+    end
+    
+    AWS[:rds].delete_db_parameter_group('fog-group')
+  
+  end
+  
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_request_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_request_tests.rb
new file mode 100644
index 0000000..720ef53
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/rds/parameter_request_tests.rb
@@ -0,0 +1,35 @@
+Shindo.tests('AWS::RDS | parameter requests', ['aws', 'rds']) do
+  tests('success') do
+    pending if Fog.mocking?
+    
+    AWS[:rds].create_db_parameter_group('fog-group', 'MySQL5.1', 'Some description')
+    
+    tests('#modify_db_parameter_group').formats(AWS::RDS::Formats::MODIFY_PARAMETER_GROUP) do
+      body = AWS[:rds].modify_db_parameter_group('fog-group',[
+        {'ParameterName' => 'query_cache_size',
+        'ParameterValue' => '12345',
+        'ApplyMethod' => 'immediate'} 
+      ]).body
+      
+      body
+    end
+    
+    tests('#describe_db_parameters').formats(AWS::RDS::Formats::DESCRIBE_DB_PARAMETERS) do
+      AWS[:rds].describe_db_parameters('fog-group', :max_records => 20).body
+    end
+
+
+    tests("#describe_db_parameters :source => 'user'")do
+      body = AWS[:rds].describe_db_parameters('fog-group', :source => 'user').body
+      returns(1){ body['DescribeDBParametersResult']['Parameters'].length}
+      
+      param = body['DescribeDBParametersResult']['Parameters'].first
+      returns('query_cache_size'){param['ParameterName']}
+      returns('12345'){param['ParameterValue']}
+      returns(true){param['IsModifiable']}
+      returns('query_cache_size'){param['ParameterName']}
+    end
+    AWS[:rds].delete_db_parameter_group('fog-group')
+    
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/ses/helper.rb b/vendor/fog-0.8.2/tests/aws/requests/ses/helper.rb
new file mode 100644
index 0000000..8ebe694
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/ses/helper.rb
@@ -0,0 +1,15 @@
+class AWS
+
+  module SES
+
+    module Formats
+
+      BASIC = {
+        'ResponseMetadata' => {'RequestId' => String}
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/ses/verified_email_address_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/ses/verified_email_address_tests.rb
new file mode 100644
index 0000000..6bfd077
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/ses/verified_email_address_tests.rb
@@ -0,0 +1,27 @@
+Shindo.tests('AWS::SES | verified email address requests', ['aws', 'ses']) do
+
+  tests('success') do
+
+    tests("#verify_email_address('test@example.com')").formats(AWS::SES::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:ses].verify_email_address('test@example.com').body
+    end
+
+    tests("#list_verified_email_addresses").formats(AWS::SES::Formats::BASIC.merge('VerifiedEmailAddresses' => [String])) do
+      pending if Fog.mocking?
+      AWS[:ses].list_verified_email_addresses.body
+    end
+
+    # email won't be there to delete, but succeeds regardless
+    tests("#delete_verified_email_address('test@example.com')").formats(AWS::SES::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:ses].delete_verified_email_address('notaanemail@example.com').body
+    end
+
+  end
+
+  tests('failure') do
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/simpledb/attributes_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/simpledb/attributes_tests.rb
new file mode 100644
index 0000000..f536b55
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/simpledb/attributes_tests.rb
@@ -0,0 +1,75 @@
+Shindo.tests('AWS::SimpleDB | attributes requests', ['aws']) do
+
+  @domain_name = "fog_domain_#{Time.now.to_f.to_s.gsub('.','')}"
+
+  AWS[:sdb].create_domain(@domain_name)
+
+  tests('success') do
+
+    tests("#batch_put_attributes('#{@domain_name}', { 'a' => { 'b' => 'c', 'd' => 'e' }, 'x' => { 'y' => 'z' } }).body").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].batch_put_attributes(@domain_name, { 'a' => { 'b' => 'c', 'd' => 'e' }, 'x' => { 'y' => 'z' } }).body
+    end
+
+    tests("#get_attributes('#{@domain_name}', 'a').body['Attributes']").returns({'b' => ['c'], 'd' => ['e']}) do
+      attributes = {}
+      Fog.wait_for {
+        attributes = AWS[:sdb].get_attributes(@domain_name, 'a').body['Attributes']
+        attributes != {}
+      }
+      attributes
+    end
+
+    tests("#get_attributes('#{@domain_name}', 'notanattribute')").succeeds do
+      AWS[:sdb].get_attributes(@domain_name, 'notanattribute')
+    end
+
+    tests("#select('select * from #{@domain_name}').body['Items']").returns({'a' => { 'b' => ['c'], 'd' => ['e']}, 'x' => { 'y' => ['z'] } }) do
+      pending if Fog.mocking?
+      AWS[:sdb].select("select * from #{@domain_name}").body['Items']
+    end
+
+    tests("#put_attributes('#{@domain_name}', 'conditional', { 'version' => '1' }).body").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].put_attributes(@domain_name, 'conditional', { 'version' => '1' }).body
+    end
+
+    tests("#put_attributes('#{@domain_name}', 'conditional', { 'version' => '2' }, :expect => { 'version' => '1' }, :replace => ['version']).body").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].put_attributes(@domain_name, 'conditional', { 'version' => '2' }, :expect => { 'version' => '1' }, :replace => ['version']).body
+    end
+
+    tests("#delete_attributes('#{@domain_name}', 'a').body").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].delete_attributes(@domain_name, 'a').body
+    end
+
+    tests("#delete_attributes('#{@domain_name}', 'a').body").succeeds do
+      AWS[:sdb].delete_attributes(@domain_name, 'a').body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#batch_put_attributes('notadomain', { 'a' => { 'b' => 'c' }, 'x' => { 'y' => 'z' } })").raises(Excon::Errors::BadRequest) do
+      AWS[:sdb].batch_put_attributes('notadomain', { 'a' => { 'b' => 'c' }, 'x' => { 'y' => 'z' } })
+    end
+
+    tests("#get_attributes('notadomain', 'a')").raises(Excon::Errors::BadRequest) do
+      AWS[:sdb].get_attributes('notadomain', 'a')
+    end
+
+    tests("#put_attributes('notadomain', 'conditional', { 'version' => '1' })").raises(Excon::Errors::BadRequest) do
+      AWS[:sdb].put_attributes('notadomain', 'foo', { 'version' => '1' })
+    end
+
+    tests("#put_attributes('#{@domain_name}', 'conditional', { 'version' => '2' }, :expect => { 'version' => '1' }, :replace => ['version'])").raises(Excon::Errors::Conflict) do
+      AWS[:sdb].put_attributes(@domain_name, 'conditional', { 'version' => '2' }, :expect => { 'version' => '1' }, :replace => ['version'])
+    end
+
+    tests("#delete_attributes('notadomain', 'a')").raises(Excon::Errors::BadRequest) do
+      AWS[:sdb].delete_attributes('notadomain', 'a')
+    end
+
+  end
+
+  AWS[:sdb].delete_domain(@domain_name)
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/simpledb/domain_tests.rb b/vendor/fog-0.8.2/tests/aws/requests/simpledb/domain_tests.rb
new file mode 100644
index 0000000..fbabf29
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/simpledb/domain_tests.rb
@@ -0,0 +1,51 @@
+Shindo.tests('AWS::SimpleDB | domain requests', ['aws']) do
+
+  @domain_metadata_format = AWS::SimpleDB::Formats::BASIC.merge({
+    'AttributeNameCount'        => Integer,
+    'AttributeNamesSizeBytes'   => Integer,
+    'AttributeValueCount'       => Integer,
+    'AttributeValuesSizeBytes'  => Integer,
+    'ItemCount'                 => Integer,
+    'ItemNamesSizeBytes'        => Integer,
+    'Timestamp'                 => Time
+  })
+
+  @domain_name = "fog_domain_#{Time.now.to_f.to_s.gsub('.','')}"
+
+  tests('success') do
+
+    tests("#create_domain(#{@domain_name})").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].create_domain(@domain_name).body
+    end
+
+    tests("#create_domain(#{@domain_name})").succeeds do
+      AWS[:sdb].create_domain(@domain_name)
+    end
+
+    tests("#domain_metadata(#{@domain_name})").formats(@domain_metadata_format) do
+      AWS[:sdb].domain_metadata(@domain_name).body
+    end
+
+    tests("#list_domains").formats(AWS::SimpleDB::Formats::BASIC.merge('Domains' => [String])) do
+      AWS[:sdb].list_domains.body
+    end
+
+    tests("#delete_domain(#{@domain_name})").formats(AWS::SimpleDB::Formats::BASIC) do
+      AWS[:sdb].delete_domain(@domain_name).body
+    end
+
+    tests("#delete_domain(#{@domain_name})").succeeds do
+      AWS[:sdb].delete_domain(@domain_name)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#domain_metadata('notadomain')").raises(Excon::Errors::BadRequest) do
+      AWS[:sdb].domain_metadata('notadomain')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/requests/simpledb/helper.rb b/vendor/fog-0.8.2/tests/aws/requests/simpledb/helper.rb
new file mode 100644
index 0000000..8c5d710
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/requests/simpledb/helper.rb
@@ -0,0 +1,16 @@
+class AWS
+
+  module SimpleDB
+
+    module Formats
+
+      BASIC = {
+        'BoxUsage'  => Float,
+        'RequestId' => String
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/aws/signed_params_tests.rb b/vendor/fog-0.8.2/tests/aws/signed_params_tests.rb
new file mode 100644
index 0000000..24ffec3
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/aws/signed_params_tests.rb
@@ -0,0 +1,3 @@
+Shindo.tests('AWS | signed_params', ['aws']) do
+  returns( Fog::AWS.escape( "'Stop!' said Fred_-~." ) ) { "%27Stop%21%27%20said%20Fred_-~." }
+end
diff --git a/vendor/fog-0.8.2/tests/compute/helper.rb b/vendor/fog-0.8.2/tests/compute/helper.rb
new file mode 100644
index 0000000..07aec7d
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/helper.rb
@@ -0,0 +1,45 @@
+def compute_providers
+  {
+    AWS       => {
+      :server_attributes => {},
+      :mocked => true
+    },
+    Bluebox   => {
+      :server_attributes => {
+        :image_id => '03807e08-a13d-44e4-b011-ebec7ef2c928', # Ubuntu 10.04 64bit
+        :password => 'chunkybacon'
+      },
+      :mocked => false
+    },
+    Brightbox => {
+      :server_attributes => {
+        :image_id => 'img-2ab98' # Ubuntu Lucid 10.04 server (i686)
+      },
+      :mocked => false
+    },
+    Rackspace => {
+      :server_attributes => {
+        :image_id => 49, # image 49 = Ubuntu 10.04 LTS (lucid)
+        :name     => "fog_#{Time.now.to_i}"
+      },
+      :mocked => true
+    },
+    Slicehost => {
+      :server_attributes => {
+        :image_id => 49, # image 49 = Ubuntu 10.04 LTS (lucid)
+        :name     => "fog_#{Time.now.to_i}"
+      },
+      :mocked => false
+    },
+    Voxel => {
+      :server_attributes => {
+        :name => "fog.#{Time.now.to_i}",
+        :disk_size => 10,
+        :processing_cores => 1,
+        :image_id => 55, # image 55 = Ubuntu 10.04 (Lucid), 64-bit, base install
+        :facility => "LDJ1"
+      },
+      :mocked => false
+    }
+  }
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/address_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/address_tests.rb
new file mode 100644
index 0000000..44afe04
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/address_tests.rb
@@ -0,0 +1,16 @@
+Shindo.tests("AWS::Compute | address", ['aws']) do
+
+  model_tests(AWS[:compute].addresses, {}, true) do
+
+    @server = AWS[:compute].servers.create
+    @server.wait_for { ready? }
+
+    tests('#server=').succeeds do
+      @instance.server = @server
+    end
+
+    @server.destroy
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/addresses_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/addresses_tests.rb
new file mode 100644
index 0000000..db7b7ce
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/addresses_tests.rb
@@ -0,0 +1,5 @@
+Shindo.tests("AWS::Compute | addresses", ['aws']) do
+
+  collection_tests(AWS[:compute].addresses, {}, true)
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/key_pair_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/key_pair_tests.rb
new file mode 100644
index 0000000..c330fe1
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/key_pair_tests.rb
@@ -0,0 +1,27 @@
+Shindo.tests("AWS::Compute | key_pair", ['aws']) do
+
+  model_tests(AWS[:compute].key_pairs, {:name => 'fogkeyname'}, true)
+
+  after do
+    @keypair.destroy
+  end
+
+  tests("new keypair") do
+    @keypair = AWS[:compute].key_pairs.create(:name => 'testkey')
+
+    test ("writable?") do
+      @keypair.writable? == true
+    end
+  end
+
+  tests("existing keypair") do
+    AWS[:compute].key_pairs.create(:name => 'testkey')
+    @keypair = AWS[:compute].key_pairs.get('testkey')
+
+    test("writable?") do
+      @keypair.writable? == false
+    end
+  end
+
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/key_pairs_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/key_pairs_tests.rb
new file mode 100644
index 0000000..ef862bd
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/key_pairs_tests.rb
@@ -0,0 +1,5 @@
+Shindo.tests("AWS::Compute | key_pairs", ['aws']) do
+
+  collection_tests(AWS[:compute].key_pairs, {:name => 'fogkeyname'}, true)
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/security_group_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/security_group_tests.rb
new file mode 100644
index 0000000..4f511f7
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/security_group_tests.rb
@@ -0,0 +1,17 @@
+Shindo.tests("AWS::Compute | security_group", ['aws']) do
+
+  model_tests(AWS[:compute].security_groups, {:description => 'foggroupdescription', :name => 'foggroupname'}, true)
+
+  tests("a group with trailing whitespace") do
+    @group = AWS[:compute].security_groups.create(:name => "foggroup with spaces   ", :description => "   fog group desc   ")
+    test("name is correct") do
+      @group.name ==  "foggroup with spaces   "
+    end
+
+    test("description is correct") do
+      @group.description == "   fog group desc   "
+    end
+
+    @group.destroy
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/security_groups.rb b/vendor/fog-0.8.2/tests/compute/models/aws/security_groups.rb
new file mode 100644
index 0000000..c1c4ac6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/security_groups.rb
@@ -0,0 +1,5 @@
+Shindo.tests("AWS::Compute | security_groups", ['aws']) do
+
+  collection_tests(AWS[:compute].security_groups, {:description => 'foggroupdescription', :name => 'foggroupname'}, true)
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/server_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/server_tests.rb
new file mode 100644
index 0000000..15f5965
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/server_tests.rb
@@ -0,0 +1,47 @@
+Shindo.tests("AWS::Compute | monitor", ['aws']) do
+
+  @instance = AWS[:compute].servers.new
+
+  [:addresses, :flavor, :key_pair, :key_pair=, :volumes].each do |association|
+    responds_to(association)
+  end
+
+
+  tests('new instance') do
+
+    test('#monitor = true') do
+      @instance.monitor = true
+      @instance.attributes[:monitoring] == true
+    end
+
+    test('#monitor = false') do
+      @instance.monitor = false
+      @instance.attributes[:monitoring] == false
+    end
+
+  end
+
+  tests('existing instance') do
+
+    @instance.save
+
+    [:id, :availability_zone, :flavor_id, :kernel_id, :image_id, :state].each do |attr|
+      test("instance##{attr} should not contain whitespace") do
+        nil == @instance.send(attr).match(/\s/)
+      end
+    end
+
+    test('#monitor = true') do
+      @instance.monitor = true
+      @instance.monitoring == true
+    end
+
+    test('#monitor = false') do
+      @instance.monitor = false
+      @instance.monitoring == false
+    end
+
+  end
+
+  @instance.destroy
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/snapshot_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/snapshot_tests.rb
new file mode 100644
index 0000000..c7120ac
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/snapshot_tests.rb
@@ -0,0 +1,10 @@
+Shindo.tests("AWS::Compute | snapshot", ['aws']) do
+
+  @volume = AWS[:compute].volumes.create(:availability_zone => 'us-east-1a', :size => 1)
+  @volume.wait_for { ready? }
+
+  model_tests(AWS[:compute].snapshots, {:volume_id => @volume.identity}, true)
+
+  @volume.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/snapshots_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/snapshots_tests.rb
new file mode 100644
index 0000000..5c8b636
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/snapshots_tests.rb
@@ -0,0 +1,10 @@
+Shindo.tests("AWS::Compute | snapshots", ['aws']) do
+
+  @volume = AWS[:compute].volumes.create(:availability_zone => 'us-east-1a', :size => 1)
+  @volume.wait_for { ready? }
+
+  collection_tests(AWS[:compute].snapshots, {:volume_id => @volume.identity}, true)
+                    
+  @volume.destroy
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/volume_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/volume_tests.rb
new file mode 100644
index 0000000..3a27474
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/volume_tests.rb
@@ -0,0 +1,26 @@
+Shindo.tests("AWS::Compute | volume", ['aws']) do
+
+  @server = AWS[:compute].servers.create
+  @server.wait_for { ready? }
+
+  model_tests(AWS[:compute].volumes, {:availability_zone => @server.availability_zone, :size => 1, :device => '/dev/sdz1'}, true) do
+
+    @instance.wait_for { ready? }
+
+    tests('#server = @server').succeeds do
+      @instance.server = @server
+    end
+
+    @instance.wait_for { state == 'in-use' }
+
+    tests('#server = nil').succeeds do
+      @instance.server = nil
+    end
+
+    @instance.wait_for { ready? }
+
+  end
+
+  @server.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/aws/volumes_tests.rb b/vendor/fog-0.8.2/tests/compute/models/aws/volumes_tests.rb
new file mode 100644
index 0000000..260acef
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/aws/volumes_tests.rb
@@ -0,0 +1,5 @@
+Shindo.tests("AWS::Compute | volumes", ['aws']) do
+
+  collection_tests(AWS[:compute].volumes, {:availability_zone => 'us-east-1a', :size => 1, :device => '/dev/sdz1'}, true)
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/compute/models/flavors_tests.rb b/vendor/fog-0.8.2/tests/compute/models/flavors_tests.rb
new file mode 100644
index 0000000..850f0b2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/flavors_tests.rb
@@ -0,0 +1,11 @@
+for provider, config in compute_providers
+
+  next if [Voxel].include?(provider)
+
+  Shindo.tests("#{provider}::Compute | flavors", [provider.to_s.downcase]) do
+
+    flavors_tests(provider[:compute], (config[:flavors_attributes] || {}), config[:mocked])
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/server_tests.rb b/vendor/fog-0.8.2/tests/compute/models/server_tests.rb
new file mode 100644
index 0000000..cc83b27
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/server_tests.rb
@@ -0,0 +1,20 @@
+for provider, config in compute_providers
+
+  Shindo.tests("#{provider}::Compute | server", [provider.to_s.downcase]) do
+
+    server_tests(provider[:compute], (config[:server_attributes] || {}), config[:mocked]) do
+
+      if Fog.mocking? && !config[:mocked]
+        pending
+      else
+        responds_to(:boostrap)
+        responds_to(:public_ip_address)
+        responds_to(:scp)
+        responds_to(:ssh)
+      end
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/models/servers_tests.rb b/vendor/fog-0.8.2/tests/compute/models/servers_tests.rb
new file mode 100644
index 0000000..31042c9
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/models/servers_tests.rb
@@ -0,0 +1,9 @@
+for provider, config in compute_providers
+
+  Shindo.tests("#{provider}::Compute | servers", [provider.to_s.downcase]) do
+
+    servers_tests(provider[:compute], (config[:server_attributes] || {}), config[:mocked])
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/parsers/aws/monitor_unmonitor_instances_tests.rb b/vendor/fog-0.8.2/tests/compute/parsers/aws/monitor_unmonitor_instances_tests.rb
new file mode 100644
index 0000000..5b543d9
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/parsers/aws/monitor_unmonitor_instances_tests.rb
@@ -0,0 +1,49 @@
+require 'fog/compute/parsers/aws/monitor_unmonitor_instances'
+
+Shindo.tests('AWS::Compute::MonitorUnmonitorInstances | monitor/unmonitor parser') do
+
+  tests('success') do
+
+    tests('#parse') do
+
+      aws_result = <<-AWS
+        <UnmonitorInstancesResponse xmlns="http://ec2.amazonaws.com/doc/2010-11-15/">
+           <requestId>59dbff89-35bd-4eac-99ed-be587EXAMPLE</requestId>
+           <instancesSet>
+              <item>
+                 <instanceId>i-43a4412a</instanceId>
+                 <monitoring>
+                    <state>enabled</state>
+                 </monitoring>
+              </item>
+              <item>
+                 <instanceId>i-23a3397d</instanceId>
+                 <monitoring>
+                    <state>disabled</state>
+                 </monitoring>
+              </item>
+           </instancesSet>
+        </UnmonitorInstancesResponse>
+      AWS
+
+      parser = Fog::Parsers::AWS::Compute::MonitorUnmonitorInstances.new
+      body = Nokogiri::XML::SAX::PushParser.new(parser)
+      body << aws_result
+
+      test('requestId') { parser.response['requestId'] == '59dbff89-35bd-4eac-99ed-be587EXAMPLE' }
+
+      test('enabled') do
+        selected = parser.response['instancesSet'].select { |item| item['instanceId'] == 'i-43a4412a' }[0]
+        selected['monitoring'] == 'enabled'
+      end
+
+      test('disabled') do
+        selected = parser.response['instancesSet'].select { |item| item['instanceId'] == 'i-23a3397d' }[0]
+        selected['monitoring'] == 'disabled'
+      end
+      
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/address_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/address_tests.rb
new file mode 100644
index 0000000..3d5bec5
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/address_tests.rb
@@ -0,0 +1,76 @@
+Shindo.tests('AWS::Compute | address requests', ['aws']) do
+
+  @addresses_format = {
+    'addressesSet' => [{
+      'instanceId'  => NilClass,
+      'publicIp'    => String
+    }],
+    'requestId' => String
+  }
+
+  @server = AWS[:compute].servers.create
+  @server.wait_for { ready? }
+  @ip_address = @server.ip_address
+
+  tests('success') do
+
+    @public_ip = nil
+
+    tests('#allocate_address').formats({'publicIp' => String, 'requestId' => String}) do
+      data = AWS[:compute].allocate_address.body
+      @public_ip = data['publicIp']
+      data
+    end
+
+    tests('#describe_addresses').formats(@addresses_format) do
+      AWS[:compute].describe_addresses.body
+    end
+
+    tests("#describe_addresses('public-ip' => #{@public_Ip}')").formats(@addresses_format) do
+      AWS[:compute].describe_addresses('public-ip' => @public_ip).body
+    end
+
+    tests("#associate_addresses('#{@server.identity}', '#{@public_Ip}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].associate_address(@server.identity, @public_ip).body
+    end
+
+    tests("#dissassociate_address('#{@public_ip}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].disassociate_address(@public_ip).body
+    end
+
+    tests("#release_address('#{@public_ip}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].release_address(@public_ip).body
+    end
+
+  end
+  tests ('failure') do
+
+    @address = AWS[:compute].addresses.create
+
+    tests("#associate_addresses('i-00000000', '#{@address.identity}')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].associate_address('i-00000000', @address.identity)
+    end
+
+    tests("#associate_addresses('#{@server.identity}', '127.0.0.1')").raises(Fog::AWS::Compute::Error) do
+      AWS[:compute].associate_address(@server.identity, '127.0.0.1')
+    end
+
+    tests("#associate_addresses('i-00000000', '127.0.0.1')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].associate_address('i-00000000', '127.0.0.1')
+    end
+
+    tests("#disassociate_addresses('127.0.0.1') raises BadRequest error").raises(Fog::AWS::Compute::Error) do
+      AWS[:compute].disassociate_address('127.0.0.1')
+    end
+
+    tests("#release_address('127.0.0.1')").raises(Fog::AWS::Compute::Error) do
+      AWS[:compute].release_address('127.0.0.1')
+    end
+
+    @address.destroy
+
+  end
+
+  @server.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/availability_zone_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/availability_zone_tests.rb
new file mode 100644
index 0000000..494b31a
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/availability_zone_tests.rb
@@ -0,0 +1,25 @@
+Shindo.tests('AWS::Compute | availability zone requests', ['aws']) do
+
+  @availability_zones_format = {
+    'availabilityZoneInfo'  => [{
+      'messageSet'  => [],
+      'regionName'  => String,
+      'zoneName'    => String,
+      'zoneState'   => String
+    }],
+    'requestId'             => String
+  }
+
+  tests('success') do
+
+    tests('#describe_availability_zones').formats(@availability_zones_format) do
+      AWS[:compute].describe_availability_zones.body
+    end
+
+    tests("#describe_availability_zones('zone-name' => 'us-east-1a')").formats(@availability_zones_format) do
+      AWS[:compute].describe_availability_zones('zone-name' => 'us-east-1a').body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/helper.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/helper.rb
new file mode 100644
index 0000000..c2ca701
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/helper.rb
@@ -0,0 +1,20 @@
+class AWS
+
+  module Compute
+
+    module Formats
+
+      BASIC = {
+        'requestId' => String,
+        'return'    => ::Fog::Boolean
+      }
+
+    end
+
+  end
+
+end
+
+unless defined?(GENTOO_AMI)
+  GENTOO_AMI = 'ami-5ee70037'
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/image_tests.rb
new file mode 100644
index 0000000..ce652da
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/image_tests.rb
@@ -0,0 +1,37 @@
+Shindo.tests('AWS::Compute | image requests', ['aws']) do
+
+  @images_format = {
+    'imagesSet'    => [{
+      'architecture'        => String,
+      'blockDeviceMapping'  =>[],
+      'imageId'             => String,
+      'imageLocation'       => String,
+      'imageOwnerId'        => String,
+      'imageState'          => String,
+      'imageType'           => String,
+      'isPublic'            => Fog::Boolean,
+      'kernelId'            => String,
+      'productCodes'        => [],
+      'ramdiskId'           => String,
+      'rootDeviceType'      => String,
+      'tagSet'              => {},
+      'virtualizationType'  => String
+    }],
+    'requestId'     => String,
+  }
+
+  tests('success') do
+
+    # the result for this is HUGE and relatively uninteresting...
+    # tests("#describe_images").formats(@images_format) do
+    #   AWS[:compute].describe_images.body
+    # end
+
+    tests("#describe_images('ImageId' => '#{GENTOO_AMI}')").formats(@images_format) do
+      pending if Fog.mocking?
+      AWS[:compute].describe_images('ImageId' => GENTOO_AMI).body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/instance_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/instance_tests.rb
new file mode 100644
index 0000000..b522780
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/instance_tests.rb
@@ -0,0 +1,172 @@
+Shindo.tests('AWS::Compute | instance requests', ['aws']) do
+
+  @instance_format = {
+    # 'architecture'    => String,
+    'amiLaunchIndex'      => Integer,
+    'blockDeviceMapping'  => [],
+    'clientToken'         => Fog::Nullable::String,
+    'dnsName'             => NilClass,
+    'imageId'             => String,
+    'instanceId'          => String,
+    'instanceState'       => {'code' => Integer, 'name' => String},
+    'instanceType'        => String,
+    # 'ipAddress'           => String,
+    'kernelId'            => Fog::Nullable::String,
+    'keyName'             => Fog::Nullable::String,
+    'launchTime'          => Time,
+    'monitoring'          => {'state' => Fog::Boolean},
+    'placement'           => {'availabilityZone' => String},
+    'privateDnsName'      => NilClass,
+    # 'privateIpAddress'    => String,
+    'productCodes'        => [],
+    'ramdiskId'           => Fog::Nullable::String,
+    'reason'              => Fog::Nullable::String,
+    # 'rootDeviceName'      => String,
+    'rootDeviceType'      => String,
+  }
+
+  @run_instances_format = {
+    'groupSet'        => [String],
+    'instancesSet'    => [@instance_format],
+    'ownerId'         => String,
+    'requestId'       => String,
+    'reservationId'   => String
+  }
+
+  @describe_instances_format = {
+    'reservationSet'  => [{
+      'groupSet'      => [String],
+      'instancesSet'  => [@instance_format.merge(
+        'architecture'      => String,
+        'dnsName'           => Fog::Nullable::String,
+        'ipAddress'         => Fog::Nullable::String,
+        'privateDnsName'    => Fog::Nullable::String,
+        'privateIpAddress'  => Fog::Nullable::String,
+        'stateReason'       => Hash,
+        'tagSet'            => Hash
+      )],
+      'ownerId'       => String,
+      'reservationId' => String
+    }],
+    'requestId'       => String
+  }
+
+  @get_console_output_format = {
+    'instanceId'  => String,
+    'output'      => Fog::Nullable::String,
+    'requestId'   => String,
+    'timestamp'   => Time
+  }
+
+  @get_password_data_format = {
+    'instanceId'   => String,
+    'passwordData' => Fog::Nullable::String,
+    'requestId'    => String,
+    'timestamp'    => Time
+  }
+
+
+  @terminate_instances_format = {
+    'instancesSet'  => [{
+      'currentState' => {'code' => Integer, 'name' => String},
+      'instanceId'    => String,
+      'previousState' => {'code' => Integer, 'name' => String},
+    }],
+    'requestId'     => String
+  }
+
+  tests('success') do
+
+    @instance_id = nil
+    # Use a MS Windows AMI to test #get_password_data
+    @windows_ami = 'ami-ee926087' # Microsoft Windows Server 2008 R2 Base 64-bit
+
+    # Create a keypair for decrypting the password
+    key_name = 'fog-test-key'
+    key = AWS.key_pairs.create(:name => key_name)
+
+    tests("#run_instances").formats(@run_instances_format) do
+      data = AWS[:compute].run_instances(@windows_ami, 1, 1, 'InstanceType' => 't1.micro', 'KeyName' => key_name).body
+      @instance_id = data['instancesSet'].first['instanceId']
+      data
+    end
+
+    server = AWS[:compute].servers.get(@instance_id)
+    while server.nil? do
+      # It may take a moment to get the server after launching it
+      sleep 0.1
+      server = AWS[:compute].servers.get(@instance_id)
+    end
+    server.wait_for { ready? }
+
+    tests("#describe_instances").formats(@describe_instances_format) do
+       AWS[:compute].describe_instances.body
+    end
+
+    # Launch another instance to test filters
+    another_server = AWS[:compute].servers.create
+
+    tests("#describe_instances('instance-id' => '#{@instance_id}')").formats(@describe_instances_format) do
+      body = AWS[:compute].describe_instances('instance-id' => @instance_id).body
+      tests("returns 1 instance").returns(1) { body['reservationSet'].size }
+      body
+    end
+
+    another_server.destroy
+
+    tests("#get_console_output('#{@instance_id}')").formats(@get_console_output_format) do
+      AWS[:compute].get_console_output(@instance_id).body
+    end
+
+    tests("#get_password_data('#{@instance_id}')").formats(@get_password_data_format) do
+      result = AWS[:compute].get_password_data(@instance_id).body
+
+      tests("key can decrypt passwordData").returns(true) do
+
+        pending if Fog.mocking?
+
+        password_data = result['passwordData']
+        Fog.wait_for do
+          password_data ||= AWS[:compute].get_password_data(@instance_id).body['passwordData']
+        end
+
+        decoded_password = Base64.decode64(password_data)
+        pkey = OpenSSL::PKey::RSA.new(key.private_key)
+        String === pkey.private_decrypt(decoded_password)
+      end
+      result
+    end
+
+    key.destroy
+
+    tests("#reboot_instances('#{@instance_id}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].reboot_instances(@instance_id).body
+    end
+
+    tests("#terminate_instances('#{@instance_id}')").formats(@terminate_instances_format) do
+      AWS[:compute].terminate_instances(@instance_id).body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_console_output('i-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].get_console_output('i-00000000')
+    end
+
+    tests("#get_password_data('i-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].get_password_data('i-00000000')
+    end
+
+    tests("#reboot_instances('i-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].reboot_instances('i-00000000')
+    end
+
+    tests("#terminate_instances('i-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].terminate_instances('i-00000000')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/key_pair_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/key_pair_tests.rb
new file mode 100644
index 0000000..a4f709d
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/key_pair_tests.rb
@@ -0,0 +1,67 @@
+Shindo.tests('AWS::Compute | key pair requests', ['aws']) do
+
+  tests('success') do
+
+    @keypair_format = {
+      'keyFingerprint'  => String,
+      'keyName'         => String,
+      'requestId'       => String
+    }
+
+    @keypairs_format = {
+      'keySet' => [{
+        'keyFingerprint' => String,
+        'keyName' => String
+      }],
+      'requestId' => String
+    }
+
+    @key_pair_name = 'fog_create_key_pair'
+    @public_key_material = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA1SL+kgze8tvSFW6Tyj3RyZc9iFVQDiCKzjgwn2tS7hyWxaiDhjfY2mBYSZwFdKN+ZdsXDJL4CPutUg4DKoQneVgIC1zuXrlpPbaT0Btu2aFd4qNfJ85PBrOtw2GrWZ1kcIgzZ1mMbQt6i1vhsySD2FEj+5kGHouNxQpI5dFR5K+nGgcTLFGnzb/MPRBk136GVnuuYfJ2I4va/chstThoP8UwnoapRHcBpwTIfbmmL91BsRVqjXZEUT73nxpxFeXXidYwhHio+5dXwE0aM/783B/3cPG6FVoxrBvjoNpQpAcEyjtRh9lpwHZtSEW47WNzpIW3PhbQ8j4MryznqF1Rhw=='
+
+    tests("#create_key_pair('#{@key_pair_name}')").formats(@keypair_format.merge({'keyMaterial' => String})) do
+      body = AWS[:compute].create_key_pair(@key_pair_name).body
+      tests("key material").returns(OpenSSL::PKey::RSA, "is a valid private RSA key") do
+        OpenSSL::PKey::RSA.new(body['keyMaterial']).class
+      end
+      body
+    end
+
+    tests('#describe_key_pairs').formats(@keypairs_format) do
+      AWS[:compute].describe_key_pairs.body
+    end
+
+    tests("#describe_key_pairs('key-name' => '#{@key_pair_name}')").formats(@keypairs_format) do
+      AWS[:compute].describe_key_pairs('key-name' => @key_pair_name).body
+    end
+
+    tests("#delete_key_pair('#{@key_pair_name}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].delete_key_pair(@key_pair_name).body
+    end
+
+    tests("#import_key_pair('fog_import_key_pair', '#{@public_key_material}')").formats(@keypair_format) do
+      AWS[:compute].import_key_pair('fog_import_key_pair', @public_key_material).body
+    end
+
+    tests("#delete_key_pair('fog_import_key_pair)").succeeds do
+      AWS[:compute].delete_key_pair('fog_import_key_pair')
+    end
+
+    tests("#delete_key_pair('not_a_key_name')").succeeds do
+      AWS[:compute].delete_key_pair('not_a_key_name')
+    end
+
+  end
+  tests('failure') do
+
+    @key_pair = AWS[:compute].key_pairs.create(:name => 'fog_key_pair')
+
+    tests("duplicate #create_key_pair('#{@key_pair.name}')").raises(Fog::AWS::Compute::Error) do
+      AWS[:compute].create_key_pair(@key_pair.name)
+    end
+
+    @key_pair.destroy
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/region_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/region_tests.rb
new file mode 100644
index 0000000..81e5fe6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/region_tests.rb
@@ -0,0 +1,23 @@
+Shindo.tests('AWS::Compute | region requests', ['aws']) do
+
+  @regions_format = {
+    'regionInfo'  => [{
+      'regionEndpoint'  => String,
+      'regionName'      => String
+    }],
+    'requestId'   => String
+  }
+
+  tests('success') do
+
+    tests("#describe_regions").formats(@regions_format) do
+      AWS[:compute].describe_regions.body
+    end
+
+    tests("#describe_regions('region-name' => 'us-east-1')").formats(@regions_format) do
+      AWS[:compute].describe_regions('region-name' => 'us-east-1').body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/security_group_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/security_group_tests.rb
new file mode 100644
index 0000000..6188d47
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/security_group_tests.rb
@@ -0,0 +1,141 @@
+Shindo.tests('AWS::Compute | security group requests', ['aws']) do
+
+  @security_groups_format = {
+    'requestId'           => String,
+    'securityGroupInfo' => [{
+      'groupDescription'  => String,
+      'groupName'         => String,
+      'ipPermissions'     => [{
+        'fromPort'    => Integer,
+        'groups'      => [{ 'groupName' => String, 'userId' => String }],
+        'ipProtocol'  => String,
+        'ipRanges'    => [],
+        'toPort'      => Integer,
+      }],
+      'ownerId'           => String
+    }]
+  }
+
+  @owner_id = AWS[:compute].describe_security_groups('group-name' => 'default').body['securityGroupInfo'].first['ownerId']
+
+  tests('success') do
+
+    tests("#create_security_group('fog_security_group', 'tests group')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].create_security_group('fog_security_group', 'tests group').body
+    end
+
+    tests("#authorize_security_group_ingress('fog_security_group', {'FromPort' => 80, 'IpProtocol' => 'tcp', 'toPort' => 80})").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].authorize_security_group_ingress(
+        'fog_security_group',
+        {
+          'FromPort' => 80,
+          'IpProtocol' => 'tcp',
+          'ToPort' => 80,
+        }
+      ).body
+    end
+
+    tests("#authorize_security_group_ingress('fog_security_group', {'SourceSecurityGroupName' => 'fog_security_group', 'SourceSecurityGroupOwnerId' => '#{@owner_id}'})").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].authorize_security_group_ingress(
+        'fog_security_group',
+        {
+          'SourceSecurityGroupName'     => 'fog_security_group',
+          'SourceSecurityGroupOwnerId'  => @owner_id
+        }
+      ).body
+    end
+
+    tests("#describe_security_groups").formats(@security_groups_format) do
+      AWS[:compute].describe_security_groups.body
+    end
+
+    tests("#describe_security_groups('group-name' => 'fog_security_group')").formats(@security_groups_format) do
+      AWS[:compute].describe_security_groups('group-name' => 'fog_security_group').body
+    end
+
+    tests("#revoke_security_group_ingress('fog_security_group', {'FromPort' => 80, 'IpProtocol' => 'tcp', 'toPort' => 80})").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].revoke_security_group_ingress(
+        'fog_security_group',
+        {
+          'FromPort' => 80,
+          'IpProtocol' => 'tcp',
+          'ToPort' => 80,
+        }
+      ).body
+    end
+
+    tests("#revoke_security_group_ingress('fog_security_group', {'SourceSecurityGroupName' => 'fog_security_group', 'SourceSecurityGroupOwnerId' => '#{@owner_id}'})").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].revoke_security_group_ingress(
+      'fog_security_group',
+        {
+          'GroupName'                   => 'fog_security_group',
+          'SourceSecurityGroupName'     => 'fog_security_group',
+          'SourceSecurityGroupOwnerId'  => @owner_id
+        }
+      ).body
+    end
+
+    tests("#delete_security_group('fog_security_group')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].delete_security_group('fog_security_group').body
+    end
+
+  end
+  tests('failure') do
+
+    @security_group = AWS[:compute].security_groups.create(:description => 'tests group', :name => 'fog_security_group')
+
+    tests("duplicate #create_security_group(#{@security_group.name}, #{@security_group.description})").raises(Fog::AWS::Compute::Error) do
+      AWS[:compute].create_security_group(@security_group.name, @security_group.description)
+    end
+
+    tests("#authorize_security_group_ingress('not_a_group_name', {'FromPort' => 80, 'IpProtocol' => 'tcp', 'toPort' => 80})").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].authorize_security_group_ingress(
+        'not_a_group_name',
+        {
+          'FromPort' => 80,
+          'IpProtocol' => 'tcp',
+          'ToPort' => 80,
+        }
+      )
+    end
+
+    tests("#authorize_security_group_ingress('not_a_group_name', {'SourceSecurityGroupName' => 'not_a_group_name', 'SourceSecurityGroupOwnerId' => '#{@owner_id}'})").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].authorize_security_group_ingress(
+        'not_a_group_name',
+        {
+          'SourceSecurityGroupName'     => 'not_a_group_name',
+          'SourceSecurityGroupOwnerId'  => @owner_id
+        }
+      )
+    end
+
+    tests("#revoke_security_group_ingress('not_a_group_name', {'FromPort' => 80, 'IpProtocol' => 'tcp', 'toPort' => 80})").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].revoke_security_group_ingress(
+        'not_a_group_name',
+        {
+          'FromPort' => 80,
+          'IpProtocol' => 'tcp',
+          'ToPort' => 80,
+        }
+      )
+    end
+
+    tests("#revoke_security_group_ingress('not_a_group_name', {'SourceSecurityGroupName' => 'not_a_group_name', 'SourceSecurityGroupOwnerId' => '#{@owner_id}'})").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].revoke_security_group_ingress(
+        'not_a_group_name',
+        {
+          'SourceSecurityGroupName'     => 'not_a_group_name',
+          'SourceSecurityGroupOwnerId'  => @owner_id
+        }
+      )
+    end
+
+    tests("#delete_security_group('not_a_group_name')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].delete_security_group('not_a_group_name')
+    end
+
+    @security_group.destroy
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/snapshot_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/snapshot_tests.rb
new file mode 100644
index 0000000..ecd9e88
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/snapshot_tests.rb
@@ -0,0 +1,57 @@
+Shindo.tests('AWS::Compute | snapshot requests', ['aws']) do
+
+  @snapshot_format = {
+    'description' => Fog::Nullable::String,
+    'ownerId'     => String,
+    'progress'    => String,
+    'snapshotId'  => String,
+    'startTime'   => Time,
+    'status'      => String,
+    'volumeId'    => String,
+    'volumeSize'  => Integer
+  }
+
+  @snapshots_format = {
+    'requestId'   => String,
+    'snapshotSet' => [@snapshot_format.merge('tagSet' => {})]
+  }
+
+  @volume = AWS[:compute].volumes.create(:availability_zone => 'us-east-1a', :size => 1)
+
+  tests('success') do
+
+    @snapshot_id = nil
+
+    tests("#create_snapshot(#{@volume.identity})").formats(@snapshot_format.merge('progress' => NilClass, 'requestId' => String)) do
+      data = AWS[:compute].create_snapshot(@volume.identity).body
+      @snapshot_id = data['snapshotId']
+      data
+    end
+
+    Fog.wait_for { AWS[:compute].snapshots.get(@snapshot_id) }
+    AWS[:compute].snapshots.get(@snapshot_id).wait_for { ready? }
+
+    tests("#describe_snapshots").formats(@snapshots_format) do
+      AWS[:compute].describe_snapshots.body
+    end
+
+    tests("#describe_snapshots('snapshot-id' => '#{@snapshot_id}')").formats(@snapshots_format) do
+      AWS[:compute].describe_snapshots('snapshot-id' => @snapshot_id).body
+    end
+
+    tests("#delete_snapshots(#{@snapshot_id})").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].delete_snapshot(@snapshot_id).body
+    end
+
+  end
+  tests ('failure') do
+
+    tests("#delete_snapshot('snap-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].delete_snapshot('snap-00000000')
+    end
+
+  end
+
+  @volume.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/tag_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/tag_tests.rb
new file mode 100644
index 0000000..84945a8
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/tag_tests.rb
@@ -0,0 +1,49 @@
+Shindo.tests('AWS::Compute | tag requests', ['aws']) do
+
+  @tags_format = {
+    'tagSet'    => [{
+      'key'          => String,
+      'resourceId'   => String,
+      'resourceType' => String,
+      'value'        => Fog::Nullable::String
+    }],
+    'requestId' => String
+  }
+
+  @volume = AWS[:compute].volumes.create(:availability_zone => 'us-east-1a', :size => 1)
+  @volume.wait_for { ready? }
+
+  tests('success') do
+
+    tests("#create_tags('#{@volume.identity}', 'foo' => 'bar')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].create_tags(@volume.identity, 'foo' => 'bar').body
+    end
+
+    tests('#describe_tags').formats(@tags_format) do
+      pending if Fog.mocking?
+      AWS[:compute].describe_tags.body
+    end
+
+    tests("#delete_tags('#{@volume.identity}', 'foo' => 'bar')").formats(AWS::Compute::Formats::BASIC) do
+      pending if Fog.mocking?
+      AWS[:compute].delete_tags(@volume.identity, 'foo' => 'bar').body
+    end
+
+    tests("#delete_tags('vol-00000000', 'baz' => 'qux')").succeeds do
+      pending if Fog.mocking?
+      AWS[:compute].delete_tags('vol-00000000', 'baz' => 'qux')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#create_tags('vol-00000000', 'baz' => 'qux')").raises(Fog::Service::NotFound) do
+      AWS[:compute].create_tags('vol-00000000', 'baz' => 'qux')
+    end
+
+  end
+
+  @volume.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/aws/volume_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/aws/volume_tests.rb
new file mode 100644
index 0000000..610ce8c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/aws/volume_tests.rb
@@ -0,0 +1,102 @@
+Shindo.tests('AWS::Compute | volume requests', ['aws']) do
+
+  @volume_format = {
+    'availabilityZone'  => String,
+    'createTime'        => Time,
+    'requestId'         => String,
+    'size'              => Integer,
+    'snapshotId'        => Fog::Nullable::String,
+    'status'            => String,
+    'volumeId'          => String
+  }
+
+  @volume_attachment_format = {
+    'attachTime'  => Time,
+    'device'      => String,
+    'instanceId'  => String,
+    'requestId'   => String,
+    'status'      => String,
+    'volumeId'    => String
+  }
+
+  @volumes_format = {
+    'volumeSet' => [{
+      'availabilityZone'  => String,
+      'attachmentSet'     => Array,
+      'createTime'        => Time,
+      'size'              => Integer,
+      'snapshotId'        => Fog::Nullable::String,
+      'status'            => String,
+      'tagSet'            => Hash,
+      'volumeId'          => String
+    }],
+    'requestId' => String
+  }
+
+  @server = AWS[:compute].servers.create
+  @server.wait_for { ready? }
+
+  tests('success') do
+
+    @volume_id = nil
+
+    tests('#create_volume').formats(@volume_format) do
+      data = AWS[:compute].create_volume(@server.availability_zone, 1).body
+      @volume_id = data['volumeId']
+      data
+    end
+
+    AWS[:compute].volumes.get(@volume_id).wait_for { ready? }
+
+    tests('#describe_volumes').formats(@volumes_format) do
+      AWS[:compute].describe_volumes.body
+    end
+
+    tests("#describe_volumes('volume-id' => #{@volume_id})").formats(@volumes_format) do
+      AWS[:compute].describe_volumes('volume-id' => @volume_id).body
+    end
+
+    tests("#attach_volume(#{@server.identity}, #{@volume_id}, '/dev/sdh')").formats(@volume_attachment_format) do
+      AWS[:compute].attach_volume(@server.identity, @volume_id, '/dev/sdh').body
+    end
+
+    AWS[:compute].volumes.get(@volume_id).wait_for { state == 'in-use' }
+
+    tests("#detach_volume('#{@volume_id}')").formats(@volume_attachment_format) do
+      AWS[:compute].detach_volume(@volume_id).body
+    end
+
+    AWS[:compute].volumes.get(@volume_id).wait_for { ready? }
+
+    tests("#delete_volume('#{@volume_id}')").formats(AWS::Compute::Formats::BASIC) do
+      AWS[:compute].delete_volume(@volume_id).body
+    end
+
+  end
+  tests ('failure') do
+
+    @volume = AWS[:compute].volumes.create(:availability_zone => @server.availability_zone, :size => 1)
+
+    tests("#attach_volume('i-00000000', '#{@volume.identity}', '/dev/sdh')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].attach_volume('i-00000000', @volume.identity, '/dev/sdh')
+    end
+
+    tests("#attach_volume('#{@server.identity}', 'vol-00000000', '/dev/sdh')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].attach_volume(@server.identity, 'vol-00000000', '/dev/sdh')
+    end
+
+    tests("#detach_volume('vol-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].detach_volume('vol-00000000')
+    end
+
+    tests("#delete_volume('vol-00000000')").raises(Fog::AWS::Compute::NotFound) do
+      AWS[:compute].delete_volume('vol-00000000')
+    end
+
+    @volume.destroy
+
+  end
+
+  @server.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/bluebox/block_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/bluebox/block_tests.rb
new file mode 100644
index 0000000..6258f94
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/bluebox/block_tests.rb
@@ -0,0 +1,81 @@
+Shindo.tests('Bluebox::Compute | block requests', ['bluebox']) do
+
+  @block_format = {
+    'cpu'             => Float,
+    'description'     => String,
+    'hostname'        => String,
+    'id'              => String,
+    'ips'             => [{'address' => String}],
+    'lb_applications' => [],
+    'memory'          => Integer,
+    'product'         => Bluebox::Compute::Formats::PRODUCT,
+    'status'          => String,
+    'storage'         => Integer,
+    'template'        => String
+  }
+
+  tests('success') do
+
+    @product_id   = '94fd37a7-2606-47f7-84d5-9000deda52ae' # 1 GB
+    @template_id  = compute_providers[Bluebox][:server_attributes][:image_id]
+    @password     = 'chunkybacon'
+
+    @block_id = nil
+
+    tests("create_block('#{@product_id}', '#{@template_id}', {'password' => '#{@password}'})").formats(@block_format.merge('add_to_lb_application_results' => {'text' => String})) do
+      pending if Fog.mocking?
+      data = Bluebox[:compute].create_block(@product_id, @template_id, {'password' => @password}).body
+      @block_id = data['id']
+      data
+    end
+
+    unless Fog.mocking?
+      Bluebox[:compute].servers.get(@block_id).wait_for { ready? }
+    end
+
+    tests("get_block('#{@block_id}')").formats(@block_format) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_block(@block_id).body
+    end
+
+    tests("get_blocks").formats([@block_format.reject {|key,value| ['product', 'template'].include?(key)}]) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_blocks.body
+    end
+
+    tests("reboot_block('#{@block_id}')").formats({'status' => String, 'text' => String}) do
+      pending if Fog.mocking?
+      Bluebox[:compute].reboot_block(@block_id).body
+    end
+
+    unless Fog.mocking?
+      Bluebox[:compute].servers.get(@block_id).wait_for { ready? }
+    end
+
+    tests("destroy_block('#{@block_id})'").formats({'text' => String}) do
+      pending if Fog.mocking?
+      Bluebox[:compute].destroy_block(@block_id).body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("get_block('00000000-0000-0000-0000-000000000000')").raises(Fog::Bluebox::Compute::NotFound) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_block('00000000-0000-0000-0000-000000000000')
+    end
+
+    tests("reboot_block('00000000-0000-0000-0000-000000000000')").raises(Fog::Bluebox::Compute::NotFound) do
+      pending if Fog.mocking?
+      Bluebox[:compute].reboot_block('00000000-0000-0000-0000-000000000000')
+    end
+
+    tests("destroy_block('00000000-0000-0000-0000-000000000000')").raises(Fog::Bluebox::Compute::NotFound) do
+      pending if Fog.mocking?
+      Bluebox[:compute].destroy_block('00000000-0000-0000-0000-000000000000')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/bluebox/helper.rb b/vendor/fog-0.8.2/tests/compute/requests/bluebox/helper.rb
new file mode 100644
index 0000000..b088e5c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/bluebox/helper.rb
@@ -0,0 +1,17 @@
+class Bluebox
+
+  module Compute
+
+    module Formats
+
+      PRODUCT = {
+        'cost'        => Float,
+        'description' => String,
+        'id'          => String
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/bluebox/product_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/bluebox/product_tests.rb
new file mode 100644
index 0000000..2c0df25
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/bluebox/product_tests.rb
@@ -0,0 +1,28 @@
+Shindo.tests('Bluebox::Compute | product requests', ['bluebox']) do
+
+  tests('success') do
+
+    @product_id   = '94fd37a7-2606-47f7-84d5-9000deda52ae' # 1 GB
+
+    tests("get_product('#{@product_id}')").formats(Bluebox::Compute::Formats::PRODUCT) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_product(@product_id).body
+    end
+
+    tests("get_products").formats([Bluebox::Compute::Formats::PRODUCT]) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_products.body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("get_product('00000000-0000-0000-0000-000000000000')").raises(Fog::Bluebox::Compute::NotFound) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_product('00000000-0000-0000-0000-000000000000')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/bluebox/template_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/bluebox/template_tests.rb
new file mode 100644
index 0000000..f3e0075
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/bluebox/template_tests.rb
@@ -0,0 +1,35 @@
+Shindo.tests('Bluebox::Compute | template requests', ['bluebox']) do
+
+  @template_format = {
+    'created'     => String,
+    'description' => String,
+    'id'          => String,
+    'public'      => Fog::Boolean
+  }
+
+  tests('success') do
+
+    @template_id  = 'a00baa8f-b5d0-4815-8238-b471c4c4bf72' # Ubuntu 9.10 64bit
+
+    tests("get_template('#{@template_id}')").formats(@template_format) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_template(@template_id).body
+    end
+
+    tests("get_templates").formats([@template_format]) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_templates.body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("get_template('00000000-0000-0000-0000-000000000000')").raises(Fog::Bluebox::Compute::NotFound) do
+      pending if Fog.mocking?
+      Bluebox[:compute].get_template('00000000-0000-0000-0000-000000000000')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/account_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/account_tests.rb
new file mode 100644
index 0000000..4cdb0d3
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/account_tests.rb
@@ -0,0 +1,40 @@
+Shindo.tests('Brightbox::Compute | account requests', ['brightbox']) do
+
+  tests('success') do
+
+    tests("#get_account").formats(Brightbox::Compute::Formats::Full::ACCOUNT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_account
+    end
+
+    unless Fog.mocking?
+      original_name = Brightbox[:compute].get_account["name"]
+      update_args = {:name => "New name from Fog test"}
+    end
+
+    tests("#update_account(#{update_args.inspect})").formats(Brightbox::Compute::Formats::Full::ACCOUNT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_account(update_args)
+    end
+
+    unless Fog.mocking?
+      Brightbox[:compute].update_account(:name => original_name)
+    end
+
+    tests("#reset_ftp_password_account").formats(Brightbox::Compute::Formats::Full::ACCOUNT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].reset_ftp_password_account
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#update_account").returns(nil) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_account
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/api_client_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/api_client_tests.rb
new file mode 100644
index 0000000..5b0fda9
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/api_client_tests.rb
@@ -0,0 +1,49 @@
+Shindo.tests('Brightbox::Compute | api client requests', ['brightbox']) do
+
+  tests('success') do
+
+    create_options = {:name => "Name from Fog test (#{Time.now.to_i})", :description => "Description from Fog test"}
+
+    tests("#create_api_client(#{create_options.inspect})").formats(Brightbox::Compute::Formats::Full::API_CLIENT) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].create_api_client(create_options)
+      @api_client_id = data["id"]
+      data
+    end
+
+    tests("#list_api_clients").formats(Brightbox::Compute::Formats::Collection::API_CLIENTS) do
+      pending if Fog.mocking?
+      Brightbox[:compute].list_api_clients
+    end
+
+    tests("#get_api_client('#{@api_client_id}')").formats(Brightbox::Compute::Formats::Full::API_CLIENT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_api_client(@api_client_id)
+    end
+
+    tests("#update_api_client('#{@api_client_id}')").formats(Brightbox::Compute::Formats::Full::API_CLIENT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_api_client(@api_client_id, :name => "New name from Fog test")
+    end
+
+    tests("#destroy_api_client('#{@api_client_id}')").formats(Brightbox::Compute::Formats::Full::API_CLIENT) do
+      pending if Fog.mocking?
+      Brightbox[:compute].destroy_api_client(@api_client_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_api_client('cli-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_api_client('cli-00000')
+    end
+
+    tests("#get_api_client").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_api_client
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/cloud_ip_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/cloud_ip_tests.rb
new file mode 100644
index 0000000..e376032
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/cloud_ip_tests.rb
@@ -0,0 +1,71 @@
+Shindo.tests('Brightbox::Compute | cloud ip requests', ['brightbox']) do
+
+  tests('success') do
+
+    unless Fog.mocking?
+      @server = Brightbox[:compute].servers.create(compute_providers[Brightbox][:server_attributes])
+    end
+
+    tests("#create_cloud_ip").formats(Brightbox::Compute::Formats::Full::CLOUD_IP) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].create_cloud_ip
+      @cloud_ip_id = data["id"]
+      data
+    end
+
+    tests("#list_cloud_ips").formats(Brightbox::Compute::Formats::Collection::CLOUD_IPS) do
+      pending if Fog.mocking?
+      Brightbox[:compute].list_cloud_ips
+    end
+
+    tests("#get_cloud_ip('#{@cloud_ip_id}')").formats(Brightbox::Compute::Formats::Full::CLOUD_IP) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_cloud_ip(@cloud_ip_id)
+    end
+
+    unless Fog.mocking?
+      @server.wait_for { ready? }
+      map_options = {:interface => @server.interfaces.first["id"]}
+    end
+
+    tests("#map_cloud_ip('#{@cloud_ip_id}', #{map_options.inspect})").formats(Brightbox::Compute::Formats::Full::CLOUD_IP) do
+      pending if Fog.mocking?
+      Brightbox[:compute].map_cloud_ip(@cloud_ip_id, map_options)
+    end
+
+    unless Fog.mocking?
+      Brightbox[:compute].cloud_ips.get(@cloud_ip_id).wait_for { mapped? }
+    end
+
+    tests("#unmap_cloud_ip('#{@cloud_ip_id}')").formats(Brightbox::Compute::Formats::Full::CLOUD_IP) do
+      pending if Fog.mocking?
+      Brightbox[:compute].unmap_cloud_ip(@cloud_ip_id)
+    end
+
+    tests("#destroy_cloud_ip('#{@cloud_ip_id}')").formats(Brightbox::Compute::Formats::Full::CLOUD_IP) do
+      pending if Fog.mocking?
+      Brightbox[:compute].destroy_cloud_ip(@cloud_ip_id)
+    end
+
+    unless Fog.mocking?
+      @server.destroy
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_cloud_ip('cip-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_cloud_ip('cip-00000')
+    end
+
+    tests("#get_cloud_ip").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_cloud_ip
+    end
+
+  end
+
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/helper.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/helper.rb
new file mode 100644
index 0000000..e5069df
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/helper.rb
@@ -0,0 +1,421 @@
+module Fog
+  module Brightbox
+    module Nullable
+      module Account; end
+      module Image; end
+      module Interface; end
+      module LoadBalancer; end
+      module Server; end
+      module Zone; end
+    end
+  end
+end
+
+Hash.send :include, Fog::Brightbox::Nullable::Account
+NilClass.send :include, Fog::Brightbox::Nullable::Account
+
+Hash.send :include, Fog::Brightbox::Nullable::Image
+NilClass.send :include, Fog::Brightbox::Nullable::Image
+
+Hash.send :include, Fog::Brightbox::Nullable::Interface
+NilClass.send :include, Fog::Brightbox::Nullable::Interface
+
+Hash.send :include, Fog::Brightbox::Nullable::LoadBalancer
+NilClass.send :include, Fog::Brightbox::Nullable::LoadBalancer
+
+Hash.send :include, Fog::Brightbox::Nullable::Server
+NilClass.send :include, Fog::Brightbox::Nullable::Server
+
+Hash.send :include, Fog::Brightbox::Nullable::Zone
+NilClass.send :include, Fog::Brightbox::Nullable::Zone
+
+class Brightbox
+  module Compute
+    module TestSupport
+      IMAGE_IDENTIFER = "img-2ab98" # Ubuntu Lucid 10.04 server (i686)
+    end
+    module Formats
+      module Struct
+        LB_LISTENER = {
+          "in"              => Integer,
+          "out"             => Integer,
+          "protocol"        => String
+        }
+        LB_HEALTHCHECK = {
+          "type"            => String,
+          "request"         => String,
+          "port"            => Integer,
+          "interval"        => Integer,
+          "timeout"         => Integer,
+          "threshold_up"    => Integer,
+          "threshold_down"  => Integer
+        }
+      end
+
+      module Nested
+        ACCOUNT = {
+          "name"            => String,
+          "ram_used"        => Integer,
+          "resource_type"   => String,
+          "ram_limit"       => Integer,
+          "url"             => String,
+          "id"              => String,
+          "status"          => String,
+          "limits_cloudips" => Integer
+        }
+
+        API_CLIENT = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "description"     => String
+        }
+
+        CLOUD_IP = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "public_ip"       => String,
+          "status"          => String,
+          "reverse_dns"     => String
+        }
+
+        IMAGE = {
+          "name"            => String,
+          "created_at"      => String,
+          "resource_type"   => String,
+          "arch"            => String,
+          "url"             => String,
+          "id"              => String,
+          "description"     => String,
+          "source"          => String,
+          "status"          => String,
+          "owner"           => String
+        }
+
+        INTERFACE = {
+          "resource_type"   => String,
+          "url"             => String,
+          "id"              => String,
+          "ipv4_address"    => String,
+          "mac_address"     => String
+        }
+
+        SERVER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "hostname"        => String,
+          "created_at"      => String,
+          "started_at"      => Fog::Nullable::String,
+          "deleted_at"      => Fog::Nullable::String
+        }
+
+        SERVER_TYPE = {
+          "name"            => String,
+          "handle"          => Fog::Nullable::String,
+          "cores"           => Integer,
+          "resource_type"   => String,
+          "disk_size"       => Integer,
+          "url"             => String,
+          "id"              => String,
+          "ram"             => Integer,
+          "status"          => String
+        }
+
+        USER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "email_address"   => String
+        }
+
+        ZONE = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "handle"          => Fog::Nullable::String
+        }
+      end
+
+      module Collected
+        API_CLIENT = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "description"     => String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT
+        }
+
+        CLOUD_IP = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "public_ip"       => String,
+          "status"          => String,
+          "reverse_dns"     => String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT,
+          "interface"       => Fog::Brightbox::Nullable::Interface,
+          "load_balancer"   => Fog::Brightbox::Nullable::LoadBalancer,
+          "server"          => Fog::Nullable::String
+        }
+
+        IMAGE = {
+          "name"            => String,
+          "created_at"      => String,
+          "resource_type"   => String,
+          "arch"            => String,
+          "url"             => String,
+          "id"              => String,
+          "description"     => String,
+          "source"          => String,
+          "source_type"     => String,
+          "status"          => String,
+          "owner"           => String,
+          "public"          => Fog::Boolean,
+          "official"        => Fog::Boolean,
+          "compatibility_mode" => Fog::Boolean,
+          "virtual_size"    => Integer,
+          "disk_size"       => Integer,
+          "ancestor"        => Fog::Brightbox::Nullable::Image
+        }
+
+        LOAD_BALANCER = {
+          "cloud_ips"       => Array,
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "created_at"      => String,
+          "deleted_at"      => Fog::Nullable::String
+        }
+
+        SERVER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "hostname"        => String,
+          "created_at"      => String,
+          "started_at"      => Fog::Nullable::String,
+          "deleted_at"      => Fog::Nullable::String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT,
+          "server_type"     => Brightbox::Compute::Formats::Nested::SERVER_TYPE,
+          "cloud_ips"       => [Brightbox::Compute::Formats::Nested::CLOUD_IP],
+          "image"           => Brightbox::Compute::Formats::Nested::IMAGE,
+          "snapshots"       => [Brightbox::Compute::Formats::Nested::IMAGE],
+          "interfaces"      => [Brightbox::Compute::Formats::Nested::INTERFACE],
+          "zone"            => Fog::Brightbox::Nullable::Zone
+        }
+
+        SERVER_TYPE = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "handle"          => Fog::Nullable::String,
+          "name"            => String,
+          "status"          => String,
+          "cores"           => Integer,
+          "ram"             => Integer,
+          "disk_size"       => Integer
+        }
+
+        USER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "email_address"   => String,
+          "email_verified"  => Fog::Boolean,
+          "accounts"        => [Brightbox::Compute::Formats::Nested::ACCOUNT],
+          "default_account" => NilClass
+        }
+
+        ZONE = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "handle"          => Fog::Nullable::String
+        }
+      end
+
+      module Full
+        ACCOUNT = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "address_1"       => String,
+          "address_2"       => String,
+          "city"            => String,
+          "county"          => String,
+          "postcode"        => String,
+          "country_code"    => String,
+          "country_name"    => String,
+          "vat_registration_number" => Fog::Nullable::String,
+          "telephone_number" => String,
+          "telephone_verified" => Fog::Boolean,
+          "created_at"      => String,
+          "ram_limit"       => Integer,
+          "ram_used"        => Integer,
+          "limits_cloudips" => Integer,
+          "library_ftp_host" => String,
+          "library_ftp_user" => String,
+          "library_ftp_password" => Fog::Nullable::String,
+          "verified_telephone" => Fog::Nullable::Boolean,
+          "verified_at"     => Fog::Nullable::Time,
+          "verified_ip"     => Fog::Nullable::String,
+          "owner"           => Brightbox::Compute::Formats::Nested::USER,
+          "users"           => [Brightbox::Compute::Formats::Nested::USER],
+          "clients"         => [Brightbox::Compute::Formats::Nested::API_CLIENT],
+          "servers"         => [Brightbox::Compute::Formats::Nested::SERVER],
+          "images"          => [Brightbox::Compute::Formats::Nested::IMAGE],
+          "zones"           => [Brightbox::Compute::Formats::Nested::ZONE]
+        }
+
+        API_CLIENT = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "description"     => String,
+          "secret"          => Fog::Nullable::String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT
+        }
+
+        CLOUD_IP = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "public_ip"       => String,
+          "status"          => String,
+          "reverse_dns"     => String,
+          "account"         => Fog::Brightbox::Nullable::Account,
+          "interface"       => Fog::Brightbox::Nullable::Interface,
+          "load_balancer"   => Fog::Brightbox::Nullable::LoadBalancer,
+          "server"          => Fog::Brightbox::Nullable::Server
+        }
+
+        IMAGE = {
+          "name"            => String,
+          "created_at"      => String,
+          "resource_type"   => String,
+          "arch"            => String,
+          "url"             => String,
+          "id"              => String,
+          "description"     => String,
+          "source"          => String,
+          "source_type"     => String,
+          "status"          => String,
+          "owner"           => String, # Account ID not object
+          "public"          => Fog::Boolean,
+          "official"        => Fog::Boolean,
+          "compatibility_mode"   => Fog::Boolean,
+          "virtual_size"    => Integer,
+          "disk_size"       => Integer,
+          "ancestor"        => Fog::Brightbox::Nullable::Image
+        }
+
+        INTERFACE = {
+          "resource_type"   => String,
+          "url"             => String,
+          "id"              => String,
+          "ipv4_address"    => String,
+          "mac_address"     => String,
+          "server"          => Brightbox::Compute::Formats::Nested::SERVER
+        }
+
+        LOAD_BALANCER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "listeners"       => [Brightbox::Compute::Formats::Struct::LB_LISTENER],
+          "policy"          => String,
+          "healthcheck"     => Brightbox::Compute::Formats::Struct::LB_HEALTHCHECK,
+          "created_at"      => String,
+          "deleted_at"      => Fog::Nullable::String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT,
+          "nodes"           => [Brightbox::Compute::Formats::Nested::SERVER],
+          "cloud_ips"       => [Brightbox::Compute::Formats::Nested::CLOUD_IP]
+        }
+
+        SERVER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "status"          => String,
+          "hostname"        => String,
+          "created_at"      => String,
+          "started_at"      => Fog::Nullable::String,
+          "deleted_at"      => Fog::Nullable::String,
+          "user_data"       => Fog::Nullable::String,
+          "console_url"     => Fog::Nullable::String,
+          "console_token"   => Fog::Nullable::String,
+          "console_token_expires" => Fog::Nullable::String,
+          "account"         => Brightbox::Compute::Formats::Nested::ACCOUNT,
+          "server_type"     => Brightbox::Compute::Formats::Nested::SERVER_TYPE,
+          "cloud_ips"       => [Brightbox::Compute::Formats::Nested::CLOUD_IP],
+          "image"           => Brightbox::Compute::Formats::Nested::IMAGE,
+          "snapshots"       => [Brightbox::Compute::Formats::Nested::IMAGE],
+          "interfaces"      => [Brightbox::Compute::Formats::Nested::INTERFACE],
+          "zone"            => Brightbox::Compute::Formats::Nested::ZONE
+        }
+
+        SERVER_TYPE = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "handle"          => Fog::Nullable::String,
+          "name"            => String,
+          "status"          => String,
+          "cores"           => Integer,
+          "ram"             => Integer,
+          "disk_size"       => Integer
+        }
+
+        USER = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "name"            => String,
+          "email_address"   => String,
+          "email_verified"  => Fog::Boolean,
+          "accounts"        => [Brightbox::Compute::Formats::Nested::ACCOUNT],
+          "default_account" => Fog::Brightbox::Nullable::Account,
+          "ssh_key"         => Fog::Nullable::String
+        }
+
+        ZONE = {
+          "id"              => String,
+          "resource_type"   => String,
+          "url"             => String,
+          "handle"          => String
+        }
+
+      end
+
+      module Collection
+        API_CLIENTS = [Brightbox::Compute::Formats::Collected::API_CLIENT]
+        CLOUD_IPS = [Brightbox::Compute::Formats::Collected::CLOUD_IP]
+        IMAGES = [Brightbox::Compute::Formats::Collected::IMAGE]
+        LOAD_BALANCERS = [Brightbox::Compute::Formats::Collected::LOAD_BALANCER]
+        SERVERS = [Brightbox::Compute::Formats::Collected::SERVER]
+        SERVER_TYPES = [Brightbox::Compute::Formats::Collected::SERVER_TYPE]
+        USERS = [Brightbox::Compute::Formats::Collected::USER]
+        ZONES = [Brightbox::Compute::Formats::Collected::ZONE]
+      end
+
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/image_tests.rb
new file mode 100644
index 0000000..7718b6d
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/image_tests.rb
@@ -0,0 +1,57 @@
+Shindo.tests('Brightbox::Compute | image requests', ['brightbox']) do
+
+  tests('success') do
+
+    ## Difficult to test without having uploaded an Image to your account to register
+    # creation_options = {
+    #   "arch" => "i686",
+    #   "source" => "fnord"
+    # }
+    # tests("#create_image(#{creation_options.inspect})").formats(Brightbox::Compute::Formats::Full::IMAGE) do
+    #   data = Brightbox[:compute].create_image(creation_options)
+    #   @image_id = data["id"]
+    #   data
+    # end
+
+    # Brightbox[:compute].images.get(@image_id).wait_for { ready? }
+
+    tests("#list_images").formats(Brightbox::Compute::Formats::Collection::IMAGES) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].list_images
+      @image_id = data.first["id"]
+      data
+    end
+
+    tests("#get_image('#{@image_id}')").formats(Brightbox::Compute::Formats::Full::IMAGE) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_image(@image_id)
+    end
+
+    ## Until Image creation can be automated, we shouldn't be updating Images randomly
+    # update_options = {}
+    # tests("#update_image('#{@image_id}', #{update_options.inspect})").formats(Brightbox::Compute::Formats::Full::IMAGE) do
+    #   Brightbox[:compute].update_image(@image_id, :name => "New name from Fog test")
+    # end
+
+    ## Same as other tests - can't be deleting them unless part of the test run
+    # tests("#destroy_server('#{@image_id}')").formats(Brightbox::Compute::Formats::Full::IMAGE) do
+    #   Brightbox[:compute].destroy_image(@image_id)
+    # end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_image('img-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_image('img-00000')
+    end
+
+    tests("#get_image").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_image
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/interface_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/interface_tests.rb
new file mode 100644
index 0000000..bd426ac
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/interface_tests.rb
@@ -0,0 +1,30 @@
+Shindo.tests('Brightbox::Compute | interface requests', ['brightbox']) do
+
+  tests('success') do
+
+    unless Fog.mocking?
+      server = Brightbox[:compute].servers.first
+      @interface_id = server.interfaces.first["id"]
+    end
+
+    tests("#get_interface('#{@interface_id}')").formats(Brightbox::Compute::Formats::Full::INTERFACE) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_interface(@interface_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_interface('int-00000')").raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_interface('int-00000')
+    end
+
+    tests("#get_interface()").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_interface()
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/load_balancer_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/load_balancer_tests.rb
new file mode 100644
index 0000000..0976aba
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/load_balancer_tests.rb
@@ -0,0 +1,74 @@
+Shindo.tests('Brightbox::Compute | load balancer requests', ['brightbox']) do
+
+  tests('success') do
+
+    unless Fog.mocking?
+      @node = Brightbox[:compute].servers.create(:image_id => Brightbox::Compute::TestSupport::IMAGE_IDENTIFER)
+      node_id = @node.id
+    end
+
+    creation_args = {
+      :nodes => [{
+        :node => node_id
+      }],
+      :listeners => [{
+        :in       => 80,
+        :out      => 8080,
+        :protocol => "http"
+      }],
+      :healthcheck => {
+        :type => "http",
+        :port => 80
+      }
+    }
+
+    tests("#create_load_balancer(#{creation_args.inspect})").formats(Brightbox::Compute::Formats::Full::LOAD_BALANCER) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].create_load_balancer(creation_args)
+      @load_balancer_id = data["id"]
+      data
+    end
+
+    unless Fog.mocking?
+      Brightbox[:compute].load_balancers.get(@load_balancer_id).wait_for { ready? }
+    end
+
+    # tests("#list_load_balancers()").formats(Brightbox::Compute::Formats::Collection::LOAD_BALANCERS) do
+    #   Brightbox[:compute].list_load_balancers
+    # end
+
+    tests("#get_load_balancer('#{@load_balancer_id}')").formats(Brightbox::Compute::Formats::Full::LOAD_BALANCER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_load_balancer(@load_balancer_id)
+    end
+
+    tests("#destroy_load_balancer('#{@load_balancer_id}')").formats(Brightbox::Compute::Formats::Full::LOAD_BALANCER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].destroy_load_balancer(@load_balancer_id)
+    end
+
+    unless Fog.mocking?
+      @node.destroy
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#create_load_balancer").raises(Excon::Errors::BadRequest) do
+      pending if Fog.mocking?
+      Brightbox[:compute].create_load_balancer
+    end
+
+    tests("#get_load_balancer('lba-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_load_balancer('lba-00000')
+    end
+
+    tests("#get_load_balancer").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_load_balancer
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_tests.rb
new file mode 100644
index 0000000..7e55e11
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_tests.rb
@@ -0,0 +1,75 @@
+Shindo.tests('Brightbox::Compute | server requests', ['brightbox']) do
+
+  tests('success') do
+
+    image_id = Brightbox::Compute::TestSupport::IMAGE_IDENTIFER
+    server_id = nil
+
+    tests("#create_server(:image => '#{image_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].create_server(:image => image_id)
+      server_id = data["id"]
+      data
+    end
+
+    unless Fog.mocking?
+      Brightbox[:compute].servers.get(server_id).wait_for { ready? }
+    end
+
+    tests("#list_servers").formats(Brightbox::Compute::Formats::Collection::SERVERS) do
+      pending if Fog.mocking?
+      Brightbox[:compute].list_servers
+    end
+
+    tests("#get_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server(server_id)
+    end
+
+    tests("#update_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_server(server_id, :name => "New name from Fog test")
+    end
+
+    tests("#activate_console_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].activate_console_server(server_id)
+    end
+
+    tests("#stop_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].stop_server(server_id)
+    end
+
+    tests("#start_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].start_server(server_id)
+    end
+
+    tests("#shutdown_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].shutdown_server(server_id)
+    end
+
+    tests("#destroy_server('#{server_id}')").formats(Brightbox::Compute::Formats::Full::SERVER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].destroy_server(server_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_server('srv-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server('srv-00000')
+    end
+
+    tests("#get_server").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_type_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_type_tests.rb
new file mode 100644
index 0000000..29543c6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/server_type_tests.rb
@@ -0,0 +1,33 @@
+Shindo.tests('Brightbox::Compute | server type requests', ['brightbox']) do
+
+  tests('success') do
+
+    tests("#list_server_types").formats(Brightbox::Compute::Formats::Collection::SERVER_TYPES) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].list_server_types
+      @server_type_id = data.first["id"]
+      data
+    end
+
+    tests("#get_server_type('#{@server_type_id}')").formats(Brightbox::Compute::Formats::Full::SERVER_TYPE) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server_type(@server_type_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_server_type('typ-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server_type('typ-00000')
+    end
+
+    tests("#get_server").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_server_type
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/user_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/user_tests.rb
new file mode 100644
index 0000000..7532645
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/user_tests.rb
@@ -0,0 +1,41 @@
+Shindo.tests('Brightbox::Compute | user requests', ['brightbox']) do
+
+  tests('success') do
+
+    tests("#list_users").formats(Brightbox::Compute::Formats::Collection::USERS) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].list_users
+      @user_id = data.first["id"]
+      data
+    end
+
+    tests("#get_user('#{@user_id}')").formats(Brightbox::Compute::Formats::Full::USER) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].get_user(@user_id)
+      @original_name = data["name"]
+      data
+    end
+
+    update_options = { :name => "New name from Fog" }
+
+    tests("#update_user('#{@user_id}', #{update_options.inspect})").formats(Brightbox::Compute::Formats::Full::USER) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_user(@user_id, update_options)
+    end
+
+    unless Fog.mocking?
+      Brightbox[:compute].update_user(@user_id, :name => @original_name)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#update_user").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].update_user
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/brightbox/zone_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/brightbox/zone_tests.rb
new file mode 100644
index 0000000..7e8ae45
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/brightbox/zone_tests.rb
@@ -0,0 +1,33 @@
+Shindo.tests('Brightbox::Compute | zone requests', ['brightbox']) do
+
+  tests('success') do
+
+    tests("#list_zones").formats(Brightbox::Compute::Formats::Collection::ZONES) do
+      pending if Fog.mocking?
+      data = Brightbox[:compute].list_zones
+      @zone_id = data.first["id"]
+      data
+    end
+
+    tests("#get_zone('#{@zone_id}')").formats(Brightbox::Compute::Formats::Full::ZONE) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_zone(@zone_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_zone('zon-00000')").raises(Excon::Errors::NotFound) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_zone('zon-00000')
+    end
+
+    tests("#get_zone").raises(ArgumentError) do
+      pending if Fog.mocking?
+      Brightbox[:compute].get_zone
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/go_grid/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/go_grid/image_tests.rb
new file mode 100644
index 0000000..e69de29
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/datacenter_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/datacenter_tests.rb
new file mode 100644
index 0000000..0b937fe
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/datacenter_tests.rb
@@ -0,0 +1,19 @@
+Shindo.tests('Linode::Compute | datacenter requests', ['linode']) do
+
+  @datacenters_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{ 
+      'DATACENTERID'  => Integer,
+      'LOCATION'      => String
+    }]
+  })
+
+  tests('success') do
+
+    tests('#avail_datacenters').formats(@datacenters_format) do
+      pending if Fog.mocking?
+      Linode[:compute].avail_datacenters.body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/distribution_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/distribution_tests.rb
new file mode 100644
index 0000000..3cf8eb7
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/distribution_tests.rb
@@ -0,0 +1,32 @@
+Shindo.tests('Linode::Compute | distribution requests', ['linode']) do
+
+  @distributions_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{ 
+      'CREATE_DT'           => String,
+      'DISTRIBUTIONID'      => Integer,
+      'IS64BIT'             => Integer,
+      'LABEL'               => String,
+      'MINIMAGESIZE'        => Integer,
+      'REQUIRESPVOPSKERNEL' => Integer
+    }]
+  })
+
+  tests('success') do
+
+    @distribution_id = nil
+
+    tests('#avail_distributions').formats(@distributions_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].avail_distributions.body
+      @distribution_id = data['DATA'].first['DISTRIBUTIONID']
+      data
+    end
+
+    tests("@avail_distributions(#{@distribution_id})").formats(@distributions_format) do
+      pending if Fog.mocking?
+      Linode[:compute].avail_distributions(@distribution_id).body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/helper.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/helper.rb
new file mode 100644
index 0000000..3219853
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/helper.rb
@@ -0,0 +1,16 @@
+class Linode
+
+  module Compute
+
+    module Formats
+
+      BASIC = {
+        'ERRORARRAY'  => [],
+        'ACTION'      => String
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/kernel_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/kernel_tests.rb
new file mode 100644
index 0000000..f44f873
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/kernel_tests.rb
@@ -0,0 +1,27 @@
+Shindo.tests('Linode::Compute | kernel requests', ['linode']) do
+
+  @kernels_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{ 
+      'LABEL'               => String,
+      'ISXEN'               => Integer,
+      'ISPVOPS'             => Integer,
+      'KERNELID'            => Integer
+    }]
+  })
+
+  tests('success') do
+    @kernel_id = nil
+
+    tests('#avail_kernels').formats(@kernels_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].avail_kernels.body
+      @kernel_id = data['DATA'].first['KERNELID']
+      data
+    end
+
+    tests("@avail_kernels(#{@kernel_id})").formats(@kernels_format) do
+      pending if Fog.mocking?
+      Linode[:compute].avail_kernels(@kernel_id).body
+    end
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/linode_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/linode_tests.rb
new file mode 100644
index 0000000..f6d26c6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/linode_tests.rb
@@ -0,0 +1,143 @@
+Shindo.tests('Linode::Compute | linode requests', ['linode']) do
+
+  @linode_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => { 'LinodeID' => Integer }
+  })
+
+  @linodes_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{
+      'ALERT_BWIN_ENABLED'      => Integer,
+      'ALERT_CPU_THRESHOLD'     => Integer,
+      'ALERT_BWOUT_ENABLED'     => Integer,
+      'ALERT_BWOUT_THRESHOLD'   => Integer,
+      'ALERT_BWQUOTA_ENABLED'   => Integer,
+      'ALERT_BWQUOTA_THRESHOLD' => Integer,
+      'ALERT_BWIN_THRESHOLD'    => Integer,
+      'ALERT_CPU_ENABLED'       => Integer,
+      'ALERT_DISKIO_ENABLED'    => Integer,
+      'ALERT_DISKIO_THRESHOLD'  => Integer,
+      'BACKUPSENABLED'          => Integer,
+      'BACKUPWEEKLYDAY'         => Integer,
+      'BACKUPWINDOW'            => Integer,
+      'DATACENTERID'            => Integer,
+      'LABEL'                   => String,
+      'LINODEID'                => Integer,
+      'LPM_DISPLAYGROUP'        => String,
+      'STATUS'                  => Integer,
+      'TOTALHD'                 => Integer,
+      'TOTALRAM'                => Integer,
+      'TOTALXFER'               => Integer,
+      'WATCHDOG'                => Integer,
+    }]
+  })
+
+  @reboot_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => { 'JobID' => Integer }
+  })
+
+  @ip_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => { 'IPAddressID' => Integer }
+  })
+
+  @disks_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{
+      "UPDATE_DT"  => String,
+      "DISKID"     => Integer,
+      "LABEL"      => String,
+      "TYPE"       => String,
+      "LINODEID"   => Integer,
+      "ISREADONLY" => Integer,
+      "STATUS"     => Integer,
+      "CREATE_DT"  => String,
+      "SIZE"       => Integer
+    }]
+  })
+
+  @disk_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => { 'JobID' => Integer, 'DiskID' => Integer }
+  })  
+
+  tests('success') do
+
+    @linode_id = nil
+
+    # (2 => Dallas, TX, USA), (1 => 1 month), (1 => Linode 512)
+    tests('#linode_create(2, 1, 1)').formats(@linode_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].linode_create(2, 1, 1).body
+      @linode_id = data['DATA']['LinodeID']
+      data
+    end
+
+    tests("#linode_list(#{@linode_id})").formats(@linodes_format) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_list(@linode_id).body
+    end
+
+    tests('#linode_list').formats(@linodes_format) do
+      pending if Fog.mocking?      
+      Linode[:compute].linode_list.body
+    end
+
+    tests('#linode_update').formats(@linode_format) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_update(@linode_id, :label => 'testing').body
+    end
+
+    tests('#linode_ip_addprivate').formats(@ip_format) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_ip_addprivate(@linode_id).body
+    end
+
+    tests('#linode_disk_create').formats(@disk_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].linode_disk_create(@linode_id, 'test1', 'ext3', 1).body
+      @disk1_id = data['DATA']['DiskID']
+      data
+    end    
+
+    tests('#linode_disk_createfromdistribution').formats(@disk_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].linode_disk_createfromdistribution(@linode_id, 73, 'test1', 600, 'P@SSW)RD').body
+      @disk2_id = data['DATA']['DiskID']
+      data
+    end
+
+    tests('#linode_disk_list').formats(@disks_format) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_disk_list(@linode_id).body
+    end
+
+    # tests("#linode_reboot(#{@linode_id})").formats(@reboot_format) do
+    #   Linode[:compute].linode_reboot(@linode_id).body
+    # end    
+
+    tests('#linode_disk_delete').formats(@disk_format) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_disk_delete(@linode_id, @disk1_id).body
+      Linode[:compute].linode_disk_delete(@linode_id, @disk2_id).body
+    end
+
+    tests('#linode_delete(#{@linode_id})').succeeds do
+      pending if Fog.mocking?
+      sleep 1 until Linode[:compute].linode_disk_list(@linode_id).body['DATA'].size == 0
+      Linode[:compute].linode_delete(@linode_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#linode_reboot(0)').raises(Fog::Linode::Compute::NotFound) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_reboot(1)
+    end
+
+    tests('#linode_delete(0)').raises(Fog::Linode::Compute::NotFound) do
+      pending if Fog.mocking?
+      Linode[:compute].linode_delete(1)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/linodeplans_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/linodeplans_tests.rb
new file mode 100644
index 0000000..d29eac2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/linodeplans_tests.rb
@@ -0,0 +1,39 @@
+Shindo.tests('Linode::Compute | linodeplans requests', ['linode']) do
+
+  @linodeplans_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{ 
+      'AVAIL' => {
+         '2' => Integer,
+         '3' => Integer,
+         '4' => Integer,
+         '6' => Integer,
+         '7' => Integer
+      },
+      'DISK'    => Integer,
+      'PLANID'  => Integer,
+      'PRICE'   => Float,
+      'RAM'     => Integer,
+      'LABEL'   => String,
+      'XFER'    => Integer
+    }]
+  })
+
+  tests('success') do
+
+    @linodeplan_id = nil
+
+    tests('#avail_linodeplans').formats(@linodeplans_format) do
+      pending if Fog.mocking?
+      data = Linode[:compute].avail_linodeplans.body
+      @linodeplan_id = data['DATA'].first['PLANID']
+      data
+    end
+
+    tests("#avail_linodeplans(#{@linodeplan_id})").formats(@linodeplans_format) do
+      pending if Fog.mocking?
+      Linode[:compute].avail_linodeplans(@linodeplan_id).body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/linode/stackscripts_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/linode/stackscripts_tests.rb
new file mode 100644
index 0000000..07862e4
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/linode/stackscripts_tests.rb
@@ -0,0 +1,35 @@
+Shindo.tests('Linode::Compute | stack_script requests', ['linode']) do
+
+  @stack_scripts_format = Linode::Compute::Formats::BASIC.merge({
+    'DATA' => [{ 
+      'STACKSCRIPTID'       => Integer,
+      'SCRIPT'              => String,
+      'DESCRIPTION'         => String,
+      'DISTRIBUTIONIDLIST'  => String,
+      'LABEL'               => String,
+      'DEPLOYMENTSTOTAL'    => Integer,
+      'LATESTREV'           => Integer,
+      'CREATE_DT'           => String,
+      'DEPLOYMENTSACTIVE'   => Integer,
+      'REV_NOTE'            => String,
+      'REV_DT'              => String,
+      'ISPUBLIC'            => Integer,
+      'USERID'              => Integer
+    }]
+  })  
+
+  tests('success') do
+
+    tests('#avail_stackscripts').formats(@stack_scripts_format) do
+      pending if Fog.mocking?
+      Linode[:compute].avail_stackscripts.body
+    end    
+    
+    tests('#stackscript_list').formats(@stack_scripts_format) do
+      pending if Fog.mocking?
+      Linode[:compute].stackscript_list.body
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/address_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/address_tests.rb
new file mode 100644
index 0000000..6a6fcf2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/address_tests.rb
@@ -0,0 +1,40 @@
+Shindo.tests('Rackspace::Compute | address requests', ['rackspace']) do
+
+  tests('success') do
+
+    @server = Rackspace[:compute].servers.create(:flavor_id => 1, :image_id => 19)
+
+    tests("#list_addresses(#{@server.id})").formats({'addresses' => {'private' => [String], 'public' => [String]}}) do
+      Rackspace[:compute].list_addresses(@server.id).body
+    end
+
+    tests("#list_private_addresses(#{@server.id})").formats({'private' => [String]}) do
+      Rackspace[:compute].list_private_addresses(@server.id).body
+    end
+
+    tests("#list_public_addresses(#{@server.id})").formats({'public' => [String]}) do
+      Rackspace[:compute].list_public_addresses(@server.id).body
+    end
+
+    @server.wait_for { ready? }
+    @server.destroy
+
+  end
+
+  tests('failure') do
+
+    tests('#list_addresses(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].list_addresses(0)
+    end
+
+    tests('#list_private_addresses(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].list_private_addresses(0)
+    end
+
+    tests('#list_public_addresses(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].list_public_addresses(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/flavor_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/flavor_tests.rb
new file mode 100644
index 0000000..c7cf9f2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/flavor_tests.rb
@@ -0,0 +1,38 @@
+Shindo.tests('Rackspace::Compute | flavor requests', ['rackspace']) do
+
+  @flavor_format = {
+    'disk'  => Integer,
+    'id'    => Integer,
+    'name'  => String,
+    'ram'   => Integer
+  }
+
+  tests('success') do
+
+    tests('#get_flavor_details(1)').formats(@flavor_format) do
+      pending if Fog.mocking?
+      Rackspace[:compute].get_flavor_details(1).body['flavor']
+    end
+
+    tests('#list_flavors').formats({'flavors' => [Rackspace::Compute::Formats::SUMMARY]}) do
+      pending if Fog.mocking?
+      Rackspace[:compute].list_flavors.body
+    end
+
+    tests('#list_flavors_detail').formats({'flavors' => [@flavor_format]}) do
+      pending if Fog.mocking?
+      Rackspace[:compute].list_flavors_detail.body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#get_flavor_details(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:compute].get_flavor_details(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/helper.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/helper.rb
new file mode 100644
index 0000000..d1fae4f
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/helper.rb
@@ -0,0 +1,16 @@
+class Rackspace
+
+  module Compute
+
+    module Formats
+
+      SUMMARY = {
+        'id'    => Integer,
+        'name'  => String
+      }
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/image_tests.rb
new file mode 100644
index 0000000..c35eeb1
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/image_tests.rb
@@ -0,0 +1,68 @@
+Shindo.tests('Rackspace::Compute | image requests', ['rackspace']) do
+
+  @image_format = {
+    'created'   => Fog::Nullable::String,
+    'id'        => Integer,
+    'name'      => String,
+    'progress'  => Fog::Nullable::Integer,
+    'serverId'  => Fog::Nullable::Integer,
+    'status'    => String,
+    'updated'   => String
+  }
+
+  tests('success') do
+
+    @server = Rackspace[:compute].servers.create(:flavor_id => 1, :image_id => 19)
+    @server.wait_for { ready? }
+    @image_id = nil
+
+    tests("#create_image(#{@server.id})").formats(@image_format) do
+      data = Rackspace[:compute].create_image(@server.id).body['image']
+      @image_id = data['id']
+      data
+    end
+
+    unless Fog.mocking?
+      Rackspace[:compute].images.get(@image_id).wait_for { ready? }
+    end
+
+    tests("#get_image_details(#{@image_id})").formats(@image_format) do
+      pending if Fog.mocking?
+      Rackspace[:compute].get_image_details(@image_id).body['image']
+    end
+
+    tests('#list_images').formats({'images' => [Rackspace::Compute::Formats::SUMMARY]}) do
+      Rackspace[:compute].list_images.body
+    end
+
+    tests('#list_images_detail').formats({'images' => [@image_format]}) do
+      Rackspace[:compute].list_images_detail.body
+    end
+
+    unless Fog.mocking?
+      Rackspace[:compute].images.get(@image_id).wait_for { ready? }
+    end
+
+    tests("#delete_image(#{@image_id})").succeeds do
+      pending if Fog.mocking? # because it will fail without the wait just above here, which won't work
+      Rackspace[:compute].delete_image(@image_id)
+    end
+
+    @server.destroy
+
+  end
+
+  tests('failure') do
+
+    tests('#delete_image(0)').raises(Excon::Errors::BadRequest) do
+      Rackspace[:compute].delete_image(0)
+    end
+
+    tests('#get_image_details(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:compute].get_image_details(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/resize_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/resize_tests.rb
new file mode 100644
index 0000000..fde5fe8
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/resize_tests.rb
@@ -0,0 +1,33 @@
+Shindo.tests('Rackspace::Compute | resize request', ['rackspace']) do
+
+    @confirm_server = Rackspace[:compute].servers.create(:flavor_id => 1, :image_id => 19)
+
+    @revert_server = Rackspace[:compute].servers.create(:flavor_id => 1, :image_id => 19)
+
+    @confirm_server.wait_for { ready? }
+    tests("#resize_server(#{@confirm_server.id}, 2) # to confirm").succeeds do
+      Rackspace[:compute].resize_server(@confirm_server.id, 2)
+    end
+
+    @revert_server.wait_for { ready? }
+    tests("#resize_server(#{@revert_server.id}, 2) # to revert").succeeds do
+      Rackspace[:compute].resize_server(@revert_server.id, 2)
+    end
+
+    @confirm_server.wait_for { state == 'VERIFY_RESIZE' }
+    tests("#confirm_resized_server(#{@confirm_server.id})").succeeds do
+      Rackspace[:compute].confirm_resized_server(@confirm_server.id)
+    end
+
+    @revert_server.wait_for { state == 'VERIFY_RESIZE' }
+    tests("#revert_resized_server(#{@revert_server.id})").succeeds do
+      Rackspace[:compute].revert_resized_server(@revert_server.id)
+    end
+
+    @confirm_server.wait_for { ready? }
+    @confirm_server.destroy
+
+    @revert_server.wait_for { ready? }
+    @revert_server.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/rackspace/server_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/rackspace/server_tests.rb
new file mode 100644
index 0000000..346dccd
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/rackspace/server_tests.rb
@@ -0,0 +1,92 @@
+Shindo.tests('Rackspace::Compute | server requests', ['rackspace']) do
+
+  @server_format = {
+    'addresses' => {
+      'private' => [String],
+      'public'  => [String]
+    },
+    'flavorId'  => Integer,
+    'hostId'    => String,
+    'id'        => Integer,
+    'imageId'   => Integer,
+    'metadata'  => {},
+    'name'      => String,
+    'progress'  => Integer,
+    'status'    => String
+  }
+
+  tests('success') do
+
+    @server_id = nil
+
+    tests('#create_server(1, 19)').formats(@server_format.merge('adminPass' => String)) do
+      # 1 => 256MB, 19 => Gentoo
+      data = Rackspace[:compute].create_server(1, 19).body['server']
+      @server_id = data['id']
+      data
+    end
+
+    Rackspace[:compute].servers.get(@server_id).wait_for { ready? }
+
+    tests("#get_server_details(#{@server_id})").formats(@server_format) do
+      Rackspace[:compute].get_server_details(@server_id).body['server']
+    end
+
+    tests('#list_servers').formats({'servers' => [Rackspace::Compute::Formats::SUMMARY]}) do
+      Rackspace[:compute].list_servers.body
+    end
+
+    tests('#list_servers_detail').formats({'servers' => [@server_format]}) do
+      Rackspace[:compute].list_servers_detail.body
+    end
+
+    Rackspace[:compute].servers.get(@server_id).wait_for { ready? }
+
+    tests("#update_server(#{@server_id}, :name => 'fogupdatedserver', :adminPass => 'fogupdatedserver')").succeeds do
+      Rackspace[:compute].update_server(@server_id, :name => 'fogupdatedserver', :adminPass => 'fogupdatedserver')
+    end
+
+    Rackspace[:compute].servers.get(@server_id).wait_for { ready? }
+
+    tests("#reboot_server(#{@server_id}, 'HARD')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:compute].reboot_server(@server_id, 'HARD')
+    end
+
+    Rackspace[:compute].servers.get(@server_id).wait_for { ready? }
+
+    tests("#reboot_server(#{@server_id}, 'SOFT')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:compute].reboot_server(@server_id, 'SOFT')
+    end
+
+    Rackspace[:compute].servers.get(@server_id).wait_for { ready? }
+
+    tests("#delete_server(#{@server_id})").succeeds do
+      Rackspace[:compute].delete_server(@server_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#delete_server(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].delete_server(0)
+    end
+
+    tests('#get_server_details(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].get_server_details(0)
+    end
+
+    tests("#update_server(0, :name => 'fogupdatedserver', :adminPass => 'fogupdatedserver')").raises(Fog::Rackspace::Compute::NotFound) do
+      Rackspace[:compute].update_server(0, :name => 'fogupdatedserver', :adminPass => 'fogupdatedserver')
+    end
+
+    tests('#reboot_server(0)').raises(Fog::Rackspace::Compute::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:compute].reboot_server(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/slicehost/backup_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/slicehost/backup_tests.rb
new file mode 100644
index 0000000..51be869
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/slicehost/backup_tests.rb
@@ -0,0 +1,18 @@
+Shindo.tests('Slicehost::Compute | backup requests', ['slicehost']) do
+
+  @backup_format = {
+    'date'      => String,
+    'id'        => Integer,
+    'name'      => String,
+    'slice-id'  => Integer
+  }
+
+  tests('success') do
+
+    tests('#get_backups').formats({ 'backups' => [@backup_format] }) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_backups.body
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/slicehost/flavor_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/slicehost/flavor_tests.rb
new file mode 100644
index 0000000..2e01576
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/slicehost/flavor_tests.rb
@@ -0,0 +1,33 @@
+Shindo.tests('Slicehost::Compute | flavor requests', ['slicehost']) do
+
+  @flavor_format = {
+    'id'    => Integer,
+    'name'  => String,
+    'price' => Integer,
+    'ram'   => Integer
+  }
+
+  tests('success') do
+
+    tests('#get_flavor(1)').formats(@flavor_format) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_flavor(1).body
+    end
+
+    tests('#get_flavors').formats({ 'flavors' => [@flavor_format] }) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_flavors.body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#get_flavor(0)').raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_flavor(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/slicehost/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/slicehost/image_tests.rb
new file mode 100644
index 0000000..efb1f0b
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/slicehost/image_tests.rb
@@ -0,0 +1,31 @@
+Shindo.tests('Slicehost::Compute | image requests', ['slicehost']) do
+
+  @image_format = {
+    'id'    => Integer,
+    'name'  => String
+  }
+
+  tests('success') do
+
+    tests('#get_image(19)').formats(@image_format) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_image(19).body
+    end
+
+    tests('#get_images').formats({ 'images' => [@image_format] }) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_images.body
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#get_image(0)').raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_image(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/slicehost/slice_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/slicehost/slice_tests.rb
new file mode 100644
index 0000000..ac3bd7b
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/slicehost/slice_tests.rb
@@ -0,0 +1,75 @@
+Shindo.tests('Slicehost::Compute | slice requests', ['slicehost']) do
+
+  @slice_format = {
+    'addresses'     => [String],
+    'bw-in'         => Float,
+    'bw-out'        => Float,
+    'flavor-id'     => Integer,
+    'id'            => Integer,
+    'image-id'      => Integer,
+    'name'          => String,
+    'progress'      => Integer,
+    'status'        => String
+  }
+
+  tests('success') do
+
+    @slice_id = nil
+
+    tests("#create_slice(1, 19, 'fogcreateslice')").formats(@slice_format.merge('root-password' => String)) do
+      pending if Fog.mocking?
+      data = Slicehost[:compute].create_slice(1, 19, 'fogcreateslice').body
+      @slice_id = data['id']
+      data
+    end
+
+    unless Fog.mocking?
+      Slicehost[:compute].servers.get(@slice_id).wait_for { ready? }
+    end
+
+    tests("#get_slice(#{@slice_id})").formats(@slice_format) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_slice(@slice_id).body
+    end
+
+    tests("#get_slices").formats({'slices' => [@slice_format]}) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_slices.body
+    end
+
+    tests("#reboot_slice(#{@slice_id})").formats(@slice_format) do
+      pending if Fog.mocking?
+      Slicehost[:compute].reboot_slice(@slice_id).body
+    end
+
+    unless Fog.mocking?
+      Slicehost[:compute].servers.get(@slice_id).wait_for { ready? }
+    end
+
+    tests("#delete_slice(#{@slice_id})").succeeds do
+      pending if Fog.mocking?
+      Slicehost[:compute].delete_slice(@slice_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests('#get_slice(0)').raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      Slicehost[:compute].get_slice(0)
+    end
+
+    tests('#reboot_slice(0)').raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      Slicehost[:compute].reboot_slice(0)
+    end
+
+    tests('#delete_slice(0)').raises(Fog::Slicehost::Compute::NotFound) do
+      pending if Fog.mocking?
+      Slicehost[:compute].delete_slice(0)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/storm_on_demand/server_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/storm_on_demand/server_tests.rb
new file mode 100644
index 0000000..d3f095c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/storm_on_demand/server_tests.rb
@@ -0,0 +1,64 @@
+Shindo.tests('StormOnDemand::Compute | server requests', ['stormondemand']) do
+
+  @server_format = {
+      'uniq_id'     => String,
+      'accnt'       => String,
+      'backup_enabled'     => String,
+      'backup_plan'     => String,
+      'backup_size'     => String,
+      'backup_quota'     => String,
+      'bandwidth_quota' => Integer,
+      'config_description'     => String,
+      'config_id'     => String,
+      'domain'     => String,
+      'ip'     => String,
+      'ip_count'     => String,
+      'subaccnt'     => String,
+      'template'     => NilClass,
+      'template_description'     => String,
+      'manage_level'     => NilClass,
+      'zone'     => Hash,
+      'active' => Integer,
+      'create_date' => String
+  }
+  
+  @servers_format = {
+    'servers' => [@server_format]
+  }
+    
+  tests('success') do
+
+    @uniq_id = nil
+    @name = "fog-test#{Time.now.to_i}.com"
+
+    tests("#create_server(:backup_enabled => 0, :config_id => 114, :domain => '#{@name}', :template => 'CENTOSUNMANAGED', :ip_count => 1, :password => 'B92bxfijsdK3!')").formats(@server_format) do
+      pending if Fog.mocking?
+      data = StormOnDemand[:compute].create_server(:backup_enabled => 0,  :config_id => 114, :domain => @name, :template => 'CENTOSUNMANAGED', :ip_count => 1, :password => 'B92bxfijsdK3!').body
+      @uniq_id = data['uniq_id']
+      data
+    end
+
+    tests('#list_servers').formats(@servers_format) do
+      pending if Fog.mocking?
+      StormOnDemand[:compute].list_servers.body
+    end
+
+    unless Fog.mocking?
+      StormOnDemand[:compute].servers.get(@uniq_id).wait_for { ready? }
+    end
+
+    tests("#delete_server(:uniq_id => #{@uniq_id})").succeeds do
+      pending if Fog.mocking?
+      StormOnDemand[:compute].delete_server(:uniq_id => @uniq_id)
+    end
+
+  end
+
+  tests('failure') do
+    tests('#delete_server(0)').raises(Fog::StormOnDemand::Compute::Error) do
+      pending if Fog.mocking?
+      StormOnDemand[:compute].delete_server(:uniq_id => 'XXXXXX')
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/voxel/image_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/voxel/image_tests.rb
new file mode 100644
index 0000000..764487c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/voxel/image_tests.rb
@@ -0,0 +1,52 @@
+Shindo.tests('Voxel::Compute | image requests', ['voxel']) do
+
+  @images_format = {
+    'images' => [{
+      'id'      => Integer,
+      'summary' => String
+    }],
+    'stat' => String
+  }
+
+  @image_format = {
+    'images' => [{
+      'description'       => String,
+      'id'                => Integer,
+      'filesystem'        => {
+        'size'  => Integer,
+        'type'  => String,
+        'units' => String,
+      },
+      'operating_system'  => {
+        'admin_username'  => String,
+        'architecture'    => Integer,
+        'family'          => String,
+        'product_family'  => String,
+        'product_version' => String,
+        'version'         => String
+      },
+      'summary'           => String
+    }],
+    'stat' => String
+  }
+
+  tests('success') do
+    tests('#images_list').formats(@images_format) do
+      pending if Fog.mocking?
+      Voxel[:compute].images_list.body
+    end
+
+    tests('#images_list(1)').formats(@image_format) do
+      pending if Fog.mocking?
+      Voxel[:compute].images_list(1).body
+    end
+  end
+
+  tests('failure') do
+    tests('#images_list(0)').raises(Fog::Voxel::Compute::Error) do
+      pending if Fog.mocking?
+      Voxel[:compute].images_list(0).body
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/compute/requests/voxel/server_tests.rb b/vendor/fog-0.8.2/tests/compute/requests/voxel/server_tests.rb
new file mode 100644
index 0000000..cfc4cfb
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/compute/requests/voxel/server_tests.rb
@@ -0,0 +1,123 @@
+Shindo.tests('Voxel::Compute | server requests', ['voxel']) do
+
+  @server_format = {
+    'device'  => {
+      'id'                => String,
+      'last_update'       => Time
+    },
+    'stat'    => String
+  }
+
+  @devices_format = {
+    'devices'   => [{
+      'access_methods'    => [],
+      'description'       => String,
+      'drives'            => {
+        'position'  => Fog::Nullable::Integer,
+        'size'      => Integer
+      },
+      'id'                => String,
+      'ipassignments'     => [{
+        'description' => String,
+        'id'          => String,
+        'type'        => String,
+        'value'       => String
+      }],
+      'label'             => String,
+      'location'          => {
+        'cage'      => {
+          'id'    => String,
+          'value' => String
+        },
+        'facility'  => {
+          'code'  => String,
+          'id'    => String,
+          'value' => String
+        },
+        'position'  => Fog::Nullable::Integer,
+        'rack'      => {
+          'id'    => String,
+          'value' => String
+        },
+        'row'       => {
+          'id'    => String,
+          'value' => String
+        },
+        'zone'      => {
+          'id'    => String,
+          'value' => String
+        }
+      },
+      'memory'            => { 'size' => Integer },
+      'model'             => {
+        'id'    => String,
+        'value' => String
+      },
+      'operating_system'  => {
+        'architecture'      => Integer,
+        'name'              => String
+      },
+      'power_consumption' => String,
+      'processor'         => {
+        'cores'   => Integer
+      },
+      'status'            => String,
+      'type'              => {
+        'id'    => String,
+        'value' => String
+      },
+    }],
+    'stat'  => String,
+  }
+
+  tests('success') do
+
+    @server_id = nil
+    @name = "fog.#{Time.now.to_i}"
+
+    tests("#voxcloud_create( :hostname => '#{@name}', :disk_size => 10, :processing_cores => 1, :image_id => 55, :facility => 'LDJ1' )").formats(@server_format) do
+      pending if Fog.mocking?
+      data = Voxel[:compute].voxcloud_create( :hostname => @name, :disk_size => 10, :processing_cores => 1, :image_id => 55, :facility => "LDJ1" ).body
+      @server_id = data['device']['id']
+      data
+    end
+
+    unless Fog.mocking?
+      Voxel[:compute].servers.get(@server_id).wait_for { ready? }
+    end
+
+    tests('#devices_list').formats(@devices_format) do
+      pending if Fog.mocking?
+      Voxel[:compute].devices_list.body
+    end
+
+    tests('#devices_list(@server_id)').formats(@devices_format) do
+      pending if Fog.mocking?
+      Voxel[:compute].devices_list(@server_id).body
+    end
+
+    tests("#voxcloud_delete(#{@server_id})").succeeds do
+      pending if Fog.mocking?
+      Voxel[:compute].voxcloud_delete(@server_id)
+    end
+
+  end
+
+  tests('failure') do
+    tests('#voxcloud_delete(0)').raises(Fog::Voxel::Compute::Error) do
+      pending if Fog.mocking?
+      Voxel[:compute].voxcloud_delete(0)
+    end
+
+    tests('#voxcloud_status(0)').raises(Fog::Voxel::Compute::Error) do
+      pending if Fog.mocking?
+      Voxel[:compute].voxcloud_status(0)
+    end
+
+    tests('#devices_list(0)').raises(Fog::Voxel::Compute::Error) do
+      pending if Fog.mocking?
+      Voxel[:compute].devices_list(0)
+    end
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/core/attribute_tests.rb b/vendor/fog-0.8.2/tests/core/attribute_tests.rb
new file mode 100644
index 0000000..c3122ec
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/core/attribute_tests.rb
@@ -0,0 +1,45 @@
+class FogAttributeTestModel < Fog::Model
+  attribute :key, :aliases => 'keys', :squash => "id"
+  attribute :time, :type => :time
+end
+
+Shindo.tests('Fog::Attributes', 'core') do
+
+  @model = FogAttributeTestModel.new
+
+  tests('squash') do
+
+    tests('"keys" => {:id => "value"}').returns('value') do
+      @model.merge_attributes("keys" => {:id => "value"})
+      @model.key
+    end
+
+    tests('"keys" => {"id" => "value"}').returns('value') do
+      @model.merge_attributes("keys" => {'id' => "value"})
+      @model.key
+    end
+
+  end
+
+  tests(':type => :time') do
+
+    @time  = Time.now
+
+    tests(':time => nil').returns(nil) do
+      @model.merge_attributes(:time => nil)
+      @model.time
+    end
+
+    tests(':time => ""').returns('') do
+      @model.merge_attributes(:time => '')
+      @model.time
+    end
+
+    tests(':time => "#{@time.to_s}"').returns(Time.parse(@time.to_s)) do
+      @model.merge_attributes(:time => @time.to_s)
+      @model.time
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/core/credential_tests.rb b/vendor/fog-0.8.2/tests/core/credential_tests.rb
new file mode 100644
index 0000000..4780c33
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/core/credential_tests.rb
@@ -0,0 +1,41 @@
+Shindo.tests do
+  before do
+    @old_home = ENV['HOME']
+    @old_rc   = ENV['FOG_RC']
+    Fog.instance_variable_set('@credential_path', nil) # kill memoization
+  end
+
+  after do
+    ENV['HOME'] = @old_home
+    ENV['FOG_RC'] = @ld_rc
+  end
+
+  tests('credentials_path') do
+    returns('/rc/path', 'FOG_RC takes precedence over HOME') {
+      ENV['HOME'] = '/home/path'
+      ENV['FOG_RC'] = '/rc/path'
+    }
+
+    returns('/expanded/path', 'properly expands paths') {
+      ENV['FOG_RC'] = '/expanded/subdirectory/../path'
+      Fog.credentials_path
+    }
+
+    returns(File.join(ENV['HOME'], '.fog'), 'falls back to home path if FOG_RC not set') {
+      ENV.delete('FOG_RC')
+      Fog.credentials_path
+    }
+
+    returns(nil, 'ignores home path if it does not exist') {
+      ENV.delete('FOG_RC')
+      ENV['HOME'] = '/no/such/path'
+      Fog.credentials_path
+    }
+
+    returns(nil, 'returns nil when neither FOG_RC or HOME are set') {
+      ENV.delete('HOME')
+      ENV.delete('FOG_RC')
+      Fog.credentials_path
+    }
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/core/parser_tests.rb b/vendor/fog-0.8.2/tests/core/parser_tests.rb
new file mode 100644
index 0000000..009f1ab
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/core/parser_tests.rb
@@ -0,0 +1,67 @@
+Shindo.tests('Fog::Parsers', 'core') do
+
+  class TestParser < Fog::Parsers::Base
+    def reset
+      super
+      reset_my_array
+    end
+
+    def reset_my_array
+      @my_array = []
+    end
+
+    def end_element(name)
+      case name
+      when 'key1', 'key2', 'key3', 'longText'
+        @response[name] = value
+      when 'myArray'
+        @response[name] = @my_array
+        reset_my_array
+      when 'id'
+        @my_array << value.to_i
+      end
+
+    end
+  end
+
+  @xml = %{
+<MyResponse>
+  <MyObject>
+    <key1>value1</key1>
+    <key2>value2</key2>
+    <myArray>
+      <id>1</id>
+      <id>2</id>
+      <id>3</id>
+    </myArray>
+    <longText>
+Lorem ipsum dolor sit amet, consectetur adipiscing elit.
+Donec quis metus arcu, quis cursus turpis.
+Aliquam leo lacus, luctus vel iaculis id,
+posuere eu odio. Donec sodales, ante porta condimentum
+</longText>
+    <key3>value3</key3>
+  </MyObject>
+<MyResponse>
+}
+
+  @response = {
+    'key1' => 'value1',
+    'key2' => 'value2',
+    'key3' => 'value3',
+    'myArray' => [1,2,3],
+    'longText' => %{
+Lorem ipsum dolor sit amet, consectetur adipiscing elit.
+Donec quis metus arcu, quis cursus turpis.
+Aliquam leo lacus, luctus vel iaculis id,
+posuere eu odio. Donec sodales, ante porta condimentum
+}
+  }
+
+
+  tests('TestParser').returns(@response, "returns the response") do
+    test_parser = TestParser.new
+    Nokogiri::XML::SAX::Parser.new(test_parser).parse(@xml)
+    test_parser.response
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/dns/helper.rb b/vendor/fog-0.8.2/tests/dns/helper.rb
new file mode 100644
index 0000000..bd66abf
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/helper.rb
@@ -0,0 +1,28 @@
+def dns_providers
+  {
+    AWS       => {
+      :mocked => false
+    },
+    Bluebox   => {
+      :mocked => false,
+      :zone_attributes => {
+        :ttl => 60
+      }
+    },
+    Linode    => {
+      :mocked => false,
+      :zone_attributes => {
+        :email => 'fog@example.com'
+      }
+    },
+    Slicehost => {
+      :mocked => false
+    },
+    Zerigo    => {
+      :mocked => false
+    },
+    DNSimple  => {
+      :mocked => false
+    }
+  }
+end
diff --git a/vendor/fog-0.8.2/tests/dns/models/record_tests.rb b/vendor/fog-0.8.2/tests/dns/models/record_tests.rb
new file mode 100644
index 0000000..db98b60
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/models/record_tests.rb
@@ -0,0 +1,24 @@
+for provider, config in dns_providers
+
+  Shindo.tests("#{provider}::DNS | record", [provider.to_s.downcase]) do
+
+    record_attributes = {
+      :ip => '1.2.3.4',
+      :name => 'www.fogrecordtests.com',
+      :type => 'A'
+    }.merge!(config[:record_attributes] || {})
+
+    if !Fog.mocking? || config[:mocked]
+      zone_attributes = {
+        :domain => 'fogrecordtests.com'
+      }.merge(config[:zone_attributes] || {})
+
+      @zone = provider[:dns].zones.create(zone_attributes)
+      model_tests(@zone.records, record_attributes, config[:mocked])
+
+      @zone.destroy
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/dns/models/records_tests.rb b/vendor/fog-0.8.2/tests/dns/models/records_tests.rb
new file mode 100644
index 0000000..569ff3a
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/models/records_tests.rb
@@ -0,0 +1,25 @@
+for provider, config in dns_providers
+
+  Shindo.tests("#{provider}::DNS | records", [provider.to_s.downcase]) do
+
+    record_attributes = {
+      :ip => '1.2.3.4',
+      :name => 'www.fogrecordstests.com',
+      :type => 'A'
+    }.merge!(config[:record_attributes] || {})
+
+    if !Fog.mocking? || config[:mocked]
+      zone_attributes = {
+        :domain => 'fogrecordstests.com'
+      }.merge(config[:zone_attributes] || {})
+
+      @zone = provider[:dns].zones.create(zone_attributes)
+
+      collection_tests(@zone.records, record_attributes, config[:mocked])
+
+      @zone.destroy
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/dns/models/zone_tests.rb b/vendor/fog-0.8.2/tests/dns/models/zone_tests.rb
new file mode 100644
index 0000000..dbb1b68
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/models/zone_tests.rb
@@ -0,0 +1,13 @@
+for provider, config in dns_providers
+
+  Shindo.tests("#{provider}::DNS | zone", [provider.to_s.downcase]) do
+
+    zone_attributes = {
+      :domain => 'fogzonetests.com'
+    }.merge!(config[:zone_attributes] || {})
+
+    model_tests(provider[:dns].zones, zone_attributes, config[:mocked])
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/dns/models/zones_tests.rb b/vendor/fog-0.8.2/tests/dns/models/zones_tests.rb
new file mode 100644
index 0000000..a2a632b
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/models/zones_tests.rb
@@ -0,0 +1,13 @@
+for provider, config in dns_providers
+
+  Shindo.tests("#{provider}::DNS | zones", [provider.to_s.downcase]) do
+
+    zone_attributes = {
+      :domain => 'fogzonestests.com'
+    }.merge!(config[:zone_attributes] || {})
+
+    collection_tests(provider[:dns].zones, zone_attributes, config[:mocked])
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/dns/requests/aws/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/aws/dns_tests.rb
new file mode 100644
index 0000000..28e38fd
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/aws/dns_tests.rb
@@ -0,0 +1,276 @@
+Shindo.tests('AWS::DNS | DNS requests', ['aws', 'dns']) do
+
+  @org_zone_count = 0
+  @zone_id = ''
+  @change_id = ''
+  @new_records =[]
+ 
+  # NOTE: can't use generate_unique_domain() as we do in other DNS provider
+  #       test suites as AWS charges $1/mth for each domain, even if it exists 
+  #       on AWS for only the time that this test suite runs!!
+  #       http://aws.amazon.com/route53/pricing/
+  @test_domain = 'test-343246324434.com'
+  
+  tests( 'success') do
+
+    test('see if test domain already exists') do
+      pending if Fog.mocking?
+      
+      @zone_id = nil
+      
+      response = AWS[:dns].list_hosted_zones()
+      if response.status == 200
+        @hosted_zones = response.body['HostedZones']
+      end
+
+      #go through zones for this account
+      @hosted_zones.each { |zone|
+        domain = zone['Name']
+        if domain.chomp == @test_domain
+          @zone_id = zone['Id']
+        end
+      }
+      
+      @zone_id.nil?
+    end
+      
+    test('get current zone count') do
+      pending if Fog.mocking?
+
+      @org_zone_count= 0
+      response = AWS[:dns].list_hosted_zones()
+      if response.status == 200
+        @hosted_zones = response.body['HostedZones']
+        @org_zone_count = @hosted_zones.count
+      end
+
+      response.status == 200
+    end
+
+    test('create simple zone') {
+      pending if Fog.mocking?
+
+      result = false
+      
+      response = AWS[:dns].create_hosted_zone( @test_domain)
+      if response.status == 201
+
+        zone= response.body['HostedZone']
+        change_info = response.body['ChangeInfo']
+        ns_servers = response.body['NameServers']
+
+        if (zone and change_info and ns_servers)
+
+          @zone_id = zone['Id']
+          caller_ref = zone['CallerReference']
+          @change_id = change_info['Id']
+          status = change_info['Status']
+          ns_srv_count = ns_servers.count
+          
+          if (@zone_id.length > 0) and (caller_ref.length > 0) and (@change_id.length > 0) and
+             (status.length > 0) and (ns_srv_count > 0)
+            result = true
+          end
+        end
+      end
+
+      result
+    }
+    
+    test("get status of change #{@change_id}") {
+      pending if Fog.mocking?
+
+      result = false
+      response = AWS[:dns].get_change(@change_id)
+      if response.status == 200
+        status = response.body['Status']
+        if (status == 'PENDING') or (status == 'INSYNC')
+          result= true
+        end
+      end
+      
+      result
+    }
+   
+    test("get info on hosted zone #{@zone_id}") {
+      pending if Fog.mocking?
+
+      result = false
+      
+      response = AWS[:dns].get_hosted_zone( @zone_id)
+      if response.status == 200
+        zone = response.body['HostedZone']
+        zone_id = zone['Id']
+        name = zone['Name']
+        caller_ref = zone['CallerReference']
+        ns_servers = response.body['NameServers']
+
+        # AWS returns domain with a dot at end - so when compare, remove dot
+        
+        if (zone_id == @zone_id) and (name.chop == @test_domain) and (caller_ref.length > 0) and
+           (ns_servers.count > 0)
+           result = true
+        end
+      end
+      
+      result
+    }
+    
+    test('list zones') do
+      pending if Fog.mocking?
+
+      result = false
+      
+      response = AWS[:dns].list_hosted_zones()
+      if response.status == 200
+        
+        zones= response.body['HostedZones']
+        if (zones.count > 0)
+          zone= zones[0]
+          zone_id = zone['Id']
+          zone_name= zone['Name']
+          caller_ref = zone['CallerReference']
+        end
+        max_items = response.body['MaxItems']
+                  
+        if (zone_id.length > 0) and (zone_name.length > 0) and (caller_ref.length > 0) and 
+           (max_items > 0)
+          result = true
+        end      
+      end
+
+      result
+    end
+    
+    test("add a A resource record") {
+      pending if Fog.mocking?
+
+      result = false
+      
+      # create an A resource record
+      host = 'www.' + @test_domain
+      ip_addrs = ['1.2.3.4']
+      resource_record = { :name => host, :type => 'A', :ttl => 3600, :resource_records => ip_addrs }
+      resource_record_set = resource_record.merge( :action => 'CREATE')
+  
+      change_batch = []
+      change_batch << resource_record_set
+      options = { :comment => 'add A record to domain'}             
+      response = AWS[:dns].change_resource_record_sets( @zone_id, change_batch, options)
+      if response.status == 200
+        change_id = response.body['Id']
+        status = response.body['Status']
+        @new_records << resource_record
+      end
+      
+      response.status == 200
+    }
+
+    test("add a CNAME resource record") {
+      pending if Fog.mocking?
+
+      result = false
+      
+      # create a CNAME resource record
+      host = 'mail.' + @test_domain
+      value = ['www.' + @test_domain]
+      resource_record = { :name => host, :type => 'CNAME', :ttl => 3600, :resource_records => value }
+      resource_record_set = resource_record.merge( :action => 'CREATE')
+  
+      change_batch = []
+      change_batch << resource_record_set
+      options = { :comment => 'add CNAME record to domain'}             
+      response = AWS[:dns].change_resource_record_sets( @zone_id, change_batch, options)
+      if response.status == 200
+        change_id = response.body['Id']
+        status = response.body['Status']
+        @new_records << resource_record
+      end
+      
+      response.status == 200
+    }
+    
+    test("add a MX resource record") {
+      pending if Fog.mocking?
+
+      result = false
+      
+      # create a MX resource record
+      host = @test_domain
+      value = ['7 mail.' + @test_domain]
+      resource_record = { :name => host, :type => 'MX', :ttl => 3600, :resource_records => value }
+      resource_record_set = resource_record.merge( :action => 'CREATE')
+  
+      change_batch = []
+      change_batch << resource_record_set
+      options = { :comment => 'add MX record to domain'}             
+      response = AWS[:dns].change_resource_record_sets( @zone_id, change_batch, options)
+      if response.status == 200
+        change_id = response.body['Id']
+        status = response.body['Status']
+        @new_records << resource_record
+      end
+      
+      response.status == 200
+    }
+
+    test("list resource records")  {
+      pending if Fog.mocking?
+
+      # get resource records for zone
+      response = AWS[:dns].list_resource_record_sets( @zone_id)
+      if response.status == 200
+        record_sets= response.body['ResourceRecordSets']
+        num_records= record_sets.count
+      end
+
+      response.status == 200
+    }
+
+    test("delete #{@new_records.count} resource records") {
+      pending if Fog.mocking?
+
+      result = true
+      
+      change_batch = []
+      @new_records.each { |record|      
+        resource_record_set = record.merge( :action => 'DELETE')
+        change_batch << resource_record_set
+      }
+      options = { :comment => 'remove records from domain'}             
+      response = AWS[:dns].change_resource_record_sets( @zone_id, change_batch, options)
+      if response.status != 200
+        result = false
+        break
+      end
+
+      result
+    }
+    
+    test("delete hosted zone #{@zone_id}") {
+      pending if Fog.mocking?
+
+      response = AWS[:dns].delete_hosted_zone( @zone_id)
+
+      response.status == 200
+    }
+  
+  end
+
+
+  tests( 'failure') do
+    tests('create hosted zone using invalid domain name').raises(Excon::Errors::BadRequest) do
+      pending if Fog.mocking?
+      response = AWS[:dns].create_hosted_zone('invalid-domain')
+    end
+    
+    tests('get hosted zone using invalid ID').raises(Excon::Errors::Forbidden) do
+      pending if Fog.mocking?
+      zone_id = 'dummy-id'
+      response = AWS[:dns].get_hosted_zone(zone_id)
+    end
+  
+  end
+
+  
+end
diff --git a/vendor/fog-0.8.2/tests/dns/requests/bluebox/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/bluebox/dns_tests.rb
new file mode 100644
index 0000000..803394e
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/bluebox/dns_tests.rb
@@ -0,0 +1,271 @@
+Shindo.tests('Bluebox::dns | DNS requests', ['bluebox', 'dns']) do
+
+  @domain = ''
+  @new_zones = []
+  @new_records =[]
+
+  def generate_unique_domain(with_trailing_dot = false)
+    #get time (with 1/100th of sec accuracy)
+    #want unique domain name and if provider is fast, this can be called more than once per second
+    time= (Time.now.to_f * 100).to_i
+    domain = 'test-' + time.to_s + '.com'
+    if with_trailing_dot
+      domain+= '.'
+    end
+
+    domain
+  end
+
+  tests( 'success') do
+
+    test('get current zone count') do
+      pending if Fog.mocking?
+
+      @org_zone_count= 0
+      response = Bluebox[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        @org_zone_count = zones.count
+      end
+
+      response.status == 200
+    end
+
+    test('create zone - simple') do
+      pending if Fog.mocking?
+
+      domain = generate_unique_domain
+      response = Bluebox[:dns].create_zone(:name => domain, :ttl => 360)
+      if response.status == 202
+        zone_id = response.body['id']
+        @new_zones << zone_id
+      end
+
+      response.status == 202
+    end
+
+    test('create zone - set all parameters') do
+      pending if Fog.mocking?
+
+      options = { :ttl => 60, :retry => 3600, :refresh => 1800, :minimum => 30 }
+      @domain= generate_unique_domain
+      response = Bluebox[:dns].create_zone(options.merge(:name => @domain))
+      if response.status == 202
+        @zone_id = response.body['id']
+        @new_zones << @zone_id
+      end
+
+      response.status == 202
+    end
+
+    test("get zone #{@zone_id} - check all parameters for #{@domain}") do
+      pending if Fog.mocking?
+
+      result = false
+
+      response = Bluebox[:dns].get_zone(@zone_id)
+      if response.status == 200
+        zone = response.body
+        if (zone['name'] == @domain) and (zone['ttl'] == 60)
+          result = true
+        end
+      end
+
+      result
+    end
+
+    test('get zones - make sure total count is correct') do
+      pending if Fog.mocking?
+
+      result = false
+
+      response = Bluebox[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        if (@org_zone_count+2) == zones.count
+          result= true;
+        end
+      end
+
+      result
+    end
+
+    test('get zones - check all parameters for a zone') do
+      pending if Fog.mocking?
+
+      result= false
+
+      response = Bluebox[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        zones.each { |zone|
+          if zone['id'] == @new_zones[1]
+            options = { :ttl => 60, :retry => 3600, :refresh => 1800, :minimum => 30 }
+             if (zone['name'] == @domain) and (zone['ttl'] == 60) and (zone['retry'] == 3600) and (zone['refresh'] == 1800) and (zone['minimum'] == 30)
+               result = true;
+             end
+          end
+        }
+        if (@org_zone_count+2) == zones.count
+          result = true;
+        end
+      end
+
+      result
+    end
+
+    test('create record - simple A record') do
+      pending if Fog.mocking?
+
+      host= 'www.' + @domain
+      zone_id= @new_zones[1]
+      response = Bluebox[:dns].create_record(zone_id, 'A', host, '1.2.3.4')
+      if response.status == 202
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+
+      response.status == 202
+    end
+
+    test('create record - A record - all parameters set') do
+      pending if Fog.mocking?
+
+      host= 'ftp.' + @domain
+      zone_id= @new_zones[1]
+      response = Bluebox[:dns].create_record( zone_id, 'A', host, '1.2.3.4')
+      if response.status == 202
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+
+      response.status == 202
+    end
+
+    test('create record - CNAME record') do
+      pending if Fog.mocking?
+
+      zone_id= @new_zones[1]
+      response = Bluebox[:dns].create_record( zone_id, 'CNAME', 'mail', @domain)
+      if response.status == 202
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+
+      response.status == 202
+    end
+
+    test('create record - NS record') do
+      pending if Fog.mocking?
+
+      ns_domain = 'ns.' + @domain
+      zone_id= @new_zones[1]
+      response = Bluebox[:dns].create_record( zone_id, 'NS', @domain, ns_domain)
+      if response.status == 202
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+
+      response.status == 202
+    end
+
+    test('create record - MX record') do
+      pending if Fog.mocking?
+
+      mail_domain = 'mail.' + @domain
+      zone_id= @new_zones[1]
+      response = Bluebox[:dns].create_record(  zone_id, 'MX', @domain, mail_domain, :priority => 10)
+      if response.status == 202
+        @record_id = response.body['id']
+        @new_records << @record_id
+      end
+
+      response.status == 202
+    end
+
+    test("get record #{@record_id} - verify all parameters") do
+      pending if Fog.mocking?
+
+      result= false
+
+      response = Bluebox[:dns].get_record(@new_zones[1], @record_id)
+      if response.status == 200
+        mail_domain = 'mail.' + @domain + "."
+        record = response.body
+        if (record['type'] == 'MX') and (record['name'] == @domain) and (record['content'] == mail_domain) and (record['priority'] == '10')
+          result= true
+        end
+      end
+
+      result
+    end
+
+    test('get records - verify all parameters for one record') do
+      pending if Fog.mocking?
+
+      result= false
+
+      response = Bluebox[:dns].get_records(@new_zones[1])
+      if response.status == 200
+        records = response.body['records']
+
+        #find mx record
+        records.each {|record|
+          if record['type'] == 'MX'
+
+            mail_domain = 'mail.' + @domain + "."
+            if (record['type'] == 'MX') and (record['name'] == @domain) and (record['content'] == mail_domain) and (record['priority'] == '10')
+              result= true
+              break
+            end
+
+          end
+        }
+      end
+
+      result
+    end
+
+    test("delete #{@new_records.count} records created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_records.each { |record_id|
+        response = Bluebox[:dns].delete_record(@new_zones[1], record_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+      result
+    end
+
+    test("delete #{@new_zones.count} zones created") do
+      pending if Fog.mocking?
+
+      result= true
+
+      @new_zones.each { |zone_id|
+        response = Bluebox[:dns].delete_zone( zone_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+
+      result
+    end
+
+  end
+
+
+  tests( 'failure') do
+
+    #create a zone with invalid parameters
+    #get zonfo info with invalid zone id
+    #delete a zone with an invalid zone id
+
+    tests('#create_zone') do
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/dns/requests/dnsimple/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/dnsimple/dns_tests.rb
new file mode 100644
index 0000000..42014bc
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/dnsimple/dns_tests.rb
@@ -0,0 +1,130 @@
+Shindo.tests('DNSimple::dns | DNS requests', ['dnsimple', 'dns']) do
+
+  @domain = ''
+  @domain_count = 0
+
+  def generate_unique_domain( with_trailing_dot = false)
+    #get time (with 1/100th of sec accuracy)
+    #want unique domain name and if provider is fast, this can be called more than once per second
+    time= (Time.now.to_f * 100).to_i
+    domain = 'test-' + time.to_s + '.com'
+    if with_trailing_dot
+      domain+= '.'
+    end
+
+    domain
+  end
+
+  tests("success") do
+
+    test("get current domain count") do
+      pending if Fog.mocking?
+
+      response = DNSimple[:dns].list_domains()
+      if response.status == 200
+        @domain_count = response.body.size
+      end
+
+      response.status == 200
+    end
+
+    test("create domain") do
+      pending if Fog.mocking?
+
+      domain = generate_unique_domain
+      response = DNSimple[:dns].create_domain(domain)
+      if response.status == 201
+        @domain = response.body["domain"]
+      end
+
+      response.status == 201
+    end
+
+    test("get domain by id") do
+      pending if Fog.mocking?
+
+      response = DNSimple[:dns].get_domain(@domain["id"])
+      response.status == 200
+    end
+
+    test("create an A resource record") do
+      pending if Fog.mocking?
+
+      domain = @domain["name"]
+      name = "www"
+      type = "A"
+      content = "1.2.3.4"
+      response = DNSimple[:dns].create_record(domain, name, type, content)
+
+      if response.status == 201
+        @record = response.body["record"]
+      end
+
+      response.status == 201
+
+    end
+
+    test("create a MX record") do
+      pending if Fog.mocking?
+
+      domain = @domain["name"]
+      name = ""
+      type = "MX"
+      content = "mail.#{domain}"
+      options = { :ttl => 60, :prio => 10 }
+      response = DNSimple[:dns].create_record(domain, name, type, content, options)
+
+      response.status == 201
+    end
+
+    test("update a record") do
+      pending if Fog.mocking?
+
+      domain = @domain["name"]
+      record_id = @record["id"]
+      options = { :content => "2.3.4.5", :ttl => 600 }
+      response = DNSimple[:dns].update_record(domain, record_id, options)
+      response.status == 200
+    end
+
+    test("list records") do
+      pending if Fog.mocking?
+
+      response = DNSimple[:dns].list_records(@domain["name"])
+
+      if response.status == 200
+        @records = response.body
+      end
+
+      (response.status == 200) and (response.body.size == 2)
+    end
+
+    test("delete records") do
+      pending if Fog.mocking?
+      domain = @domain["name"]
+
+      result = true
+      @records.each do |record|
+        response = DNSimple[:dns].delete_record(domain, record["record"]["id"])
+        if(response.status != 200)
+          result = false
+          break
+        end
+      end
+
+      result
+    end
+
+    test("delete domain") do
+      pending if Fog.mocking?
+
+      response = DNSimple[:dns].delete_domain(@domain["name"])
+      response.status == 200
+    end
+
+  end
+
+  tests( 'failure') do
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/dns/requests/linode/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/linode/dns_tests.rb
new file mode 100644
index 0000000..19fec80
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/linode/dns_tests.rb
@@ -0,0 +1,262 @@
+Shindo.tests('Linode::dns | DNS requests', ['linode', 'dns']) do
+
+  @domain = ''
+  @new_zones = []
+  @new_records =[]
+    
+  def generate_unique_domain( with_trailing_dot = false)
+    #get time (with 1/100th of sec accuracy)
+    #want unique domain name and if provider is fast, this can be called more than once per second
+    time= (Time.now.to_f * 100).to_i   
+    domain = 'test-' + time.to_s + '.com'
+    if with_trailing_dot
+      domain+= '.'
+    end
+    
+    domain
+  end
+    
+  tests( 'success') do
+
+    test('get current zone count') do
+      pending if Fog.mocking?
+
+      @org_zone_count= 0
+      response = Linode[:dns].domain_list()
+      if response.status == 200
+        zones = response.body['DATA']
+        @org_zone_count = zones.count
+      end
+      
+      response.status == 200
+    end
+
+    test('create zone - simple') do
+      pending if Fog.mocking?
+
+      type = 'master'
+      domain= generate_unique_domain
+      options = { :SOA_email => "netops@#{domain}", :description => "Sample-Domain Inc", :status => 0}
+      response = Linode[:dns].domain_create( domain, type, options)
+      if response.status == 200
+        @master_zone_id = response.body['DATA']['DomainID']
+        @new_zones << @master_zone_id
+      end
+      
+      response.status == 200
+    end
+
+    test('create zone - set all parameters') do
+      pending if Fog.mocking?
+
+      type = 'slave'
+      @domain= generate_unique_domain
+      options = { :SOA_email => "netops@#{@domain}", :refresh_sec => 14400, :retry_sec => 3600, 
+                  :expire_sec => 604800, :ttl_sec => 28800, :status => 0, :master_ips => '1.2.3.4;2.3.4.5' }
+      response = Linode[:dns].domain_create( @domain, type, options)
+      if response.status == 200
+        @slave_zone_id = response.body['DATA']['DomainID']
+        @new_zones << @slave_zone_id
+      end
+  
+      response.status == 200
+    end
+
+    test("get zone #{@slave_zone_id} - check all parameters for #{@domain}") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Linode[:dns].domain_list( @slave_zone_id)
+      if response.status == 200
+        zones = response.body['DATA']
+        num_zones = zones.count
+        if num_zones == 1
+          zone= zones[0]
+          if (zone['SOA_EMAIL'] == "netops@#{@domain}") and (zone['REFRESH_SEC'] == 14400) and
+            (zone['RETRY_SEC'] == 3600) and (zone['EXPIRE_SEC'] == 604800) and (zone['TTL_SEC'] == 28800) and
+            (zone['STATUS'] == 0) and (zone['DOMAIN'] == @domain) and (zone['TYPE'] == 'slave') 
+            (zone['MASTER_IPS'] == '1.2.3.4;2.3.4.5')
+            result= true
+          end          
+        end
+      end
+      
+      result
+    end
+
+    test("update zone #{@slave_zone_id}- update TTL parameter") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      options = { :ttl_sec => 14400 }
+      response = Linode[:dns].domain_update( @slave_zone_id, options)
+      if response.status == 200
+        result= true
+      end
+  
+      result
+    end
+
+    test("get zone #{@slave_zone_id} - check TTL parameters") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Linode[:dns].domain_list( @slave_zone_id)
+      if response.status == 200
+        zones = response.body['DATA']
+        num_zones = zones.count
+        if num_zones == 1
+          zone= zones[0]
+          if (zone['TTL_SEC'] == 14400)
+            result= true
+          end          
+        end
+      end
+      
+      result
+    end
+
+    test('create record - simple A record') do
+      pending if Fog.mocking?
+
+      host= 'www.' + @domain
+      options = { :name => host, :target => '4.5.6.7', :ttl_sec => 3600 }
+      response = Linode[:dns].domain_resource_create( @master_zone_id, 'A', options)
+      if response.status == 200
+        record_id = response.body['DATA']['ResourceID']
+        @new_records << record_id
+      end
+      
+      response.status == 200
+    end
+
+    test('create record - CNAME record') do
+      pending if Fog.mocking?
+
+      host= 'mail'
+      options = { :name => host, :target => 'www.' + @domain }
+      response = Linode[:dns].domain_resource_create( @master_zone_id, 'CNAME', options)
+      if response.status == 200
+        record_id = response.body['DATA']['ResourceID']
+        @new_records << record_id
+      end
+      
+      response.status == 200
+    end
+
+    test('create record - NS record') do
+      pending if Fog.mocking?
+
+      options = { :name => @domain, :target => 'ns.' + @domain}
+      response = Linode[:dns].domain_resource_create( @master_zone_id, 'NS', options)
+      if response.status == 200
+        record_id = response.body['DATA']['ResourceID']
+        @new_records << record_id
+      end
+      
+      response.status == 200
+    end
+
+    test('create record - MX record') do
+      pending if Fog.mocking?
+
+      options = { :target => 'mail.' + @domain, :ttl_sec => 7200, :priority => 5 }
+      response = Linode[:dns].domain_resource_create( @master_zone_id, 'MX', options)
+      if response.status == 200
+        @record_id = response.body['DATA']['ResourceID']
+        @new_records << @record_id
+      end
+      
+      response.status == 200
+    end
+
+    test("get record #{@record_id} - verify all parameters") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      domain= 'mail.' + @domain
+      response = Linode[:dns].domain_resource_list(@master_zone_id, @record_id)
+      if response.status == 200
+
+        records= response.body['DATA']
+        if records.count == 1
+          record = records[0]
+          if (record['TYPE'] == 'MX') and (record['PRIORITY'] == 5) and (record['TTL_SEC'] == 7200) and
+            (record['TARGET'] == domain)
+            result= true
+          end
+        end
+        
+      end
+              
+      result
+    end
+
+    test("update record #{@record_id} - change target") do 
+      pending if Fog.mocking?
+
+      options = { :target => 'mail2.' + @domain }
+      response = Linode[:dns].domain_resource_update( @master_zone_id, @record_id, options)
+
+      response.status == 200
+    end
+
+    test("get record #{@record_id} - verify target changed") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      domain= 'mail2.' + @domain
+      response = Linode[:dns].domain_resource_list(@master_zone_id, @record_id)
+      if response.status == 200
+
+        records= response.body['DATA']
+        if records.count == 1
+          record = records[0]
+          if record['TARGET'] == domain
+            result= true
+          end
+        end
+        
+      end
+              
+      result
+
+    end
+    
+    test("delete #{@new_records.count} records created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_records.each { |record_id|
+        response = Linode[:dns].domain_resource_delete( @master_zone_id, record_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+      result
+    end
+
+    test("delete #{@new_zones.count} zones created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_zones.each { |zone_id|
+        response = Linode[:dns].domain_delete( zone_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+      result
+    end
+
+  end
+  
+  tests( 'failure') do
+  end
+    
+end
diff --git a/vendor/fog-0.8.2/tests/dns/requests/slicehost/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/slicehost/dns_tests.rb
new file mode 100644
index 0000000..6c19897
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/slicehost/dns_tests.rb
@@ -0,0 +1,279 @@
+Shindo.tests('Slicehost::dns | DNS requests', ['slicehost', 'dns']) do
+
+  @domain = ''
+  @new_zones = []
+  @new_records =[]
+  
+  def generate_unique_domain( with_trailing_dot = false)
+    #get time (with 1/100th of sec accuracy)
+    #want unique domain name and if provider is fast, this can be called more than once per second
+    time= (Time.now.to_f * 100).to_i   
+    domain = 'test-' + time.to_s + '.com'
+    if with_trailing_dot
+      domain+= '.'
+    end
+    
+    domain
+  end
+  
+  tests( 'success') do
+    
+    test('get current zone count') do
+      pending if Fog.mocking?
+
+      @org_zone_count= 0
+      response = Slicehost[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        @org_zone_count = zones.count
+      end
+      
+      response.status == 200
+    end
+
+    test('create zone - simple') do
+      pending if Fog.mocking?
+
+      domain = generate_unique_domain( true)
+      response = Slicehost[:dns].create_zone(domain)
+      if response.status == 201
+        zone_id = response.body['id']
+        @new_zones << zone_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create zone - set all parameters') do
+      pending if Fog.mocking?
+
+      options = { :ttl => 1800, :active => 'N' }
+      @domain= generate_unique_domain( true)
+      response = Slicehost[:dns].create_zone( @domain, options)
+      if response.status == 201
+        @zone_id = response.body['id']
+        @new_zones << @zone_id
+      end
+      
+      response.status == 201
+    end
+
+    test("get zone #{@zone_id} - check all parameters for #{@domain}") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Slicehost[:dns].get_zone( @zone_id)
+      if response.status == 200
+        zone = response.body
+        if (zone['origin'] == @domain) and (zone['ttl'] == 1800) and
+          (zone['active'] == 'N') 
+          result= true;
+        end
+      end
+      
+      result
+    end
+
+    test('get zones - make sure total count is correct') do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Slicehost[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        if (@org_zone_count+2) == zones.count
+          result= true;
+        end
+      end
+      
+      result
+    end
+
+    test('get zones - check all parameters for a zone') do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Slicehost[:dns].get_zones()
+      if response.status == 200
+        zones = response.body['zones']
+        zones.each { |zone|
+          if zone['id'] == @new_zones[1]
+             if (zone['origin'] == 'sub.' + @domain) and (zone['ttl'] == 1800) and
+               (zone['active'] == 'N') 
+               result= true;
+             end
+          end
+        }
+        if (@org_zone_count+2) == zones.count
+          result= true;
+        end
+      end
+      
+      result
+    end
+
+    test('create record - simple A record') do
+      pending if Fog.mocking?
+
+      host= 'www.' + @domain
+      zone_id= @new_zones[1]
+      response = Slicehost[:dns].create_record( 'A', zone_id, host, '1.2.3.4')
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - A record - all parameters set') do
+      pending if Fog.mocking?
+
+      host= 'ftp.' + @domain
+      zone_id= @new_zones[1]
+      options = { :ttl => 3600, :active => 'N'}
+      response = Slicehost[:dns].create_record( 'A', zone_id, host, '1.2.3.4', options)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - CNAME record') do
+      pending if Fog.mocking?
+
+      zone_id= @new_zones[1]
+      response = Slicehost[:dns].create_record( 'CNAME', zone_id, 'mail', @domain)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - NS record') do
+      pending if Fog.mocking?
+
+      ns_domain = 'ns.' + @domain
+      zone_id= @new_zones[1]
+      options = { :ttl => 3600, :active => 'N'}
+      response = Slicehost[:dns].create_record( 'NS', zone_id, @domain, ns_domain, options)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - MX record') do
+      pending if Fog.mocking?
+
+      mail_domain = 'mail.' + @domain
+      zone_id= @new_zones[1]
+      options = { :ttl => 3600, :active => 'N', :aux => '10'}
+      response = Slicehost[:dns].create_record( 'MX', zone_id, @domain, mail_domain, options)
+      if response.status == 201
+        @record_id = response.body['id']
+        @new_records << @record_id
+      end
+      
+      response.status == 201
+    end
+
+    test("get record #{@record_id} - verify all parameters") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Slicehost[:dns].get_record(@record_id)
+      if response.status == 200
+        mail_domain = 'mail.' + @domain
+        record = response.body['records'][0]
+        if (record['record-type'] == 'MX') and (record['name'] == @domain) and
+          (record['data'] == mail_domain) and (record['ttl'] == 3600) and (record['active'] == 'N') and
+          (record['aux'] == "10")
+          result= true
+        end
+      end
+              
+      result
+    end
+    
+    test('get records - verify all parameters for one record') do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Slicehost[:dns].get_records()
+      if response.status == 200
+        records = response.body['records']
+        
+        #find mx record
+        records.each {|record|
+          if record['record-type'] == 'MX'
+
+            mail_domain = 'mail.' + @domain
+            if (record['record-type'] == 'MX') and (record['name'] == @domain) and
+              (record['data'] == mail_domain) and (record['ttl'] == 3600) and (record['active'] == 'N') and
+              (record['aux'] == "10")
+              result= true
+              break
+            end
+
+          end
+        }
+      end
+              
+      result
+    end
+    
+    test("delete #{@new_records.count} records created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_records.each { |record_id|
+        response = Slicehost[:dns].delete_record( record_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+      result
+    end
+    
+    test("delete #{@new_zones.count} zones created") do
+      pending if Fog.mocking?
+
+      result= true
+      
+      @new_zones.each { |zone_id|
+        response = Slicehost[:dns].delete_zone( zone_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+
+      result
+    end
+
+  end
+
+  
+  tests( 'failure') do
+    
+    #create a zone with invalid parameters
+    #get zonfo info with invalid zone id
+    #delete a zone with an invalid zone id
+    
+    tests('#create_zone') do
+    end
+    
+  end
+    
+end
diff --git a/vendor/fog-0.8.2/tests/dns/requests/zerigo/dns_tests.rb b/vendor/fog-0.8.2/tests/dns/requests/zerigo/dns_tests.rb
new file mode 100644
index 0000000..1a0923d
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/dns/requests/zerigo/dns_tests.rb
@@ -0,0 +1,374 @@
+Shindo.tests('Zerigo::dns | DNS requests', ['zerigo', 'dns']) do
+
+  # tests assume have a free acccount - ie need to limit # of zones to max of 3
+  
+  @domain = ''
+  @org_zone_count = 0
+  @new_zones = []
+  @new_records =[]
+ 
+  def generate_unique_domain( with_trailing_dot = false)
+    #get time (with 1/100th of sec accuracy)
+    #want unique domain name and if provider is fast, this can be called more than once per second
+    time= (Time.now.to_f * 100).to_i   
+    domain = 'test-' + time.to_s + '.com'
+    if with_trailing_dot
+      domain+= '.'
+    end
+    
+    domain
+  end
+  
+ 
+  tests( 'success') do
+
+    test('get current zone count') do
+      pending if Fog.mocking?
+
+      @org_zone_count= 0
+      response = Zerigo[:dns].count_zones()
+      if response.status == 200
+        @org_zone_count = response.body['count']
+      end
+
+      response.status == 200
+    end
+
+    test('create zone - simple') do
+      pending if Fog.mocking?
+
+      options = { :nx_ttl => 1800 }
+      domain = generate_unique_domain
+      response = Zerigo[:dns].create_zone( domain, 3600, 'pri_sec', options)
+      if response.status == 201
+        zone_id = response.body['id']
+        #worked so can now delete
+        response = Zerigo[:dns].delete_zone( zone_id)
+      end
+      
+      response.status == 200
+    end
+
+    test('create zone - set zerigo as slave') do
+      pending if Fog.mocking?
+
+      options = { :active => 'N', :ns1=> '2.3.4.5' }
+      domain= generate_unique_domain
+      response = Zerigo[:dns].create_zone( domain, 14400, 'sec', options )
+      if response.status == 201
+        zone_id = response.body['id']
+        #worked so can now delete
+        response = Zerigo[:dns].delete_zone( zone_id)
+      end
+      
+      response.status == 200
+    end
+
+    test('create zone - set zerigo as master') do
+      pending if Fog.mocking?
+
+      domain= generate_unique_domain
+      options = { :active => 'N', :slave_nameservers=> "ns1.#{domain},ns2.#{domain}" }
+      response = Zerigo[:dns].create_zone( domain, 14400, 'pri', options )
+      if response.status == 201
+        zone_id = response.body['id']
+        #worked so can now delete
+        response = Zerigo[:dns].delete_zone( zone_id)
+      end
+
+      response.status == 200
+    end
+    
+    test('create zone - set all parameters') do
+      pending if Fog.mocking?
+
+      @domain = generate_unique_domain
+      options = { :nx_ttl => 1800, :active => 'N', :hostmaster => "netops@#{@domain}", 
+                  :notes => 'for client ABC', :tag_list=> 'sample-tag' }
+      response = Zerigo[:dns].create_zone( @domain, 14400, 'pri', options )
+      if response.status == 201
+        @zone_id = response.body['id']
+        @new_zones << @zone_id
+      end
+      
+      response.status == 201
+    end
+
+    test("get zone #{@zone_id} for #{@domain}- check all parameters") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Zerigo[:dns].get_zone( @zone_id)
+      if response.status == 200
+        zone = response.body
+        if (zone['ns-type'] == 'pri') and (zone['tag-list'] == 'sample-tag') and 
+            (zone['default-ttl'] == 14400) and (zone['nx-ttl'] == 1800) and
+            (zone['updated-at'].length > 0) and (zone['created-at'].length > 0) and 
+            (zone['domain'] == @domain) and (zone['notes'] == 'for client ABC') and 
+            (zone['id'] == @zone_id)
+            result = true
+        end
+
+        result
+      end
+    end
+    
+    test("update zone #{@zone_id} - set notes & tags") do
+      pending if Fog.mocking?
+      
+      options = { :notes => 'for client XYZ', :tag_list=> 'testing-tag' }
+      response = Zerigo[:dns].update_zone( @zone_id, options )
+      
+      response.status == 200
+    end
+
+    test("get zone #{@zone_id} - check updated parameters") do
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Zerigo[:dns].get_zone( @zone_id)
+      if response.status == 200
+        zone = response.body
+        if (zone['tag-list'] == 'testing-tag') and (zone['notes'] == 'for client XYZ') 
+            result = true
+        end
+
+        result
+      end
+    end
+    
+    test("get zone stats for #{@zone_id}") do 
+      pending if Fog.mocking?
+
+      result= false
+      
+      response = Zerigo[:dns].get_zone_stats( @zone_id)
+      if response.status == 200
+        zone = response.body
+        if (zone['domain'] == @domain) and (zone['id'] == @zone_id) and
+           (zone['period-begin'].length > 0) and (zone['period-end'].length > 0)
+          result= true
+        end
+        
+        result
+      end
+
+    end
+    
+    test('list zones - make sure total count is correct') do
+       pending if Fog.mocking?
+
+       result= false
+
+       response = Zerigo[:dns].list_zones()
+       if response.status == 200
+         zones = response.body['zones']
+         if (@org_zone_count+1) == zones.count
+           result= true;
+         end
+       end
+
+       result
+     end
+    
+    test('create record - simple A record') do
+      pending if Fog.mocking?
+
+      host= 'www'
+      options = { :hostname => host }
+      response = Zerigo[:dns].create_host( @zone_id, 'A', '1.2.3.4', options)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+  
+    test('create record - CNAME record') do
+      pending if Fog.mocking?
+      
+      host = 'mail'
+      options = { :hostname => host }
+      response = Zerigo[:dns].create_host( @zone_id, 'CNAME', @domain, options)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - NS record') do
+      pending if Fog.mocking?
+
+      #note, when use create_host for a NS record, it needs to be a delation
+      #rather than a NS record for the main domain (those NS records are setup
+      #using the zone methods)
+      sub_domain = 'subdomain'        # that we want to delete DNS for
+      ns_host = 'ns.' + @domain
+      options = { :hostname => sub_domain}
+      response = Zerigo[:dns].create_host( @zone_id, 'NS', ns_host, options)
+      if response.status == 201
+        record_id = response.body['id']
+        @new_records << record_id
+      end
+      
+      response.status == 201
+    end
+
+    test('create record - MX record') do
+      pending if Fog.mocking?
+
+      mail_domain = 'mail.' + @domain
+      options = { :hostname => @domain, :ttl => 3600, :priority => '3'}
+      response = Zerigo[:dns].create_host( @zone_id, 'MX', mail_domain, options)
+      if response.status == 201
+        @record_id = response.body['id']
+        @new_records << @record_id
+      end
+      
+      response.status == 201
+    end
+        
+    test("get host #{@record_id}") do
+      pending if Fog.mocking?
+
+      result = false
+      
+      response = Zerigo[:dns].get_host( @record_id)
+      if response.status == 200
+        host = response.body
+        if (host['id'] == @record_id) and (host['host-type'] == 'MX') and
+           (host['created-at'].length > 0) and (host['updated-at'].length > 0)
+          result = true
+        end
+      end
+      
+      result
+    end
+
+    test("update host #{@record_id}") do
+      pending if Fog.mocking?
+
+      result = false
+      
+      options = { :priority => 7 }
+      response = Zerigo[:dns].update_host( @record_id, options)
+      if response.status == 200
+        response = Zerigo[:dns].get_host( @record_id)
+        if response.status == 200
+          host= response.body
+          if (host['priority']  == 7)
+            result = true
+          end
+        end
+      end
+              
+      result
+    end
+
+    test('count host records') do
+      pending if Fog.mocking?
+
+      host_count = 0
+      response = Zerigo[:dns].count_hosts( @zone_id)
+      if response.status == 200
+        host_count = response.body['count']
+      end
+      
+      host_count == 4
+    end
+
+    test('list host records') do
+      pending if Fog.mocking?
+
+      result = false
+      
+      response = Zerigo[:dns].list_hosts( @zone_id)
+      if response.status == 200
+        hosts = response.body['hosts']
+        if (hosts.count == 4)
+          hosts.each { |host|
+            if (host['id'] > 0) and (host['fqdn'].length > 0) and (host['host-type'].length > 0) and
+               (host['created-at'].length > 0) and (host['updated-at'].length > 0)
+              result = true
+            end
+          }
+        end
+      end      
+      
+      result
+    end
+  
+    test("find host: mail.#{@domain}") do
+      pending if Fog.mocking?
+
+      result = false
+      
+      host = 'mail.' + @domain
+      response = Zerigo[:dns].find_hosts( host)
+      if response.status == 200
+        hosts = response.body['hosts']
+        host_count = hosts.count
+        if (host_count == 1)
+          result = true
+        end
+      end
+      
+      result
+    end
+
+    test("find host: mail.#{@domain} - method 2") do
+      pending if Fog.mocking?
+
+      result = false
+      
+      host = 'mail.' + @domain
+      response = Zerigo[:dns].find_hosts( host, @zone_id)
+      if response.status == 200
+        hosts = response.body['hosts']
+        host_count = hosts.count
+        if (host_count == 1)
+          result = true
+        end
+      end
+      
+      result
+    end
+
+    test("delete #{@new_records.count} records created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_records.each { |record_id|
+        response = Zerigo[:dns].delete_host( record_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+
+      result
+    end
+
+    test("delete #{@new_zones.count} zones created") do
+      pending if Fog.mocking?
+
+      result= true
+      @new_zones.each { |zone_id|
+        response = Zerigo[:dns].delete_zone( zone_id)
+        if response.status != 200
+            result= false;
+        end
+      }
+      result
+    end
+        
+  end
+  
+  tests( 'failure') do
+  end
+  
+end
diff --git a/vendor/fog-0.8.2/tests/helper.rb b/vendor/fog-0.8.2/tests/helper.rb
new file mode 100644
index 0000000..b076f52
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helper.rb
@@ -0,0 +1,16 @@
+require 'fog'
+require 'fog/bin'
+
+require File.expand_path(File.join(File.dirname(__FILE__), 'helpers', 'mock_helper'))
+
+def lorem_file
+  File.open(File.dirname(__FILE__) + '/lorem.txt', 'r')
+end
+
+# check to see which credentials are available and add others to the skipped tags list
+all_providers = ['aws', 'bluebox', 'brightbox', 'dnsimple', 'ecloud', 'gogrid', 'google', 'linode', 'local', 'newservers', 'rackspace', 'slicehost', 'stormondemand', 'voxel', 'zerigo']
+available_providers = Fog.available_providers.map {|provider| provider.downcase}
+for provider in (all_providers - available_providers)
+  Formatador.display_line("[yellow]Skipping tests for [bold]#{provider}[/] [yellow]due to lacking credentials (add some to '~/.fog' to run them)[/]")
+  Thread.current[:tags] << ('-' << provider)
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/collection_helper.rb b/vendor/fog-0.8.2/tests/helpers/collection_helper.rb
new file mode 100644
index 0000000..7c731ba
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/collection_helper.rb
@@ -0,0 +1,51 @@
+def collection_tests(collection, params = {}, mocks_implemented = true)
+
+  tests('success') do
+
+    tests("#new(#{params.inspect})").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      collection.new(params)
+    end
+
+    tests("#create(#{params.inspect})").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      @instance = collection.create(params)
+    end
+
+    tests("#all").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      collection.all
+    end
+
+    if !Fog.mocking? || mocks_implemented
+      @identity = @instance.identity
+    end
+
+    tests("#get(#{@identity})").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      collection.get(@identity)
+    end
+
+    if block_given?
+      yield
+    end
+
+    if !Fog.mocking? || mocks_implemented
+      @instance.destroy
+    end
+  end
+
+  tests('failure') do
+
+    if !Fog.mocking? || mocks_implemented
+      @identity = @identity.to_s.gsub(/\w/, '0')
+    end
+
+    tests("#get('#{@identity}')").returns(nil) do
+      pending if Fog.mocking? && !mocks_implemented
+      collection.get(@identity)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/compute/flavors_helper.rb b/vendor/fog-0.8.2/tests/helpers/compute/flavors_helper.rb
new file mode 100644
index 0000000..11b98a3
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/compute/flavors_helper.rb
@@ -0,0 +1,34 @@
+def flavors_tests(connection, params = {}, mocks_implemented = true)
+
+  tests('success') do
+
+    tests("#all").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      connection.flavors.all
+    end
+
+    if !Fog.mocking? || mocks_implemented
+      @identity = connection.flavors.first.identity
+    end
+
+    tests("#get('#{@identity}')").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      connection.flavors.get(@identity)
+    end
+
+  end
+
+  tests('failure') do
+
+    if !Fog.mocking? || mocks_implemented
+      invalid_flavor_identity = connection.flavors.first.identity.to_s.gsub(/\w/, '0')
+    end
+
+    tests("#get('#{invalid_flavor_identity}')").returns(nil) do
+      pending if Fog.mocking? && !mocks_implemented
+      connection.flavors.get(invalid_flavor_identity)
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/compute/server_helper.rb b/vendor/fog-0.8.2/tests/helpers/compute/server_helper.rb
new file mode 100644
index 0000000..1dc7b6f
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/compute/server_helper.rb
@@ -0,0 +1,25 @@
+def server_tests(connection, params = {}, mocks_implemented = true)
+
+  model_tests(connection.servers, params, mocks_implemented) do
+
+    tests('#reload').returns(true) do
+      pending if Fog.mocking? && !mocks_implemented
+      identity = @instance.identity
+      !identity.nil? && identity == @instance.reload.identity
+    end
+
+    responds_to([:ready?, :state])
+
+    tests('#reboot').succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      @instance.wait_for { ready? }
+      @instance.reboot
+    end
+
+    if !Fog.mocking? || mocks_implemented
+      @instance.wait_for { ready? }
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/compute/servers_helper.rb b/vendor/fog-0.8.2/tests/helpers/compute/servers_helper.rb
new file mode 100644
index 0000000..643a123
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/compute/servers_helper.rb
@@ -0,0 +1,11 @@
+def servers_tests(connection, params = {}, mocks_implemented = true)
+
+  collection_tests(connection.servers, params, mocks_implemented) do
+
+    if !Fog.mocking? || mocks_implemented
+      @instance.wait_for { ready? }
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/formats_helper.rb b/vendor/fog-0.8.2/tests/helpers/formats_helper.rb
new file mode 100644
index 0000000..6fed3f6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/formats_helper.rb
@@ -0,0 +1,74 @@
+# format related hackery
+# allows both true.is_a?(Fog::Boolean) and false.is_a?(Fog::Boolean)
+# allows both nil.is_a?(Fog::Nullable::String) and ''.is_a?(Fog::Nullable::String)
+module Fog
+  module Boolean; end
+  module Nullable
+    module Boolean; end
+    module Integer; end
+    module String; end
+    module Time; end
+  end
+end
+[FalseClass, TrueClass].each {|klass| klass.send(:include, Fog::Boolean)}
+[NilClass, Fog::Boolean].each {|klass| klass.send(:include, Fog::Nullable::Boolean)}
+[NilClass, String].each {|klass| klass.send(:include, Fog::Nullable::String)}
+[NilClass, Time].each {|klass| klass.send(:include, Fog::Nullable::Time)}
+[Integer, NilClass].each {|klass| klass.send(:include, Fog::Nullable::Integer)}
+
+module Shindo
+  class Tests
+
+    def formats(format)
+      raise ArgumentError, 'format is nil' unless format
+
+      test('has proper format') do
+        formats_kernel(instance_eval(&Proc.new), format)
+      end
+    end
+
+    private
+
+    def formats_kernel(original_data, original_format, original = true)
+      valid = true
+      data = original_data.dup
+      format = original_format.dup
+      if format.is_a?(Array)
+        data   = {:element => data}
+        format = {:element => format}
+      end
+      for key, value in format
+        datum = data.delete(key)
+        format.delete(key)
+        case value
+        when Array
+          valid &&= datum.is_a?(Array) || p("not Array: #{datum.inspect}")
+          if datum.is_a?(Array) && !value.empty?
+            for element in datum
+              type = value.first
+              if type.is_a?(Hash)
+                valid &&= formats_kernel({:element => element}, {:element => type}, false)
+              else
+                valid &&= element.is_a?(type)
+              end
+            end
+          end
+        when Hash
+          valid &&= datum.is_a?(Hash) || p("not Hash: #{datum.inspect}")
+          valid &&= formats_kernel(datum, value, false)
+        else
+          p "#{key} not #{value}: #{datum.inspect}" unless datum.is_a?(value)
+          valid &&= datum.is_a?(value)
+        end
+      end
+      p data unless data.empty?
+      p format unless format.empty?
+      valid &&= data.empty? && format.empty?
+      if !valid && original
+        @message = "#{original_data.inspect} does not match #{original_format.inspect}"
+      end
+      valid
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/formats_helper_tests.rb b/vendor/fog-0.8.2/tests/helpers/formats_helper_tests.rb
new file mode 100644
index 0000000..64ff8cc
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/formats_helper_tests.rb
@@ -0,0 +1,43 @@
+Shindo.tests('test_helper', 'meta') do
+
+  tests('#formats_kernel') do
+
+    tests('returns true') do
+
+      test('when format of value matches') do
+        formats_kernel({:a => :b}, {:a => Symbol})
+      end
+
+      test('when format of nested array elements matches') do
+        formats_kernel({:a => [:b, :c]}, {:a => [Symbol]})
+      end
+
+      test('when format of nested hash matches') do
+        formats_kernel({:a => {:b => :c}}, {:a => {:b => Symbol}})
+      end
+
+      test('when format of an array') do
+        formats_kernel([{:a => :b}], [{:a => Symbol}])
+      end
+
+    end
+
+    tests('returns false') do
+
+      test('when format of value does not match') do
+        !formats_kernel({:a => :b}, {:a => String})
+      end
+
+      test('when not all keys are checked') do
+        !formats_kernel({:a => :b}, {})
+      end
+
+      test('when some keys do not appear') do
+        !formats_kernel({}, {:a => String})
+      end
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/mock_helper.rb b/vendor/fog-0.8.2/tests/helpers/mock_helper.rb
new file mode 100644
index 0000000..d71fd9c
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/mock_helper.rb
@@ -0,0 +1,43 @@
+# Use so you can run in mock mode from the command line
+#
+# FOG_MOCK=true fog
+
+if ENV["FOG_MOCK"] == "true"
+  Fog.mock!
+end
+
+# if in mocked mode, fill in some fake credentials for us
+if Fog.mock?
+  Fog.instance_variable_set(:@credentials, {
+    :aws_access_key_id                => 'aws_access_key_id',
+    :aws_secret_access_key            => 'aws_secret_access_key',
+    :bluebox_api_key                  => 'bluebox_api_key',
+    :bluebox_customer_id              => 'bluebox_customer_id',
+    :brightbox_client_id              => 'brightbox_client_id',
+    :brightbox_secret                 => 'brightbox_secret',
+    :dnsimple_email                   => 'dnsimple_email',
+    :dnsimple_password                => 'dnsimple_password',
+    :ecloud_username                  => 'ecloud_username',
+    :ecloud_password                  => 'ecloud_password',
+    :ecloud_versions_uri              => 'http://ecloud.versions.uri',
+    :go_grid_api_key                  => 'go_grid_api_key',
+    :go_grid_shared_secret            => 'go_grid_shared_secret',
+    :google_storage_access_key_id     => 'google_storage_access_key_id',
+    :google_storage_secret_access_key => 'google_storage_secret_access_key',
+    :linode_api_key                   => 'linode_api_key',
+    :local_root                       => '~/.fog',
+    :new_servers_password             => 'new_servers_password',
+    :new_servers_username             => 'new_servers_username',
+#    :public_key_path                  => '~/.ssh/id_rsa.pub',
+#    :private_key_path                 => '~/.ssh/id_rsa',
+    :rackspace_api_key                => 'rackspace_api_key',
+    :rackspace_username               => 'rackspace_username',
+    :slicehost_password               => 'slicehost_password',
+    :storm_on_demand_username         => 'storm_on_demand_username',
+    :storm_on_demand_password         => 'storm_on_demand_password',
+    :voxel_api_key                    => 'voxel_api_key',
+    :voxel_api_secret                 => 'voxel_api_secret',
+    :zerigo_email                     => 'zerigo_email',
+    :zerigo_token                     => 'zerigo_token'
+  })
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/model_helper.rb b/vendor/fog-0.8.2/tests/helpers/model_helper.rb
new file mode 100644
index 0000000..ff1fca2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/model_helper.rb
@@ -0,0 +1,26 @@
+def model_tests(collection, params = {}, mocks_implemented = true)
+
+  tests('success') do
+
+    @instance = collection.new(params)
+
+    tests("#save").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      @instance.save
+    end
+
+    if block_given?
+      yield
+    end
+
+    tests("#destroy").succeeds do
+      pending if Fog.mocking? && !mocks_implemented
+      @instance.destroy
+    end
+
+  end
+
+  tests('failure') do
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/responds_to_helper.rb b/vendor/fog-0.8.2/tests/helpers/responds_to_helper.rb
new file mode 100644
index 0000000..f1482df
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/responds_to_helper.rb
@@ -0,0 +1,13 @@
+module Shindo
+  class Tests
+
+    def responds_to(method_names)
+      for method_name in [*method_names]
+        tests("#respond_to?(:#{method_name})").returns(true) do
+          @instance.respond_to?(method_name)
+        end
+      end
+    end
+
+  end
+end
diff --git a/vendor/fog-0.8.2/tests/helpers/succeeds_helper.rb b/vendor/fog-0.8.2/tests/helpers/succeeds_helper.rb
new file mode 100644
index 0000000..527a067
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/helpers/succeeds_helper.rb
@@ -0,0 +1,12 @@
+module Shindo
+  class Tests
+
+    def succeeds
+      test('succeeds') do
+        instance_eval(&Proc.new)
+        true
+      end
+    end
+
+  end
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/lorem.txt b/vendor/fog-0.8.2/tests/lorem.txt
new file mode 100644
index 0000000..e8b7adf
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/lorem.txt
@@ -0,0 +1 @@
+Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/storage/helper.rb b/vendor/fog-0.8.2/tests/storage/helper.rb
new file mode 100644
index 0000000..3c60826
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/helper.rb
@@ -0,0 +1,16 @@
+def storage_providers
+  {
+    AWS       => {
+      :mocked => true
+    },
+    Google    => {
+      :mocked => true
+    },
+    Local     => {
+      :mocked => false
+    },
+    Rackspace => {
+      :mocked => false
+    }
+  }
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/storage/models/directories_tests.rb b/vendor/fog-0.8.2/tests/storage/models/directories_tests.rb
new file mode 100644
index 0000000..f64a0ab
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/models/directories_tests.rb
@@ -0,0 +1,17 @@
+for provider, config in storage_providers
+
+  Shindo.tests("#{provider}::Storage | directories", [provider.to_s.downcase]) do
+
+    if !Fog.mocking? || config[:mocked]
+
+      directory_attributes = {
+        :key => 'fogdirectoriestests',
+      }.merge!(config[:directory_attributes] || {})
+
+      collection_tests(provider[:storage].directories, directory_attributes, config[:mocked])
+
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/storage/models/directory_test.rb b/vendor/fog-0.8.2/tests/storage/models/directory_test.rb
new file mode 100644
index 0000000..e5e8da2
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/models/directory_test.rb
@@ -0,0 +1,29 @@
+for provider, config in storage_providers
+
+  Shindo.tests("#{provider}::Storage | directory", [provider.to_s.downcase]) do
+
+    if !Fog.mocking? || config[:mocked]
+
+      directory_attributes = {
+        :key => 'fogdirectorytests'
+      }.merge!(config[:directory_attributes] || {})
+
+      model_tests(provider[:storage].directory, directory_attributes, config[:mocked]) do
+
+        tests("#public=(true)").succeeds do
+          pending if Fog.mocking? && !config[:mocked]
+          @instance.public=(true)
+        end
+
+        tests('responds_to(:public_url)') do
+          pending if Fog.mocking? && !config[:mocked]
+          @instance.responds_to(:public_url)
+        end
+
+      end
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/models/file_tests.rb b/vendor/fog-0.8.2/tests/storage/models/file_tests.rb
new file mode 100644
index 0000000..6c12237
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/models/file_tests.rb
@@ -0,0 +1,41 @@
+for provider, config in storage_providers
+
+  Shindo.tests("#{provider}::Storage | file", [provider.to_s.downcase]) do
+
+    if !Fog.mocking? || config[:mocked]
+
+      file_attributes = {
+        :key => 'fog_file_tests',
+        :body => lorem_file,
+        :public => true
+      }.merge!(config[:file_attributes] || {})
+
+      directory_attributes = {
+        :key => 'fogfilestests'
+      }.merge!(config[:directory_attributes] || {})
+
+      @directory = provider[:storage].directories.create(directory_attributes)
+
+      model_tests(@directory.files, file_attributes, config[:mocked]) do
+
+        responds_to(:public_url)
+
+        tests("#public=(true)").succeeds do
+          pending if Fog.mocking? && !config[:mocked]
+          @instance.public=(true)
+        end
+
+        test("@instance.public_url.nil? || Excon.get(@instance.public_url).body == lorem_file.read") do
+          pending if Fog.mocking?
+          @instance.public_url.nil? || Excon.get(@instance.public_url).body == lorem_file.read
+        end
+
+      end
+
+      @directory.destroy
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/models/files_tests.rb b/vendor/fog-0.8.2/tests/storage/models/files_tests.rb
new file mode 100644
index 0000000..284df7f
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/models/files_tests.rb
@@ -0,0 +1,26 @@
+for provider, config in storage_providers
+
+  Shindo.tests("#{provider}::Storage | files", [provider.to_s.downcase]) do
+
+    if !Fog.mocking? || config[:mocked]
+
+      file_attributes = {
+        :key => 'fog_files_tests',
+        :body => lorem_file
+      }.merge!(config[:file_attributes] || {})
+
+      directory_attributes = {
+        :key => 'fogfilestests'
+      }.merge!(config[:directory_attributes] || {})
+
+      @directory = provider.directories.create(directory_attributes)
+
+      collection_tests(@directory.files, file_attributes, config[:mocked])
+
+      @directory.destroy
+
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/aws/bucket_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/aws/bucket_tests.rb
new file mode 100644
index 0000000..87c2853
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/aws/bucket_tests.rb
@@ -0,0 +1,114 @@
+Shindo.tests('AWS::Storage | bucket requests', ['aws']) do
+
+  tests('success') do
+
+    @bucket_format = {
+      'CommonPrefixes'  => [],
+      'IsTruncated'     => Fog::Boolean,
+      'Marker'          => NilClass,
+      'MaxKeys'         => Integer,
+      'Name'            => String,
+      'Prefix'          => NilClass,
+      'Contents'    => [{
+        'ETag'          => String,
+        'Key'           => String,
+        'LastModified'  => Time,
+        'Owner' => {
+          'DisplayName' => String,
+          'ID'          => String
+        },
+        'Size' => Integer,
+        'StorageClass' => String
+      }]
+    }
+
+    @service_format = {
+      'Buckets' => [{
+        'CreationDate'  => Time,
+        'Name'          => String,
+      }],
+      'Owner'   => {
+        'DisplayName' => String,
+        'ID'          => String
+      }
+    }
+
+    tests("#put_bucket('fogbuckettests')").succeeds do
+      AWS[:storage].put_bucket('fogbuckettests')
+    end
+
+    tests("#get_service").formats(@service_format) do
+      AWS[:storage].get_service.body
+    end
+
+    file = AWS[:storage].directories.get('fogbuckettests').files.create(:body => 'y', :key => 'x')
+
+    tests("#get_bucket('fogbuckettests)").formats(@bucket_format) do
+      AWS[:storage].get_bucket('fogbuckettests').body
+    end
+
+    file.destroy
+
+    tests("#get_bucket_location('fogbuckettests)").formats('LocationConstraint' => NilClass) do
+      AWS[:storage].get_bucket_location('fogbuckettests').body
+    end
+
+    tests("#get_request_payment('fogbuckettests')").formats('Payer' => String) do
+      AWS[:storage].get_request_payment('fogbuckettests').body
+    end
+
+    tests("#put_request_payment('fogbuckettests', 'Requester')").succeeds do
+      AWS[:storage].put_request_payment('fogbuckettests', 'Requester')
+    end
+
+    tests("#put_bucket_website('fogbuckettests', 'index.html')").succeeds do
+      pending if Fog.mocking?
+      AWS[:storage].put_bucket_website('fogbuckettests', 'index.html')
+    end
+
+    tests("#delete_bucket_website('fogbuckettests')").succeeds do
+      pending if Fog.mocking?
+      AWS[:storage].delete_bucket_website('fogbuckettests')
+    end
+
+    tests("#delete_bucket('fogbuckettests')").succeeds do
+      AWS[:storage].delete_bucket('fogbuckettests')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#delete_bucket('fognonbucket')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].delete_bucket('fognonbucket')
+    end
+
+    @bucket = AWS[:storage].directories.create(:key => 'fognonempty')
+    @file = @bucket.files.create(:key => 'foo', :body => 'bar')
+
+    tests("#delete_bucket('fognonempty')").raises(Excon::Errors::Conflict) do
+      AWS[:storage].delete_bucket('fognonempty')
+    end
+
+    @file.destroy
+    @bucket.destroy
+
+    tests("#get_bucket('fognonbucket')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].get_bucket('fognonbucket')
+    end
+
+    tests("#get_bucket_location('fognonbucket')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].get_bucket_location('fognonbucket')
+    end
+
+    tests("#get_request_payment('fognonbucket')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].get_request_payment('fognonbucket')
+    end
+
+    tests("#put_request_payment('fognonbucket', 'Requester')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].put_request_payment('fognonbucket', 'Requester')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/aws/multipart_upload_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/aws/multipart_upload_tests.rb
new file mode 100644
index 0000000..17f3cd6
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/aws/multipart_upload_tests.rb
@@ -0,0 +1,135 @@
+Shindo.tests('AWS::Storage | object requests', ['aws']) do
+
+  @directory = AWS[:storage].directories.create(:key => 'fogmultipartuploadtests')
+
+  tests('success') do
+
+    @initiate_multipart_upload_format = {
+      'Bucket'    => String,
+      'Key'       => String,
+      'UploadId'  => String
+    }
+
+    tests("#initiate_multipart_upload('#{@directory.identity}')", 'fog_multipart_upload').formats(@initiate_multipart_upload_format) do
+      pending if Fog.mocking?
+      data = AWS[:storage].initiate_multipart_upload(@directory.identity, 'fog_multipart_upload').body
+      @upload_id = data['UploadId']
+      data
+    end
+
+    @list_multipart_uploads_format = {
+      'Bucket'              => String,
+      'IsTruncated'         => Fog::Boolean,
+      'MaxUploads'          => Integer,
+      'KeyMarker'           => NilClass,
+      'NextKeyMarker'       => String,
+      'NextUploadIdMarker'  => Fog::Nullable::String,
+      'Upload' => [{
+        'Initiated'     => Time,
+        'Initiator' => {
+          'DisplayName' => String,
+          'ID'          => String
+        },
+        'Key'           => String,
+        'Owner' => {
+          'DisplayName' => String,
+          'ID'          => String
+        },
+        'StorageClass'      => String,
+        'UploadId'          => String
+      }],
+      'UploadIdMarker'      => NilClass,
+    }
+
+    tests("#list_multipart_uploads('#{@directory.identity})").formats(@list_multipart_uploads_format) do
+      pending if Fog.mocking?
+      AWS[:storage].list_multipart_uploads(@directory.identity).body
+    end
+
+    @parts = []
+
+    tests("#upload_part('#{@directory.identity}', 'fog_multipart_upload', '#{@upload_id}', 1, ('x' * 6 * 1024 * 1024))").succeeds do
+      pending if Fog.mocking?
+      data = AWS[:storage].upload_part(@directory.identity, 'fog_multipart_upload', @upload_id, 1, ('x' * 6 * 1024 * 1024))
+      @parts << data.headers['ETag']
+    end
+
+    @list_parts_format = {
+      'Bucket'            => String,
+      'Initiator' => {
+        'DisplayName'     => String,
+        'ID'              => String
+      },
+      'IsTruncated'       => Fog::Boolean,
+      'Key'               => String,
+      'MaxParts'          => Integer,
+      'NextPartNumberMarker' => String,
+      'Part' => [{
+        'ETag'            => String,
+        'LastModified'    => Time,
+        'PartNumber'      => Integer,
+        'Size'            => Integer
+      }],
+      'PartNumberMarker'  => String,
+      'StorageClass'      => String,
+      'UploadId'          => String
+    }
+
+    tests("#list_parts('#{@directory.identity}', 'fog_multipart_upload', '#{@upload_id}')").formats(@list_parts_format) do
+      pending if Fog.mocking?
+      AWS[:storage].list_parts(@directory.identity, 'fog_multipart_upload', @upload_id).body
+    end
+
+    if !Fog.mocking?
+      @parts << AWS[:storage].upload_part(@directory.identity, 'fog_multipart_upload', @upload_id, 2, ('x' * 4 * 1024 * 1024)).headers['ETag']
+    end
+
+    @complete_multipart_upload_format = {
+      'Bucket'    => String,
+      'ETag'      => String,
+      'Key'       => String,
+      'Location'  => String
+    }
+
+    tests("#complete_multipart_upload('#{@directory.identity}', 'fog_multipart_upload', '#{@upload_id}', #{@parts.inspect})").formats(@complete_multipart_upload_format) do
+      pending if Fog.mocking?
+      AWS[:storage].complete_multipart_upload(@directory.identity, 'fog_multipart_upload', @upload_id, @parts).body
+    end
+
+    tests("#get_object('#{@directory.identity}', 'fog_multipart_upload').body").succeeds do
+      pending if Fog.mocking?
+      data = AWS[:storage].get_object(@directory.identity, 'fog_multipart_upload').body
+      unless data == ('x' * 10 * 1024 * 1024)
+        raise 'content mismatch'
+      end
+    end
+
+    if !Fog.mocking?
+      @directory.files.new(:key => 'fog_multipart_upload').destroy
+    end
+
+    if !Fog.mocking?
+      @upload_id = AWS[:storage].initiate_multipart_upload(@directory.identity, 'fog_multipart_abort').body['UploadId']
+    end
+
+    tests("#abort_multipart_upload('#{@directory.identity}', 'fog_multipart_abort', '#{@upload_id}')").succeeds do
+      pending if Fog.mocking?
+      AWS[:storage].abort_multipart_upload(@directory.identity, 'fog_multipart_abort', @upload_id)
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("initiate_multipart_upload")
+    tests("list_multipart_uploads")
+    tests("upload_part")
+    tests("list_parts")
+    tests("complete_multipart_upload")
+    tests("abort_multipart_upload")
+
+  end
+
+  @directory.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/aws/object_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/aws/object_tests.rb
new file mode 100644
index 0000000..161860e
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/aws/object_tests.rb
@@ -0,0 +1,81 @@
+Shindo.tests('AWS::Storage | object requests', ['aws']) do
+
+  @directory = AWS[:storage].directories.create(:key => 'fogobjecttests')
+
+  tests('success') do
+
+    tests("#put_object('#{@directory.identity}', 'fog_object', lorem_file)").succeeds do
+      AWS[:storage].put_object(@directory.identity, 'fog_object', lorem_file)
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_object', '#{@directory.identity}', 'fog_other_object')").succeeds do
+      AWS[:storage].copy_object(@directory.identity, 'fog_object', @directory.identity, 'fog_other_object')
+    end
+
+    @directory.files.get('fog_other_object').destroy
+
+    tests("#get_object('#{@directory.identity}', 'fog_object')").returns(lorem_file.read) do
+      AWS[:storage].get_object(@directory.identity, 'fog_object').body
+    end
+
+    tests("#get_object('#{@directory.identity}', 'fog_object', &block)").returns(lorem_file.read) do
+      data = ''
+      AWS[:storage].get_object(@directory.identity, 'fog_object') do |chunk, remaining_bytes, total_bytes|
+        data << chunk
+      end
+      data
+    end
+
+    tests("#head_object('#{@directory.identity}', 'fog_object')").succeeds do
+      AWS[:storage].head_object(@directory.identity, 'fog_object')
+    end
+
+    tests("#delete_object('#{@directory.identity}', 'fog_object')").succeeds do
+      AWS[:storage].delete_object(@directory.identity, 'fog_object')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#put_object('fognonbucket', 'fog_non_object', lorem_file)").raises(Excon::Errors::NotFound) do
+      AWS[:storage].put_object('fognonbucket', 'fog_non_object', lorem_file)
+    end
+
+    tests("#copy_object('fognonbucket', 'fog_object', '#{@directory.identity}', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].copy_object('fognonbucket', 'fog_object', @directory.identity, 'fog_other_object')
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_non_object', '#{@directory.identity}', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].copy_object(@directory.identity, 'fog_non_object', @directory.identity, 'fog_other_object')
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_object', 'fognonbucket', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].copy_object(@directory.identity, 'fog_object', 'fognonbucket', 'fog_other_object')
+    end
+
+    tests("#get_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].get_object('fognonbucket', 'fog_non_object')
+    end
+
+    tests("#get_object('#{@directory.identity}', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].get_object(@directory.identity, 'fog_non_object')
+    end
+
+    tests("#head_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].head_object('fognonbucket', 'fog_non_object')
+    end
+
+    tests("#head_object('#{@directory.identity}', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].head_object(@directory.identity, 'fog_non_object')
+    end
+
+    tests("#delete_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      AWS[:storage].delete_object('fognonbucket', 'fog_non_object')
+    end
+
+  end
+
+  @directory.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/google/bucket_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/google/bucket_tests.rb
new file mode 100644
index 0000000..18c4c2f
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/google/bucket_tests.rb
@@ -0,0 +1,78 @@
+Shindo.tests('Google::Storage | bucket requests', ['google']) do
+
+  tests('success') do
+
+    @bucket_format = {
+      'CommonPrefixes' => [],
+      'IsTruncated'     => Fog::Boolean,
+      'Marker'          => NilClass,
+      'Name'            => String,
+      'Prefix'          => NilClass,
+      'Contents'        => [{
+        'ETag'          => String,
+        'Key'           => String,
+        'LastModified'  => Time,
+        'Owner' => {
+          'DisplayName' => String,
+          'ID'          => String
+        },
+        'Size' => Integer,
+        'StorageClass'  => String
+      }]
+    }
+
+    @service_format = {
+      'Buckets' => [{
+        'CreationDate'  => Time,
+        'Name'          => String,
+      }],
+      'Owner'   => {
+        'ID'          => String
+      }
+    }
+
+    tests("#put_bucket('fogbuckettests')").succeeds do
+      Google[:storage].put_bucket('fogbuckettests')
+    end
+
+    tests("#get_service").formats(@service_format) do
+      Google[:storage].get_service.body
+    end
+
+    file = Google[:storage].directories.get('fogbuckettests').files.create(:body => 'y', :key => 'x')
+
+    tests("#get_bucket('fogbuckettests)").formats(@bucket_format) do
+      Google[:storage].get_bucket('fogbuckettests').body
+    end
+
+    file.destroy
+
+    tests("#delete_bucket('fogbuckettests')").succeeds do
+      Google[:storage].delete_bucket('fogbuckettests')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#delete_bucket('fognonbucket')").raises(Excon::Errors::NotFound) do
+      Google[:storage].delete_bucket('fognonbucket')
+    end
+
+    @bucket = Google[:storage].directories.create(:key => 'fognonempty')
+    @file = @bucket.files.create(:key => 'foo', :body => 'bar')
+
+    tests("#delete_bucket('fognonempty')").raises(Excon::Errors::Conflict) do
+      Google[:storage].delete_bucket('fognonempty')
+    end
+
+    @file.destroy
+    @bucket.destroy
+
+    tests("#get_bucket('fognonbucket')").raises(Excon::Errors::NotFound) do
+      Google[:storage].get_bucket('fognonbucket')
+    end
+
+  end
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/google/object_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/google/object_tests.rb
new file mode 100644
index 0000000..7432539
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/google/object_tests.rb
@@ -0,0 +1,81 @@
+Shindo.tests('Google::Storage | object requests', ['google']) do
+
+  @directory = Google[:storage].directories.create(:key => 'fogobjecttests')
+
+  tests('success') do
+
+    tests("#put_object('#{@directory.identity}', 'fog_object', lorem_file)").succeeds do
+      Google[:storage].put_object(@directory.identity, 'fog_object', lorem_file)
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_object', '#{@directory.identity}', 'fog_other_object')").succeeds do
+      Google[:storage].copy_object(@directory.identity, 'fog_object', @directory.identity, 'fog_other_object')
+    end
+
+    @directory.files.get('fog_other_object').destroy
+
+    tests("#get_object('#{@directory.identity}', 'fog_object')").returns(lorem_file.read) do
+      Google[:storage].get_object(@directory.identity, 'fog_object').body
+    end
+
+    tests("#get_object('#{@directory.identity}', 'fog_object', &block)").returns(lorem_file.read) do
+      data = ''
+      Google[:storage].get_object(@directory.identity, 'fog_object') do |chunk, remaining_bytes, total_bytes|
+        data << chunk
+      end
+      data
+    end
+
+    tests("#head_object('#{@directory.identity}', 'fog_object')").succeeds do
+      Google[:storage].head_object(@directory.identity, 'fog_object')
+    end
+
+    tests("#delete_object('#{@directory.identity}', 'fog_object')").succeeds do
+      Google[:storage].delete_object(@directory.identity, 'fog_object')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#put_object('fognonbucket', 'fog_non_object', lorem_file)").raises(Excon::Errors::NotFound) do
+      Google[:storage].put_object('fognonbucket', 'fog_non_object', lorem_file)
+    end
+
+    tests("#copy_object('fognonbucket', 'fog_object', '#{@directory.identity}', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].copy_object('fognonbucket', 'fog_object', @directory.identity, 'fog_other_object')
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_non_object', '#{@directory.identity}', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].copy_object(@directory.identity, 'fog_non_object', @directory.identity, 'fog_other_object')
+    end
+
+    tests("#copy_object('#{@directory.identity}', 'fog_object', 'fognonbucket', 'fog_other_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].copy_object(@directory.identity, 'fog_object', 'fognonbucket', 'fog_other_object')
+    end
+
+    tests("#get_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].get_object('fognonbucket', 'fog_non_object')
+    end
+
+    tests("#get_object('#{@directory.identity}', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].get_object(@directory.identity, 'fog_non_object')
+    end
+
+    tests("#head_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].head_object('fognonbucket', 'fog_non_object')
+    end
+
+    tests("#head_object('#{@directory.identity}', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].head_object(@directory.identity, 'fog_non_object')
+    end
+
+    tests("#delete_object('fognonbucket', 'fog_non_object')").raises(Excon::Errors::NotFound) do
+      Google[:storage].delete_object('fognonbucket', 'fog_non_object')
+    end
+
+  end
+
+  @directory.destroy
+
+end
diff --git a/vendor/fog-0.8.2/tests/storage/requests/rackspace/container_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/rackspace/container_tests.rb
new file mode 100644
index 0000000..00d1831
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/rackspace/container_tests.rb
@@ -0,0 +1,64 @@
+Shindo.tests('Rackspace::Storage | container requests', ['rackspace']) do
+
+  @container_format = [String]
+
+  @containers_format = [{
+    'bytes' => Integer,
+    'count' => Integer,
+    'name'  => String
+  }]
+
+  tests('success') do
+
+    tests("#put_container('fogcontainertests')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].put_container('fogcontainertests')
+    end
+
+    tests("#get_container('fogcontainertests')").formats(@container_format) do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_container('fogcontainertests').body
+    end
+
+    tests("#get_containers").formats(@containers_format) do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_containers.body
+    end
+
+    tests("#head_container('fogcontainertests')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_container('fogcontainertests')
+    end
+
+    tests("#head_containers").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_containers
+    end
+
+    tests("#delete_container('fogcontainertests')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].delete_container('fogcontainertests')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_container('fognoncontainer')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_container('fognoncontainer')
+    end
+
+    tests("#head_container('fognoncontainer')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_container('fognoncontainer')
+    end
+
+    tests("#delete_container('fognoncontainer')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].delete_container('fognoncontainer')
+    end
+
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/fog-0.8.2/tests/storage/requests/rackspace/object_tests.rb b/vendor/fog-0.8.2/tests/storage/requests/rackspace/object_tests.rb
new file mode 100644
index 0000000..04d87dc
--- /dev/null
+++ b/vendor/fog-0.8.2/tests/storage/requests/rackspace/object_tests.rb
@@ -0,0 +1,78 @@
+Shindo.tests('Rackspace::Storage | object requests', ['rackspace']) do
+
+  unless Fog.mocking?
+    @directory = Rackspace[:storage].directories.create(:key => 'fogobjecttests')
+  end
+
+  tests('success') do
+
+    tests("#put_object('fogobjecttests', 'fog_object')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].put_object('fogobjecttests', 'fog_object', lorem_file)
+    end
+
+    tests("#get_object('fogobjectests', 'fog_object')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_object('fogobjecttests', 'fog_object')
+    end
+
+    tests("#get_object('fogobjecttests', 'fog_object', &block)").returns(lorem_file.read) do
+      pending if Fog.mocking?
+      data = ''
+      Rackspace[:storage].get_object('fogobjecttests', 'fog_object') do |chunk, remaining_bytes, total_bytes|
+        data << chunk
+      end
+      data
+    end
+
+    tests("#head_object('fogobjectests', 'fog_object')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_object('fogobjecttests', 'fog_object')
+    end
+
+    tests("#delete_object('fogobjecttests', 'fog_object')").succeeds do
+      pending if Fog.mocking?
+      Rackspace[:storage].delete_object('fogobjecttests', 'fog_object')
+    end
+
+  end
+
+  tests('failure') do
+
+    tests("#get_object('fogobjecttests', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_object('fogobjecttests', 'fog_non_object')
+    end
+
+    tests("#get_object('fognoncontainer', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].get_object('fognoncontainer', 'fog_non_object')
+    end
+
+    tests("#head_object('fogobjecttests', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_object('fogobjecttests', 'fog_non_object')
+    end
+
+    tests("#head_object('fognoncontainer', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].head_object('fognoncontainer', 'fog_non_object')
+    end
+
+    tests("#delete_object('fogobjecttests', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].delete_object('fogobjecttests', 'fog_non_object')
+    end
+
+    tests("#delete_object('fognoncontainer', 'fog_non_object')").raises(Fog::Rackspace::Storage::NotFound) do
+      pending if Fog.mocking?
+      Rackspace[:storage].delete_object('fognoncontainer', 'fog_non_object')
+    end
+
+  end
+
+  unless Fog.mocking?
+    @directory.destroy
+  end
+
+end
\ No newline at end of file
diff --git a/vendor/formatador-0.1.4/Gemfile b/vendor/formatador-0.1.4/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/vendor/formatador-0.1.4/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/vendor/formatador-0.1.4/README.rdoc b/vendor/formatador-0.1.4/README.rdoc
new file mode 100644
index 0000000..760e15b
--- /dev/null
+++ b/vendor/formatador-0.1.4/README.rdoc
@@ -0,0 +1,64 @@
+= formatador
+
+STDOUT text formatting
+
+== Quick and dirty
+
+You can call class methods to print out single lines like this:
+
+  Formatador.display_line('Hello World')
+
+You use tags, similar to html, to set formatting options:
+
+  Formatador.display_line('[green]Hello World[/]')
+
+  [/] resets everything to normal, colors are supported and [_color_] sets the background color.
+
+== Standard options
+
+* format - and adds color codes if STDOUT.tty? is true
+* display - calls format on the input and prints it
+* display_line - calls display, but adds on a newline (\n)
+* redisplay - Displays text, prepended with \r which will overwrite the last existing line
+
+== Extensions
+
+* display_table: takes an array of hashes. Each hash is a row, with the keys being the headers and values being the data. An optional second argument can specify which headers/columns to include and in what order they should appear.
+* display_compact_table: Same as display_table, execpt that split lines are not drawn by default in the body of the table. If you need a split line, put a :split constant in the body array.
+* redisplay_progressbar: takes the current and total values as its first two arguments and redisplays a progressbar (until current = total and then it display_lines). An optional third argument represents the start time and will add an elapsed time counter.
+
+== Indentation
+
+By initializing a formatador object you can keep track of indentation:
+
+  formatador = Formatador.new
+  formatador.display_line('one level of indentation')
+  formatador.indent {
+    formatador.display_line('two levels of indentation')
+  }
+  formatador.display_line('one level of indentation')
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2009 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/formatador-0.1.4/Rakefile b/vendor/formatador-0.1.4/Rakefile
new file mode 100644
index 0000000..a742dbf
--- /dev/null
+++ b/vendor/formatador-0.1.4/Rakefile
@@ -0,0 +1,143 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+require 'shindo/rake'
+Shindo::Rake.new
+
+task :default => :tests
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/vendor/formatador-0.1.4/formatador.gemspec b/vendor/formatador-0.1.4/formatador.gemspec
new file mode 100644
index 0000000..b59658f
--- /dev/null
+++ b/vendor/formatador-0.1.4/formatador.gemspec
@@ -0,0 +1,79 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'formatador'
+  s.version           = '0.1.4'
+  s.date              = '2011-05-20'
+  s.rubyforge_project = 'formatador'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "Ruby STDOUT text formatting"
+  s.description = "STDOUT text formatting"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('rake')
+  s.add_development_dependency('shindo')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    formatador.gemspec
+    lib/formatador.rb
+    lib/formatador/progressbar.rb
+    lib/formatador/table.rb
+    tests/basic_tests.rb
+    tests/table_tests.rb
+    tests/tests_helper.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/vendor/formatador-0.1.4/lib/formatador.rb b/vendor/formatador-0.1.4/lib/formatador.rb
new file mode 100644
index 0000000..b133e2d
--- /dev/null
+++ b/vendor/formatador-0.1.4/lib/formatador.rb
@@ -0,0 +1,115 @@
+require File.join(File.dirname(__FILE__), 'formatador', 'table')
+require File.join(File.dirname(__FILE__), 'formatador', 'progressbar')
+
+class Formatador
+
+  VERSION = '0.1.4'
+
+  STYLES = {
+    :"\/"             => "0",
+    :reset            => "0",
+    :bold             => "1",
+    :underline        => "4",
+    :blink_slow       => "5",
+    :blink_fast       => "6",
+    :negative         => "7", # invert color/color
+    :normal           => "22",
+    :underline_none   => "24",
+    :blink_off        => "25",
+    :positive         => "27", # revert color/color
+    :black            => "30",
+    :red              => "31",
+    :green            => "32",
+    :yellow           => "33",
+    :blue             => "34",
+    :magenta          => "35",
+    :purple           => "35",
+    :cyan             => "36",
+    :white            => "37",
+    :_black_          => "40",
+    :_red_            => "41",
+    :_green_          => "42",
+    :_yellow_         => "43",
+    :_blue_           => "44",
+    :_magenta_        => "45",
+    :_purple_         => "45",
+    :_cyan_           => "46",
+    :_white_          => "47",
+    :light_black      => "90",
+    :light_red        => "91",
+    :light_green      => "92",
+    :light_yellow     => "93",
+    :light_blue       => "94",
+    :light_magenta    => "95",
+    :light_purple     => "95",
+    :light_cyan       => "96",
+    :_light_black_    => "100",
+    :_light_red_      => "101",
+    :_light_green_    => "102",
+    :_light_yellow_   => "103",
+    :_light_blue_     => "104",
+    :_light_magenta_  => "105",
+    :_light_purple_   => "105",
+    :_light_cyan_     => "106",
+  }
+
+  PARSE_REGEX  = /\[(#{ STYLES.keys.join('|') })\]/ix
+  INDENT_REGEX = /\[indent\]/ix
+
+  def initialize
+    @indent = 1
+  end
+
+  def display(string = '')
+    print(parse("[indent]#{string}"))
+    STDOUT.flush
+    nil
+  end
+
+  def display_line(string = '')
+    display(string)
+    print("\n")
+    nil
+  end
+
+  def display_lines(lines = [])
+    for line in [*lines]
+      display_line(line)
+    end
+    nil
+  end
+
+  def parse(string)
+    if STDOUT.tty?
+      string.gsub(PARSE_REGEX) { "\e[#{STYLES[$1.to_sym]}m" }.gsub(INDENT_REGEX) { indentation }
+    else
+      string.gsub(PARSE_REGEX, '').gsub(INDENT_REGEX) { indentation }
+    end
+  end
+
+  def indent(&block)
+    @indent += 1
+    yield
+    @indent -= 1
+  end
+
+  def indentation
+    '  ' * @indent
+  end
+
+  def redisplay(string = '')
+    print("\r#{' ' * 80}\r")
+    display("#{string}")
+    nil
+  end
+
+  %w{display display_line display_lines display_table display_compact_table indent parse redisplay redisplay_progressbar}.each do |method|
+    eval <<-DEF
+      def self.#{method}(*args, &block)
+        Thread.current[:formatador] ||= new
+        Thread.current[:formatador].#{method}(*args, &block)
+      end
+    DEF
+  end
+
+end
diff --git a/vendor/formatador-0.1.4/lib/formatador/progressbar.rb b/vendor/formatador-0.1.4/lib/formatador/progressbar.rb
new file mode 100644
index 0000000..7c386fc
--- /dev/null
+++ b/vendor/formatador-0.1.4/lib/formatador/progressbar.rb
@@ -0,0 +1,46 @@
+class Formatador
+
+  def redisplay_progressbar(current, total, options = {})
+    options = { :color => 'white', :width => 50 }.merge!(options)
+    data = progressbar(current, total, options)
+    if current < total
+      redisplay(data)
+    else
+      redisplay("#{data}\n")
+      @progressbar_started_at = nil
+    end
+  end
+
+  private
+
+  def progressbar(current, total, options)
+    color = options[:color]
+    started_at = options[:started_at]
+    width = options[:width]
+
+    output = []
+
+    if options[:label]
+      output << options[:label]
+    end
+
+    padding = ' ' * (total.to_s.size - current.to_s.size)
+    output << "[#{color}]#{padding}#{current}/#{total}[/]"
+
+    percent = current.to_f / total.to_f
+    done = '*' * (percent * width).ceil
+    remaining = ' ' * (width - done.length)
+    output << "[_white_]|[/][#{color}][_#{color}_]#{done}[/]#{remaining}[_white_]|[/]"
+
+    if started_at
+      elapsed = Time.now - started_at
+      minutes = (elapsed / 60).round.to_s
+      seconds = (elapsed % 60).round.to_s
+      output << "#{minutes}:#{'0' if seconds.size < 2}#{seconds}"
+    end
+
+    output << ''
+    output.join('  ')
+  end
+
+end
diff --git a/vendor/formatador-0.1.4/lib/formatador/table.rb b/vendor/formatador-0.1.4/lib/formatador/table.rb
new file mode 100644
index 0000000..95f757d
--- /dev/null
+++ b/vendor/formatador-0.1.4/lib/formatador/table.rb
@@ -0,0 +1,78 @@
+class Formatador
+  def display_table(hashes, keys = nil, &block)
+    new_hashes = hashes.inject([]) do |accum,item|
+      accum << :split unless accum.empty?
+      accum << item
+    end
+    display_compact_table(new_hashes, keys, &block)
+  end
+
+  def display_compact_table(hashes, keys = nil, &block)
+    headers = keys || []
+    widths = {}
+    if hashes.empty? && keys
+      for key in keys
+        widths[key] = key.to_s.length
+      end
+    else
+      for hash in hashes
+        next unless hash.respond_to?(:keys)
+
+        for key in hash.keys
+          unless keys
+            headers << key
+          end
+          widths[key] = [ length(key), widths[key] || 0, hash[key] && length(hash[key]) || 0].max
+        end
+        headers = headers.uniq
+      end
+    end
+
+    if block_given?
+      headers = headers.sort(&block)
+    elsif !keys
+      headers = headers.sort {|x,y| x.to_s <=> y.to_s}
+    end
+
+    split = "+"
+    if headers.empty?
+      split << '--+'
+    else
+      for header in headers
+        widths[header] ||= length(header)
+        split << ('-' * (widths[header] + 2)) << '+'
+      end
+    end
+
+    display_line(split)
+    columns = []
+    for header in headers
+      columns << "[bold]#{header}[/]#{' ' * (widths[header] - header.to_s.length)}"
+    end
+    display_line("| #{columns.join(' | ')} |")
+    display_line(split)
+
+    for hash in hashes
+      if hash.respond_to? :keys
+        columns = []
+        for header in headers
+          datum = hash[header] || ''
+          columns << "#{datum}#{' ' * (widths[header] - length(datum))}"
+        end
+        display_line("| #{columns.join(' | ')} |")
+      else
+        if hash == :split
+          display_line(split)
+        end 
+      end
+      nil
+    end
+    display_line(split)
+  end
+
+  private
+
+  def length(value)
+    value.to_s.gsub(PARSE_REGEX, '').length
+  end
+end
diff --git a/vendor/formatador-0.1.4/tests/basic_tests.rb b/vendor/formatador-0.1.4/tests/basic_tests.rb
new file mode 100644
index 0000000..4021093
--- /dev/null
+++ b/vendor/formatador-0.1.4/tests/basic_tests.rb
@@ -0,0 +1,28 @@
+Shindo.tests("Formatador") do
+
+  tests("#display_line(Formatador)").returns("    Formatador\n") do
+    capture_stdout do
+      Formatador.display_line('Formatador')
+    end
+  end
+
+output = <<-OUTPUT
+    one
+    two
+OUTPUT
+
+  tests("#display_lines(['one', 'two']").returns(output) do
+    capture_stdout do
+      Formatador.display_lines(['one', 'two'])
+    end
+  end
+
+  tests("#indent { display_line('Formatador') }").returns("      Formatador\n") do
+    capture_stdout do
+      Formatador.indent do
+        Formatador.display_line('Formatador')
+      end
+    end
+  end
+
+end
diff --git a/vendor/formatador-0.1.4/tests/table_tests.rb b/vendor/formatador-0.1.4/tests/table_tests.rb
new file mode 100644
index 0000000..457bcf6
--- /dev/null
+++ b/vendor/formatador-0.1.4/tests/table_tests.rb
@@ -0,0 +1,45 @@
+Shindo.tests("Formatador") do
+
+output = <<-OUTPUT
+    +---+
+    | \e[1ma\e[0m |
+    +---+
+    | 1 |
+    +---+
+    | 2 |
+    +---+
+OUTPUT
+
+  tests("#display_table([{:a => 1}, {:a => 2}])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([{:a => 1}, {:a => 2}])
+    end
+  end
+
+output = <<-OUTPUT
+    +--------+
+    | \e[1mheader\e[0m |
+    +--------+
+OUTPUT
+
+  tests("#display_table([], [:header])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([], [:header])
+    end
+  end
+
+output = <<-OUTPUT
+    +--------+
+    | \e[1mheader\e[0m |
+    +--------+
+    |        |
+    +--------+
+OUTPUT
+
+  tests("#display_table([{:a => 1}], [:header])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([{:a => 1}], [:header])
+    end
+  end
+
+end
diff --git a/vendor/formatador-0.1.4/tests/tests_helper.rb b/vendor/formatador-0.1.4/tests/tests_helper.rb
new file mode 100644
index 0000000..5c0d6fc
--- /dev/null
+++ b/vendor/formatador-0.1.4/tests/tests_helper.rb
@@ -0,0 +1,14 @@
+$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
+$LOAD_PATH.unshift(File.dirname(__FILE__))
+require 'formatador'
+require 'rubygems'
+require 'shindo'
+
+def capture_stdout
+  old_stdout = $stdout
+  new_stdout = StringIO.new
+  $stdout = new_stdout
+  yield
+  $stdout = old_stdout
+  new_stdout.string
+end
diff --git a/vendor/hirb-0.3.5/.gemspec b/vendor/hirb-0.3.5/.gemspec
new file mode 100644
index 0000000..3490062
--- /dev/null
+++ b/vendor/hirb-0.3.5/.gemspec
@@ -0,0 +1,22 @@
+# -*- encoding: utf-8 -*-
+require 'rubygems' unless Object.const_defined?(:Gem)
+require File.dirname(__FILE__) + "/lib/hirb/version"
+ 
+Gem::Specification.new do |s|
+  s.name        = "hirb"
+  s.version     = Hirb::VERSION
+  s.authors     = ["Gabriel Horner"]
+  s.email       = "gabriel.horner@gmail.com"
+  s.homepage    = "http://tagaholic.me/hirb/"
+  s.summary     = "A mini view framework for console/irb that's easy to use, even while under its influence."
+  s.description = "Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output. Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer two dimensional menus."
+  s.required_rubygems_version = ">= 1.3.5"
+  s.rubyforge_project = 'tagaholic'
+  s.add_development_dependency 'bacon', '>= 1.1.0'
+  s.add_development_dependency 'mocha'
+  s.add_development_dependency 'mocha-on-bacon'
+  s.add_development_dependency 'bacon-bits'
+  s.files = Dir.glob(%w[{lib,test}/**/*.rb bin/* [A-Z]*.{txt,rdoc} ext/**/*.{rb,c} **/deps.rip]) + %w{Rakefile .gemspec}
+  s.extra_rdoc_files = ["README.rdoc", "LICENSE.txt"]
+  s.license = 'MIT'
+end
diff --git a/vendor/hirb-0.3.5/CHANGELOG.rdoc b/vendor/hirb-0.3.5/CHANGELOG.rdoc
new file mode 100644
index 0000000..7a65e28
--- /dev/null
+++ b/vendor/hirb-0.3.5/CHANGELOG.rdoc
@@ -0,0 +1,112 @@
+== 0.3.5
+* Add ripl support
+* Fix Formatter#determine_output_class for IO and Hash
+* Remove :output_method option for Hirb.enable
+* Allow rubygems 1.3.5
+
+== 0.3.4
+* Added auto format of array-like objects i.e. ActiveRecord::Relation and Set.
+* Fixed bug when Hirb::Console#table is used without Hirb enabled.
+* Fixed bug when hirb is running within cron and uses tput.
+
+== 0.3.3
+* Added ignore_errors option to ignore view errors and continue with original view.
+* Added support for array menu items.
+* Added support to ObjectTable for objects with an undefined :send method.
+
+== 0.3.2
+* Added irb autocompletions for bond.
+* Fixed tests for ruby 1.9.
+* Changed tests to use bacon.
+* Removed jeweler in Rakefile and pointless $LOAD_PATH manipulation.
+
+== 0.3.1
+* Bug fix on DynamicView.class_to_method to allow overrides of default views.
+* Modified mongo_mapper view to have _id first.
+
+== 0.3.0
+* Added dynamic views.
+* Added default table views for the following database classes/modules:
+  CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+  DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+  Mongoid::Document, Ripple::Document and Sequel::Model.
+* Added Hirb.add_view and Hirb.add_dynamic_view for easier view manipulation.
+* Added :multi_line_nodes option for Tree.
+* Fixed :change_fields option bug in Table.
+* Fixed no headers and nil fields bug in Table.
+* Removed deprecations in Hirb.config_file + View.enable.
+* Removed Views classes and View.format_class.
+* Removed :return_rows option for Table.
+
+== 0.2.10
+* Added multiple options to Menu, most importantly :two_d and :action.
+* Improved table resizing algorithm.
+* Added merging of configs for multiple Hirb.enable calls.
+* Added :max_fields, :hide_empty, :delete_callbacks, :resize, :header_filter
+  and :return_rows options to Table.
+* Added escaping for \t and \r in Table.
+* Renamed Table's :no_newlines option to :escape_special_chars.
+* Removed Table's :field_lengths option.
+* Removed Menu's :validate_one option.
+* Bug fix for table header of a basic array.
+* Deprecating Hirb.config_file + View.enable in next release.
+
+== 0.2.9
+* Added newline filtering and :no_newlines option for table helper.
+* Added default filters for hashes that have hash values.
+* Bug fix for deprecated to_a call.
+
+== 0.2.8
+* Added callbacks to Hirb::Helpers::Table.
+* Added :change_fields option to Hirb::Helpers::Table.
+* Added terminal size detection for jruby.
+* Bug fix for paging long outputs.
+* Bug fix to make unexpected hirb rendering errors more clear.
+
+== 0.2.7
+* 2 ruby 1.9 bug fixes.
+* Bug fix in :fields of Hirb::Helpers::ObjectTable.
+* Made :class option in Hirb::Formatter friendlier to external apps.
+
+== 0.2.6
+* Added :description option and added proc ability to :children_method option for helpers.
+* Bug fix for no ENV['HOME'] on Windows.
+* Bug fix on unaliasing output_method.
+* Bug fix on multiple renders of vertical table.
+
+== 0.2.5
+* Added ability to use Hirb.enable with non-irb ruby shells.
+* Helper configs now recursively merge when inheriting from others via :ancestor option.
+
+== 0.2.4
+* Bug fix on UTF-8 support.
+
+== 0.2.3
+* Added UTF-8 support for Ruby 1.8.x
+* Added :all_fields option to Table helper.
+
+== 0.2.2
+* Added a friendlier default (a vertical table) to incorrectly configured tables.
+* Added vertical table helper thanks to chrononaut.
+* Added detection of :select option from ActiveRecord queries in ActiveRecordTable helper.
+* Added handling anything that responds to :to_a in AutoTable helper.
+
+== 0.2.1
+* Fixed typo in Hirb::Console.view
+
+== 0.2.0
+* Major refactoring with bug fixes and better tests.
+* Improved table algorithm to ensure that tables don't wrap.
+* Added a pager which detects if output should be paged, Hirb::Pager.
+* Added a selection menu, Hirb::Menu
+* Following API changes: Hirb::Helpers::Table.max_width removed and config files don't use
+  the :view key anymore.
+== 0.1.2
+* Added tree views.
+* Added output_method option to Hirb::View.render_output.
+
+== 0.1.1
+* Fixed bug when rendering table with many fields.
+
+== 0.1.0
+* Initial release
diff --git a/vendor/hirb-0.3.5/LICENSE.txt b/vendor/hirb-0.3.5/LICENSE.txt
new file mode 100644
index 0000000..5b44505
--- /dev/null
+++ b/vendor/hirb-0.3.5/LICENSE.txt
@@ -0,0 +1,22 @@
+The MIT LICENSE
+
+Copyright (c) 2010 Gabriel Horner
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/vendor/hirb-0.3.5/README.rdoc b/vendor/hirb-0.3.5/README.rdoc
new file mode 100644
index 0000000..1e86139
--- /dev/null
+++ b/vendor/hirb-0.3.5/README.rdoc
@@ -0,0 +1,182 @@
+To read a linked version of this README, {click here}[http://tagaholic.me/hirb/doc/].
+
+== Description
+
+Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output.
+Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable
+views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options
+for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems
+i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager
+only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer
+{two dimensional menus}[http://tagaholic.me/2010/02/16/two-dimensional-console-menus-with-hirb.html].
+
+== Install
+
+Install the gem with:
+
+    sudo gem install hirb
+
+== View Tutorials
+
+* To create and configure views, see Hirb::View or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/View.html].
+* To create dynamic views, see Hirb::DynamicView or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/DynamicView.html].
+
+== Printing Ascii Tables
+
+To print ascii tables from an array of arrays, hashes or any objects:
+
+  puts Hirb::Helpers::AutoTable.render(ARRAY_OF_OBJECTS)
+
+Hirb will intelligently pick up on field names from an array of hashes and create properly-aligned
+fields from an array of arrays. See
+{here}[http://tagaholic.me/2009/10/15/boson-and-hirb-interactions.html#hirbs_handy_tables] for examples.
+
+== Rails Example
+
+Let's load and enable the view framework:
+  $ script/console
+  Loading local environment (Rails 2.3.5)
+  >> require 'hirb'
+  => true
+  >> Hirb.enable
+  => nil
+
+The default configuration provides table views for ActiveRecord::Base descendants.
+If a class isn't configured, Hirb reverts to irb's default echo mode.
+  >> Hirb::Formatter.dynamic_config['ActiveRecord::Base']
+  => {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+
+  # Tag is a model class and descendant of ActiveRecord::Base
+  >> Tag.last
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | id  | created_at              | description | name          | namespace | predicate | value |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml | gem       | tags      | yaml  |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  1 row in set
+
+  >> Hirb::Formatter.dynamic_config['String']
+  => nil
+  >> 'plain ol irb'
+  => 'plain ol irb'
+  >> Hirb::Formatter.dynamic_config['Symbol']
+  => nil
+  >> :blah
+  => :blah
+
+From above you can see there are no views configured for a String or a Symbol so Hirb defaults to
+irb's echo mode. On the other hand, Tag has a view thanks to being a descendant of ActiveRecord::Base
+and there being an :ancestor option.
+
+Having seen hirb display views based on an output object's class, let's see it handle an array of objects:
+
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | id  | created_at              | description | name              | namespace | predicate | value    |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml     | gem       | tags      | yaml     |
+  | 906 | 2009-03-06 08:47:04 UTC |             | gem:tags=nomonkey | gem       | tags      | nomonkey |
+  | 905 | 2009-03-04 00:30:10 UTC |             | article:tags=ruby | article   | tags      | ruby     |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  3 rows in set
+
+At any time you can disable Hirb if you really like irb's lovely echo mode:
+  >> Hirb.disable
+  => nil
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  => [#<Tag id: 907, name: "gem:tags=yaml", description: nil, created_at: "2009-03-06 21:10:41",
+  namespace: "gem", predicate: "tags", value: "yaml">, #<Tag id: 906, name: "gem:tags=nomonkey",
+  description: nil, created_at: "2009-03-06 08:47:04", namespace: "gem", predicate: "tags", value:
+  "nomonkey">, #<Tag id: 905, name: "article:tags=ruby", description: nil, created_at: "2009-03-04
+  00:30:10", namespace: "article", predicate: "tags", value: "ruby">]
+
+== Views: Anytime, Anywhere
+While preconfigured tables are great for database records, sometimes you just want to create
+tables/views for any output object:
+  
+  #These examples don't need to have Hirb::View enabled.
+  >> Hirb.disable
+  => nil
+
+  # Imports table() and view()
+  >> extend Hirb::Console
+  => main
+
+  # Create a table of Dates comparing them with different formats.
+  >> table [Date.today, Date.today.next_month], :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+  +------------+--------+-----------+-------+--------------------------+
+  | to_s       | ld     | ajd       | amjd  | asctime                  |
+  +------------+--------+-----------+-------+--------------------------+
+  | 2009-03-11 | 155742 | 4909803/2 | 54901 | Wed Mar 11 00:00:00 2009 |
+  | 2009-04-11 | 155773 | 4909865/2 | 54932 | Sat Apr 11 00:00:00 2009 |
+  +------------+--------+-----------+-------+--------------------------+
+  2 rows in set
+
+  # Same table as the previous method. However view() will be able to call any helper.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+If these console methods weren't convenient enough, try:
+
+  # Imports view() to all objects.
+  >> require 'hirb/import_object'
+  =>true
+  # Yields same table as above examples.
+  >> [Date.today, Date.today.next_month].view :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+Although views by default are printed to STDOUT, they can be easily modified to write anywhere:
+  # Setup views to write to file 'console.log'.
+  >> Hirb::View.render_method = lambda {|output| File.open("console.log", 'w') {|f| f.write(output) } }
+
+  # Writes to file with same table output as above example.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+  # Doesn't write to file because Symbol doesn't have a view and thus defaults to irb's echo mode.
+  >> :blah
+  =>:blah
+
+  # Go back to printing Hirb views to STDOUT.
+  >> Hirb::View.reset_render_method
+
+== Pager
+
+Hirb has both pager and formatter functionality enabled by default.
+If you want to turn off the functionality of either you can pass that in at startup:
+
+  Hirb.enable :pager=>false
+  Hirb.enable :formatter=>false
+
+or toggle their state at runtime:
+
+  Hirb::View.toggle_pager
+  Hirb::View.toggle_formatter
+
+== Sharing Helpers and Views
+If you have tested helpers you'd like to share, fork Hirb and put them under lib/hirb/helpers. To share
+views for certain classes, put them under lib/hirb/views. Please submit views for gems that have a nontrivial
+number of users.
+
+== Limitations
+If using Wirble, you should call Hirb after it since they both override irb's default output.
+
+== Motivation
+Table code from http://gist.github.com/72234 and {my console app's needs}[http://github.com/cldwalker/tag-tree].
+
+== Credits
+* Chrononaut for vertical table helper.
+* crafterm, spastorino, xaviershay, bogdan and joshua for patches.
+
+== Bugs/Issues
+Please report them {on github}[http://github.com/cldwalker/hirb/issues].
+
+== Links
+* http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html
+* http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html
+* http://tagaholic.me/2009/06/19/page-irb-output-and-improve-ri-with-hirb.html
+
+== Todo
+* Consider generating views based on methods an object responds to.
+* Provide helper methods to all views.
+* Consider adding a template helper.
diff --git a/vendor/hirb-0.3.5/Rakefile b/vendor/hirb-0.3.5/Rakefile
new file mode 100644
index 0000000..a88c05a
--- /dev/null
+++ b/vendor/hirb-0.3.5/Rakefile
@@ -0,0 +1,35 @@
+require 'rake'
+require 'fileutils'
+
+def gemspec
+  @gemspec ||= eval(File.read('.gemspec'), binding, '.gemspec')
+end
+
+desc "Build the gem"
+task :gem=>:gemspec do
+  sh "gem build .gemspec"
+  FileUtils.mkdir_p 'pkg'
+  FileUtils.mv "#{gemspec.name}-#{gemspec.version}.gem", 'pkg'
+end
+
+desc "Install the gem locally"
+task :install => :gem do
+  sh %{gem install pkg/#{gemspec.name}-#{gemspec.version}}
+end
+
+desc "Generate the gemspec"
+task :generate do
+  puts gemspec.to_ruby
+end
+
+desc "Validate the gemspec"
+task :gemspec do
+  gemspec.validate
+end
+
+desc 'Run tests'
+task :test do |t|
+  sh 'bacon -q -Ilib -I. test/*_test.rb'
+end
+
+task :default => :test
diff --git a/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb b/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
new file mode 100644
index 0000000..ca9a642
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
@@ -0,0 +1,15 @@
+complete(:methods=>%w{Hirb::View.enable Hirb.enable}) {
+  %w{config_file output_method output width height formatter pager pager_command}
+}
+complete(:methods=>%w{Hirb::Helpers::Table.render table}) {
+  %w{fields headers max_fields max_width resize number change_fields}+
+  %w{filters header_filter filter_any filter_classes vertical all_fields}+
+  %w{description escape_special_chars table_class hide_empty}
+}
+complete(:method=>"Hirb::Helpers::Tree.render") {
+  %w{type validate indent limit description multi_line_nodes value_method children_method}
+}
+complete(:methods=>%w{Hirb::Menu.render menu}) {
+  %w{helper_class prompt ask directions readline two_d default_field action multi_action} +
+    %w{action_object command reopen}
+}
diff --git a/vendor/hirb-0.3.5/lib/hirb.rb b/vendor/hirb-0.3.5/lib/hirb.rb
new file mode 100644
index 0000000..e3f77ab
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb.rb
@@ -0,0 +1,81 @@
+# Needed by Hirb::String to handle multibyte characters
+$KCODE = 'u' if RUBY_VERSION < '1.9'
+
+require 'hirb/util'
+require 'hirb/string'
+require 'hirb/formatter' # must come before helpers/auto_table
+require 'hirb/dynamic_view'
+require 'hirb/helpers'
+require 'hirb/views'
+require 'hirb/view'
+require 'hirb/console'
+require 'hirb/pager'
+require 'hirb/menu'
+require 'hirb/version'
+
+# Most of Hirb's functionality is in Hirb::View.
+# For a tutorial  on configuring and creating views see Hirb::View. For a tutorial on dynamic views see Hirb::DynamicView.
+#
+# == Config Files
+# Hirb can have multiple config files defined by config_files(). These config files
+# have the following top level keys:
+# [*:output*] This hash is used by the formatter object. See Hirb::Formatter.config for its format.
+# [*:width*]  Width of the terminal/console. Defaults to Hirb::View::DEFAULT_WIDTH or possibly autodetected when Hirb is enabled.
+# [*:height*]  Height of the terminal/console. Defaults to Hirb::View::DEFAULT_HEIGHT or possibly autodetected when Hirb is enabled.
+# [*:formatter*] Boolean which determines if the formatter is enabled. Defaults to true.
+# [*:pager*] Boolean which determines if the pager is enabled. Defaults to true.
+# [*:pager_command*] Command to be used for paging. Command can have options after it i.e. 'less -r'.
+#                    Defaults to common pagers i.e. less and more if detected.
+# [*:ignore_errors*] Boolean which ignores internal view errors and continues with original view
+#                    (i.e. #inspect for irb). Defaults to false.
+module Hirb
+  class <<self
+    attr_accessor :config_files, :config
+
+    # Enables view functionality. See Hirb::View.enable for details.
+    def enable(options={}, &block)
+      View.enable(options, &block)
+    end
+
+    # Disables view functionality. See Hirb::View.disable for details.
+    def disable
+      View.disable
+    end
+
+    # Adds views. See Hirb::View.add for details.
+    def add_view(view, options, &block)
+      View.add(view, options, &block)
+    end
+
+    # Adds views. See Hirb::DynamicView.add for details.
+    def add_dynamic_view(view, options, &block)
+      DynamicView.add(view, options, &block)
+    end
+
+    # Array of config files which are merged sequentially to produce config.
+    # Defaults to config/hirb.yml and ~/.hirb_yml
+    def config_files
+      @config_files ||= default_config_files
+    end
+
+    #:stopdoc:
+    def default_config_files
+      [File.join(Util.find_home, ".hirb.yml")] +
+        (File.exists?('config/hirb.yml') ? ['config/hirb.yml'] : [])
+    end
+
+    def read_config_file(file=config_file)
+      File.exists?(file) ? YAML::load_file(file) : {}
+    end
+
+    def config(reload=false)
+      if (@config.nil? || reload)
+        @config = config_files.inject({}) {|acc,e|
+          Util.recursive_hash_merge(acc,read_config_file(e))
+        }
+      end
+      @config
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/console.rb b/vendor/hirb-0.3.5/lib/hirb/console.rb
new file mode 100644
index 0000000..fefb134
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/console.rb
@@ -0,0 +1,43 @@
+module Hirb
+  # This module is meant to be extended to provide methods for use in a console/irb shell.
+  # For example:
+  #    >> extend Hirb::Console
+  #    >> view 'some string', :class=>Some::String::Formatter
+  #    >> table [[:row1], [:row2]]
+  module Console
+    class<<self
+      # A console version of render_output() which takes its same options but allows for shorthand. All options are passed to
+      # the helper except for the formatter options. Formatter options are :class, :method and :output_method.
+      # Examples:
+      #   render_output output, :class=>:tree :type=>:directory
+      #   # is the same as:
+      #   render_output output, :class=>:tree, :options=> {:type=>:directory}
+      #
+      def render_output(output, options={})
+        View.load_config unless View.config_loaded?
+        View.render_output(output, options.merge(:console=>true))
+      end
+
+      # Takes same arguments and options as render_output() but returns formatted output instead of rendering it.
+      def format_output(output, options={}, &block)
+        View.load_config unless View.config_loaded?
+        View.formatter.format_output(output, options.merge(:console=>true), &block)
+      end
+    end
+
+    # Renders a table for the given object. Takes same options as Hirb::Helpers::Table.render.
+    def table(output, options={})
+      Console.render_output(output, options.merge(:class=>"Hirb::Helpers::AutoTable"))
+    end
+
+    # Renders any specified view for the given object. Takes same options as Hirb::View.render_output.
+    def view(output, options={})
+      Console.render_output(output, options)
+    end
+
+    # Renders a menu given an array using Hirb::Menu.render.
+    def menu(output, options={}, &block)
+      Console.format_output(output, options.merge(:class=>"Hirb::Menu"), &block)
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb b/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
new file mode 100644
index 0000000..31929f6
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
@@ -0,0 +1,113 @@
+module Hirb
+  # This module extends a Helper with the ability to have dynamic views for configured output classes.
+  # After a Helper has extended this module, it can use it within a render() by calling
+  # dynamic_options() to get dynamically generated options for the object it's rendering. See Hirb::Helpers::AutoTable as an example.
+  #
+  # == Dynamic Views
+  # Whereas normal views are generated from helpers with static helper options, dynamic views are generated from helpers and
+  # dynamically generated helper options. Let's look at an example for Rails' ActiveRecord classes:
+  #
+  #   Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj|
+  #    {:fields=>obj.class.column_names} }
+  #
+  # From this dynamic view definition, _any_ ActiveRecord model class will render a table with the correct fields, since the fields
+  # are extracted from the output object's class at runtime. Note that dynamic view definitions should return a hash of helper options.
+  #
+  # To define multiple dynamic views, create a Views module where each method ending in '\_view' maps to a class/module:
+  #
+  #   module Hirb::Views::ORM
+  #     def data_mapper__resource_view(obj)
+  #       {:fields=>obj.class.properties.map {|e| e.name }}
+  #     end
+  #
+  #     def sequel__model_view(obj)
+  #       {:fields=>obj.class.columns}
+  #     end
+  #   end
+  #
+  #   Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+  #
+  # In this example, 'data_mapper__resource_view' maps to DataMapper::Resource and 'sequel__model_view' maps to Sequel::Model.
+  # Note that when mapping method names to class names, '__' maps to '::' and '_' signals the next letter to be capitalized.
+  module DynamicView
+    # Add dynamic views to output class(es) for a given helper. If defining one view, the first argument is the output class
+    # and a block defines the dynamic view. If defining multiple views, the first argument should be a Views::* module where
+    # each method in the module ending in _view defines a view for an output class. To map output classes to method names in
+    # a Views module, translate'::' to '__' and a capital letter translates to a '_' and a lowercase letter.
+    # ==== Options:
+    # [*:helper*] Required option. Helper class that view(s) use to format. Hirb::Helpers::AutoTable is the only valid
+    #             helper among default helpers. Can be given in aliased form i.e. :auto_table -> Hirb::Helpers::AutoTable.
+    #
+    # Examples:
+    #    Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+    #    Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj| {:fields=>obj.class.column_names} }
+    def self.add(view, options, &block)
+      raise ArgumentError, ":helper option is required" unless options[:helper]
+      helper = Helpers.helper_class options[:helper]
+      unless helper.is_a?(Module) && class << helper; self.ancestors; end.include?(self)
+        raise ArgumentError, ":helper option must be a helper that has extended DynamicView"
+      end
+      mod = block ? generate_single_view_module(view, &block) : view
+      raise ArgumentError, "'#{mod}' must be a module" unless mod.is_a?(Module)
+      helper.add_module mod
+    end
+
+    def self.generate_single_view_module(output_mod, &block) #:nodoc:
+      meth = class_to_method output_mod.to_s
+      view_mod = meth.capitalize
+      Views::Single.send(:remove_const, view_mod) if Views::Single.const_defined?(view_mod)
+      mod = Views::Single.const_set(view_mod, Module.new)
+      mod.send(:define_method, meth, block)
+      mod
+    end
+
+    def self.class_to_method(mod) #:nodoc:
+      mod.gsub(/(?!^)([A-Z])/) {|e| '_'+e }.gsub('::_', '__').downcase + '_view'
+    end
+
+    # Returns a hash of options based on dynamic views defined for the object's ancestry. If no config is found returns nil.
+    def dynamic_options(obj)
+      view_methods.each do |meth|
+        if obj.class.ancestors.map {|e| e.to_s }.include?(method_to_class(meth))
+          begin
+            return send(meth, obj)
+          rescue
+            raise "View failed to generate for '#{method_to_class(meth)}' "+
+              "while in '#{meth}' with error:\n#{$!.message}"
+          end
+        end
+      end
+      nil
+    end
+
+    #:stopdoc:
+    def add_module(mod)
+      new_methods = mod.instance_methods.select {|e| e.to_s =~ /_view$/ }.map {|e| e.to_s}
+      return if new_methods.empty?
+      extend mod
+      view_methods.replace(view_methods + new_methods).uniq!
+      update_config(new_methods)
+    end
+
+    def update_config(meths)
+      output_config = meths.inject({}) {|t,e|
+        t[method_to_class(e)] = {:class=>self, :ancestor=>true}; t
+      }
+      Formatter.dynamic_config.merge! output_config
+    end
+
+    def method_to_class(meth)
+      view_method_classes[meth] ||= Util.camelize meth.sub(/_view$/, '').gsub('__', '/')
+    end
+
+    def view_method_classes
+      @view_method_classes ||= {}
+    end
+    #:startdoc:
+
+    # Stores view methods that a Helper has been given via DynamicView.add
+    def view_methods
+      @view_methods ||= []
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/formatter.rb b/vendor/hirb-0.3.5/lib/hirb/formatter.rb
new file mode 100644
index 0000000..df1269a
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/formatter.rb
@@ -0,0 +1,119 @@
+module Hirb
+  # A Formatter object formats an output object (using Formatter.format_output) into a string based on the views defined
+  # for its class and/or ancestry.
+  class Formatter
+    TO_A_EXCEPTIONS = ['Hash', 'IO']
+
+    class<<self
+      # This config is used by Formatter.format_output to lazily load dynamic views defined with Hirb::DynamicView.
+      # This hash has the same format as Formatter.config.
+      attr_accessor :dynamic_config
+    end
+    self.dynamic_config = {}
+
+    def initialize(additional_config={}) #:nodoc:
+      @klass_config = {}
+      @config = additional_config || {}
+    end
+
+    # A hash of Ruby class strings mapped to view hashes. A view hash must have at least a :method, :output_method
+    # or :class option for a view to be applied to an output. A view hash has the following keys:
+    # [*:method*] Specifies a global (Kernel) method to do the formatting.
+    # [*:class*] Specifies a class to do the formatting, using its render() class method. If a symbol it's converted to a corresponding
+    #            Hirb::Helpers::* class if it exists.
+    # [*:output_method*] Specifies a method or proc to call on output before passing it to a helper. If the output is an array, it's applied
+    #                    to every element in the array.
+    # [*:options*] Options to pass the helper method or class.
+    # [*:ancestor*] Boolean which when true causes subclasses of the output class to inherit its config. This doesn't effect the current
+    #               output class. Defaults to false. This is used by ActiveRecord classes.
+    # 
+    #   Examples:
+    #     {'WWW::Delicious::Element'=>{:class=>'Hirb::Helpers::ObjectTable', :ancestor=>true, :options=>{:max_width=>180}}}
+    #     {'Date'=>{:class=>:auto_table, :ancestor=>true}}
+    #     {'Hash'=>{:method=>:puts}}
+    def config
+      @config
+    end
+
+    # Adds the view for the given class and view hash config. See Formatter.config for valid keys for view hash.
+    def add_view(klass, view_config)
+      @klass_config.delete(klass)
+      @config[klass.to_s] = view_config
+      true
+    end
+
+    # This method looks for an output object's view in Formatter.config and then Formatter.dynamic_config.
+    # If a view is found, a stringified view is returned based on the object. If no view is found, nil is returned. The options this
+    # class takes are a view hash as described in Formatter.config. These options will be merged with any existing helper
+    # config hash an output class has in Formatter.config. Any block given is passed along to a helper class.
+    def format_output(output, options={}, &block)
+      output_class = determine_output_class(output)
+      options = parse_console_options(options) if options.delete(:console)
+      options = Util.recursive_hash_merge(klass_config(output_class), options)
+      _format_output(output, options, &block)
+    end
+
+    #:stopdoc:
+    def _format_output(output, options, &block)
+      output = options[:output_method] ? (output.is_a?(Array) ?
+        output.map {|e| call_output_method(options[:output_method], e) } :
+        call_output_method(options[:output_method], output) ) : output
+      args = [output]
+      args << options[:options] if options[:options] && !options[:options].empty?
+      if options[:method]
+        send(options[:method],*args)
+      elsif options[:class] && (helper_class = Helpers.helper_class(options[:class]))
+        helper_class.render(*args, &block)
+      elsif options[:output_method]
+        output
+      end
+    end
+
+    def parse_console_options(options) #:nodoc:
+      real_options = [:method, :class, :output_method].inject({}) do |h, e|
+        h[e] = options.delete(e) if options[e]; h
+      end
+      real_options.merge! :options=>options
+    end
+
+    def determine_output_class(output)
+      output.respond_to?(:to_a) && !TO_A_EXCEPTIONS.include?(output.class.to_s) ?
+        Array(output)[0].class : output.class
+    end
+
+    def call_output_method(output_method, output)
+      output_method.is_a?(Proc) ? output_method.call(output) : output.send(output_method)
+    end
+
+    # Internal view options built from user-defined ones. Options are built by recursively merging options from oldest
+    # ancestors to the most recent ones.
+    def klass_config(output_class)
+      @klass_config[output_class] ||= build_klass_config(output_class)
+    end
+
+    def build_klass_config(output_class)
+      output_ancestors = output_class.ancestors.map {|e| e.to_s}.reverse
+      output_ancestors.pop
+      hash = output_ancestors.inject({}) {|h, klass|
+        add_klass_config_if_true(h, klass) {|c,klass| c[klass] && c[klass][:ancestor] }
+      }
+      add_klass_config_if_true(hash, output_class.to_s) {|c,klass| c[klass] }
+    end
+
+    def add_klass_config_if_true(hash, klass)
+      if yield(@config, klass)
+        Util.recursive_hash_merge hash, @config[klass]
+      elsif yield(self.class.dynamic_config, klass)
+        @config[klass] = self.class.dynamic_config[klass].dup # copy to local
+        Util.recursive_hash_merge hash, self.class.dynamic_config[klass]
+      else
+        hash
+      end
+    end
+
+    def reset_klass_config
+      @klass_config = {}
+    end
+    #:startdoc:
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers.rb b/vendor/hirb-0.3.5/lib/hirb/helpers.rb
new file mode 100644
index 0000000..4c8bbd6
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers.rb
@@ -0,0 +1,17 @@
+module Hirb
+  module Helpers #:nodoc:
+    @helper_classes ||= {}
+    def self.helper_class(klass)
+      @helper_classes[klass.to_s] ||= begin
+        if (helper_class = constants.find {|e| e.to_s == Util.camelize(klass.to_s)})
+          klass = "Hirb::Helpers::#{helper_class}"
+        end
+        Util.any_const_get(klass)
+      end
+    end
+  end
+end
+
+%w{table object_table auto_table tree parent_child_tree vertical_table}.each do |e|
+  require "hirb/helpers/#{e}"
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
new file mode 100644
index 0000000..ed31357
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
@@ -0,0 +1,24 @@
+# This helper wraps around the other table helpers i.e. Hirb::Helpers::Table while
+# providing default helper options via Hirb::DynamicView. Using these default options, this
+# helper supports views for the following modules/classes:
+# ActiveRecord::Base, CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+# DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+# Mongoid::Document, Ripple::Document, Sequel::Model.
+class Hirb::Helpers::AutoTable < Hirb::Helpers::Table
+  extend Hirb::DynamicView
+
+  # Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:table_class] Explicit table class to use for rendering. Defaults to
+  #                Hirb::Helpers::ObjectTable if output is not an Array or Hash. Otherwise
+  #                defaults to Hirb::Helpers::Table.
+  def self.render(output, options={})
+    output = Array(output)
+    (defaults = dynamic_options(output[0])) && (options = defaults.merge(options))
+    klass = options.delete(:table_class) || (
+      !(output[0].is_a?(Hash) || output[0].is_a?(Array)) ?
+      Hirb::Helpers::ObjectTable : Hirb::Helpers::Table)
+    klass.render(output, options)
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
new file mode 100644
index 0000000..6227dac
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
@@ -0,0 +1,14 @@
+class Hirb::Helpers::ObjectTable < Hirb::Helpers::Table
+  # Rows are any ruby objects. Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:fields] Methods of the object to represent as columns. Defaults to [:to_s].
+  def self.render(rows, options ={})
+    options[:fields] ||= [:to_s]
+    options[:headers] ||= {:to_s=>'value'} if options[:fields] == [:to_s]
+    item_hashes = options[:fields].empty? ? [] : Array(rows).inject([]) {|t,item|
+      t << options[:fields].inject({}) {|h,f| h[f] = item.__send__(f); h}
+    }
+    super(item_hashes, options)
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
new file mode 100644
index 0000000..d056057
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
@@ -0,0 +1,24 @@
+class Hirb::Helpers::ParentChildTree < Hirb::Helpers::Tree
+  class <<self
+    # Starting with the given node, this builds a tree by recursively calling a children method.
+    # Takes same options as Hirb::Helper::Table.render with some additional ones below.
+    # ==== Options:
+    # [:value_method] Method or proc to call to display as a node's value. If not given, uses :name if node
+    #                 responds to :name or defaults to :object_id.
+    # [:children_method] Method or proc to call to obtain a node's children. Default is :children.
+    def render(root_node, options={})
+      value_method = options[:value_method] || (root_node.respond_to?(:name) ? :name : :object_id)
+      @value_method = value_method.is_a?(Proc) ? value_method : lambda {|n| n.send(value_method) }
+      children_method = options[:children_method] || :children
+      @children_method = children_method.is_a?(Proc) ? children_method : lambda {|n| n.send(children_method)}
+      @nodes = []
+      build_node(root_node, 0)
+      super(@nodes, options)
+    end
+
+    def build_node(node, level) #:nodoc:
+      @nodes << {:value=>@value_method.call(node), :level=>level}
+      @children_method.call(node).each {|e| build_node(e, level + 1)}
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
new file mode 100644
index 0000000..de51309
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
@@ -0,0 +1,323 @@
+require 'hirb/helpers/table/filters'
+require 'hirb/helpers/table/resizer'
+
+module Hirb
+# Base Table class from which other table classes inherit.
+# By default, a table is constrained to a default width but this can be adjusted
+# via the max_width option or Hirb::View.width.
+# Rows can be an array of arrays or an array of hashes.
+#
+# An array of arrays ie [[1,2], [2,3]], would render:
+#   +---+---+
+#   | 0 | 1 |
+#   +---+---+
+#   | 1 | 2 |
+#   | 2 | 3 |
+#   +---+---+
+#
+# By default, the fields/columns are the numerical indices of the array.
+# 
+# An array of hashes ie [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], would render:
+#   +-----+--------+
+#   | age | weight |
+#   +-----+--------+
+#   | 10  | 100    |
+#   | 80  | 500    |
+#   +-----+--------+
+#
+# By default, the fields/columns are the keys of the first hash.
+#
+# === Custom Callbacks
+# Callback methods can be defined to add your own options that modify rows right before they are rendered.
+# Here's an example that allows for searching with a :query option:
+#   module Query
+#     # Searches fields given a query hash
+#     def query_callback(rows, options)
+#       return rows unless options[:query]
+#       options[:query].map {|field,query|
+#         rows.select {|e| e[field].to_s =~ /#{query}/i }
+#       }.flatten.uniq
+#     end
+#   end
+#   Hirb::Helpers::Table.send :include, Query
+#
+#   >> puts Hirb::Helpers::Table.render [{:name=>'batman'}, {:name=>'robin'}], :query=>{:name=>'rob'}
+#   +-------+
+#   | name  |
+#   +-------+
+#   | robin |
+#   +-------+
+#   1 row in set
+#
+# Callback methods:
+# * must be defined in Helpers::Table and end in '_callback'.
+# * should expect rows and a hash of render options. Rows will be an array of hashes.
+# * are expected to return an array of hashes.
+# * are invoked in alphabetical order.
+# For a thorough example, see {Boson::Pipe}[http://github.com/cldwalker/boson/blob/master/lib/boson/pipe.rb].
+#--
+# derived from http://gist.github.com/72234
+ class Helpers::Table
+  BORDER_LENGTH = 3 # " | " and "-+-" are the borders
+  MIN_FIELD_LENGTH = 3
+  class TooManyFieldsForWidthError < StandardError; end
+
+  class << self
+    
+    # Main method which returns a formatted table.
+    # ==== Options:
+    # [*:fields*] An array which overrides the default fields and can be used to indicate field order.
+    # [*:headers*] A hash of fields and their header names. Fields that aren't specified here default to their name.
+    #              When set to false, headers are hidden. Can also be an array but only for array rows.
+    # [*:max_fields*] A hash of fields and their maximum allowed lengths. Maximum length can also be a percentage of the total width
+    #                 (decimal less than one). When a field exceeds it's maximum then it's
+    #                 truncated and has a ... appended to it. Fields that aren't specified have no maximum.
+    # [*:max_width*] The maximum allowed width of all fields put together including field borders. Only valid when :resize is true.
+    #                Default is Hirb::View.width.
+    # [*:resize*] Resizes table to display all columns in allowed :max_width. Default is true. Setting this false will display the full
+    #             length of each field.
+    # [*:number*] When set to true, numbers rows by adding a :hirb_number column as the first column. Default is false.
+    # [*:change_fields*] A hash to change old field names to new field names. This can also be an array of new names but only for array rows.
+    #                    This is useful when wanting to change auto-generated keys to more user-friendly names i.e. for array rows.
+    # [*:filters*] A hash of fields and their filters, applied to every row in a field. A filter can be a proc, an instance method
+    #              applied to the field value or a Filters method. Also see the filter_classes attribute below.
+    # [*:header_filter*] A filter, like one in :filters, that is applied to all headers after the :headers option.
+    # [*:filter_any*] When set to true, any cell defaults to being filtered by its class in :filter_classes.
+    #                 Default Hirb::Helpers::Table.filter_any().
+    # [*:filter_classes*] Hash which maps classes to filters. Default is Hirb::Helpers::Table.filter_classes().
+    # [*:vertical*] When set to true, renders a vertical table using Hirb::Helpers::VerticalTable. Default is false.
+    # [*:all_fields*] When set to true, renders fields in all rows. Valid only in rows that are hashes. Default is false.
+    # [*:description*] When set to true, renders row count description at bottom. Default is true.
+    # [*:escape_special_chars*] When set to true, escapes special characters \n,\t,\r so they don't disrupt tables. Default is false for
+    #                           vertical tables and true for anything else.
+    # Examples:
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]]
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]], :max_fields=>{0=>10}, :header_filter=>:capitalize
+    #    Hirb::Helpers::Table.render [['a',1], ['b',2]], :change_fields=>%w{letters numbers}, :max_fields=>{'numbers'=>0.4}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}]
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :headers=>{:weight=>"Weight(lbs)"}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :filters=>{:age=>[:to_f]}
+    def render(rows, options={})
+      options[:vertical] ? Helpers::VerticalTable.render(rows, options) :
+      new(rows, options).render
+    rescue TooManyFieldsForWidthError
+      $stderr.puts "", "** Error: Too many fields for the current width. Configure your width " +
+        "and/or fields to avoid this error. Defaulting to a vertical table. **"
+      Helpers::VerticalTable.render(rows, options)
+    end
+
+    # A hash which maps a cell value's class to a filter. This serves to set a default filter per field if all of its
+    # values are a class in this hash. By default, Array values are comma joined and Hashes are inspected.
+    # See the :filter_any option to apply this filter per value.
+    attr_accessor :filter_classes
+    # Boolean which sets the default for :filter_any option.
+    attr_accessor :filter_any
+    # Holds last table object created
+    attr_accessor :last_table
+  end
+  self.filter_classes = { Array=>:comma_join, Hash=>:inspect }
+
+  #:stopdoc:
+  attr_accessor :width, :max_fields, :field_lengths, :fields
+  def initialize(rows, options={})
+    raise ArgumentError, "Table must be an array of hashes or array of arrays" unless rows.is_a?(Array) &&
+      (rows[0].is_a?(Hash) or rows[0].is_a?(Array) or rows.empty?)
+    @options = {:description=>true, :filters=>{}, :change_fields=>{}, :escape_special_chars=>true,
+      :filter_any=>Helpers::Table.filter_any, :resize=>true}.merge(options)
+    @fields = set_fields(rows)
+    @rows = set_rows(rows)
+    @headers = set_headers
+    if @options[:number]
+      @headers[:hirb_number] = "number"
+      @fields.unshift :hirb_number
+    end
+    Helpers::Table.last_table = self
+  end
+
+  def set_fields(rows)
+    @options[:change_fields] = array_to_indices_hash(@options[:change_fields]) if @options[:change_fields].is_a?(Array)
+    return @options[:fields].dup if @options[:fields]
+
+    fields = if rows[0].is_a?(Hash)
+      keys = @options[:all_fields] ? rows.map {|e| e.keys}.flatten.uniq : rows[0].keys
+      keys.sort {|a,b| a.to_s <=> b.to_s}
+    else
+      rows[0].is_a?(Array) ? (0..rows[0].length - 1).to_a : []
+    end
+
+    @options[:change_fields].each do |oldf, newf|
+      (index = fields.index(oldf)) && fields[index] = newf
+    end
+    fields
+  end
+
+  def set_rows(rows)
+    rows = Array(rows)
+    if rows[0].is_a?(Array)
+      rows = rows.inject([]) {|new_rows, row|
+        new_rows << array_to_indices_hash(row)
+      }
+    end
+    @options[:change_fields].each do |oldf, newf|
+      rows.each {|e| e[newf] = e.delete(oldf) if e.key?(oldf) }
+    end
+    rows = filter_values(rows)
+    rows.each_with_index {|e,i| e[:hirb_number] = (i + 1).to_s} if @options[:number]
+    deleted_callbacks = Array(@options[:delete_callbacks]).map {|e| "#{e}_callback" }
+    (methods.grep(/_callback$/).map {|e| e.to_s} - deleted_callbacks).sort.each do |meth|
+      rows = send(meth, rows, @options.dup)
+    end
+    validate_values(rows)
+    rows
+  end
+
+  def set_headers
+    headers = @fields.inject({}) {|h,e| h[e] = e.to_s; h}
+    if @options.has_key?(:headers)
+      headers = @options[:headers].is_a?(Hash) ? headers.merge(@options[:headers]) :
+        (@options[:headers].is_a?(Array) ? array_to_indices_hash(@options[:headers]) : @options[:headers])
+    end
+    if @options[:header_filter]
+      headers.each {|k,v|
+        headers[k] = call_filter(@options[:header_filter], v)
+      }
+    end
+    headers
+  end
+
+  def render
+    body = []
+    unless @rows.length == 0
+      setup_field_lengths
+      body += render_header
+      body += render_rows
+      body += render_footer
+    end
+    body << render_table_description if @options[:description]
+    body.join("\n")
+  end
+
+  def render_header
+    @headers ? render_table_header : [render_border]
+  end
+
+  def render_footer
+    [render_border]
+  end
+
+  def render_table_header
+    title_row = '| ' + @fields.map {|f|
+      format_cell(@headers[f], @field_lengths[f])
+    }.join(' | ') + ' |'
+    [render_border, title_row, render_border]
+  end
+  
+  def render_border
+    '+-' + @fields.map {|f| '-' * @field_lengths[f] }.join('-+-') + '-+'
+  end
+  
+  def format_cell(value, cell_width)
+    text = String.size(value) > cell_width ?
+      (
+      (cell_width < 5) ? String.slice(value, 0, cell_width) : String.slice(value, 0, cell_width - 3) + '...'
+      ) : value
+    String.ljust(text, cell_width)
+  end
+
+  def render_rows
+    @rows.map do |row|
+      row = '| ' + @fields.map {|f|
+        format_cell(row[f], @field_lengths[f])
+      }.join(' | ') + ' |'
+    end
+  end
+  
+  def render_table_description
+    (@rows.length == 0) ? "0 rows in set" :
+      "#{@rows.length} #{@rows.length == 1 ? 'row' : 'rows'} in set"
+  end
+  
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+    if @options[:resize]
+      raise TooManyFieldsForWidthError if @fields.size > self.actual_width.to_f / MIN_FIELD_LENGTH
+      Resizer.resize!(self)
+    else
+      enforce_field_constraints
+    end
+  end
+
+  def enforce_field_constraints
+    max_fields.each {|k,max| @field_lengths[k] = max if @field_lengths[k].to_i > max }
+  end
+
+  def max_fields
+    @max_fields ||= (@options[:max_fields] ||= {}).each {|k,v|
+      @options[:max_fields][k] = (actual_width * v.to_f.abs).floor if v.to_f.abs < 1
+    }
+  end
+
+  def actual_width
+    @actual_width ||= self.width - (@fields.size * BORDER_LENGTH + 1)
+  end
+
+  def width
+    @width ||= @options[:max_width] || View.width
+  end
+
+  # find max length for each field; start with the headers
+  def default_field_lengths
+    field_lengths = @headers ? @headers.inject({}) {|h,(k,v)| h[k] = String.size(v); h} :
+      @fields.inject({}) {|h,e| h[e] = 1; h }
+    @rows.each do |row|
+      @fields.each do |field|
+        len = String.size(row[field])
+        field_lengths[field] = len if len > field_lengths[field].to_i
+      end
+    end
+    field_lengths
+  end
+
+  def set_filter_defaults(rows)
+    @filter_classes.each do |klass, filter|
+      @fields.each {|field|
+        if rows.all? {|r| r[field].class == klass }
+          @options[:filters][field] ||= filter
+        end
+      }
+    end
+  end
+
+  def filter_values(rows)
+    @filter_classes = Helpers::Table.filter_classes.merge @options[:filter_classes] || {}
+    set_filter_defaults(rows) unless @options[:filter_any]
+    rows.map {|row|
+      @fields.inject({}) {|new_row,f|
+        (filter = @options[:filters][f]) || (@options[:filter_any] && (filter = @filter_classes[row[f].class]))
+        new_row[f] = filter ? call_filter(filter, row[f]) : row[f]
+        new_row
+      }
+    }
+  end
+
+  def call_filter(filter, val)
+    filter.is_a?(Proc) ? filter.call(val) :
+      val.respond_to?(Array(filter)[0]) ? val.send(*filter) : Filters.send(filter, val)
+  end
+
+  def validate_values(rows)
+    rows.each {|row|
+      @fields.each {|f|
+        row[f] = row[f].to_s || ''
+        row[f] = row[f].gsub(/(\t|\r|\n)/) {|e| e.dump.gsub('"','') } if @options[:escape_special_chars]
+      }
+    }
+  end
+  
+  # Converts an array to a hash mapping a numerical index to its array value.
+  def array_to_indices_hash(array)
+    array.inject({}) {|hash,e|  hash[hash.size] = e; hash }
+  end
+  #:startdoc:
+end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
new file mode 100644
index 0000000..46ba518
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
@@ -0,0 +1,10 @@
+class Hirb::Helpers::Table
+  # Contains filter methods used by :filters option. To define a custom filter, simply open this module and create a method
+  # that take one argument, the value you will be filtering.
+  module Filters
+    extend self
+    def comma_join(arr) #:nodoc:
+      arr.join(', ')
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
new file mode 100644
index 0000000..eadbc12
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
@@ -0,0 +1,82 @@
+class Hirb::Helpers::Table
+  # Resizes a table's fields to the table's max width.
+  class Resizer
+    # Modifies field_lengths to fit within width. Also enforces a table's max_fields.
+    def self.resize!(table)
+      obj = new(table)
+      obj.resize
+      obj.field_lengths
+    end
+
+    #:stopdoc:
+    attr_reader :field_lengths
+    def initialize(table)
+      @table, @width, @field_size = table, table.actual_width, table.fields.size
+      @field_lengths = table.field_lengths
+      @original_field_lengths = @field_lengths.dup
+    end
+
+    def resize
+      adjust_long_fields || default_restrict_field_lengths
+      @table.enforce_field_constraints
+      add_extra_width
+    end
+
+    # Simple algorithm which allows smaller fields to be displayed while
+    # restricting longer fields to an average_long_field
+    def adjust_long_fields
+      while (total_length = sum(@field_lengths.values)) > @width
+        average_field = total_length / @field_size.to_f
+        long_lengths = @field_lengths.values.select {|e| e > average_field }
+        return false if long_lengths.empty?
+
+        # adjusts average long field by ratio with @width
+        average_long_field = sum(long_lengths)/long_lengths.size * @width/total_length
+        @field_lengths.each {|f,length|
+          @field_lengths[f] = average_long_field if length > average_long_field
+        }
+      end
+      true
+    end
+
+    # Produces a field_lengths which meets the @width requirement
+    def default_restrict_field_lengths
+      original_total_length = sum @original_field_lengths.values
+      # set fields by their relative weight to original length
+      new_lengths = @original_field_lengths.inject({}) {|t,(k,v)|
+        t[k] = (v / original_total_length.to_f * @width).to_i; t  }
+
+      # set all fields the same if relative doesn't work
+      unless new_lengths.values.all? {|e| e > MIN_FIELD_LENGTH} && (sum(new_lengths.values) <= @width)
+        new_lengths = @field_lengths.inject({}) {|t,(k,v)| t[k] = @width / @field_size; t }
+      end
+      @field_lengths.each {|k,v| @field_lengths[k] = new_lengths[k] }
+    end
+
+    def add_extra_width
+      added_width = 0
+      extra_width = @width - sum(@field_lengths.values)
+      unmaxed_fields = @field_lengths.keys.select {|f| !remaining_width(f).zero? }
+      # order can affect which one gets the remainder so let's keep it consistent
+      unmaxed_fields = unmaxed_fields.sort_by {|e| e.to_s}
+
+      unmaxed_fields.each_with_index do |f, i|
+        extra_per_field = (extra_width - added_width) / (unmaxed_fields.size - i)
+        add_to_field = remaining_width(f) < extra_per_field ? remaining_width(f) : extra_per_field
+        added_width += add_to_field
+        @field_lengths[f] += add_to_field
+      end
+    end
+
+    def remaining_width(field)
+      (@remaining_width ||= {})[field] ||= begin
+        (@table.max_fields[field] || @original_field_lengths[field]) - @field_lengths[field]
+      end
+    end
+
+    def sum(arr)
+      arr.inject {|t,e| t += e }
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
new file mode 100644
index 0000000..2697423
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
@@ -0,0 +1,181 @@
+# Base tree class which given an array of nodes produces different types of trees.
+# The types of trees currently are:
+# * basic:
+#    0
+#      1
+#        2
+#        3
+#      4
+# 
+# * directory:
+#    0
+#    |-- 1
+#    |   |-- 2
+#    |   `-- 3
+#    `-- 4
+# 
+# * number:
+#    1. 0
+#      1. 1
+#        1. 2
+#        2. 3
+#      2. 4 
+# 
+# Tree nodes can be given as an array of arrays or an array of hashes.
+# To render the above basic tree with an array of hashes:
+#   Hirb::Helpers::Tree.render([{:value=>0, :level=>0}, {:value=>1, :level=>1}, {:value=>2, :level=>2}, 
+#     {:value=>3, :level=>2}, {:value=>4, :level=>1}])
+# Note from the hash keys that :level refers to the depth of the tree while :value refers to the text displayed
+# for a node.
+#
+# To render the above basic tree with an array of arrays:
+#   Hirb::Helpers::Tree.render([[0,0], [1,1], [2,2], [2,3], [1,4]])
+# Note that the each array pair consists of the level and the value for the node.
+class Hirb::Helpers::Tree
+  class ParentlessNodeError < StandardError; end
+
+  class <<self
+    # Main method which renders a tree.
+    # ==== Options:
+    # [:type] Type of tree. Either :basic, :directory or :number. Default is :basic.
+    # [:validate] Boolean to validate tree. Checks to see if all nodes have parents. Raises ParentlessNodeError if
+    #             an invalid node is found. Default is false.
+    # [:indent] Number of spaces to indent between levels for basic + number trees. Default is 4.
+    # [:limit] Limits the level or depth of a tree that is displayed. Root node is level 0.
+    # [:description] Displays brief description about tree ie how many nodes it has.
+    # [:multi_line_nodes] Handles multi-lined nodes by indenting their newlines. Default is false.
+    #  Examples:
+    #     Hirb::Helpers::Tree.render([[0, 'root'], [1, 'child']], :type=>:directory)
+    def render(nodes, options={})
+      new(nodes, options).render
+    end
+  end
+
+  # :stopdoc:
+  attr_accessor :nodes
+  
+  def initialize(input_nodes, options={})
+    @options = options
+    @type = options[:type] || :basic
+    if input_nodes[0].is_a?(Array)
+      @nodes = input_nodes.map {|e| Node.new(:level=>e[0], :value=>e[1]) }
+    else
+      @nodes = input_nodes.map {|e| Node.new(e)}
+    end
+    @nodes.each_with_index {|e,i| e.merge!(:tree=>self, :index=>i)}
+    @nodes.each {|e| e[:value] = e[:value].to_s }
+    validate_nodes if options[:validate]
+    self
+  end
+
+  def render
+    body = render_tree
+    body += render_description if @options[:description]
+    body
+  end
+  
+  def render_description
+    "\n\n#{@nodes.length} #{@nodes.length == 1 ? 'node' : 'nodes'} in tree"
+  end
+
+  def render_tree
+    @indent = ' ' * (@options[:indent] || 4 )
+    @nodes = @nodes.select {|e| e[:level] <= @options[:limit] } if @options[:limit]
+    case @type.to_s
+    when 'directory' then render_directory
+    when 'number'    then render_number
+    else render_basic
+    end
+  end
+
+  def render_nodes
+    value_indent = @options[:multi_line_nodes] ? @indent : nil
+    @nodes.map {|e| yield(e) + e.value(value_indent) }.join("\n")
+  end
+
+  def render_directory
+    mark_last_nodes_per_level
+    render_nodes {|e|
+      value = ''
+      unless e.root?
+        value << e.render_parent_characters
+        value << (e[:last_node] ? "`-- " : "|-- ")
+      end
+      value
+    }
+  end
+  
+  def render_number
+    counter = {}
+    @nodes.each {|e|
+      parent_level_key = "#{(e.parent ||{})[:index]}.#{e[:level]}"
+      counter[parent_level_key] ||= 0
+      counter[parent_level_key] += 1
+      e[:pre_value] = "#{counter[parent_level_key]}. "
+    }
+    render_nodes {|e| @indent * e[:level] + e[:pre_value] }
+  end
+
+  def render_basic
+    render_nodes {|e| @indent * e[:level] }
+  end
+
+  def validate_nodes
+    @nodes.each do |e|
+      raise ParentlessNodeError if (e[:level] > e.previous[:level]) && (e[:level] - e.previous[:level]) > 1
+    end
+  end
+  
+  # walks tree accumulating last nodes per unique parent+level
+  def mark_last_nodes_per_level
+    @nodes.each {|e| e.delete(:last_node)}
+    last_node_hash = @nodes.inject({}) {|h,e|
+      h["#{(e.parent ||{})[:index]}.#{e[:level]}"] = e; h
+    }
+    last_node_hash.values.uniq.each {|e| e[:last_node] = true}
+  end
+  #:startdoc:
+  class Node < ::Hash #:nodoc:
+    class MissingLevelError < StandardError; end
+    class MissingValueError < StandardError; end
+    
+    def initialize(hash)
+      super
+      raise MissingLevelError unless hash.has_key?(:level)
+      raise MissingValueError unless hash.has_key?(:value)
+      replace(hash)
+    end
+
+    def value(indent=nil)
+      indent ? self[:value].gsub("\n", "\n#{indent * self[:level]}") : self[:value]
+    end
+
+    def parent
+      self[:tree].nodes.slice(0 .. self[:index]).reverse.detect {|e| e[:level] < self[:level]}
+    end
+
+    def next
+      self[:tree].nodes[self[:index] + 1]
+    end
+
+    def previous
+      self[:tree].nodes[self[:index] - 1]
+    end
+
+    def root?; self[:level] == 0; end
+
+    # refers to characters which connect parent nodes 
+    def render_parent_characters
+      parent_chars = []
+      get_parents_character(parent_chars)
+      parent_chars.reverse.map {|level| level + ' ' * 3 }.join('')
+    end
+
+    def get_parents_character(parent_chars)
+      if self.parent
+        parent_chars << (self.parent[:last_node] ? ' ' : '|') unless self.parent.root?
+        self.parent.get_parents_character(parent_chars)
+      end
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb b/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
new file mode 100644
index 0000000..1f18f3e
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
@@ -0,0 +1,37 @@
+class Hirb::Helpers::VerticalTable < Hirb::Helpers::Table
+
+  # Renders a vertical table using the same options as Hirb::Helpers::Table.render except for the ones below
+  # and :max_fields, :vertical and :max_width which aren't used.
+  # ==== Options:
+  # [:hide_empty] Boolean which hides empty values (nil or '') from being displayed. Default is false.
+  def self.render(rows, options={})
+    new(rows, {:escape_special_chars=>false, :resize=>false}.merge(options)).render
+  end
+
+  #:stopdoc:
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+  end
+
+  def render_header; []; end
+  def render_footer; []; end
+
+  def render_rows
+    i = 0
+    longest_header = Hirb::String.size @headers.values.sort_by {|e| Hirb::String.size(e) }.last
+    stars = "*" * [(longest_header + (longest_header / 2)), 3].max
+    @rows.map do |row|
+      row = "#{stars} #{i+1}. row #{stars}\n" +
+      @fields.map {|f|
+        if !@options[:hide_empty] || (@options[:hide_empty] && !row[f].empty?)
+          "#{Hirb::String.rjust(@headers[f], longest_header)}: #{row[f]}"
+        else
+          nil
+        end
+      }.compact.join("\n")
+      i+= 1
+      row
+    end
+  end
+  #:startdoc:
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/import_object.rb b/vendor/hirb-0.3.5/lib/hirb/import_object.rb
new file mode 100644
index 0000000..8bd0f1f
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/import_object.rb
@@ -0,0 +1,10 @@
+module Hirb
+  module ObjectMethods
+    # Takes same options as Hirb::View.render_output.
+    def view(*args)
+      Hirb::Console.render_output(*(args.unshift(self)))
+    end
+  end
+end
+
+Object.send :include, Hirb::ObjectMethods
diff --git a/vendor/hirb-0.3.5/lib/hirb/menu.rb b/vendor/hirb-0.3.5/lib/hirb/menu.rb
new file mode 100644
index 0000000..ffafd14
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/menu.rb
@@ -0,0 +1,221 @@
+module Hirb
+  # This class provides a menu using Hirb's table helpers by default to display choices.
+  # Menu choices (syntax at Hirb::Util.choose_from_array) refer to rows. However, when in
+  # two_d mode, choices refer to specific cells by appending a ':field' to a choice.
+  # A field name can be an abbreviated. Menus can also have an action mode, which turns the
+  # menu prompt into a commandline that executes the choices as arguments and uses methods as
+  # actions/commands.
+  class Menu
+    class Error < StandardError; end
+
+    # Detects valid choices and optional field/column
+    CHOSEN_REGEXP = /^(\d([^:]+)?)(?::)?(\S+)?/
+    CHOSEN_ARG = '%s'
+    DIRECTIONS = "Specify individual choices (4,7), range of choices (1-3) or all choices (*)."
+
+
+    # This method will return an array unless it's exited by simply pressing return, which returns nil.
+    # If given a block, the block will yield if and with any menu items are chosen.
+    # All options except for the ones below are passed to render the menu.
+    #
+    # ==== Options:
+    # [*:helper_class*]  Helper class to render menu. Helper class is expected to implement numbering given a :number option.
+    #                    To use a very basic menu, set this to false. Defaults to Hirb::Helpers::AutoTable.
+    # [*:prompt*]  String for menu prompt. Defaults to "Choose: ".
+    # [*:ask*] Always ask for input, even if there is only one choice. Default is true.
+    # [*:directions*] Display directions before prompt. Default is true.
+    # [*:readline*] Use readline to get user input if available. Input strings are added to readline history. Default is false.
+    # [*:two_d*] Turn menu into a 2 dimensional (2D) menu by allowing user to pick values from table cells. Default is false.
+    # [*:default_field*] Default field for a 2D menu. Defaults to first field in a table.
+    # [*:action*] Turn menu into an action menu by letting user pass menu choices as an argument to a method/command.
+    #             A menu choice's place amongst other arguments is preserved. Default is false.
+    # [*:multi_action*] Execute action menu multiple times iterating over the menu choices. Default is false.
+    # [*:action_object*] Object that takes method/command calls. Default is main.
+    # [*:command*] Default method/command to call when no command given.
+    # [*:reopen*] Reopens $stdin with given file or with /dev/tty when set to true. Use when
+    #             $stdin is already reading in piped data.
+    # Examples:
+    #     >> extend Hirb::Console
+    #     => self
+    #     >> menu [1,2,3], :prompt=> "So many choices, so little time: "
+    #     >> menu [{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:a,b], :two_d=>true)
+    def self.render(output, options={}, &block)
+      new(options).render(output, &block)
+    rescue Error=>e
+      $stderr.puts "Error: #{e.message}"
+    end
+
+    #:stopdoc:
+    def initialize(options={})
+      @options = {:helper_class=>Hirb::Helpers::AutoTable, :prompt=>"Choose: ", :ask=>true,
+        :directions=>true}.merge options
+      @options[:reopen] = '/dev/tty' if @options[:reopen] == true
+    end
+
+    def render(output, &block)
+      @output = Array(output)
+      return [] if @output.size.zero?
+      chosen = choose_from_menu
+      block.call(chosen) if block && chosen.size > 0
+      @options[:action] ? execute_action(chosen) : chosen
+    end
+
+    def get_input
+      prompt = pre_prompt + @options[:prompt]
+      prompt = DIRECTIONS+"\n"+prompt if @options[:directions]
+      $stdin.reopen @options[:reopen] if @options[:reopen]
+
+      if @options[:readline] && readline_loads?
+        get_readline_input(prompt)
+      else
+        print prompt
+        $stdin.gets.chomp.strip
+      end
+    end
+
+    def get_readline_input(prompt)
+      input = Readline.readline prompt
+      Readline::HISTORY << input
+      input
+    end
+
+    def pre_prompt
+      prompt = ''
+      prompt << "Default field: #{default_field}\n" if @options[:two_d] && default_field
+      prompt << "Default command: #{@options[:command]}\n" if @options[:action] && @options[:command]
+      prompt
+    end
+
+    def choose_from_menu
+      return unasked_choice if @output.size == 1 && !@options[:ask]
+
+      if (helper_class = Util.any_const_get(@options[:helper_class]))
+        View.render_output(@output, :class=>@options[:helper_class], :options=>@options.merge(:number=>true))
+      else
+        @output.each_with_index {|e,i| puts "#{i+1}: #{e}" }
+      end
+
+      parse_input get_input
+    end
+
+    def unasked_choice
+      return @output unless @options[:action]
+      raise(Error, "Default command and field required for unasked action menu") unless default_field && @options[:command]
+      @new_args = [@options[:command], CHOSEN_ARG]
+      map_tokens([[@output, default_field]])
+    end
+
+    def execute_action(chosen)
+      return nil if chosen.size.zero?
+      if @options[:multi_action]
+        chosen.each {|e| invoke command, add_chosen_to_args(e) }
+      else
+        invoke command, add_chosen_to_args(chosen)
+      end
+    end
+
+    def invoke(cmd, args)
+      action_object.send(cmd, *args)
+    end
+
+    def parse_input(input)
+      if (@options[:two_d] || @options[:action])
+        tokens = input_to_tokens(input)
+        map_tokens(tokens)
+      else
+        Util.choose_from_array(@output, input)
+      end
+    end
+
+    def map_tokens(tokens)
+      if return_cell_values?
+        @output[0].is_a?(Hash) ? tokens.map {|arr,f| arr.map {|e| e[f]} }.flatten :
+          tokens.map {|arr,f|
+            arr.map {|e| e.is_a?(Array) && f.is_a?(Integer) ? e[f] : e.send(f) }
+          }.flatten
+      else
+        tokens.map {|e| e[0] }.flatten
+      end
+    end
+
+    def return_cell_values?
+      @options[:two_d]
+    end
+
+    def input_to_tokens(input)
+      @new_args = []
+      tokens = (@args = split_input_args(input)).map {|word| parse_word(word) }.compact
+      cleanup_new_args
+      tokens
+    end
+
+    def parse_word(word)
+      if word[CHOSEN_REGEXP]
+        @new_args << CHOSEN_ARG
+        field = $3 ? unalias_field($3) : default_field ||
+          raise(Error, "No default field/column found. Fields must be explicitly picked.")
+        [Util.choose_from_array(@output, word), field ]
+      else
+        @new_args << word
+        nil
+      end
+    end
+
+    def cleanup_new_args
+      if @new_args.all? {|e| e == CHOSEN_ARG }
+        @new_args = [CHOSEN_ARG]
+      else
+        i = @new_args.index(CHOSEN_ARG) || raise(Error, "No rows chosen")
+        @new_args.delete(CHOSEN_ARG)
+        @new_args.insert(i, CHOSEN_ARG)
+      end
+    end
+
+    def add_chosen_to_args(items)
+      args = @new_args.dup
+      args[args.index(CHOSEN_ARG)] = items
+      args
+    end
+
+    def command
+      @command ||= begin
+        cmd = (@new_args == [CHOSEN_ARG]) ? nil : @new_args.shift
+        cmd ||= @options[:command] || raise(Error, "No command given for action menu")
+      end
+    end
+
+    def action_object
+      @options[:action_object] || eval("self", TOPLEVEL_BINDING)
+    end
+
+    def split_input_args(input)
+      input.split(/\s+/)
+    end
+
+    def default_field
+      @default_field ||= @options[:default_field] || fields[0]
+    end
+
+    # Has to be called after displaying menu
+    def fields
+      @fields ||= @options[:fields] || (@options[:ask] && table_helper_class? && Helpers::Table.last_table ?
+        Helpers::Table.last_table.fields[1..-1] : [])
+    end
+
+    def table_helper_class?
+      @options[:helper_class].is_a?(Class) && @options[:helper_class] < Helpers::Table
+    end
+
+    def unalias_field(field)
+      fields.sort_by {|e| e.to_s }.find {|e| e.to_s[/^#{field}/] } || raise(Error, "Invalid field '#{field}'")
+    end
+
+    def readline_loads?
+      require 'readline'
+      true
+    rescue LoadError
+      false
+    end
+    #:startdoc:
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/pager.rb b/vendor/hirb-0.3.5/lib/hirb/pager.rb
new file mode 100644
index 0000000..8ff1250
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/pager.rb
@@ -0,0 +1,95 @@
+module Hirb
+  # This class provides class methods for paging and an object which can conditionally page given a terminal size that is exceeded.
+  class Pager
+    class<<self
+      # Pages using a configured or detected shell command.
+      def command_pager(output, options={})
+        basic_pager(output) if valid_pager_command?(options[:pager_command])
+      end
+
+      def pager_command(*commands) #:nodoc:
+        @pager_command = (!@pager_command.nil? && commands.empty?) ? @pager_command : 
+          begin
+            commands = [ENV['PAGER'], 'less', 'more', 'pager'] if commands.empty?
+            commands.compact.uniq.find {|e| Util.command_exists?(e[/\w+/]) }
+          end
+      end
+
+      # Pages with a ruby-only pager which either pages or quits.
+      def default_pager(output, options={})
+        pager = new(options[:width], options[:height])
+        while pager.activated_by?(output, options[:inspect])
+          puts pager.slice!(output, options[:inspect])
+          return unless continue_paging?
+        end
+        puts output
+        puts "=== Pager finished. ==="
+      end
+
+      #:stopdoc:
+      def valid_pager_command?(cmd)
+        cmd ? pager_command(cmd) : pager_command
+      end
+
+      private
+      def basic_pager(output)
+        pager = IO.popen(pager_command, "w")
+        begin
+          save_stdout = STDOUT.clone
+          STDOUT.reopen(pager)
+          STDOUT.puts output
+        rescue Errno::EPIPE
+        ensure
+         STDOUT.reopen(save_stdout)
+         save_stdout.close
+         pager.close
+        end
+      end
+
+      def continue_paging?
+        puts "=== Press enter/return to continue or q to quit: ==="
+        !$stdin.gets.chomp[/q/i]
+      end
+      #:startdoc:
+    end
+
+    attr_reader :width, :height
+
+    def initialize(width, height, options={})
+      resize(width, height)
+      @pager_command = options[:pager_command] if options[:pager_command]
+    end
+
+    # Pages given string using configured pager.
+    def page(string, inspect_mode)
+      if self.class.valid_pager_command?(@pager_command)
+        self.class.command_pager(string, :pager_command=>@pager_command)
+      else
+        self.class.default_pager(string, :width=>@width, :height=>@height, :inspect=>inspect_mode)
+      end
+    end
+
+    def slice!(output, inspect_mode=false) #:nodoc:
+      effective_height = @height - 2 # takes into account pager prompt
+      if inspect_mode
+        sliced_output = String.slice(output, 0, @width * effective_height)
+        output.replace String.slice(output, @width * effective_height, String.size(output))
+        sliced_output
+      else
+        # could use output.scan(/[^\n]*\n?/) instead of split
+        sliced_output = output.split("\n").slice(0, effective_height).join("\n")
+        output.replace output.split("\n").slice(effective_height..-1).join("\n")
+        sliced_output
+      end
+    end
+
+    # Determines if string should be paged based on configured width and height.
+    def activated_by?(string_to_page, inspect_mode=false)
+      inspect_mode ? (String.size(string_to_page) > @height * @width) : (string_to_page.count("\n") > @height)
+    end
+
+    def resize(width, height) #:nodoc:
+      @width, @height = View.determine_terminal_size(width, height)
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/string.rb b/vendor/hirb-0.3.5/lib/hirb/string.rb
new file mode 100644
index 0000000..0d96585
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/string.rb
@@ -0,0 +1,44 @@
+module Hirb
+  # Provides string helpers to deal with UTF-8 and ruby 1.8.x
+  module String
+    extend self
+    # :stopdoc:
+    if RUBY_VERSION < '1.9'
+      def size(string)
+        string.scan(/./).length
+      end
+
+      def ljust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? string + " " * leftover : string
+      end
+
+      def rjust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? " " * leftover + string : string
+      end
+
+      def slice(string, start, finish)
+        string.scan(/./).slice(start, finish).join('')
+      end
+    else
+      def size(string)
+        string.length
+      end
+
+      def ljust(string, desired_length)
+        string.ljust(desired_length)
+      end
+
+      def rjust(string, desired_length)
+        string.rjust(desired_length)
+      end
+
+      def slice(*args)
+        string = args.shift
+        string.slice(*args)
+      end
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/util.rb b/vendor/hirb-0.3.5/lib/hirb/util.rb
new file mode 100644
index 0000000..2db4b65
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/util.rb
@@ -0,0 +1,96 @@
+module Hirb
+  # Group of handy utility functions used throughout Hirb.
+  module Util
+    extend self
+    # Returns a constant like Module#const_get no matter what namespace it's nested in.
+    # Returns nil if the constant is not found.
+    def any_const_get(name)
+      return name if name.is_a?(Module)
+      begin
+        klass = Object
+        name.split('::').each {|e|
+          klass = klass.const_get(e)
+        }
+        klass
+      rescue
+         nil
+      end
+    end
+
+    # Recursively merge hash1 with hash2.
+    def recursive_hash_merge(hash1, hash2)
+      hash1.merge(hash2) {|k,o,n| (o.is_a?(Hash)) ? recursive_hash_merge(o,n) : n}
+    end
+
+    # From Rails ActiveSupport, converting undescored lowercase to camel uppercase.
+    def camelize(string)
+      string.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+    end
+
+    # Used by Hirb::Menu to select items from an array. Array counting starts at 1. Ranges of numbers are specified with a '-' or '..'.
+    # Multiple ranges can be comma delimited. Anything that isn't a valid number is ignored. All elements can be returned with a '*'.
+    # Examples:
+    #    1-3,5-6 -> [1,2,3,5,6]
+    #    *   -> all elements in array
+    #    ''  -> [] 
+    def choose_from_array(array, input, options={})
+      options = {:splitter=>","}.merge(options)
+      return array if input.strip == '*'
+      result = []
+      input.split(options[:splitter]).each do |e|
+        if e =~ /-|\.\./
+          min,max = e.split(/-|\.\./)
+          slice_min = min.to_i - 1
+          result.push(*array.slice(slice_min, max.to_i - min.to_i + 1))
+        elsif e =~ /\s*(\d+)\s*/
+          index = $1.to_i - 1
+          next if index < 0
+          result.push(array[index]) if array[index]
+        end
+      end
+      result
+    end
+
+    # Determines if a shell command exists by searching for it in ENV['PATH'].
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Returns [width, height] of terminal when detected, nil if not detected.
+    # Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
+    def detect_terminal_size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [`tput cols`.to_i, `tput lines`.to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        nil
+      end
+    rescue
+      nil
+    end
+
+    # Captures STDOUT of anything run in its block and returns it as string.
+    def capture_stdout(&block)
+      original_stdout = $stdout
+      $stdout = fake = StringIO.new
+      begin
+        yield
+      ensure
+        $stdout = original_stdout
+      end
+      fake.string
+    end
+
+    # From Rubygems, determine a user's home.
+    def find_home
+      ['HOME', 'USERPROFILE'].each {|e| return ENV[e] if ENV[e] }
+      return "#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}" if ENV['HOMEDRIVE'] && ENV['HOMEPATH']
+      File.expand_path("~")
+    rescue
+      File::ALT_SEPARATOR ? "C:/" : "/"
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/version.rb b/vendor/hirb-0.3.5/lib/hirb/version.rb
new file mode 100644
index 0000000..58002c4
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/version.rb
@@ -0,0 +1,3 @@
+module Hirb
+  VERSION = '0.3.5'
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/view.rb b/vendor/hirb-0.3.5/lib/hirb/view.rb
new file mode 100644
index 0000000..70a4563
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/view.rb
@@ -0,0 +1,270 @@
+module Hirb
+  # This class is responsible for managing all view-related functionality.
+  #
+  # == Create a View
+  # Let's create a simple view for Hash objects:
+  #   $ irb -rubygems
+  #   >> require 'hirb'
+  #   =>true
+  #   >> Hirb.enable
+  #   =>nil
+  #   >> require 'yaml'
+  #   =>true
+  #
+  #   # A view method is the smallest view
+  #   >> def yaml(output); output.to_yaml; end
+  #   => nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :method=>:yaml
+  #   => true
+  #
+  #   # Hashes now appear as yaml
+  #   >> {:a=>1, :b=>{:c=>3}}
+  #   ---
+  #   :a : 1
+  #   :b : 
+  #     :c : 3
+  #   => true
+  #
+  # Another way of creating a view is a Helper class:
+  #
+  #   # Create yaml view class
+  #   >> class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   =>nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :class=>Hirb::Helpers::Yaml
+  #   =>true
+  #
+  #   # Hashes appear as yaml like above ...
+  #
+  # == Configure a View
+  # To configure the above Helper class as a view, either pass Hirb.enable a hash:
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable :output=>{"Hash"=>{:class=>"Hirb::Helpers::Yaml"}}
+  #
+  # Or create a config file at config/hirb.yml or ~/.hirb.yml:
+  #   # The config file for the yaml example would look like:
+  #   # ---
+  #   # :output :
+  #   #   Hash :
+  #   #    :class : Hirb::Helpers::Yaml
+  #
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable
+  #
+  # For more about configuring Hirb, see the Config Files section in Hirb.
+  module View
+    DEFAULT_WIDTH = 120
+    DEFAULT_HEIGHT = 40
+    class<<self
+      attr_accessor :render_method
+      attr_reader :config
+
+      # This activates view functionality i.e. the formatter, pager and size detection. If irb exists, it overrides irb's output
+      # method with Hirb::View.view_output. When called multiple times, new configs are merged into the existing config.
+      # If using Wirble, you should call this after it. The view configuration can be specified in a hash via a config file,
+      # or as options to this method. In addition to the config keys mentioned in Hirb, options also take the following keys:
+      # ==== Options:
+      # * config_file: Name of config file(s) that are merged into existing config
+      # Examples:
+      #   Hirb.enable
+      #   Hirb.enable :formatter=>false
+      def enable(options={}, &block)
+        Array(options.delete(:config_file)).each {|e|
+          @new_config_file = true
+          Hirb.config_files << e
+        }
+        enable_output_method unless @output_method
+        merge_or_load_config options
+        resize(config[:width], config[:height])
+        @enabled = true
+      end
+
+      # Indicates if Hirb::View is enabled.
+      def enabled?
+        @enabled || false
+      end
+
+      # Disable's Hirb's output and revert's irb's output method if irb exists.
+      def disable
+        @enabled = false
+        disable_output_method if @output_method
+        false
+      end
+
+      # Toggles pager on or off. The pager only works while Hirb::View is enabled.
+      def toggle_pager
+        config[:pager] = !config[:pager]
+      end
+
+      # Toggles formatter on or off.
+      def toggle_formatter
+        config[:formatter] = !config[:formatter]
+      end
+
+      # Resizes the console width and height for use with the table and pager i.e. after having resized the console window. *nix users
+      # should only have to call this method. Non-*nix users should call this method with explicit width and height. If you don't know
+      # your width and height, in irb play with "a"* width to find width and puts "a\n" * height to find height.
+      def resize(width=nil, height=nil)
+        config[:width], config[:height] = determine_terminal_size(width, height)
+        pager.resize(config[:width], config[:height])
+      end
+      
+      # This is the main method of this class. When view is enabled, this method searches for a formatter it can use for the output and if
+      # successful renders it using render_method(). The options this method takes are helper config hashes as described in 
+      # Hirb::Formatter.format_output(). Returns true if successful and false if no formatting is done or if not enabled.
+      def view_output(output, options={})
+        enabled? && config[:formatter] && render_output(output, options)
+      rescue Exception=>e
+        if config[:ignore_errors]
+          $stderr.puts "Hirb Error: #{e.message}"
+          false
+        else
+          index = (obj = e.backtrace.find {|f| f =~ /^\(eval\)/}) ? e.backtrace.index(obj) : e.backtrace.length
+          $stderr.puts "Hirb Error: #{e.message}", e.backtrace.slice(0,index).map {|e| "    " + e }
+          true
+        end
+      end
+
+      # Captures STDOUT and renders it using render_method(). The main use case is to conditionally page captured stdout.
+      def capture_and_render(&block)
+        render_method.call Util.capture_stdout(&block)
+      end
+
+      # A lambda or proc which handles the final formatted object.
+      # Although this pages/puts the object by default, it could be set to do other things
+      # i.e. write the formatted object to a file.
+      def render_method
+        @render_method ||= default_render_method
+      end
+
+      # Resets render_method back to its default.
+      def reset_render_method
+        @render_method = default_render_method
+      end
+      
+      # Current console width
+      def width
+        config && config[:width] ? config[:width] : DEFAULT_WIDTH
+      end
+
+      # Current console height
+      def height
+        config && config[:height] ? config[:height] : DEFAULT_HEIGHT
+      end
+
+      # Current formatter config, storing a hash of all static views
+      def formatter_config
+        formatter.config
+      end
+
+      # Adds a view when View is enabled. See Formatter.add_view for more details.
+      def add(klass, view_config)
+        if enabled?
+          formatter.add_view(klass, view_config)
+        else
+          puts "View must be enabled to add a view"
+        end
+      end
+
+      #:stopdoc:
+      def enable_output_method
+        if defined? Ripl
+          @output_method = true
+          require 'ripl/hirb'
+        elsif defined? IRB
+          @output_method = true
+          ::IRB::Irb.class_eval do
+            alias_method :non_hirb_view_output, :output_value
+            def output_value #:nodoc:
+              Hirb::View.view_or_page_output(@context.last_value) || non_hirb_view_output
+            end
+          end
+        end
+      end
+
+      def disable_output_method
+        if defined?(IRB) && !defined? Ripl
+          ::IRB::Irb.send :alias_method, :output_value, :non_hirb_view_output
+        end
+        @output_method = nil
+      end
+
+      def view_or_page_output(str)
+        view_output(str) || page_output(str.inspect, true)
+      end
+
+      def render_output(output, options={})
+        if (formatted_output = formatter.format_output(output, options))
+          render_method.call(formatted_output)
+          true
+        else
+          false
+        end
+      end
+
+      def determine_terminal_size(width, height)
+        detected  = (width.nil? || height.nil?) ? Util.detect_terminal_size || [] : []
+        [width || detected[0] || DEFAULT_WIDTH , height || detected[1] || DEFAULT_HEIGHT]
+      end
+
+      def page_output(output, inspect_mode=false)
+        if enabled? && config[:pager] && pager.activated_by?(output, inspect_mode)
+          pager.page(output, inspect_mode)
+          true
+        else
+          false
+        end
+      end
+
+      def pager
+        @pager ||= Pager.new(config[:width], config[:height], :pager_command=>config[:pager_command])
+      end
+
+      def pager=(value); @pager = value; end
+
+      def formatter(reload=false)
+        @formatter = reload || @formatter.nil? ? Formatter.new(config[:output]) : @formatter
+      end
+
+      def formatter=(value); @formatter = value; end
+
+      def merge_or_load_config(additional_config={})
+        if @config && (@new_config_file || !additional_config.empty?)
+          Hirb.config = nil
+          load_config Util.recursive_hash_merge(@config, additional_config)
+          @new_config_file = false
+        elsif !@enabled
+          load_config(additional_config)
+        end
+      end
+
+      def load_config(additional_config={})
+        @config = Util.recursive_hash_merge default_config, additional_config
+        formatter(true)
+        true
+      end
+
+      def config_loaded?; !!@config; end
+
+      def config
+        @config
+      end
+      
+      def default_render_method
+        lambda {|output| page_output(output) || puts(output) }
+      end
+
+      def default_config
+        Util.recursive_hash_merge({:pager=>true, :formatter=>true}, Hirb.config || {})
+      end
+      #:startdoc:
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/lib/hirb/views.rb b/vendor/hirb-0.3.5/lib/hirb/views.rb
new file mode 100644
index 0000000..330a802
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views.rb
@@ -0,0 +1,8 @@
+module Hirb
+  # Namespace for Helpers defining multiple views in a module i.e. via DynamicView.
+  module Views
+    module Single #:nodoc:
+    end
+  end
+end
+%w{rails orm mongo_db couch_db misc_db}.each {|e| require "hirb/views/#{e}" }
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb b/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
new file mode 100644
index 0000000..ad4ef11
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::CouchDb #:nodoc:
+  def default_couch(obj)
+    {:fields=>([:_id] + obj.class.properties.map {|e| e.name }) }
+  end
+
+  alias_method :couch_rest__extended_document_view, :default_couch
+  alias_method :couch_foo__base_view, :default_couch
+  alias_method :couch_potato__persistence_view, :default_couch
+end
+
+Hirb::DynamicView.add Hirb::Views::CouchDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb b/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
new file mode 100644
index 0000000..48f8d1b
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
@@ -0,0 +1,15 @@
+module Hirb::Views::MiscDb #:nodoc:
+  def friendly__document_view(obj)
+    {:fields=>obj.class.attributes.keys - [:id]}
+  end
+
+  def ripple__document_view(obj)
+    {:fields=>obj.class.properties.keys}
+  end
+
+  def d_b_i__row_view(obj)
+    {:fields=>obj.column_names, :table_class=>Hirb::Helpers::Table}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::MiscDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb b/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
new file mode 100644
index 0000000..a79d35b
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
@@ -0,0 +1,14 @@
+module Hirb::Views::MongoDb #:nodoc:
+  def mongoid__document_view(obj)
+    {:fields=>['_id'] + obj.class.fields.keys}
+  end
+
+  def mongo_mapper__document_view(obj)
+    fields = obj.class.column_names
+    fields.delete('_id') && fields.unshift('_id')
+    {:fields=>fields}
+  end
+  alias_method :mongo_mapper__embedded_document_view, :mongo_mapper__document_view
+end
+
+Hirb::DynamicView.add Hirb::Views::MongoDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/views/orm.rb b/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
new file mode 100644
index 0000000..ded4b9b
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::ORM #:nodoc:
+  def data_mapper__resource_view(obj)
+    {:fields=>obj.class.properties.map {|e| e.name }}
+  end
+
+  def sequel__model_view(obj)
+    {:fields=>obj.class.columns}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::ORM, :helper=>:auto_table
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/hirb/views/rails.rb b/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
new file mode 100644
index 0000000..03105ff
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
@@ -0,0 +1,19 @@
+module Hirb::Views::Rails #:nodoc:
+  def active_record__base_view(obj)
+    {:fields=>get_active_record_fields(obj)}
+  end
+
+  def get_active_record_fields(obj)
+    fields = obj.class.column_names.map {|e| e.to_sym }
+    # if query used select
+    if obj.attributes.keys.sort != obj.class.column_names.sort
+      selected_columns = obj.attributes.keys
+      sorted_columns = obj.class.column_names.dup.delete_if {|e| !selected_columns.include?(e) }
+      sorted_columns += (selected_columns - sorted_columns)
+      fields = sorted_columns.map {|e| e.to_sym}
+    end
+    fields
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::Rails, :helper=>:auto_table
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/lib/ripl/hirb.rb b/vendor/hirb-0.3.5/lib/ripl/hirb.rb
new file mode 100644
index 0000000..c56a45d
--- /dev/null
+++ b/vendor/hirb-0.3.5/lib/ripl/hirb.rb
@@ -0,0 +1,14 @@
+module Ripl::Hirb
+  def before_loop
+    super
+    require 'hirb'
+    Hirb.enable(Ripl.config[:hirb] || {}) unless Hirb::View.enabled?
+  end
+
+  def format_result(result)
+    return super if !Hirb::View.enabled?
+    Hirb::View.view_or_page_output(result) || super
+  end
+end
+
+Ripl::Shell.send :include, Ripl::Hirb
diff --git a/vendor/hirb-0.3.5/test/auto_table_test.rb b/vendor/hirb-0.3.5/test/auto_table_test.rb
new file mode 100644
index 0000000..8e90d9a
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/auto_table_test.rb
@@ -0,0 +1,30 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "auto table" do
+  it "converts nonarrays to arrays and renders" do
+    require 'set'
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    +-------+
+    3 rows in set
+    TABLE
+    Helpers::AutoTable.render(::Set.new([1,2,3])).should == expected_table
+  end
+
+  it "renders hash" do
+    expected_table = <<-TABLE.unindent
+    +---+-------+
+    | 0 | 1     |
+    +---+-------+
+    | a | 12345 |
+    +---+-------+
+    1 row in set
+    TABLE
+    Helpers::AutoTable.render({:a=>12345}).should == expected_table
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/console_test.rb b/vendor/hirb-0.3.5/test/console_test.rb
new file mode 100644
index 0000000..b34a0ef
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/console_test.rb
@@ -0,0 +1,27 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Console" do
+  it "#table is called without Hirb enabled" do
+    extend Hirb::Console
+    reset_config
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 5     |
+    | 3     |
+    +-------+
+    2 rows in set
+    TABLE
+    capture_stdout {
+      table([5,3], :fields=>[:to_s])
+    }.should == expected_table +"\n"
+  end
+
+  it ".render_output sets config if it wasn't before" do
+    reset_config
+    View.expects(:render_output)
+    Console.render_output('blah')
+    View.config.is_a?(Hash).should == true
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/deps.rip b/vendor/hirb-0.3.5/test/deps.rip
new file mode 100644
index 0000000..89eacd3
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/deps.rip
@@ -0,0 +1,4 @@
+bacon >=1.1.0
+mocha >=0
+mocha-on-bacon >=0
+bacon-bits >=0
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/dynamic_view_test.rb b/vendor/hirb-0.3.5/test/dynamic_view_test.rb
new file mode 100644
index 0000000..2523684
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/dynamic_view_test.rb
@@ -0,0 +1,94 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "DynamicView" do
+  def output_expects(output, expects)
+    Helpers::ObjectTable.expects(:render).with(output, expects)
+    Helpers::AutoTable.render(output)
+  end
+
+  describe "add" do
+    before_all { View.load_config }
+
+    it "raises error if no :helper option" do
+      lambda { Hirb.add_dynamic_view 'Blah', {} }.should.raise(ArgumentError).
+        message.should =~ /:helper.*required/
+    end
+
+    it "raises error if :helper option not a dynamic_view module" do
+      lambda { Hirb.add_dynamic_view('Blah', :helper=>:table) {|obj| } }.
+        should.raise(ArgumentError).message.should =~ /:helper.*must/
+    end
+
+    it "raises error if views module not a module" do
+      lambda { Hirb.add_dynamic_view 'Blah', :helper=>:auto_table }.should.raise(ArgumentError).
+        message.should =~ /must be a module/
+    end
+
+    it "adds a view with block" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "when adding views with a block, second view for same class overrides first one" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>[:blah]}
+      end
+      output_expects [Date.new], :fields=>[:blah]
+    end
+  end
+
+  it "class_to_method and method_to_class convert to each other" do
+    ["DBI::Row", "Hirb::View"].each do |e|
+      Helpers::AutoTable.method_to_class(DynamicView.class_to_method(e).downcase).should == e
+    end
+  end
+
+  it "class_to_method converts correctly" do
+    DynamicView.class_to_method("DBI::Row").should == 'd_b_i__row_view'
+  end
+
+  describe "dynamic_view" do
+    def define_view(mod_name= :Blah, &block)
+      mod = Views.const_set(mod_name, Module.new)
+      mod_block = block_given? ? block : lambda {|obj| {:fields=>obj.class::DAYNAMES}}
+      mod.send(:define_method, :date_view, mod_block)
+      Hirb.add_dynamic_view mod, :helper=>:auto_table
+    end
+
+    before_all { View.load_config }
+    before { Formatter.dynamic_config = {} }
+    after { Views.send(:remove_const, :Blah) }
+
+    it "sets a view's options" do
+      define_view
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "does override existing formatter dynamic_config" do
+      Formatter.dynamic_config["Date"] = {:class=>Helpers::Table}
+      define_view
+      Formatter.dynamic_config["Date"].should == {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+    end
+
+    it "raises a readable error when error occurs in a view" do
+      define_view {|obj| raise 'blah' }
+      lambda { Helpers::AutoTable.render([Date.new]) }.should.raise(RuntimeError).
+        message.should =~ /'Date'.*date_view.*\nblah/
+    end
+
+    it "another view can reuse an old view's options" do
+      define_view
+      define_view(:Blah2) do |obj|
+        {:fields=>obj.class::DAYNAMES + ['blah']}
+      end
+      output_expects [Date.new], :fields=>(Date::DAYNAMES + ['blah'])
+    end
+    after_all { reset_config }
+  end
+  after_all { Formatter.dynamic_config = {} }
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/formatter_test.rb b/vendor/hirb-0.3.5/test/formatter_test.rb
new file mode 100644
index 0000000..883f65e
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/formatter_test.rb
@@ -0,0 +1,176 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Formatter" do
+  def set_formatter(hash={})
+    @formatter = Formatter.new(hash)
+  end
+
+  describe "klass_config" do
+    it "recursively merges ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2], :options=>{:fields=>[:to_s]}},
+        "Object"=>{:method=>:object_output, :ancestor=>true, :options=>{:vertical=>true}},
+        "Kernel"=>{:method=>:default_output}
+      expected_result = {:method=>:object_output, :args=>[1, 2], :ancestor=>true, :options=>{:fields=>[:to_s], :vertical=>true}}
+      @formatter.klass_config(::String).should == expected_result
+    end
+
+    it "doesn't merge ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2]}, "Object"=>{:method=>:object_output},
+       "Kernel"=>{:method=>:default_output}
+      @formatter.klass_config(::String).should == {:args=>[1, 2]}
+    end
+
+    it "returns hash when nothing found" do
+      set_formatter.klass_config(::String).should == {}
+    end
+
+    describe "with dynamic_config" do
+      def set_formatter(hash={})
+        @formatter = Formatter.new(hash)
+      end
+      after { Formatter.dynamic_config = {}}
+
+      it "merges ancestor options and sets local config" do
+        Formatter.dynamic_config = {"Object"=>{:method=>:blah}, "Kernel"=>{:args=>[1,2], :ancestor=>true}}
+        set_formatter.klass_config(::String).should == {:args=>[1,2], :ancestor=>true}
+        @formatter.config['Kernel'].should == {:args=>[1,2], :ancestor=>true}
+      end
+
+      it "uses local config over dynamic_config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter "String"=>{:args=>[1,2]}
+        @formatter.klass_config(::String).should == {:args=>[1,2]}
+      end
+
+      it "uses dynamic_config and sets local config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter.klass_config(::String).should == {:method=>:blah}
+        @formatter.config['String'].should == {:method=>:blah}
+      end
+    end
+  end
+
+  describe "formatter methods:" do
+    before_all { eval "module ::Dooda; end" }
+
+    it "#add_view sets formatter config" do
+      @formatter = set_formatter
+      @formatter.add_view ::Dooda, :class=>"DoodaView"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView"}
+    end
+
+    it "#add_view overwrites existing formatter config" do
+      @formatter = set_formatter "Dooda"=>{:class=>"DoodaView"}
+      @formatter.add_view ::Dooda, :class=>"DoodaView2"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView2"}
+    end
+
+    it "#parse_console_options passes all options except for formatter options into :options" do
+      @formatter = set_formatter
+      options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :blah=>'blah'}
+      expected_options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :options=>{:blah=>'blah'}}
+      @formatter.parse_console_options(options).should == expected_options
+    end
+
+    it "#determine_output_class has exceptions for to_a" do
+      @formatter.determine_output_class(STDOUT).should == IO
+      @formatter.determine_output_class({:a=>1}).should == Hash
+    end
+  end
+
+  describe "format_output" do
+    def view_output(*args, &block); View.view_output(*args, &block); end
+    def render_method(*args); View.render_method(*args); end
+
+    def enable_with_output(value)
+      Hirb.enable :output=>value
+    end
+
+    before_all {
+      eval %[module ::Commify
+        def self.render(strings)
+          strings = Array(strings)
+          strings.map {|e| e.split('').join(',')}.join("\n")
+        end
+      end]
+      reset_config
+    }
+    before { View.formatter = nil; reset_config }
+    after { Hirb.disable }
+    
+    it "formats with method option" do
+      eval "module ::Kernel; def commify(string); string.split('').join(','); end; end"
+      enable_with_output "String"=>{:method=>:commify}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option as symbol" do
+      enable_with_output "String"=>{:class=>:auto_table}
+      Helpers::AutoTable.expects(:render)
+      view_output('dude')
+    end
+
+    it "formats arrays" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output(['dude'])
+    end
+
+    it "formats array-like objects" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      require 'set'
+      view_output Set.new(['dude'])
+    end
+
+    it "formats with options option" do
+      eval "module ::Blahify; def self.render(*args); end; end"
+      enable_with_output "String"=>{:class=>"Blahify", :options=>{:fields=>%w{a b}}}
+      Blahify.expects(:render).with('dude', :fields=>%w{a b})
+      view_output('dude')
+    end
+    
+    it "doesn't format and returns false when no format method found" do
+      Hirb.enable
+      render_method.expects(:call).never
+      view_output(Date.today).should == false
+    end
+    
+    it "formats with output_method option as method" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats with output_method option as proc" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>lambda {|e| e.chop}}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats output array with output_method option" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with("d,u,d\nm,a")
+      view_output(['dude', 'man'])
+    end
+
+    it "formats with explicit class option" do
+      enable_with_output 'String'=>{:class=>"Blahify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude', :class=>"Commify")
+    end
+    
+    it "formats with explicit options option merges with existing options" do
+      enable_with_output "String"=>{:class=>"Commify", :options=>{:fields=>%w{f1 f2}}}
+      Commify.expects(:render).with('dude', :max_width=>10, :fields=>%w{f1 f2})
+      view_output('dude', :options=>{:max_width=>10})
+    end
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/hirb_test.rb b/vendor/hirb-0.3.5/test/hirb_test.rb
new file mode 100644
index 0000000..58edc95
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/hirb_test.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Hirb" do
+  before_all { Hirb.config_files = nil }
+  before { Hirb.config = nil }
+
+  it "config converts yaml when config file exists" do
+    yaml_data = {:blah=>'blah'}
+    File.stubs('exists?').returns(true)
+    Hirb.config_files = ['ok']
+    YAML::expects(:load_file).returns(yaml_data)
+    Hirb.config.should == yaml_data
+  end
+  
+  it "config defaults to hash when no config file" do
+    File.stubs('exists?').returns(false)
+    Hirb.config.should == {}
+  end
+  
+  it "config reloads if given explicit reload" do
+    Hirb.config
+    Hirb.expects(:read_config_file).returns({})
+    Hirb.config(true)
+  end
+
+  it "config reads multiple config files and merges them" do
+    Hirb.config_files = %w{one two}
+    Hirb.expects(:read_config_file).times(2).returns({:output=>{"String"=>:auto_table}}, {:output=>{"Array"=>:auto_table}})
+    Hirb.config.should == {:output=>{"Array"=>:auto_table, "String"=>:auto_table}}
+    Hirb.config_files = nil
+  end
+
+  it "config_file sets correctly when no ENV['HOME']" do
+    Hirb.config_files = nil
+    home = ENV.delete('HOME')
+    Hirb.config_files[0].class.should == String
+    ENV["HOME"] = home
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/import_test.rb b/vendor/hirb-0.3.5/test/import_test.rb
new file mode 100644
index 0000000..0a75368
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/import_test.rb
@@ -0,0 +1,9 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "import" do
+  it "require import_object extends Object" do
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == false
+    require 'hirb/import_object'
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == true
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/menu_test.rb b/vendor/hirb-0.3.5/test/menu_test.rb
new file mode 100644
index 0000000..d8f57db
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/menu_test.rb
@@ -0,0 +1,239 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Menu" do
+  before_all { View.instance_variable_set("@config", :width=>Hirb::View::DEFAULT_WIDTH) }
+
+  def menu(*args, &block)
+    # testing via menu's main use case (through console) instead of Menu.render
+    @console ||= Object.new.extend(Hirb::Console)
+    @console.menu(*args, &block)
+  end
+
+  def basic_menu(*args, &block)
+    menu_input('1')
+    capture_stdout { menu(*args, &block).should == [1] }
+  end
+
+  def menu_input(input='')
+    $stdin.expects(:gets).returns(input)
+  end
+
+  describe "menu" do
+    it "by default renders table menu" do
+      expected_menu = <<-MENU.unindent
+      +--------+-------+
+      | number | value |
+      +--------+-------+
+      | 1      | 1     |
+      | 2      | 2     |
+      | 3      | 3     |
+      +--------+-------+
+      3 rows in set
+      MENU
+      basic_menu([1,2,3]).include?(expected_menu).should == true
+    end
+
+    it "with block renders" do
+      menu_input "1,2"
+      expected_result = [1,2]
+      capture_stdout { 
+        menu([1,2,3]) {|e| e.should == expected_result }.should == expected_result
+      }
+    end
+
+    it "with block and no chosen doesn't call block" do
+      menu_input ""
+      block = lambda {|e| @called = true }
+      capture_stdout {
+        menu([1,2,3], &block).should == []
+      }
+      assert !@called
+    end
+
+    it "with valid helper_class option renders" do
+      Helpers::Table.expects(:render)
+      basic_menu [1,2,3], :helper_class=>"Hirb::Helpers::Table"
+    end
+
+    it "with invalid helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>"SomeHelper").include?(expected_menu).should == true
+    end
+
+    it "with false helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>false).include?(expected_menu).should == true
+    end
+
+    it "prints prompt option" do
+      prompt = "Input or else ..."
+      basic_menu([1,2,3], :prompt=>prompt).include?(prompt).should == true
+    end
+
+    it "converts non-array inputs to array" do
+      Helpers::AutoTable.expects(:render).with([1], anything)
+      basic_menu 1
+    end
+
+    it "with false ask option returns one choice without asking" do
+      $stdin.expects(:gets).never
+      menu([1], :ask=>false).should == [1]
+    end
+
+    it "with no items to choose from always return without asking" do
+      $stdin.expects(:gets).never
+      menu([], :ask=>false).should == []
+      menu([], :ask=>true).should == []
+    end
+
+    it "with directions option turns off directions" do
+      menu_input('blah')
+      capture_stdout { menu([1], :directions=>false) }.should.not =~ /range.*all/
+    end
+
+    it "with true reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/tty')
+      basic_menu [1], :reopen=>true
+    end
+
+    it "with string reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/blah')
+      basic_menu [1], :reopen=>'/dev/blah'
+    end
+  end
+
+  def two_d_menu(options={})
+    if options[:invokes] || options[:invoke]
+      cmd = options[:command] || 'p'
+      (options[:invokes] || [options[:invoke]]).each {|e|
+        Menu.any_instance.expects(:invoke).with(cmd, e)
+      }
+    end
+
+    capture_stdout {
+      return menu(options[:output] || [{:a=>1, :bro=>2}, {:a=>3, :bro=>4}],
+       {:two_d=>true}.merge(options))
+    }
+  end
+
+  describe "2d menu" do
+    it "with default field from last_table renders" do
+      menu_input "1"
+      two_d_menu.should == [1]
+    end
+
+    it "with default field from fields option renders" do
+      menu_input "1"
+      two_d_menu(:fields=>[:bro, :a]).should == [2]
+    end
+
+    it "with default field option renders" do
+      menu_input "1"
+      two_d_menu(:default_field=>:bro).should == [2]
+    end
+
+    it "with non-table helper class renders" do
+      menu_input "1"
+      two_d_menu(:helper_class=>false, :fields=>[:a,:bro]).should == [1]
+    end
+
+    it "with no default field prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:fields=>[]) }.should =~ /No default.*found/
+    end
+
+    it "with invalid field prints error" do
+      menu_input "1:z"
+      capture_stderr { two_d_menu }.should =~ /Invalid.*'z'/
+    end
+
+    it "with choice from abbreviated field" do
+      menu_input "2:b"
+      two_d_menu.should == [4]
+    end
+
+    it "with choices from multiple fields renders" do
+      menu_input "1 2:bro"
+      two_d_menu.should == [1,4]
+    end
+  end
+
+  describe "action menu" do
+    it "invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :invoke=>[[1,4]])
+    end
+
+    it "with 1d invokes" do
+      menu_input "p 1"
+      two_d_menu(:action=>true, :two_d=>nil, :invoke=>[[{:a=>1, :bro=>2}]])
+    end
+
+    it "with non-choice arguments invokes" do
+      menu_input "p arg1 1"
+      two_d_menu :action=>true, :invoke=>['arg1', [1]]
+    end
+
+    it "with multiple choice arguments flattens them into arg" do
+      menu_input "p arg1 1 2:bro arg2"
+      two_d_menu :action=>true, :invoke=>['arg1', [1,4], 'arg2']
+    end
+
+    it "with nothing chosen prints error" do
+      menu_input "cmd"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No rows chosen/
+    end
+
+    it "with no command given prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No command given/
+    end
+
+    it "with array menu items" do
+      menu_input "p 1"
+      two_d_menu :action=>true, :output=>[['some', 'choice'], ['and', 'another']],
+        :invokes=>[[['some']]]
+    end
+
+    it "with multi_action option invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :multi_action=>true, :invokes=>[[1], [4]])
+    end
+
+    it "with command option invokes" do
+      menu_input "1"
+      two_d_menu(:action=>true, :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with command option and empty input doesn't invoke action and exists silently" do
+      Menu.any_instance.expects(:invoke).never
+      menu_input ""
+      two_d_menu(:action=>true, :command=>'p').should == nil
+    end
+
+    it "with action_object option invokes" do
+      obj = mock(:blah=>true)
+      menu_input "blah 1"
+      two_d_menu(:action=>true, :action_object=>obj)
+    end
+
+    it "with ask false and defaults invokes" do
+      two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :default_field=>:a,
+        :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with ask false and no defaults prints error" do
+      capture_stderr {
+        two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :command=>'p')
+      }.should =~ /Default.*required/
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/object_table_test.rb b/vendor/hirb-0.3.5/test/object_table_test.rb
new file mode 100644
index 0000000..c0ef8f2
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/object_table_test.rb
@@ -0,0 +1,79 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "object table" do
+  def table(*args)
+    Helpers::ObjectTable.render(*args)
+  end
+
+  before_all {
+    @pets = [stub(:name=>'rufus', :age=>7, :to_s=>'rufus'), stub(:name=>'alf', :age=>101, :to_s=>'alf')]
+  }
+  it "renders" do
+    expected_table = <<-TABLE.unindent
+    +-------+-----+
+    | name  | age |
+    +-------+-----+
+    | rufus | 7   |
+    | alf   | 101 |
+    +-------+-----+
+    2 rows in set
+    TABLE
+    table(@pets, :fields=>[:name, :age]).should == expected_table
+  end
+  
+  it "with no options defaults to to_s field" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | rufus |
+    | alf   |
+    +-------+
+    2 rows in set
+    TABLE
+    table(@pets).should == expected_table
+  end
+
+  it "renders simple arrays" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    | 4     |
+    +-------+
+    4 rows in set
+    TABLE
+    table([1,2,3,4]).should == expected_table
+  end
+
+  it "renders simple arrays with custom header" do
+    expected_table = <<-TABLE.unindent
+    +-----+
+    | num |
+    +-----+
+    | 1   |
+    | 2   |
+    | 3   |
+    | 4   |
+    +-----+
+    4 rows in set
+    TABLE
+    table([1,2,3,4], :headers=>{:to_s=>'num'}).should == expected_table
+  end
+
+  it "with empty fields" do
+    expected_table = <<-TABLE.unindent
+    0 rows in set
+    TABLE
+    table(@pets, :fields => []).should == expected_table
+  end
+
+  it "doesn't raise error for objects that don't have :send defined" do
+    object = Object.new
+    class<<object; self; end.send :undef_method, :send
+    should.not.raise(NoMethodError) { table([object], :fields=>[:to_s]) }
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/pager_test.rb b/vendor/hirb-0.3.5/test/pager_test.rb
new file mode 100644
index 0000000..4878e12
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/pager_test.rb
@@ -0,0 +1,162 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Pager" do
+  def pager; View.pager; end
+
+  def create_pageable_string(inspect_mode=false, size={})
+    size = {:width=>pager.width, :height=>pager.height}.merge(size)
+    seed = inspect_mode ? "a" : "a\n"
+    if inspect_mode
+      seed * (size[:width] * size[:height] + 1)
+    else
+      seed * (size[:height] + 1)
+    end
+  end
+
+  it "command_pager sets pager_command when command exists" do
+    Util.expects(:command_exists?).returns(true)
+    Pager.expects(:basic_pager)
+    Pager.command_pager 'blah', :pager_command=>'less'
+  end
+
+  it "command_pager doesn't set pager_command when command doesn't exist" do
+    Util.expects(:command_exists?).returns(false)
+    Pager.expects(:basic_pager).never
+    Pager.command_pager 'blah', :pager_command=>'moreless'
+  end
+
+  describe "default_pager" do
+    before_all { reset_config; Hirb.enable :pager=>true }
+    before { View.pager = nil; Pager.stubs(:pager_command).returns(nil) }
+
+    it "pages once in normal mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string, false) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in normal mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a\n", false) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+
+    it "pages once in inspect mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string(true), true) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in inspect mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a", true) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+    after_all { Hirb.disable }
+  end
+
+  describe "pager" do
+    before_all { reset_config; Hirb.enable }
+    before { View.pager = nil; View.formatter = nil }
+
+    def irb_eval(string)
+      context_stub = stub(:last_value=>string)
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    # this mode is called within @irb.output_value
+    describe "in inspect_mode" do
+      it "activates when output is wide enough" do
+        output = create_pageable_string(true)
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "doesn't activate when output isn't wide enough" do
+        pager.expects(:page).never
+        View.expects(:render_output).returns(false)
+        irb_eval("a")
+      end
+
+      it "activates with an explicit width" do
+        View.config[:width] = 10
+        output = create_pageable_string true, :width=>10
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "activates default_pager when pager command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string(true)
+        Pager.expects(:default_pager).with(output.inspect, anything)
+        View.expects(:render_output).returns(false)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    # this mode is called within View.render_output
+    describe "in normal mode" do
+      it "activates when output is long enough" do
+        output = create_pageable_string
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "doesn't activate when output isn't long enough" do
+        output = "a\n"
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).never
+        capture_stdout { irb_eval(output) }
+      end
+
+      it "activates with an explicit height" do
+        View.config[:height] = 100
+        output = create_pageable_string false, :height=>100
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "activates default_pager when pager_command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string
+        Pager.expects(:default_pager).with(output, anything)
+        View.formatter.expects(:format_output).returns(output)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    it "activates pager_command with valid pager_command option" do
+      View.config[:pager_command] = "less"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "activates pager_command with pager_command option that has command options" do
+      View.config[:pager_command] = "less -r"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).with('less').returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "doesn't activate pager_command with invalid pager_command option" do
+      View.config[:pager_command] = "moreless"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(false)
+      Pager.expects(:default_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+  end
+  after_all { Hirb.disable }
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/resizer_test.rb b/vendor/hirb-0.3.5/test/resizer_test.rb
new file mode 100644
index 0000000..55160a7
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/resizer_test.rb
@@ -0,0 +1,62 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Resizer" do
+  def table(options)
+    @table = Helpers::Table.new [options[:field_lengths].keys.inject({}) {|t,e| t[e] = '1'; t}]
+    @table.field_lengths = options[:field_lengths]
+    @table.width = options[:width]
+    @table.max_fields = options[:max_fields] if options[:max_fields]
+    @width, @field_lengths = @table.width, @table.field_lengths
+    @table
+  end
+
+  it "resize ensures columns total doesn't exceed max width" do
+    table :field_lengths=>{:f1=>135, :f2=>45, :f3=>4, :f4=>55}, :width=>195
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+  end
+
+  it "resize sets columns by relative lengths" do
+    table :field_lengths=>{:a=>30, :b=>30, :c=>40}, :width=>60
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.uniq.size.should.not == 1
+  end
+
+  it "resize sets all columns roughly equal when adusting long fields don't work" do
+    table :field_lengths=>{:field1=>10, :field2=>15, :field3=>100}, :width=>20
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.each {|e| e.should <= 4 }
+  end
+
+  describe "add_extra_width and max_fields" do
+    def table_and_resize(options={})
+      defaults = {:field_lengths=>{:f1=>135, :f2=>30, :f3=>4, :f4=>100}, :width=>195, :max_fields=>{:f1=>80, :f4=>30} }
+      @table = table defaults.merge(options)
+      # repeated from table since instance variables aren't copied b/n contexts
+      @width, @field_lengths = @table.width, @table.field_lengths
+      Helpers::Table::Resizer.resize! @table
+    end
+
+    it "doesn't add to already maxed out field" do
+      table_and_resize
+      @field_lengths[:f3].should == 4
+    end
+
+    it "restricted before adding width" do
+      table_and_resize
+      @field_lengths[:f4].should <= 30
+    end
+
+    it "adds to restricted field" do
+      table_and_resize
+      @field_lengths[:f1].should <= 80
+    end
+
+    it "adds to unrestricted field" do
+      table_and_resize :field_lengths=>{:f1=>135, :f2=>70, :f3=>4, :f4=>100}
+      @field_lengths[:f2].should == 70
+    end
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/table_test.rb b/vendor/hirb-0.3.5/test/table_test.rb
new file mode 100644
index 0000000..1247a42
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/table_test.rb
@@ -0,0 +1,550 @@
+# encoding: UTF-8
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Table" do
+  def table(*args)
+    Helpers::Table.render(*args)
+  end
+  before_all { reset_config }
+  
+  describe "basic table" do
+    it "renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}]).should == expected_table
+    end
+    
+    it "with no headers renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 | 2 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>2}], :headers=>false).should == expected_table
+    end
+
+    it "with no headers and nil fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 |   |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>nil}], :headers=>false).should == expected_table
+    end
+
+    it "with string keys renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}]).should == expected_table
+    end
+
+    it "with array only rows renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]]).should == expected_table
+    end
+
+    it "with too many fields defaults to vertical table" do
+      rows = [Array.new(25, "A"* 10)]
+      Helpers::VerticalTable.expects(:render).with(rows, anything)
+      capture_stderr { table(rows)}.should =~ /Error/
+    end
+
+    it "with no rows renders" do
+      table([]).should == "0 rows in set"
+    end
+
+    it "with invalid rows raises an argumenterror" do
+      lambda { table(:a=>1) }.should.raise(ArgumentError).message.should =~ /Table must/
+    end
+
+    it "renders utf8" do
+      expected_table = <<-TABLE.unindent
+      +--------------------+
+      | name               |
+      +--------------------+
+      |             |
+      |        |
+      | Tata l'asticote    |
+      | toto ltoile PAOLI |
+      +--------------------+
+      4 rows in set
+      TABLE
+      table([{:name=>""}, {:name=>""}, {:name=>"Tata l'asticote"}, {:name=>"toto ltoile PAOLI"}]).should == expected_table
+    end
+
+    it "stringifies newlines and tabs and renders" do
+      expected_table = <<-TABLE.unindent
+      +-----+---+
+      | a   | b |
+      +-----+---+
+      | 1#{'\n'} | 2 |
+      | 3#{'\t'} | 4 |
+      +-----+---+
+      2 rows in set
+      TABLE
+      value = [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+      table(value).should == expected_table
+      value.should == [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+    end
+
+    it "with a field of only array values renders values comma joined" do
+      expected_table = <<-TABLE.unindent
+      +----+------+
+      | a  | b    |
+      +----+------+
+      | 1  | 1, 2 |
+      | ok | 3, 4 |
+      +----+------+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>[1,2]}, {:a=>'ok', :b=>[3,4]}]).should == expected_table
+    end
+
+    it "with filter class default doesn't override explicit filters" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | a    | 1     |
+      +------+-------+
+      1 row in set
+      TABLE
+      table([{:name=>'a', :value=>{:b=>1}}], :filters=>{:value=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with" do
+    it "fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | a |
+      +---+---+
+      | 2 | 1 |
+      | 4 | 3 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :a]).should == expected_table
+    end
+    
+    it "fields option and array only rows" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 2 |
+      +---+---+
+      | 1 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([[1,2,3]], :fields=>[0,2]).should == expected_table
+    end
+
+    it "fields and number options copies fields option and does not modify it" do
+      options = {:fields=>[:f1], :number=>true}
+      table([{:f1=>1, :f2=>2}], options)
+      options[:fields].should == [:f1]
+    end
+  
+    it "invalid fields option renders empty columns" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | c |
+      +---+---+
+      | 2 |   |
+      | 4 |   |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :c]).should == expected_table
+    end
+  
+    it "invalid field in max_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10,:c=>10}).should == expected_table
+    end
+  
+    it "max_fields option with fields less than 3 characters renders" do
+      expected_table = <<-TABLE.unindent
+      +----+---+
+      | a  | b |
+      +----+---+
+      | AA | 2 |
+      +----+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>2}, :resize=>false).should == expected_table
+    end
+  
+    it "max_fields option without resize renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10}, :resize=>false).should == expected_table
+    end
+
+    it "max_fields option with percentage renders" do
+      expected_table = <<-TABLE.unindent
+      +------------------+---+
+      | a                | b |
+      +------------------+---+
+      | AAAAAAAAAAAAA... | 2 |
+      +------------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>'0.15'}).should == expected_table
+    end
+  
+    it "max_width option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :max_width=>30).should == expected_table
+    end
+
+    it "resize option false renders full table" do
+      expected_table = <<-TABLE.unindent
+      +----------------------------------------------------+---+------------+
+      | a                                                  | b | c          |
+      +----------------------------------------------------+---+------------+
+      | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | 2 | CCCCCCCCCC |
+      +----------------------------------------------------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :resize=>false).should == expected_table
+    end
+    
+    it "global width renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      View.load_config
+      View.resize(30)
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}]).should == expected_table
+      reset_config
+    end
+
+    it "headers option and headers longer than fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---------+---------+
+      | a | field B | field C |
+      +---+---------+---------+
+      | A | 2       | C       |
+      +---+---------+---------+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2, :c=>"C"}], :headers=>{:b=>"field B", :c=>"field C"}).should == expected_table
+    end
+  
+    it "headers option and headers shortened by max_fields renders" do
+      expected_table = <<-TABLE.unindent
+      +-------+---+
+      | fi... | b |
+      +-------+---+
+      | A     | 2 |
+      +-------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2}], :headers=>{:a=>"field A"}, :max_fields=>{:a=>5}, :resize=>false).should == expected_table
+    end
+    
+    it "headers option as an array renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]], :headers=>['A', 'B']).should == expected_table
+    end
+
+    it "header_filter option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 2 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=> 2, :b=>3}], :header_filter=>:capitalize).should == expected_table
+    end
+
+    it "filters option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+
+      | 0         | 1 |
+      +-----------+---+
+      | s,o,m,e   | 2 |
+      | t,h,i,n,g | 1 |
+      +-----------+---+
+      2 rows in set
+      TABLE
+      table([['some', {:num=>2}], ['thing', {:num=>1}]], :filters=>{0=>lambda {|e| e.split("").join(",")},
+        1=>[:[], :num]}).should == expected_table
+    end
+
+    it "filters option calls Filters method and renders" do
+      module ::Hirb::Helpers::Table::Filters
+        def semicolon_join(arr); arr.join('; '); end
+      end
+
+      expected_table = <<-TABLE.unindent
+      +------+------------------------------+
+      | 0    | 1                            |
+      +------+------------------------------+
+      | some | unsightly; unreadable; array |
+      +------+------------------------------+
+      1 row in set
+      TABLE
+      table([[['some'], %w{unsightly unreadable array}]], :filters=>{1=>:semicolon_join}).should == expected_table
+    end
+
+    it "number option renders" do
+      expected_table = <<-TABLE.unindent
+      +--------+---+---+
+      | number | 0 | 1 |
+      +--------+---+---+
+      | 1      | a | b |
+      | 2      | c | d |
+      +--------+---+---+
+      2 rows in set
+      TABLE
+      table([['a','b'], ['c', 'd']], :number=>true).should == expected_table
+    end
+
+    it "description option false renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | a | b |
+      | c | d |
+      +---+---+
+      TABLE
+      table([['a','b'], ['c', 'd']], :description=>false).should == expected_table
+    end
+
+    it "vertical option renders vertical table" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table with newlines" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      and one
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>"4\nand one"}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table successively" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      options = {:vertical=>true}
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+    end
+
+    it "hide_empty and vertical options renders" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      b: 2
+      *** 2. row ***
+      a: 3
+      2 rows in set
+      TABLE
+      table([{:a=>'', :b=>2}, {:a=>3, :b=>nil}], :hide_empty=>true, :vertical=>true).should == expected_table
+    end
+
+    it "all_fields option renders all fields" do
+      expected_table = <<-TABLE.unindent
+      +---+---+---+
+      | a | b | c |
+      +---+---+---+
+      | 1 | 2 |   |
+      | 3 |   | 4 |
+      +---+---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :c=>4}], :all_fields=>true).should == expected_table
+    end
+
+    it "change_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>{0=>'name', 1=>'value'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value']).should == expected_table
+    end
+
+    it "change_fields and fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+
+      | name |
+      +------+
+      | 1    |
+      | 2    |
+      +------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>['name', 'value'], :fields=>['name']).should == expected_table
+    end
+
+    it "invalid fields in change_fields options are ignored" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([{:a=>1,:b=>2}, {:a=>2,:b=>3}], :change_fields=>{:a=>'name', :b=>'value', :c=>'time'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value','time']).should == expected_table
+    end
+
+    it "filter_any option filters any value" do
+      expected_table = <<-TABLE.unindent
+      +---------+
+      | a       |
+      +---------+
+      | {:b=>1} |
+      | 2       |
+      +---------+
+      2 rows in set
+      TABLE
+      table([{:a=>{:b=>1}}, {:a=>2}], :filter_any=>true).should == expected_table
+    end
+
+    it "filter_classes option overrides class-wide filter_classes" do
+      expected_table = <<-TABLE.unindent
+      +---+
+      | a |
+      +---+
+      | 1 |
+      +---+
+      1 row in set
+      TABLE
+      table([{:a=>{:b=>1}}], :filter_classes=>{Hash=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with callbacks" do
+    before_all {
+      Helpers::Table.send(:define_method, :and_one_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] += opt[:add] } }
+        obj
+      end
+    }
+    it "detects and runs them" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1).should == expected_table
+    end
+
+    it "doesn't run callbacks in delete_callbacks option" do
+      Helpers::Table.send(:define_method, :and_two_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] = row[k] * 2 } }
+        obj
+      end
+
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1, :delete_callbacks=>[:and_two]).should == expected_table
+
+      Helpers::Table.send(:remove_method, :and_two_callback)
+    end
+    after_all { Helpers::Table.send(:remove_method, :and_one_callback) }
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/test_helper.rb b/vendor/hirb-0.3.5/test/test_helper.rb
new file mode 100644
index 0000000..4706d0a
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/test_helper.rb
@@ -0,0 +1,61 @@
+require 'bacon'
+require 'bacon/bits'
+require 'mocha'
+require 'mocha-on-bacon'
+require 'hirb'
+include Hirb
+
+module TestHelpers
+  # set these to avoid invoking stty multiple times which doubles test suite running time
+  ENV["LINES"] = ENV["COLUMNS"] = "20"
+  def reset_terminal_size
+    ENV["LINES"] = ENV["COLUMNS"] = "20"
+  end
+
+  def capture_stdout(&block)
+    original_stdout = $stdout
+    $stdout = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stdout = original_stdout
+    end
+    fake.string
+  end
+
+  def capture_stderr(&block)
+    original_stderr = $stderr
+    $stderr = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stderr = original_stderr
+    end
+    fake.string
+  end
+
+  def reset_config
+    View.instance_eval "@config = nil"
+  end
+end
+
+class Bacon::Context
+  include TestHelpers
+end
+
+class String
+  def unindent(num=nil)
+    regex = num ? /^\s{#{num}}/ : /^\s*/
+    gsub(regex, '').chomp
+  end
+end
+
+# mocks IRB for View + Pager
+module ::IRB
+  class Irb
+    def initialize(context)
+      @context = context
+    end
+    def output_value; end
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/tree_test.rb b/vendor/hirb-0.3.5/test/tree_test.rb
new file mode 100644
index 0000000..cd046ef
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/tree_test.rb
@@ -0,0 +1,184 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Tree helpers:" do
+  def tree(*args)
+    Helpers::Tree.render(*args)
+  end
+  
+  describe "basic tree" do
+    it "with hash nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([{:level=>0, :value=>'0.0'}, {:level=>1, :value=>'1.1'}, {:level=>2, :value=>'2.2'},{:level=>2, :value=>'3.2'},
+         {:level=>1, :value=>'4.1'}]).should == expected_tree
+    end
+  
+    it "with array nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]]).should == expected_tree
+    end
+    
+    it "with non-string values renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0,0.0],[1,1.1],[2,2.2],[2,3.2],[1,4.1]]).should == expected_tree
+    end
+
+    it "with indent option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+        1.1
+          2.2
+          3.2
+        4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :indent=>2).should == expected_tree
+    end
+
+    it "with limit option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :limit=>1).should == expected_tree
+    end
+
+    it "with description option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      
+      5 nodes in tree
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :description=>true).should == expected_tree
+    end
+
+    it "with type directory renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :type=>:directory).should == expected_tree
+    end
+
+    it "with type directory and multiple children per level renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   |   `-- 3.3
+      |   `-- 4.2
+      |       `-- 5.3
+      `-- 6.1
+      TREE
+      tree([[0,'0.0'], [1,'1.1'], [2,'2.2'],[3,'3.3'],[2,'4.2'],[3,'5.3'],[1,'6.1']], :type=>:directory).should == expected_tree
+    end
+
+    it "with type number renders" do
+      expected_tree = <<-TREE.unindent(6)
+      1. 0
+          1. 1
+              1. 2
+              2. 3
+          2. 4
+      TREE
+      tree([[0,'0'],[1,'1'],[2,'2'],[2,'3'],[1,'4']], :type=>:number).should == expected_tree
+    end
+
+    it "with multi-line nodes option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      parent
+          +-------+
+          | value |
+          +-------+
+          | 1     |
+          | 2     |
+          | 3     |
+          +-------+
+              indented
+              stuff
+      TREE
+      node1 = "+-------+\n| value |\n+-------+\n| 1     |\n| 2     |\n| 3     |\n+-------+"
+      tree([ [0, 'parent'],[1, node1],[2, "indented\nstuff"]], :multi_line_nodes=>true).should == expected_tree
+    end
+  end
+
+  def mock_node(value, value_method)
+    children = []
+    value,children = *value if value.is_a?(Array)
+    mock(value_method=>value, :children=>children.map {|e| mock_node(e, value_method)})
+  end
+
+  describe "parent_child_tree" do
+    it "with name value renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :name)
+      Helpers::ParentChildTree.render(root, :type=>:directory).should == expected_tree
+    end
+    
+    it "with value_method option renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :blah)
+      Helpers::ParentChildTree.render(root, :type=>:directory, :value_method=>:blah).should == expected_tree
+    end
+
+    it "with children_method proc option renders" do
+      expected_tree = <<-TREE.unindent
+      1
+      |-- 2
+      |-- 3
+      |-- 4
+      `-- 5
+      TREE
+      Helpers::ParentChildTree.render(1, :type=>:directory,
+        :children_method=>lambda {|e| e == 1 ? (2..5).to_a : []}, :value_method=>:to_s).should == expected_tree
+    end
+  end
+
+  it "tree with parentless nodes renders ParentlessNodeError" do
+    lambda { tree([[0, "0.0"], [2, '1.2']], :validate=>true) }.should.raise(Helpers::Tree::ParentlessNodeError)
+  end
+  
+  it "tree with hash nodes missing level raises MissingLevelError" do
+    lambda { tree([{:value=>'ok'}]) }.should.raise(Helpers::Tree::Node::MissingLevelError)
+  end
+
+  it "tree with hash nodes missing level raises MissingValueError" do
+    lambda { tree([{:level=>0}]) }.should.raise(Helpers::Tree::Node::MissingValueError)
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/util_test.rb b/vendor/hirb-0.3.5/test/util_test.rb
new file mode 100644
index 0000000..faadd5d
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/util_test.rb
@@ -0,0 +1,59 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Util" do
+  it "camelize converts underscore lowercase to camelcase" do
+    Util.camelize('hirb/util').should == "Hirb::Util"
+    Util.camelize('hirb_hash').should == "HirbHash"
+  end
+
+  it "any_const_get returns nested class" do
+    Util.any_const_get("YAML::BaseNode").should == ::YAML::BaseNode
+  end
+
+  it "any_const_get returns nil for invalid class" do
+    Util.any_const_get("Basdfr").should == nil
+  end
+
+  it "any_const_get returns class when given class" do
+    Util.any_const_get(String).should == String
+  end
+
+  it "recursive_hash_merge merges" do
+    expected_hash = {:output=>{:fields=>["f1", "f2"], :method=>"blah"}, :key1=>"hash1", :key2=>"hash2"}
+    Util.recursive_hash_merge({:output=>{:fields=>%w{f1 f2}}, :key1=>'hash1'},
+      {:output=>{:method=>'blah'}, :key2=>'hash2'}).should == expected_hash
+  end
+
+  it "choose_from_array specifies range with -" do
+    Util.choose_from_array([1,2,3,4], '1-2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array specifies range with .." do
+    Util.choose_from_array([1,2,3,4], '1 .. 2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array chooses all with *" do
+    Util.choose_from_array([1,2,3,4], '*').should == [1,2,3,4]
+  end
+
+  it "choose_from_array ignores non-numerical input" do
+    Util.choose_from_array([1,2,3,4], 'a,2').should == [2]
+  end
+
+  it "choose_from_array ignores 0" do
+    Util.choose_from_array([1,2,3,4], '0,2').should == [2]
+  end
+
+  it "choose_from_array returns empty when empty input" do
+    Util.choose_from_array([1,2,3,4], "\n").should == []
+  end
+
+  it "choose_from_array returns empty with an invalid range" do
+    Util.choose_from_array([1,2,3,4], "5").should == []
+  end
+
+  it "capture_stdout" do
+    string = "sweetness man"
+    Util.capture_stdout { puts string }.should == string + "\n"
+  end
+end
\ No newline at end of file
diff --git a/vendor/hirb-0.3.5/test/view_test.rb b/vendor/hirb-0.3.5/test/view_test.rb
new file mode 100644
index 0000000..4d611a0
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/view_test.rb
@@ -0,0 +1,165 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "View" do
+  def formatter_config
+    View.formatter.config
+  end
+  
+  it "page_output pages when view is enabled" do
+    Hirb.enable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page)
+    View.page_output('blah').should == true
+    Hirb.disable
+  end
+
+  it "page_output doesn't page when view is disabled" do
+    Hirb.enable
+    Hirb.disable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page).never
+    View.page_output('blah').should == false
+  end
+
+  it "view_output catches unexpected errors and prints them" do
+    reset_config
+    Hirb.enable
+    View.expects(:render_output).raises('blah')
+    capture_stderr { View.view_output([1,2,3]) }.should =~ /Hirb Error: blah/
+    Hirb.disable
+  end
+
+  describe "enable" do
+    before { reset_config }
+    after { Hirb.disable }
+    it "redefines irb output_value" do
+      View.expects(:render_output).once
+      Hirb.enable
+      context_stub = stub(:last_value=>'')
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    it "is enabled?" do
+      Hirb.enable
+      View.enabled?.should == true
+    end
+
+    def output_class_config(klass)
+      { :output=>{klass=>{:class=>:auto_table}} }
+    end
+
+    it "sets formatter config" do
+      class_hash = {"Something::Base"=>{:class=>"BlahBlah"}}
+      Hirb.enable :output=>class_hash
+      View.formatter_config['Something::Base'].should == class_hash['Something::Base']
+    end
+
+    it "when called multiple times merges configs" do
+      Hirb.config = nil
+      # default config + config_file
+      Hirb.expects(:read_config_file).returns(output_class_config('Regexp'))
+      Hirb.enable output_class_config('String')
+
+      # add config file and explicit config
+      [{:config_file=>'ok'}, output_class_config('Struct')].each do |config|
+        Hirb.expects(:read_config_file).times(2).returns(
+          output_class_config('ActiveRecord::Base'), output_class_config('Array'))
+        Hirb.enable config
+      end
+
+      Hirb.config_files.include?('ok').should == true
+      output_keys = %w{ActiveRecord::Base Array Regexp String Struct}
+      View.config[:output].keys.sort.should == output_keys
+    end
+
+    it "when called multiple times without config doesn't affect config" do
+      Hirb.enable
+      old_config = View.config
+      Hirb.expects(:read_config_file).never
+      View.expects(:load_config).never
+      Hirb.enable
+      View.config.should == old_config
+    end
+
+    it "works without irb" do
+      Object.stubs(:const_defined?).with(:IRB).returns(false)
+      Hirb.enable
+      formatter_config.size.should.be > 0
+    end
+
+    it "with config_file option adds to config_file" do
+      Hirb.enable :config_file=> 'test_file'
+      Hirb.config_files.include?('test_file').should == true
+    end
+
+    it "with ignore_errors enable option" do
+      Hirb.enable :ignore_errors => true
+      View.stubs(:render_output).raises(Exception, "Ex mesg")
+      capture_stderr { View.view_output("").should == false }.should =~ /Error: Ex mesg/
+    end
+  end
+
+  describe "resize" do
+    def pager; View.pager; end
+    before { View.pager = nil; reset_config; Hirb.enable }
+    after { Hirb.disable}
+    it "changes width and height with stty" do
+      Util.expects(:command_exists?).with('stty').returns(true)
+      ENV['COLUMNS'] = ENV['LINES'] = nil # bypasses env usage
+      View.resize
+      pager.width.should.not == 10
+      pager.height.should.not == 10
+      reset_terminal_size
+    end
+
+    it "changes width and height with ENV" do
+      ENV['COLUMNS'] = ENV['LINES'] = '10' # simulates resizing
+      View.resize
+      pager.width.should == 10
+      pager.height.should == 10
+    end
+
+    it "with no environment or stty still has valid width and height" do
+      View.config[:width] = View.config[:height] = nil
+      Util.expects(:command_exists?).with('stty').returns(false)
+      ENV['COLUMNS'] = ENV['LINES'] = nil
+      View.resize
+      pager.width.is_a?(Integer).should == true
+      pager.height.is_a?(Integer).should == true
+      reset_terminal_size
+    end
+  end
+
+  it "disable points output_value back to original output_value" do
+    View.expects(:render_output).never
+    Hirb.enable
+    Hirb.disable
+    context_stub = stub(:last_value=>'')
+    ::IRB::Irb.new(context_stub).output_value
+  end
+
+  it "disable works without irb defined" do
+    Object.stubs(:const_defined?).with(:IRB).returns(false)
+    Hirb.enable
+    Hirb.disable
+    View.enabled?.should == false
+  end
+
+  it "capture_and_render" do
+    string = 'no waaaay'
+    View.render_method.expects(:call).with(string)
+    View.capture_and_render { print string }
+  end
+  
+  it "state is toggled by toggle_pager" do
+    previous_state = View.config[:pager]
+    View.toggle_pager
+    View.config[:pager].should == !previous_state
+  end
+  
+  it "state is toggled by toggle_formatter" do
+    previous_state = View.config[:formatter]
+    View.toggle_formatter
+    View.config[:formatter].should == !previous_state
+  end
+end
diff --git a/vendor/hirb-0.3.5/test/views_test.rb b/vendor/hirb-0.3.5/test/views_test.rb
new file mode 100644
index 0000000..1aeb641
--- /dev/null
+++ b/vendor/hirb-0.3.5/test/views_test.rb
@@ -0,0 +1,13 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "activerecord table" do
+  it "with no select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{"name"=>'rufus', 'age'=>7}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:age, :name]}
+  end
+
+  it "with select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{'name'=>'rufus'}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:name]}
+  end
+end
\ No newline at end of file
