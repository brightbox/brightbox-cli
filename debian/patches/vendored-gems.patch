diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/Gemfile b/lib/brightbox-cli/vendor/excon-0.6.6/Gemfile
new file mode 100644
index 0000000..4f71f9c
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/Gemfile
@@ -0,0 +1,14 @@
+source "http://rubygems.org"
+
+gemspec
+
+group :benchmark do
+  gem 'em-http-request'
+  gem 'httparty'
+  gem 'rest-client'
+  gem 'tach'
+  gem 'typhoeus'
+  gem 'sinatra'
+  gem 'streamly_ffi'
+  gem 'curb'
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/README.rdoc b/lib/brightbox-cli/vendor/excon-0.6.6/README.rdoc
new file mode 100644
index 0000000..12a8924
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/README.rdoc
@@ -0,0 +1,130 @@
+= excon
+
+Http(s) EXtended CONnections
+
+== Getting Started
+
+Install the gem.
+
+  $ sudo gem install excon
+
+Require with rubygems.
+
+  require 'rubygems'
+  require 'excon'
+
+The simplest way to use excon is with one-off requests:
+
+  response = Excon.get('http://geemus.com')
+
+Supported one-off request methods are #connect, #delete, #get, #head, #options, #post, #put, and #trace. 
+
+The returned response object has #body, #headers and #status attributes. 
+
+Alternately you can create a connection object which is reusable across multiple requests (more performant!).
+
+  connection = Excon.new('http://geemus.com')
+  response_one = connection.get
+  response_two = connection.post(:path => '/foo')
+  response_three = connection.delete(:path => '/bar')
+  
+Sometimes it is more convenient to specify the request type as an argument:
+
+  response_four = connection.request(:method => :get, :path => '/more')
+
+Both one-off and persistent connections support many other options. Here are a few common examples:
+
+  # Custom headers
+  Excon.get('http://geemus.com', :headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  connection.get(:headers => {'Authorization' => 'Basic 0123456789ABCDEF'})
+  
+  # Changing query strings
+  connection = Excon.new('http://geemus.com/')
+  connection.get(:query => {:foo => 'bar'})
+  
+  # POST body
+  Excon.post('http://geemus.com', :body => 'language=ruby&class=fog')
+  
+  # request accepts either symbols or strings
+  connection.request(:method => :get)
+  connection.request(:method => 'GET')
+
+These options can be combined to make pretty much any request you might need.
+
+== Streaming Responses
+
+You can stream responses by passing a block that will receive each chunk.
+
+  Excon.get('http://geemus.com') do |chunk, remaining_bytes, total_bytes|
+    puts chunk
+    puts "Remaining: #{remaining_bytes.to_f / total_bytes}%"
+  end
+  
+Iterating over each chunk will allow you to do work on the response incrementally without buffering the entire response first. For very large responses this can lead to significant memory savings.
+
+== Proxy Support
+
+You can specify a proxy URL that Excon will use with both HTTP and HTTPS connections:
+
+  connection = Excon.new('http://geemus.com', :proxy => 'http://my.proxy:3128')
+  connection.request(:method => 'GET')
+
+The proxy URL must be fully specified, including scheme (e.g. "http://") and port.
+
+Excon will also use the environment variables "http_proxy" and "https_proxy" if they are present. 
+
+If "https_proxy" is not set, the value of "http_proxy" will be used for both HTTP and HTTPS connections.
+
+NOTE: Environment variables will take precedence over a :proxy option that has been specified in code.
+
+== Stubs
+
+You can stub out requests for testing purposes by enabling mock mode on a connection.
+
+  Excon.mock = true
+
+Then you can add stubs, for instance:
+
+  # Excon.stub(request_attributes, response_attributes)
+  Excon.stub({:method => :get}, {:body => 'body', :status => 200})
+
+Omitted attributes are assumed to match, so this stub will match any get request and return an Excon::Response with a body of 'body' and status of 200.  You can add whatever stubs you might like this way and they will be checked against in the order they were added, if none of them match then excon will raise an error to let you know.
+
+== HTTPS/SSL Issues
+
+By default excon will try to verify peer certificates when using SSL for HTTPS. Unfortunately on some operating systems the defaults will not work. This will likely manifest itself as something like "Excon::Errors::SocketError: SSL_connect returned=1 ..."
+
+If you have the misfortune of running into this problem you have a couple options. If you have certificates but they aren't being auto-discovered, you can specify the path to your certificates:
+
+  Excon.ssl_ca_path = '/path/to/certs'
+
+Failing that, you can turn off peer verification (less secure):
+
+  Excon.ssl_verify_peer = false
+
+Either of these should allow you to work around the socket error and continue with your work.
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2010-2011 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/Rakefile b/lib/brightbox-cli/vendor/excon-0.6.6/Rakefile
new file mode 100644
index 0000000..c897e47
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/Rakefile
@@ -0,0 +1,143 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}/constants.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+require 'shindo/rake'
+Shindo::Rake.new
+
+task :default => :tests
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov tests/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/class_vs_lambda.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/class_vs_lambda.rb
new file mode 100644
index 0000000..6f902ee
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/class_vs_lambda.rb
@@ -0,0 +1,50 @@
+require 'rubygems'
+require 'tach'
+
+class Concatenator
+  def initialize(string)
+    @string = string
+  end
+
+  def call(data)
+    @string << data
+  end
+end
+
+string = "0123456789ABCDEF"
+
+Tach.meter(100_000) do
+  tach('class') do
+    s = ""
+    obj = Concatenator.new(s)
+    10.times { obj.call(string) }
+  end
+
+  tach('lambda') do
+    s = ""
+    obj = lambda {|data| s << data }
+    10.times { obj.call(string) }
+  end
+end
+
+# ruby 1.9.2p136 (2010-12-25 revision 30365) [x86_64-linux]
+#
+#  +--------+----------+
+#  | tach   | total    |
+#  +--------+----------+
+#  | class  | 1.450284 |
+#  +--------+----------+
+#  | lambda | 2.506496 |
+#  +--------+----------+
+
+# ruby 1.8.7 (2010-12-23 patchlevel 330) [x86_64-linux]
+#
+#  +--------+----------+
+#  | tach   | total    |
+#  +--------+----------+
+#  | class  | 1.373917 |
+#  +--------+----------+
+#  | lambda | 2.589384 |
+#  +--------+----------+
+  
+
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_insert.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_insert.rb
new file mode 100644
index 0000000..237a973
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_insert.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(1_000_000) do
+  tach('concat') do
+    path = 'path'
+    path = '/' << path
+  end
+  tach('insert') do
+    path = 'path'
+    path.insert(0, '/')
+  end
+end
+
+# +--------+----------+
+# | tach   | total    |
+# +--------+----------+
+# | insert | 0.974036 |
+# +--------+----------+
+# | concat | 0.998904 |
+# +--------+----------+
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_interpolate.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_interpolate.rb
new file mode 100644
index 0000000..bd2b7d9
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/concat_vs_interpolate.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+key = 'Content-Length'
+value = '100'
+Tach.meter(1_000) do
+  tach('concat') do
+    key << ': ' << value << "\r\n"
+  end
+  tach('interpolate') do
+    "#{key}: value\r\n"
+  end
+end
+
+# +-------------+----------+
+# | tach        | total    |
+# +-------------+----------+
+# | concat      | 0.000902 |
+# +-------------+----------+
+# | interpolate | 0.019667 |
+# +-------------+----------+
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/cr_lf.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/cr_lf.rb
new file mode 100644
index 0000000..77adc33
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/cr_lf.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+CR_LF = "\r\n"
+
+Tach.meter(1_000_000) do
+  tach('constant') do
+    '' << CR_LF
+  end
+  tach('string') do
+    '' << "\r\n"
+  end
+end
+
+# +----------+----------+
+# | tach     | total    |
+# +----------+----------+
+# | constant | 0.819885 |
+# +----------+----------+
+# | string   | 0.893602 |
+# +----------+----------+
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/downcase-eq-eq_vs_casecmp.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/downcase-eq-eq_vs_casecmp.rb
new file mode 100644
index 0000000..b36e993
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/downcase-eq-eq_vs_casecmp.rb
@@ -0,0 +1,169 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+comp  = "hello"
+hello = "HelLo"
+
+puts 'String#downcase == vs. String#casecmp'
+Benchmark.bmbm do |x|
+  x.report('String#downcase1') do
+    iters.times.each do
+      hello.downcase == comp
+    end
+  end
+
+  x.report('String#downcase2') do
+    iters.times.each do
+      "HelLo".downcase == "hello"
+    end
+  end
+
+  x.report('String#downcase3') do
+    iters.times.each do
+      var = "HelLo"
+      var.downcase!
+      var == "hello"
+    end
+  end
+
+  x.report('casecmp1') do
+    iters.times.each do
+      hello.casecmp(comp).zero?
+    end
+  end
+
+  x.report('casecmp1-1') do
+    iters.times.each do
+      hello.casecmp(comp) == 0
+    end
+  end
+
+  x.report('casecmp2') do
+    iters.times.each do
+      "HelLo".casecmp(comp).zero?
+    end
+  end
+
+  x.report('casecmp2-1') do
+    iters.times.each do
+      "HelLo".casecmp(comp) == 0
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby downcase-eq-eq_vs_casecmp.rb'
+
+jruby-1.5.6
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.461000   0.000000   0.461000 (  0.387000)
+String#downcase2   0.269000   0.000000   0.269000 (  0.269000)
+String#downcase3   0.224000   0.000000   0.224000 (  0.224000)
+casecmp1           0.157000   0.000000   0.157000 (  0.157000)
+casecmp1-1         0.153000   0.000000   0.153000 (  0.153000)
+casecmp2           0.163000   0.000000   0.163000 (  0.163000)
+casecmp2-1         0.163000   0.000000   0.163000 (  0.163000)
+------------------------------------------- total: 1.590000sec
+
+                       user     system      total        real
+String#downcase1   0.190000   0.000000   0.190000 (  0.191000)
+String#downcase2   0.225000   0.000000   0.225000 (  0.225000)
+String#downcase3   0.190000   0.000000   0.190000 (  0.190000)
+casecmp1           0.125000   0.000000   0.125000 (  0.125000)
+casecmp1-1         0.127000   0.000000   0.127000 (  0.127000)
+casecmp2           0.144000   0.000000   0.144000 (  0.144000)
+casecmp2-1         0.147000   0.000000   0.147000 (  0.147000)
+
+macruby-0.7.1
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   2.340000   0.040000   2.380000 (  1.765141)
+String#downcase2   5.510000   0.100000   5.610000 (  3.893249)
+String#downcase3   4.200000   0.080000   4.280000 (  3.031621)
+casecmp1           0.270000   0.000000   0.270000 (  0.267613)
+casecmp1-1         0.190000   0.000000   0.190000 (  0.188848)
+casecmp2           1.450000   0.020000   1.470000 (  1.027956)
+casecmp2-1         1.380000   0.030000   1.410000 (  0.951474)
+------------------------------------------ total: 15.610000sec
+
+                       user     system      total        real
+String#downcase1   2.350000   0.040000   2.390000 (  1.774292)
+String#downcase2   5.890000   0.120000   6.010000 (  4.214038)
+String#downcase3   4.530000   0.090000   4.620000 (  3.286059)
+casecmp1           0.270000   0.000000   0.270000 (  0.271119)
+casecmp1-1         0.190000   0.000000   0.190000 (  0.189462)
+casecmp2           1.540000   0.030000   1.570000 (  1.104751)
+casecmp2-1         1.440000   0.030000   1.470000 (  0.999689)
+
+rbx-head
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.702746   0.005229   0.707975 (  0.621969)
+String#downcase2   0.701429   0.001617   0.703046 (  0.691833)
+String#downcase3   1.042835   0.002952   1.045787 (  0.953992)
+casecmp1           0.654571   0.002239   0.656810 (  0.480158)
+casecmp1-1         0.484706   0.001105   0.485811 (  0.398601)
+casecmp2           0.564140   0.001579   0.565719 (  0.545332)
+casecmp2-1         0.554889   0.001153   0.556042 (  0.539569)
+------------------------------------------- total: 4.721190sec
+
+                       user     system      total        real
+String#downcase1   0.491199   0.001081   0.492280 (  0.493727)
+String#downcase2   0.631059   0.001018   0.632077 (  0.629885)
+String#downcase3   0.968867   0.002504   0.971371 (  0.976734)
+casecmp1           0.364496   0.000434   0.364930 (  0.365262)
+casecmp1-1         0.373140   0.000562   0.373702 (  0.374136)
+casecmp2           0.487644   0.001057   0.488701 (  0.490302)
+casecmp2-1         0.469868   0.001178   0.471046 (  0.472220)
+
+ruby-1.8.7-p330
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.780000   0.000000   0.780000 (  0.783979)
+String#downcase2   0.950000   0.000000   0.950000 (  0.954109)
+String#downcase3   0.960000   0.000000   0.960000 (  0.960554)
+casecmp1           0.440000   0.000000   0.440000 (  0.442546)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.487795)
+casecmp2           0.530000   0.000000   0.530000 (  0.535819)
+casecmp2-1         0.570000   0.000000   0.570000 (  0.574653)
+------------------------------------------- total: 4.720000sec
+
+                       user     system      total        real
+String#downcase1   0.780000   0.000000   0.780000 (  0.780692)
+String#downcase2   0.980000   0.010000   0.990000 (  0.982925)
+String#downcase3   0.960000   0.000000   0.960000 (  0.961501)
+casecmp1           0.440000   0.000000   0.440000 (  0.444528)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.487437)
+casecmp2           0.540000   0.000000   0.540000 (  0.537686)
+casecmp2-1         0.570000   0.000000   0.570000 (  0.574253)
+
+ruby-1.9.2-p136
+
+String#downcase == vs. String#casecmp
+Rehearsal ----------------------------------------------------
+String#downcase1   0.750000   0.000000   0.750000 (  0.750523)
+String#downcase2   1.190000   0.000000   1.190000 (  1.193346)
+String#downcase3   1.030000   0.010000   1.040000 (  1.036435)
+casecmp1           0.640000   0.000000   0.640000 (  0.640327)
+casecmp1-1         0.480000   0.000000   0.480000 (  0.484709)  # With all this crap running, some flukes pop out
+casecmp2           0.820000   0.000000   0.820000 (  0.822223)
+casecmp2-1         0.660000   0.000000   0.660000 (  0.664190)
+------------------------------------------- total: 5.580000sec
+
+                       user     system      total        real
+String#downcase1   0.760000   0.000000   0.760000 (  0.759816)
+String#downcase2   1.150000   0.010000   1.160000 (  1.150792)
+String#downcase3   1.000000   0.000000   1.000000 (  1.005549)
+casecmp1           0.650000   0.000000   0.650000 (  0.644021)
+casecmp1-1         0.490000   0.000000   0.490000 (  0.494456)
+casecmp2           0.820000   0.000000   0.820000 (  0.817689)
+casecmp2-1         0.680000   0.000000   0.680000 (  0.685121)
+=end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon.rb
new file mode 100644
index 0000000..5196730
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon.rb
@@ -0,0 +1,69 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default)
+Bundler.require(:benchmark)
+
+require 'sinatra/base'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'tach'
+
+size = 10_000
+path = '/data/' << size.to_s
+url = 'http://localhost:9292' << path
+
+times = 1_000
+
+with_server do
+
+  Tach.meter(times) do
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+    excon = Excon.new(url)
+    tach('Excon (persistent)') do
+      excon.request(:method => 'get').body
+    end
+
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon_vs.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon_vs.rb
new file mode 100644
index 0000000..7d16969
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/excon_vs.rb
@@ -0,0 +1,165 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default)
+Bundler.require(:benchmark)
+
+require 'sinatra/base'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'em-http-request'
+require 'httparty'
+require 'net/http'
+require 'open-uri'
+require 'rest_client'
+require 'tach'
+require 'typhoeus'
+
+size = 10_000
+path = '/data/' << size.to_s
+url = 'http://localhost:9292' << path
+
+times = 1_000
+
+with_server do
+
+  Tach.meter(times) do
+
+    tach('curb (persistent)') do |n|
+      curb = Curl::Easy.new
+
+      n.times do
+        curb.url = url
+        curb.http_get
+        curb.body_str
+      end
+    end
+
+    tach('em-http-request') do |n|
+      EventMachine.run {
+        count = 0
+
+        n.times do
+          http = EventMachine::HttpRequest.new(url).get
+
+          http.callback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+
+          http.errback {
+            http.response
+            count += 1
+            EM.stop if count == n
+          }
+        end
+      }
+    end
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+    excon = Excon.new(url)
+    tach('Excon (persistent)') do
+      excon.request(:method => 'get').body
+    end
+
+    tach('HTTParty') do
+      HTTParty.get(url).body
+    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', path, 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get(path).body }
+    end
+
+    Net::HTTP.start('localhost', 9292) do |http|
+      tach('Net::HTTP (persistent)') do
+        http.get(path).body
+      end
+    end
+
+    tach('open-uri') do
+      open(url).read
+    end
+
+    tach('RestClient') do
+      RestClient.get(url)
+    end
+
+    streamly = StreamlyFFI::Connection.new
+    tach('StreamlyFFI (persistent)') do
+      streamly.get(url)
+    end
+
+    tach('Typhoeus') do
+      Typhoeus::Request.get(url).body
+    end
+
+  end
+end
+
+# +--------------------------+----------+
+# | tach                     | total    |
+# +--------------------------+----------+
+# | Excon (persistent)       | 1.529095 |
+# +--------------------------+----------+
+# | curb (persistent)        | 1.740387 |
+# +--------------------------+----------+
+# | Typhoeus                 | 1.876236 |
+# +--------------------------+----------+
+# | Excon                    | 2.001858 |
+# +--------------------------+----------+
+# | StreamlyFFI (persistent) | 2.200701 |
+# +--------------------------+----------+
+# | Net::HTTP                | 2.395704 |
+# +--------------------------+----------+
+# | Net::HTTP (persistent)   | 2.418099 |
+# +--------------------------+----------+
+# | HTTParty                 | 2.659317 |
+# +--------------------------+----------+
+# | RestClient               | 2.958159 |
+# +--------------------------+----------+
+# | open-uri                 | 2.987051 |
+# +--------------------------+----------+
+# | em-http-request          | 4.123798 |
+# +--------------------------+----------+
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_array_each.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_array_each.rb
new file mode 100644
index 0000000..b88f449
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_array_each.rb
@@ -0,0 +1,27 @@
+require 'rubygems'
+require 'tach'
+
+data = ["some", "var", "goes", "in", :here, 0]
+Tach.meter(1_000_000) do
+  tach('for') do
+    for element in data
+      element == nil
+    end
+  end
+  tach('each') do
+    data.each do |element|
+      element == nil
+    end
+  end
+end
+
+# ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0]
+# 
+# +------+----------+
+# | tach | total    |
+# +------+----------+
+# | for  | 2.958672 |
+# +------+----------+
+# | each | 2.983550 |
+# +------+----------+
+# 
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_hash_each.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_hash_each.rb
new file mode 100644
index 0000000..c4db5ef
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/for_vs_hash_each.rb
@@ -0,0 +1,27 @@
+require 'rubygems'
+require 'tach'
+
+data = {"some" => "var", "goes" => "in", :here => 0}
+Tach.meter(1_000_000) do
+  tach('for') do
+    for key, values in data
+      key == values
+    end
+  end
+  tach('each') do
+    data.each do |key, values|
+      key == values
+    end
+  end
+end
+
+# ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0]
+# 
+# +------+----------+
+# | tach | total    |
+# +------+----------+
+# | each | 2.748909 |
+# +------+----------+
+# | for  | 2.949512 |
+# +------+----------+
+#
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/has_key-vs-hash[key].rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/has_key-vs-hash[key].rb
new file mode 100755
index 0000000..95d6a3f
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/has_key-vs-hash[key].rb
@@ -0,0 +1,177 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+hash  = {
+  'some_key' => 'some_val',
+  'nil_key' => nil
+}
+
+puts 'Hash#has_key vs. Hash#[]'
+Benchmark.bmbm do |x|
+  x.report('Hash#has_key') do
+    iters.times.each do
+      hash.has_key? 'some_key'
+    end
+  end
+
+  x.report('Hash#has_key (if statement)') do
+    iters.times.each do
+      if hash.has_key?('other_key')
+        "hooray!"
+      end
+    end
+  end
+  
+  x.report('Hash#has_key (non-existant)') do
+    iters.times.each do
+      hash.has_key? 'other_key'
+    end
+  end
+
+  x.report('Hash#[]') do
+    iters.times.each do
+      hash['some_key']
+    end
+  end
+
+  x.report('Hash#[] (if statement)') do
+    iters.times.each do
+      if hash['some_key']
+        "hooray!"
+      end
+    end
+  end
+
+  x.report('Hash#[] (non-existant)') do
+    iters.times.each do
+      hash['other_key']
+    end
+  end
+  
+  x.report('Hash#has_key (if statement) explicit nil check') do
+    iters.times.each do
+      if hash.has_key?('nil_key') && !hash['nil_key'].nil?
+        "hooray!"
+      end
+    end
+  end
+  
+  
+  x.report('Hash#has_key (if statement) implicit nil check') do
+    iters.times.each do
+      if hash.has_key?('nil_key') && hash['nil_key']
+        "hooray!"
+      end
+    end
+  end
+  
+  x.report('Hash#[] (if statement with nil)') do
+    iters.times.each do
+      if hash['nil_key']
+        "hooray!"
+      end
+    end
+  end
+end
+
+=begin
+
+$ rvm exec bash -c 'echo $RUBY_VERSION && ruby has_key-vs-hash\[key\].rb'
+
+jruby-1.5.6
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.410000   0.000000   0.410000 (  0.341000)
+Hash#has_key (if statement)   0.145000   0.000000   0.145000 (  0.145000)
+Hash#has_key (non-existant)   0.116000   0.000000   0.116000 (  0.116000)
+Hash#[]                       0.189000   0.000000   0.189000 (  0.189000)
+Hash#[] (if statement)        0.176000   0.000000   0.176000 (  0.176000)
+Hash#[] (non-existant)        0.302000   0.000000   0.302000 (  0.302000)
+------------------------------------------------------ total: 1.338000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.128000   0.000000   0.128000 (  0.128000)
+Hash#has_key (if statement)   0.128000   0.000000   0.128000 (  0.128000)
+Hash#has_key (non-existant)   0.153000   0.000000   0.153000 (  0.153000)
+Hash#[]                       0.206000   0.000000   0.206000 (  0.206000)
+Hash#[] (if statement)        0.182000   0.000000   0.182000 (  0.182000)
+Hash#[] (non-existant)        0.252000   0.000000   0.252000 (  0.252000)
+
+macruby-0.7.1
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  2.530000   0.050000   2.580000 (  1.917643)
+Hash#has_key (if statement)   2.590000   0.050000   2.640000 (  1.935221)
+Hash#has_key (non-existant)   2.580000   0.050000   2.630000 (  1.964230)
+Hash#[]                       2.240000   0.040000   2.280000 (  1.640999)
+Hash#[] (if statement)        3.620000   0.070000   3.690000 (  2.530248)
+Hash#[] (non-existant)        2.060000   0.040000   2.100000 (  1.473487)
+----------------------------------------------------- total: 15.920000sec
+
+                                  user     system      total        real
+Hash#has_key                  2.230000   0.030000   2.260000 (  1.661843)
+Hash#has_key (if statement)   2.180000   0.040000   2.220000 (  1.605644)
+Hash#has_key (non-existant)   2.160000   0.040000   2.200000 (  1.582561)
+Hash#[]                       2.160000   0.030000   2.190000 (  1.581448)
+Hash#[] (if statement)        3.440000   0.070000   3.510000 (  2.393421)
+Hash#[] (non-existant)        2.330000   0.040000   2.370000 (  1.699338)
+
+rbx-head
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.660584   0.004932   0.665516 (  0.508601)
+Hash#has_key (if statement)   0.261708   0.000532   0.262240 (  0.263021)
+Hash#has_key (non-existant)   0.265908   0.000827   0.266735 (  0.259509)
+Hash#[]                       0.396607   0.001189   0.397796 (  0.372997)
+Hash#[] (if statement)        0.553003   0.001589   0.554592 (  0.543859)
+Hash#[] (non-existant)        0.323748   0.000884   0.324632 (  0.319055)
+------------------------------------------------------ total: 2.471511sec
+
+                                  user     system      total        real
+Hash#has_key                  0.332239   0.000819   0.333058 (  0.333809)
+Hash#has_key (if statement)   0.284344   0.000521   0.284865 (  0.285330)
+Hash#has_key (non-existant)   0.339695   0.001301   0.340996 (  0.324259)
+Hash#[]                       0.298555   0.000368   0.298923 (  0.299557)
+Hash#[] (if statement)        0.392755   0.000773   0.393528 (  0.395473)
+Hash#[] (non-existant)        0.277721   0.000464   0.278185 (  0.278540)
+
+ruby-1.8.7-p330
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.450000   0.000000   0.450000 (  0.450143)
+Hash#has_key (if statement)   0.440000   0.000000   0.440000 (  0.448278)
+Hash#has_key (non-existant)   0.420000   0.000000   0.420000 (  0.416959)
+Hash#[]                       0.450000   0.000000   0.450000 (  0.450727)
+Hash#[] (if statement)        0.550000   0.000000   0.550000 (  0.555043)
+Hash#[] (non-existant)        0.530000   0.000000   0.530000 (  0.527189)
+------------------------------------------------------ total: 2.840000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.440000   0.000000   0.440000 (  0.447746)
+Hash#has_key (if statement)   0.450000   0.000000   0.450000 (  0.450331)
+Hash#has_key (non-existant)   0.420000   0.000000   0.420000 (  0.419157)
+Hash#[]                       0.450000   0.000000   0.450000 (  0.454438)
+Hash#[] (if statement)        0.570000   0.000000   0.570000 (  0.563948)
+Hash#[] (non-existant)        0.520000   0.000000   0.520000 (  0.527866)
+
+ruby-1.9.2-p136
+Hash#has_key vs. Hash#[]
+Rehearsal ---------------------------------------------------------------
+Hash#has_key                  0.690000   0.000000   0.690000 (  0.691657)
+Hash#has_key (if statement)   0.630000   0.000000   0.630000 (  0.638418)
+Hash#has_key (non-existant)   0.640000   0.000000   0.640000 (  0.637510)
+Hash#[]                       0.580000   0.000000   0.580000 (  0.584500)
+Hash#[] (if statement)        0.840000   0.010000   0.850000 (  0.837541)
+Hash#[] (non-existant)        0.810000   0.000000   0.810000 (  0.811598)
+------------------------------------------------------ total: 4.200000sec
+
+                                  user     system      total        real
+Hash#has_key                  0.690000   0.000000   0.690000 (  0.694192)
+Hash#has_key (if statement)   0.640000   0.000000   0.640000 (  0.641729)
+Hash#has_key (non-existant)   0.630000   0.000000   0.630000 (  0.634470)
+Hash#[]                       0.580000   0.000000   0.580000 (  0.587844)
+Hash#[] (if statement)        0.830000   0.000000   0.830000 (  0.832323)
+Hash#[] (non-existant)        0.790000   0.010000   0.800000 (  0.791689)
+=end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_case_sensitivity.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_case_sensitivity.rb
new file mode 100644
index 0000000..85aa513
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_case_sensitivity.rb
@@ -0,0 +1,83 @@
+require 'rubygems'
+require 'stringio'
+require 'tach'
+
+def all_match_socket
+  io = StringIO.new
+  io << "Connection: close\n"
+  io << "Content-Length: 000\n"
+  io << "Content-Type: text/html\n"
+  io << "Date: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Server: xxx\n"
+  io << "Transfer-Encoding: chunked\n"
+  io << "\n\n"
+  io.rewind
+  io
+end
+
+Formatador.display_line('all_match')
+Formatador.indent do
+  Tach.meter(10_000) do
+    tach('compare on read') do
+      socket, headers = all_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+        (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+        (key.casecmp('Connection') == 0) && (value.casecmp('close') == 0)
+        (key.casecmp('Content-Length') == 0)
+      end
+    end
+
+    tach('original') do
+      socket, headers = all_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+      end
+      headers.has_key?('Transfer-Encoding') && headers['Transfer-Encoding'].casecmp('chunked') == 0
+      headers.has_key?('Connection') && headers['Connection'].casecmp('close') == 0
+      headers.has_key?('Content-Length')
+    end
+  end
+end
+
+def none_match_socket
+  io = StringIO.new
+  io << "Cache-Control: max-age=0\n"
+  io << "Content-Type: text/html\n"
+  io << "Date: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Expires: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Last-Modified: Xxx, 00 Xxx 0000 00:00:00 GMT\n"
+  io << "Server: xxx\n"
+  io << "\n\n"
+  io.rewind
+  io
+end
+
+Formatador.display_line('none_match')
+Formatador.indent do
+  Tach.meter(10_000) do
+    tach('compare on read') do
+      socket, headers = none_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+        (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+        (key.casecmp('Connection') == 0) && (value.casecmp('close') == 0)
+        (key.casecmp('Content-Length') == 0)
+      end
+    end
+
+    tach('original') do
+      socket, headers = none_match_socket, {}
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(': ')
+        headers[key] = value
+      end
+      headers.has_key?('Transfer-Encoding') && headers['Transfer-Encoding'].casecmp('chunked') == 0
+      headers.has_key?('Connection') && headers['Connection'].casecmp('close') == 0
+      headers.has_key?('Content-Length')
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_split_vs_match.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_split_vs_match.rb
new file mode 100644
index 0000000..276c366
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/headers_split_vs_match.rb
@@ -0,0 +1,34 @@
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100"
+Tach.meter(1_000_000) do
+  tach('regex') do
+    data.match(/(.*):\s(.*)/)
+    header = [$1, $2]
+  end
+  tach('split') do
+    header = data.split(': ', 2)
+  end
+  tach('split regex') do
+    header = data.split(/:\s*/, 2)
+  end
+end
+
+#  +-------------+----------+
+#  | tach        | total    |
+#  +-------------+----------+
+#  | split regex | 5.940233 |
+#  +-------------+----------+
+#  | split       | 7.327549 |
+#  +-------------+----------+
+#  | regex       | 8.736390 |
+#  +-------------+----------+
+
+# +-------+----------+----------+
+# | tach  | average  | total    |
+# +-------+----------+----------+
+# | regex | 4.680451 | 4.680451 |
+# +-------+----------+----------+
+# | split | 4.393218 | 4.393218 |
+# +-------+----------+----------+
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/implicit_block-vs-explicit_block.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/implicit_block-vs-explicit_block.rb
new file mode 100644
index 0000000..7337b4e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/implicit_block-vs-explicit_block.rb
@@ -0,0 +1,98 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+def do_explicit(&block)
+  var = "hello"
+  block.call(var)
+end
+
+def do_implicit
+  var = "hello"
+  yield(var)
+end
+
+puts 'explicit block vs implicit'
+Benchmark.bmbm do |x|
+  x.report('explicit') do
+    iters.times.each do
+      do_explicit {|var|
+        var << "goodbye"
+      }
+    end
+  end
+
+  x.report('implicit') do
+    iters.times.each do
+      do_implicit {|var|
+        var << "goodbye"
+      }
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby implicit_block-vs-explicit_block.rb'
+
+jruby-1.5.6
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   1.163000   0.000000   1.163000 (  1.106000)
+implicit   0.499000   0.000000   0.499000 (  0.499000)
+----------------------------------- total: 1.662000sec
+
+               user     system      total        real
+explicit   0.730000   0.000000   0.730000 (  0.730000)
+implicit   0.453000   0.000000   0.453000 (  0.453000)
+
+macruby-0.7.1
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   5.070000   0.130000   5.200000 (  3.546388)
+implicit   3.140000   0.050000   3.190000 (  2.255986)
+----------------------------------- total: 8.390000sec
+
+               user     system      total        real
+explicit   5.340000   0.140000   5.480000 (  3.774963)
+implicit   3.170000   0.060000   3.230000 (  2.279951)
+
+rbx-head
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   1.270136   0.006507   1.276643 (  1.181588)
+implicit   0.839831   0.002203   0.842034 (  0.820849)
+----------------------------------- total: 2.118677sec
+
+               user     system      total        real
+explicit   0.960593   0.001526   0.962119 (  0.966404)
+implicit   0.700361   0.001126   0.701487 (  0.703591)
+
+ruby-1.8.7-p330
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   3.970000   0.000000   3.970000 (  3.985157)
+implicit   1.560000   0.000000   1.560000 (  1.567599)
+----------------------------------- total: 5.530000sec
+
+               user     system      total        real
+explicit   3.990000   0.010000   4.000000 (  4.002637)
+implicit   1.560000   0.000000   1.560000 (  1.560901)
+
+ruby-1.9.2-p136
+
+explicit block vs implicit
+Rehearsal --------------------------------------------
+explicit   2.620000   0.010000   2.630000 (  2.633762)
+implicit   1.080000   0.000000   1.080000 (  1.076809)
+----------------------------------- total: 3.710000sec
+
+               user     system      total        real
+explicit   2.630000   0.010000   2.640000 (  2.637658)
+implicit   1.070000   0.000000   1.070000 (  1.073589)
+=end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/merging.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/merging.rb
new file mode 100644
index 0000000..7674e3f
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/merging.rb
@@ -0,0 +1,21 @@
+require 'rubygems'
+require 'tach'
+
+Tach.meter(10_000) do
+
+  tach('merge') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    override = default.merge(override)
+  end
+
+  tach('loop') do
+    default = { :a => 1, :b => 2 }
+    override = { :b => 3, :c => 4 }
+    for key, value in default
+      override[key] ||= default[key]
+    end
+    override
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/string_ranged_index.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/string_ranged_index.rb
new file mode 100644
index 0000000..68c2fdc
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/string_ranged_index.rb
@@ -0,0 +1,87 @@
+# Copied from my benchmark_hell repo: github.com/sgonyea/benchmark_hell
+
+require 'benchmark'
+
+iters = 1000000
+
+string = "Test String OMG"
+
+puts 'String ranged index vs. "coordinates"'
+Benchmark.bmbm do |x|
+  x.report('ranged index') do
+    iters.times.each do
+      text = string[2..9]
+    end
+  end
+
+  x.report('coordinates') do
+    iters.times.each do
+      text = string[2, 9]
+    end
+  end
+end
+
+=begin
+rvm exec bash -c 'echo && echo $RUBY_VERSION && echo && ruby string_ranged_index.rb'
+
+
+jruby-1.5.6
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.419000   0.000000   0.419000 (  0.372000)
+coordinates    0.167000   0.000000   0.167000 (  0.167000)
+--------------------------------------- total: 0.586000sec
+
+                   user     system      total        real
+ranged index   0.158000   0.000000   0.158000 (  0.159000)
+coordinates    0.125000   0.000000   0.125000 (  0.125000)
+
+macruby-0.7.1
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   1.490000   0.030000   1.520000 (  1.061326)
+coordinates    1.410000   0.030000   1.440000 (  0.973640)
+--------------------------------------- total: 2.960000sec
+
+                   user     system      total        real
+ranged index   1.520000   0.030000   1.550000 (  1.081424)
+coordinates    1.480000   0.030000   1.510000 (  1.029214)
+
+rbx-head
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   1.333304   0.009398   1.342702 (  1.229629)
+coordinates    0.306087   0.000603   0.306690 (  0.303538)
+--------------------------------------- total: 1.649392sec
+
+                   user     system      total        real
+ranged index   0.923626   0.001597   0.925223 (  0.927411)
+coordinates    0.298910   0.000533   0.299443 (  0.300255)
+
+ruby-1.8.7-p330
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.730000   0.000000   0.730000 (  0.738612)
+coordinates    0.660000   0.000000   0.660000 (  0.660689)
+--------------------------------------- total: 1.390000sec
+
+                   user     system      total        real
+ranged index   0.750000   0.000000   0.750000 (  0.746172)
+coordinates    0.640000   0.000000   0.640000 (  0.640687)
+
+ruby-1.9.2-p136
+
+String ranged index vs. "coordinates"
+Rehearsal ------------------------------------------------
+ranged index   0.670000   0.000000   0.670000 (  0.679046)
+coordinates    0.620000   0.000000   0.620000 (  0.622257)
+--------------------------------------- total: 1.290000sec
+
+                   user     system      total        real
+ranged index   0.680000   0.000000   0.680000 (  0.686510)
+coordinates    0.620000   0.000000   0.620000 (  0.624269)
+=end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/strip_newline.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/strip_newline.rb
new file mode 100644
index 0000000..88a964f
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/strip_newline.rb
@@ -0,0 +1,115 @@
+# require 'benchmark'
+# 
+# COUNT = 1_000_000
+# data = "Content-Length: 100\r\n"
+# Benchmark.bmbm(25) do |bench|
+#   bench.report('chomp') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp
+#     end
+#   end
+#   bench.report('chomp!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chomp!
+#     end
+#   end
+#   bench.report('chop') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop
+#     end
+#   end
+#   bench.report('chop!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.chop!
+#     end
+#   end
+#   bench.report('strip') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip
+#     end
+#   end
+#   bench.report('strip!') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data.strip!
+#     end
+#   end
+#   bench.report('index') do
+#     COUNT.times do
+#       data = "Content-Length: 100\r\n"
+#       data[0..-3]
+#     end
+#   end
+# end
+
+
+
+# Rehearsal ------------------------------------------------------------
+# chomp                      0.640000   0.000000   0.640000 (  0.644043)
+# chomp!                     0.530000   0.000000   0.530000 (  0.531415)
+# chop                       0.620000   0.000000   0.620000 (  0.624321)
+# chop!                      0.500000   0.000000   0.500000 (  0.509146)
+# strip                      0.640000   0.000000   0.640000 (  0.638785)
+# strip!                     0.530000   0.000000   0.530000 (  0.532196)
+# index                      0.740000   0.000000   0.740000 (  0.745742)
+# --------------------------------------------------- total: 4.200000sec
+# 
+#                                user     system      total        real
+# chomp                      0.640000   0.010000   0.650000 (  0.647287)
+# chomp!                     0.530000   0.000000   0.530000 (  0.532868)
+# chop                       0.630000   0.000000   0.630000 (  0.628236)
+# chop!                      0.520000   0.000000   0.520000 (  0.522950)
+# strip                      0.640000   0.000000   0.640000 (  0.646328)
+# strip!                     0.520000   0.000000   0.520000 (  0.532715)
+# index                      0.740000   0.010000   0.750000 (  0.771277)
+
+require 'rubygems'
+require 'tach'
+
+data = "Content-Length: 100\r\n"
+Tach.meter(1_000_000) do
+  tach('chomp') do
+    data.dup.chomp
+  end
+  tach('chomp!') do
+    data.dup.chomp!
+  end
+  tach('chop') do
+    data.dup.chop
+  end
+  tach('chop!') do
+    data.dup.chop!
+  end
+  tach('strip') do
+    data.dup.strip
+  end
+  tach('strip!') do
+    data.dup.strip!
+  end
+  tach('index') do
+    data.dup[0..-3]
+  end
+end
+
+# +--------+----------+----------+
+# | tach   | average  | total    |
+# +--------+----------+----------+
+# | chomp  | 1.444547 | 1.444547 |
+# +--------+----------+----------+
+# | chomp! | 1.276813 | 1.276813 |
+# +--------+----------+----------+
+# | chop   | 1.422744 | 1.422744 |
+# +--------+----------+----------+
+# | chop!  | 1.240941 | 1.240941 |
+# +--------+----------+----------+
+# | strip  | 1.444776 | 1.444776 |
+# +--------+----------+----------+
+# | strip! | 1.266459 | 1.266459 |
+# +--------+----------+----------+
+# | index  | 1.557975 | 1.557975 |
+# +--------+----------+----------+
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/vs_stdlib.rb b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/vs_stdlib.rb
new file mode 100644
index 0000000..fca9a1e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/benchmarks/vs_stdlib.rb
@@ -0,0 +1,82 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+
+require 'sinatra/base'
+require 'tach'
+
+require File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib', 'excon')
+
+module Excon
+  class Server < Sinatra::Base
+
+    def self.run
+      Rack::Handler::WEBrick.run(
+        Excon::Server.new,
+        :Port => 9292,
+        :AccessLog => [],
+        :Logger => WEBrick::Log.new(nil, WEBrick::Log::ERROR)
+      )
+    end
+
+    get '/data/:amount' do |amount|
+      'x' * amount.to_i
+    end
+
+  end
+end
+
+def with_server(&block)
+  pid = Process.fork do
+    Excon::Server.run
+  end
+  loop do
+    sleep(1)
+    begin
+      Excon.get('http://localhost:9292/api/foo')
+      break
+    rescue
+    end
+  end
+  yield
+ensure
+  Process.kill(9, pid)
+end
+
+require 'net/http'
+require 'open-uri'
+
+url = 'http://localhost:9292/data/1000'
+
+with_server do
+
+  Tach.meter(100) do
+
+    tach('Excon') do
+      Excon.get(url).body
+    end
+
+#    tach('Excon (persistent)') do |times|
+#      excon = Excon.new(url)
+#      times.times do
+#        excon.request(:method => 'get').body
+#      end
+#    end
+
+    tach('Net::HTTP') do
+      # Net::HTTP.get('localhost', '/data/1000', 9292)
+      Net::HTTP.start('localhost', 9292) {|http| http.get('/data/1000').body }
+    end
+
+#    tach('Net::HTTP (persistent)') do |times|
+#      Net::HTTP.start('localhost', 9292) do |http|
+#        times.times do
+#          http.get('/data/1000').body
+#        end
+#      end
+#    end
+
+#    tach('open-uri') do
+#      open(url).read
+#    end
+
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/changelog.txt b/lib/brightbox-cli/vendor/excon-0.6.6/changelog.txt
new file mode 100644
index 0000000..339a51b
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/changelog.txt
@@ -0,0 +1,61 @@
+0.6.2 04/11/11
+==============
+
+* fix block arguments for connection close. thanks ggoodale
+
+0.6.1 04/05/11
+==============
+
+* add support for HTTPS proxies. thanks mrowe
+* add support for http_proxy and https_proxy ENV variables. thanks mrowe
+* fix progress for requests with blocks that are chunked or connection close
+
+0.6.0 03/30/11
+==============
+
+* basic support for using proxies. thanks mattsa
+* yield remaining/total bytes to streaming block. thanks nate
+* minor optimizations/cleanup
+
+0.5.8 03/24/11
+==============
+
+* fix regression where nil values in queries were ignored in 1.9. thanks mattsa
+* fix regression causing EOFError when making many connections in one thread
+* added tests to prevent both of the former from recurring
+
+0.5.7 03/21/11
+==============
+
+* lazily connect, rather than connecting at #initialize
+* add rough first pass at stubbing
+* minor optimizations
+* ssl client certification support. thanks thommay
+* skip figuring out/setting Content-Length if one is supplied. Thanks pweldon
+* do not try to parse body for 205 and 304. Thanks seancribbs
+
+0.5.6 02/19/11
+==============
+
+* only split headers by first ':' to allow for values with ':'. Thanks mtodd!
+* check a string instance for force_encoding, not class. Thanks seancribbs!
+* add benchmarks related to for vs each for enumerable. Thanks caius!
+* fix default rake task to run tests
+
+0.5.5 02/18/11
+==============
+
+* use local variables in response parsing, prevents keeping state across requests
+
+0.5.4 02/18/11
+==============
+
+* 204 should not attempt to parse body
+
+
+0.5.3 02/17/11
+==============
+
+* header comparison for responses is now case insensitive
+* change to allow :idempotent => false to operate correctly
+* misc cleanup
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/excon.gemspec b/lib/brightbox-cli/vendor/excon-0.6.6/excon.gemspec
new file mode 100644
index 0000000..3785955
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/excon.gemspec
@@ -0,0 +1,114 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'excon'
+  s.version           = '0.6.6'
+  s.date              = '2011-09-06'
+  s.rubyforge_project = 'excon'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "speed, persistence, http(s)"
+  s.description = "EXtended http(s) CONnections"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'https://github.com/geemus/excon'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  # s.add_development_dependency('DEVDEPNAME', [">= 1.1.0", "< 2.0.0"])
+  s.add_development_dependency('open4')
+  s.add_development_dependency('rake')
+  s.add_development_dependency('shindo', '0.2.0')
+  s.add_development_dependency('sinatra')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    benchmarks/class_vs_lambda.rb
+    benchmarks/concat_vs_insert.rb
+    benchmarks/concat_vs_interpolate.rb
+    benchmarks/cr_lf.rb
+    benchmarks/downcase-eq-eq_vs_casecmp.rb
+    benchmarks/excon.rb
+    benchmarks/excon_vs.rb
+    benchmarks/for_vs_array_each.rb
+    benchmarks/for_vs_hash_each.rb
+    benchmarks/has_key-vs-hash[key].rb
+    benchmarks/headers_case_sensitivity.rb
+    benchmarks/headers_split_vs_match.rb
+    benchmarks/implicit_block-vs-explicit_block.rb
+    benchmarks/merging.rb
+    benchmarks/string_ranged_index.rb
+    benchmarks/strip_newline.rb
+    benchmarks/vs_stdlib.rb
+    changelog.txt
+    excon.gemspec
+    lib/excon.rb
+    lib/excon/connection.rb
+    lib/excon/constants.rb
+    lib/excon/errors.rb
+    lib/excon/response.rb
+    tests/basic_tests.rb
+    tests/header_tests.rb
+    tests/idempotent_tests.rb
+    tests/proxy_tests.rb
+    tests/query_string_tests.rb
+    tests/rackups/basic.ru
+    tests/rackups/proxy.ru
+    tests/rackups/query_string.ru
+    tests/rackups/request_methods.ru
+    tests/rackups/response_header.ru
+    tests/rackups/thread_safety.ru
+    tests/request_method_tests.rb
+    tests/stub_tests.rb
+    tests/test_helper.rb
+    tests/thread_safety_tests.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon.rb b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon.rb
new file mode 100644
index 0000000..72be633
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon.rb
@@ -0,0 +1,89 @@
+$:.unshift(File.dirname(__FILE__)) unless
+  $:.include?(File.dirname(__FILE__)) || $:.include?(File.expand_path(File.dirname(__FILE__)))
+
+require 'cgi'
+require 'openssl'
+require 'rbconfig'
+require 'socket'
+require 'uri'
+
+require 'excon/constants'
+require 'excon/connection'
+require 'excon/errors'
+require 'excon/response'
+
+module Excon
+  class << self
+    # @return [String] The filesystem path to the SSL Certificate Authority
+    attr_accessor :ssl_ca_path
+
+    # @return [true, false] Whether or not to verify the peer's SSL certificate / chain
+    attr_reader :ssl_verify_peer
+
+    # setup ssl defaults based on platform
+    @ssl_verify_peer = RbConfig::CONFIG['host_os'] !~ /mswin|win32|dos|cygwin|mingw/i
+
+    # default mocking to off
+    @mock = false
+
+    # Status of mocking
+    def mock
+      @mock
+    end
+
+    # Change the status of mocking
+    # false is the default and works as expected
+    # true returns a value from stubs or raises
+    def mock=(new_mock)
+      @mock = new_mock
+    end
+
+    # @see Connection#initialize
+    # Initializes a new keep-alive session for a given remote host
+    #   @param [String] url The destination URL
+    #   @param [Hash<Symbol, >] params One or more option params to set on the Connection instance
+    #   @return [Connection] A new Excon::Connection instance
+    def new(url, params = {})
+      Excon::Connection.new(url, params)
+    end
+
+    # Change the status of ssl peer verification
+    # @see Excon#ssl_verify_peer (attr_reader)
+    def ssl_verify_peer=(new_ssl_verify_peer)
+      @ssl_verify_peer = new_ssl_verify_peer && true || false
+    end
+
+    # push an additional stub onto the list to check for mock requests
+    #   @param [Hash<Symbol, >] request params to match against, omitted params match all
+    #   @param [Hash<Symbol, >] response params to return from matched request or block to call with params
+    def stub(request_params, response_params = nil)
+      if block_given?
+        if response_params
+          raise(ArgumentError.new("stub requires either response_params OR a block"))
+        else
+          stub = [request_params, Proc.new]
+        end
+      elsif response_params
+        stub = [request_params, response_params]
+      else
+        raise(ArgumentError.new("stub requires either response_params OR a block"))
+      end
+      stubs << stub
+      stub
+    end
+
+    # get a list of defined stubs
+    def stubs
+      @stubs ||= []
+    end
+
+    # Generic non-persistent HTTP methods
+    HTTP_VERBS.each do |method|
+      eval <<-DEF
+        def #{method}(url, params = {}, &block)
+          new(url).request(params.merge!(:method => :#{method}), &block)
+        end
+      DEF
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/connection.rb b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/connection.rb
new file mode 100644
index 0000000..1e522e6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/connection.rb
@@ -0,0 +1,314 @@
+module Excon
+  class Connection
+    attr_reader :connection, :proxy
+
+    CR_NL     = "\r\n"
+    HTTP_1_1  = " HTTP/1.1\r\n"
+    FORCE_ENC = CR_NL.respond_to?(:force_encoding)
+
+    # Initializes a new Connection instance
+    #   @param [String] url The destination URL
+    #   @param [Hash<Symbol, >] params One or more optional params
+    #     @option params [String] :body Default text to be sent over a socket. Only used if :body absent in Connection#request params
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request. Only used if params[:headers] is not supplied to Connection#request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path Default path; appears after 'scheme://host:port/'. Only used if params[:path] is not supplied to Connection#request
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query Default query; appended to the 'scheme://host:port/path/' in the form of '?key=value'. Will only be used if params[:query] is not supplied to Connection#request
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    #     @option params [String] :proxy Proxy server; e.g. 'http://myproxy.com:8888'
+    def initialize(url, params = {})
+      uri = URI.parse(url)
+      @connection = {
+        :headers  => {},
+        :host     => uri.host,
+        :mock     => Excon.mock,
+        :path     => uri.path,
+        :port     => uri.port.to_s,
+        :query    => uri.query,
+        :scheme   => uri.scheme
+      }.merge!(params)
+
+      # use proxy from the environment if present
+      if ENV.has_key?('http_proxy')
+        @proxy = setup_proxy(ENV['http_proxy'])
+      elsif params.has_key?(:proxy)
+        @proxy = setup_proxy(params[:proxy])
+      end
+
+      if https?
+        # use https_proxy if that has been specified
+        if ENV.has_key?('https_proxy')
+          @proxy = setup_proxy(ENV['https_proxy'])
+        end
+      end
+
+      if @proxy
+        @connection[:headers]['Proxy-Connection'] ||= 'Keep-Alive'
+      end
+
+      @socket_key = '' << @connection[:host] << ':' << @connection[:port]
+      reset
+    end
+
+    # Sends the supplied request to the destination host.
+    #   @yield [chunk] @see Response#self.parse
+    #   @param [Hash<Symbol, >] params One or more optional params, override defaults set in Connection.new
+    #     @option params [String] :body text to be sent over a socket
+    #     @option params [Hash<Symbol, String>] :headers The default headers to supply in a request
+    #     @option params [String] :host The destination host's reachable DNS name or IP, in the form of a String
+    #     @option params [String] :path appears after 'scheme://host:port/'
+    #     @option params [Fixnum] :port The port on which to connect, to the destination host
+    #     @option params [Hash]   :query appended to the 'scheme://host:port/path/' in the form of '?key=value'
+    #     @option params [String] :scheme The protocol; 'https' causes OpenSSL to be used
+    def request(params, &block)
+      begin
+        # connection has defaults, merge in new params to override
+        params = @connection.merge(params)
+        params[:headers] = @connection[:headers].merge(params[:headers] || {})
+        params[:headers]['Host'] ||= '' << params[:host] << ':' << params[:port]
+
+        # if path is empty or doesn't start with '/', insert one
+        unless params[:path][0, 1] == '/'
+          params[:path].insert(0, '/')
+        end
+
+        if params[:mock]
+          for stub, response in Excon.stubs
+            # all specified non-headers params match and no headers were specified or all specified headers match
+            if (stub.keys - [:headers]).all? {|key| stub[key] == params[key] } &&
+              (!stub.has_key?(:headers) || stub[:headers].keys.all? {|key| stub[:headers][key] == params[:headers][key]})
+              response_attributes = case response
+              when Proc
+                response.call(params)
+              else
+                response
+              end
+              if block_given? && response_attributes.has_key?(:body)
+                body = response_attributes.delete(:body)
+                content_length = remaining = body.bytesize
+                i = 0
+                while i < body.length
+                  yield(body[i, CHUNK_SIZE], [remaining - CHUNK_SIZE, 0].max, content_length)
+                  remaining -= CHUNK_SIZE
+                  i += CHUNK_SIZE
+                end
+              end
+              return Excon::Response.new(response_attributes)
+            end
+          end
+          # if we reach here no stubs matched
+          raise(Excon::Errors::StubNotFound.new('no stubs matched ' << params.inspect))
+        end
+
+        # start with "METHOD /path"
+        request = params[:method].to_s.upcase << ' '
+        if @proxy
+          request << params[:scheme] << '://' << params[:host] << ':' << params[:port]
+        end
+        request << params[:path]
+
+        # add query to path, if there is one
+        case params[:query]
+        when String
+          request << '?' << params[:query]
+        when Hash
+          request << '?'
+          for key, values in params[:query]
+            if values.nil?
+              request << key.to_s << '&'
+            else
+              for value in [*values]
+                request << key.to_s << '=' << CGI.escape(value.to_s) << '&'
+              end
+            end
+          end
+          request.chop! # remove trailing '&'
+        end
+
+        # finish first line with "HTTP/1.1\r\n"
+        request << HTTP_1_1
+
+        # calculate content length and set to handle non-ascii
+        unless params[:headers].has_key?('Content-Length')
+          params[:headers]['Content-Length'] = case params[:body]
+          when File
+            params[:body].binmode
+            File.size(params[:body])
+          when String
+            if FORCE_ENC
+              params[:body].force_encoding('BINARY')
+            end
+            params[:body].length
+          else
+            0
+          end
+        end
+
+        # add headers to request
+        for key, values in params[:headers]
+          for value in [*values]
+            request << key.to_s << ': ' << value.to_s << CR_NL
+          end
+        end
+
+        # add additional "\r\n" to indicate end of headers
+        request << CR_NL
+
+        # write out the request, sans body
+        socket.write(request)
+        socket.flush
+
+        # write out the body
+        if params[:body]
+          if params[:body].is_a?(String)
+            socket.write(params[:body])
+          else
+            while chunk = params[:body].read(CHUNK_SIZE)
+              socket.write(chunk)
+            end
+          end
+        end
+
+        # read the response
+        response = Excon::Response.parse(socket, params, &block)
+
+        if response.headers['Connection'] == 'close'
+          reset
+        end
+
+        response
+      rescue Excon::Errors::StubNotFound => stub_not_found
+        raise(stub_not_found)
+      rescue => socket_error
+        reset
+        raise(Excon::Errors::SocketError.new(socket_error))
+      end
+
+      if params.has_key?(:expects) && ![*params[:expects]].include?(response.status)
+        reset
+        raise(Excon::Errors.status_error(params, response))
+      else
+        response
+      end
+
+    rescue => request_error
+      if params[:idempotent] && [Excon::Errors::SocketError, Excon::Errors::HTTPStatusError].any? {|ex| request_error.kind_of? ex }
+        retries_remaining ||= 4
+        retries_remaining -= 1
+        if retries_remaining > 0
+          if params[:body].respond_to?(:pos=)
+            params[:body].pos = 0
+          end
+          retry
+        else
+          raise(request_error)
+        end
+      else
+        raise(request_error)
+      end
+    end
+
+    def reset
+      (old_socket = sockets.delete(@socket_key)) && old_socket.close
+    end
+    
+    # Generate HTTP request verb methods
+    Excon::HTTP_VERBS.each do |method|
+      eval <<-DEF
+        def #{method}(params={}, &block)
+          request(params.merge!(:method => :#{method}), &block)
+        end
+      DEF
+    end
+
+  private
+    def connect
+      new_socket = open_socket
+
+      if https?
+        # create ssl context
+        ssl_context = OpenSSL::SSL::SSLContext.new
+
+        if Excon.ssl_verify_peer
+          # turn verification on
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
+
+          if Excon.ssl_ca_path
+            ssl_context.ca_path = Excon.ssl_ca_path
+          else
+            # use default cert store
+            store = OpenSSL::X509::Store.new
+            store.set_default_paths
+            ssl_context.cert_store = store
+          end
+        else
+          # turn verification off
+          ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
+        end
+
+        if @connection.has_key?(:client_cert) && @connection.has_key?(:client_key)
+          ssl_context.cert = OpenSSL::X509::Certificate.new(File.read(@connection[:client_cert]))
+          ssl_context.key = OpenSSL::PKey::RSA.new(File.read(@connection[:client_key]))
+        end
+
+        new_socket = open_ssl_socket(new_socket, ssl_context)
+      end
+
+      new_socket
+    end
+
+    def open_ssl_socket(socket, ssl_context)
+
+      new_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
+      new_socket.sync_close = true
+
+      if @proxy
+        new_socket << "CONNECT " << @connection[:host] << ":" << @connection[:port] << HTTP_1_1
+        new_socket << "Host: " << @connection[:host] << ":" << @connection[:port] << CR_NL << CR_NL
+
+        # eat the proxy's connection response
+        while line = new_socket.readline.strip
+          break if line.empty?
+        end
+      end
+
+      new_socket.connect
+      # verify connection
+      if Excon.ssl_verify_peer
+        new_socket.post_connection_check(@connection[:host])
+      end
+      new_socket
+    end
+
+    def open_socket
+      if @proxy
+        socket = TCPSocket.open(@proxy[:host], @proxy[:port])
+      else
+        socket = TCPSocket.open(@connection[:host], @connection[:port])
+      end
+      socket
+    end
+
+    def socket
+      sockets[@socket_key] ||= connect
+    end
+
+    def sockets
+      Thread.current[:_excon_sockets] ||= {}
+    end
+
+    def https?
+      @connection[:scheme] == 'https'
+    end
+
+    def setup_proxy(proxy)
+      uri = URI.parse(proxy)
+      unless uri.host and uri.port and uri.scheme
+        raise Excon::Errors::ProxyParseError, "Proxy is invalid"
+      end
+      {:host => uri.host, :port => uri.port, :scheme => uri.scheme}
+    end
+
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/constants.rb b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/constants.rb
new file mode 100644
index 0000000..2abd8b0
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/constants.rb
@@ -0,0 +1,13 @@
+module Excon
+  unless const_defined?(:VERSION)
+    VERSION = '0.6.6'
+  end
+
+  unless const_defined?(:CHUNK_SIZE)
+    CHUNK_SIZE = 1048576 # 1 megabyte
+  end
+  
+  unless const_defined?(:HTTP_VERBS)
+    HTTP_VERBS = %w{connect delete get head options post put trace}
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/errors.rb b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/errors.rb
new file mode 100644
index 0000000..4c851d3
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/errors.rb
@@ -0,0 +1,124 @@
+module Excon
+  module Errors
+
+    class Error < StandardError; end
+
+    class SocketError < Error
+      attr_reader :socket_error
+
+      def initialize(socket_error=nil)
+        if socket_error.message =~ /certificate verify failed/
+          super('Unable to verify certificate, please set `Excon.ssl_ca_path = path_to_certs` or `Excon.ssl_verify_peer = false` (less secure).')
+        else
+          super(socket_error.message)
+        end
+        set_backtrace(socket_error.backtrace)
+        @socket_error = socket_error
+      end
+    end
+
+    class ProxyParseError < Error; end
+
+    class StubNotFound < Error; end
+
+    class HTTPStatusError < Error
+      attr_reader :request, :response
+
+      def initialize(msg, request = nil, response = nil)
+        super(msg)
+        @request = request
+        @response = response
+      end
+    end
+
+    class Continue < HTTPStatusError; end                     # 100
+    class SwitchingProtocols < HTTPStatusError; end           # 101
+    class OK < HTTPStatusError; end                           # 200
+    class Created < HTTPStatusError; end                      # 201
+    class Accepted < HTTPStatusError; end                     # 202
+    class NonAuthoritativeInformation < HTTPStatusError; end  # 203
+    class NoContent < HTTPStatusError; end                    # 204
+    class ResetContent < HTTPStatusError; end                 # 205
+    class PartialContent < HTTPStatusError; end               # 206
+    class MultipleChoices < HTTPStatusError; end              # 300
+    class MovedPermanently < HTTPStatusError; end             # 301
+    class Found < HTTPStatusError; end                        # 302
+    class SeeOther < HTTPStatusError; end                     # 303
+    class NotModified < HTTPStatusError; end                  # 304
+    class UseProxy < HTTPStatusError; end                     # 305
+    class TemporaryRedirect < HTTPStatusError; end            # 307
+    class BadRequest < HTTPStatusError; end                   # 400
+    class Unauthorized < HTTPStatusError; end                 # 401
+    class PaymentRequired < HTTPStatusError; end              # 402
+    class Forbidden < HTTPStatusError; end                    # 403
+    class NotFound < HTTPStatusError; end                     # 404
+    class MethodNotAllowed < HTTPStatusError; end             # 405
+    class NotAcceptable < HTTPStatusError; end                # 406
+    class ProxyAuthenticationRequired < HTTPStatusError; end  # 407
+    class RequestTimeout < HTTPStatusError; end               # 408
+    class Conflict < HTTPStatusError; end                     # 409
+    class Gone < HTTPStatusError; end                         # 410
+    class LengthRequired < HTTPStatusError; end               # 411
+    class PreconditionFailed < HTTPStatusError; end           # 412
+    class RequestEntityTooLarge < HTTPStatusError; end        # 413
+    class RequestURITooLong < HTTPStatusError; end            # 414
+    class UnsupportedMediaType < HTTPStatusError; end         # 415
+    class RequestedRangeNotSatisfiable < HTTPStatusError; end # 416
+    class ExpectationFailed < HTTPStatusError; end            # 417
+    class UnprocessableEntity < HTTPStatusError; end          # 422
+    class InternalServerError < HTTPStatusError; end          # 500
+    class NotImplemented < HTTPStatusError; end               # 501
+    class BadGateway < HTTPStatusError; end                   # 502
+    class ServiceUnavailable < HTTPStatusError; end           # 503
+    class GatewayTimeout < HTTPStatusError; end               # 504
+
+    # Messages for nicer exceptions, from rfc2616
+    def self.status_error(request, response)
+      @errors ||= { 
+        100 => [Excon::Errors::Continue, 'Continue'],
+        101 => [Excon::Errors::SwitchingProtocols, 'Switching Protocols'],
+        200 => [Excon::Errors::OK, 'OK'],
+        201 => [Excon::Errors::Created, 'Created'],
+        202 => [Excon::Errors::Accepted, 'Accepted'],
+        203 => [Excon::Errors::NonAuthoritativeInformation, 'Non-Authoritative Information'],
+        204 => [Excon::Errors::NoContent, 'No Content'],
+        205 => [Excon::Errors::ResetContent, 'Reset Content'],
+        206 => [Excon::Errors::PartialContent, 'Partial Content'],
+        300 => [Excon::Errors::MultipleChoices, 'Multiple Choices'],
+        301 => [Excon::Errors::MovedPermanently, 'Moved Permanently'],
+        302 => [Excon::Errors::Found, 'Found'],
+        303 => [Excon::Errors::SeeOther, 'See Other'],
+        304 => [Excon::Errors::NotModified, 'Not Modified'],
+        305 => [Excon::Errors::UseProxy, 'Use Proxy'],
+        307 => [Excon::Errors::TemporaryRedirect, 'Temporary Redirect'],
+        400 => [Excon::Errors::BadRequest, 'Bad Request'],
+        401 => [Excon::Errors::Unauthorized, 'Unauthorized'],
+        402 => [Excon::Errors::PaymentRequired, 'Payment Required'],
+        403 => [Excon::Errors::Forbidden, 'Forbidden'],
+        404 => [Excon::Errors::NotFound, 'Not Found'],
+        405 => [Excon::Errors::MethodNotAllowed, 'Method Not Allowed'],
+        406 => [Excon::Errors::NotAcceptable, 'Not Acceptable'],
+        407 => [Excon::Errors::ProxyAuthenticationRequired, 'Proxy Authentication Required'],
+        408 => [Excon::Errors::RequestTimeout, 'Request Timeout'],
+        409 => [Excon::Errors::Conflict, 'Conflict'],
+        410 => [Excon::Errors::Gone, 'Gone'],
+        411 => [Excon::Errors::LengthRequired, 'Length Required'],
+        412 => [Excon::Errors::PreconditionFailed, 'Precondition Failed'],
+        413 => [Excon::Errors::RequestEntityTooLarge, 'Request Entity Too Large'],
+        414 => [Excon::Errors::RequestURITooLong, 'Request-URI Too Long'],
+        415 => [Excon::Errors::UnsupportedMediaType, 'Unsupported Media Type'],
+        416 => [Excon::Errors::RequestedRangeNotSatisfiable, 'Request Range Not Satisfiable'],
+        417 => [Excon::Errors::ExpectationFailed, 'Expectation Failed'],
+        422 => [Excon::Errors::UnprocessableEntity, 'Unprocessable Entity'],
+        500 => [Excon::Errors::InternalServerError, 'InternalServerError'],
+        501 => [Excon::Errors::NotImplemented, 'Not Implemented'],
+        502 => [Excon::Errors::BadGateway, 'Bad Gateway'],
+        503 => [Excon::Errors::ServiceUnavailable, 'Service Unavailable'],
+        504 => [Excon::Errors::GatewayTimeout, 'Gateway Timeout']
+      }
+      error, message = @errors[response.status] || [Excon::Errors::HTTPStatusError, 'Unknown']
+      error.new("Expected(#{request[:expects].inspect}) <=> Actual(#{response.status} #{message})\n  request => #{request.inspect}\n  response => #{response.inspect}", request, response)
+    end
+
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/response.rb b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/response.rb
new file mode 100644
index 0000000..a477be6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/lib/excon/response.rb
@@ -0,0 +1,92 @@
+module Excon
+  class Response
+    NO_ENTITY = [204, 205, 304].freeze
+
+    attr_accessor :body, :headers, :status
+
+    def attributes
+      {
+        :body     => body,
+        :headers  => headers,
+        :status   => status
+      }
+    end
+
+    def initialize(attrs={})
+      @body    = attrs[:body]    || ''
+      @headers = attrs[:headers] || {}
+      @status  = attrs[:status]
+    end
+
+    def self.parse(socket, params={})
+      response = new(:status => socket.readline[9, 11].to_i)
+      block_given = block_given?
+
+      until ((data = socket.readline).chop!).empty?
+        key, value = data.split(/:\s*/, 2)
+        response.headers[key] = ([*response.headers[key]] << value).compact.join(', ')
+        if key.casecmp('Content-Length') == 0
+          content_length = value.to_i
+        elsif (key.casecmp('Transfer-Encoding') == 0) && (value.casecmp('chunked') == 0)
+          transfer_encoding_chunked = true
+        end
+      end
+
+      unless (params[:method].to_s.casecmp('HEAD') == 0) || NO_ENTITY.include?(response.status)
+
+        # don't pass stuff into a block if there was an error
+        if params[:expects] && ![*params[:expects]].include?(response.status)
+          block_given = false
+        end
+
+        if block_given
+          if transfer_encoding_chunked
+            # 2 == "/r/n".length
+            while (chunk_size = socket.readline.chop!.to_i(16)) > 0
+              yield(socket.read(chunk_size + 2).chop!, nil, content_length)
+            end
+            socket.read(2)
+          elsif remaining = content_length
+            remaining = content_length
+            while remaining > 0
+              yield(socket.read([CHUNK_SIZE, remaining].min), [remaining - CHUNK_SIZE, 0].max, content_length)
+              remaining -= CHUNK_SIZE
+            end
+          else
+            while remaining = socket.read(CHUNK_SIZE)
+              yield(remaining, remaining.length, content_length)
+            end
+          end
+        else
+          if transfer_encoding_chunked
+            while (chunk_size = socket.readline.chop!.to_i(16)) > 0
+              response.body << socket.read(chunk_size + 2).chop! # 2 == "/r/n".length
+            end
+            socket.read(2) # 2 == "/r/n".length
+          elsif remaining = content_length
+            while remaining > 0
+              response.body << socket.read([CHUNK_SIZE, remaining].min)
+              remaining -= CHUNK_SIZE
+            end
+          else
+            response.body << socket.read
+          end
+        end
+      end
+
+      response
+    end
+
+    # Retrieve a specific header value. Header names are treated case-insensitively.
+    #   @param [String] name Header name
+    def get_header(name)
+      headers.each do |key,value|
+        if key.casecmp(name) == 0
+          return value
+        end
+      end
+      nil
+    end
+
+  end # class Response
+end # module Excon
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/basic_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/basic_tests.rb
new file mode 100644
index 0000000..b29b829
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/basic_tests.rb
@@ -0,0 +1,5 @@
+with_rackup('basic.ru') do
+  Shindo.tests('Excon basics') do
+    basic_tests
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/header_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/header_tests.rb
new file mode 100644
index 0000000..1912201
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/header_tests.rb
@@ -0,0 +1,49 @@
+Shindo.tests('Excon response header support') do
+
+  with_rackup('response_header.ru') do
+
+    tests('Response#get_header') do
+      connection = Excon.new('http://foo.com:8080', :proxy => 'http://localhost:9292')
+      response = connection.request(:method => :get, :path => '/foo')
+
+      tests('with variable header capitalization') do
+        
+        tests('response.get_header("mixedcase-header")').returns('MixedCase') do
+          response.get_header("mixedcase-header")
+        end
+        
+        tests('response.get_header("uppercase-header")').returns('UPPERCASE') do
+          response.get_header("uppercase-header")
+        end
+        
+        tests('response.get_header("lowercase-header")').returns('lowercase') do
+          response.get_header("lowercase-header")
+        end
+        
+      end
+      
+      tests('when provided key capitalization varies') do
+        
+        tests('response.get_header("MIXEDCASE-HEADER")').returns('MixedCase') do
+          response.get_header("MIXEDCASE-HEADER")
+        end
+        
+        tests('response.get_header("MiXeDcAsE-hEaDeR")').returns('MixedCase') do
+          response.get_header("MiXeDcAsE-hEaDeR")
+        end
+        
+      end
+      
+      tests('when header is unavailable') do
+        
+        tests('response.get_header("missing")').returns(nil) do
+          response.get_header("missing")
+        end
+        
+      end
+      
+    end
+
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/idempotent_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/idempotent_tests.rb
new file mode 100644
index 0000000..69c2333
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/idempotent_tests.rb
@@ -0,0 +1,56 @@
+Shindo.tests('Excon request idempotencey') do
+  Excon.mock = true
+
+  tests("Non-idempotent call with an erroring socket").raises(Excon::Errors::SocketError) do
+    Excon.stub({:method => :get}) { |params|
+      run_count += 1
+      if run_count < 4 # First 3 calls fail.
+        raise Excon::Errors::SocketError.new(Exception.new "Mock Error")
+      else
+        {:body => params[:body], :headers => params[:headers], :status => 200}
+      end
+    }
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/some-path')
+  end
+
+  Excon.stubs.pop
+
+  tests("Idempotent request with socket erroring first 3 times").returns(200) do
+    run_count = 0
+    Excon.stub({:method => :get}) { |params|
+      run_count += 1
+      if run_count <= 3 # First 3 calls fail.
+        raise Excon::Errors::SocketError.new(Exception.new "Mock Error")
+      else
+        {:body => params[:body], :headers => params[:headers], :status => 200}
+      end
+    }
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :idempotent => true, :path => '/some-path')
+    response.status
+  end
+
+  Excon.stubs.pop
+
+  tests("Idempotent request with socket erroring first 5 times").raises(Excon::Errors::SocketError) do
+    run_count = 0
+    Excon.stub({:method => :get}) { |params|
+      run_count += 1
+      if run_count <= 5 # First 5 calls fail.
+        raise Excon::Errors::SocketError.new(Exception.new "Mock Error")
+      else
+        {:body => params[:body], :headers => params[:headers], :status => 200}
+      end
+    }
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :idempotent => true, :path => '/some-path')
+    response.status
+  end
+
+  Excon.stubs.pop
+  Excon.mock = false
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/proxy_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/proxy_tests.rb
new file mode 100644
index 0000000..850f688
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/proxy_tests.rb
@@ -0,0 +1,136 @@
+Shindo.tests('Excon proxy support') do
+
+  tests('proxy configuration') do
+
+    tests('no proxy') do
+      connection = Excon.new('http://foo.com')
+
+      tests('connection.proxy').returns(nil) do
+        connection.proxy
+      end
+    end
+
+    tests('with fully-specified proxy: https://myproxy.net:8080') do
+      connection = Excon.new('http://foo.com', :proxy => 'https://myproxy.net:8080')
+
+      tests('connection.proxy.host').returns('myproxy.net') do
+        connection.proxy[:host]
+      end
+
+      tests('connection.proxy.port').returns(8080) do
+        connection.proxy[:port]
+      end
+
+      tests('connection.proxy.scheme').returns('https') do
+        connection.proxy[:scheme]
+      end
+    end
+
+    tests('with proxy config from the environment') do
+      ENV['http_proxy'] = 'http://myproxy:8080'
+      ENV['https_proxy'] = 'http://mysecureproxy:8081'
+
+      tests('an http connection') do
+        connection = Excon.new('http://foo.com')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      tests('an https connection') do
+        connection = Excon.new('https://secret.com')
+
+        tests('connection.proxy.host').returns('mysecureproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8081) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      tests('http proxy from the environment overrides config') do
+        connection = Excon.new('http://foo.com', :proxy => 'http://hard.coded.proxy:6666')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+      end
+
+      ENV.delete('http_proxy')
+      ENV.delete('https_proxy')
+    end
+
+    tests('with only http_proxy config from the environment') do
+      ENV['http_proxy'] = 'http://myproxy:8080'
+      ENV.delete('https_proxy')
+
+      tests('an https connection') do
+        connection = Excon.new('https://secret.com')
+
+        tests('connection.proxy.host').returns('myproxy') do
+          connection.proxy[:host]
+        end
+
+        tests('connection.proxy.port').returns(8080) do
+          connection.proxy[:port]
+        end
+
+        tests('connection.proxy.scheme').returns('http') do
+          connection.proxy[:scheme]
+        end
+      end
+
+      ENV.delete('http_proxy')
+    end
+
+  end
+
+  with_rackup('proxy.ru') do
+
+    tests('http proxying: http://foo.com:8080') do
+      connection = Excon.new('http://foo.com:8080', :proxy => 'http://localhost:9292')
+      response = connection.request(:method => :get, :path => '/bar', :query => {:alpha => 'kappa'})
+
+      tests('response.status').returns(200) do
+        response.status
+      end
+
+      # must be absolute form for proxy requests
+      tests('sent Request URI').returns('http://foo.com:8080/bar?alpha=kappa') do
+        response.headers['Sent-Request-Uri']
+      end
+
+      tests('sent Host header').returns('foo.com:8080') do
+        response.headers['Sent-Host']
+      end
+
+      tests('sent Proxy-Connection header').returns('Keep-Alive') do
+        response.headers['Sent-Proxy-Connection']
+      end
+
+      tests('response.body (proxied content)').returns('proxied content') do
+        response.body
+      end
+    end
+
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/query_string_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/query_string_tests.rb
new file mode 100644
index 0000000..21a37e6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/query_string_tests.rb
@@ -0,0 +1,58 @@
+with_rackup('query_string.ru') do
+  Shindo.tests('Excon query string variants') do
+    connection = Excon.new('http://127.0.0.1:9292')
+
+    tests(":query => {:foo => 'bar'}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar'})
+      query_string = response.body[7..-1] # query string sent
+
+      tests("query string sent").returns('foo=bar') do
+        query_string
+      end
+
+    end
+
+    tests(":query => {:foo => nil}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => nil})
+      query_string = response.body[7..-1] # query string sent
+
+      tests("query string sent").returns('foo') do
+        query_string
+      end
+
+    end
+
+    tests(":query => {:foo => 'bar', :me => nil}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar', :me => nil})
+      query_string = response.body[7..-1] # query string sent
+
+      test("query string sent includes 'foo=bar'") do
+        query_string.split('&').include?('foo=bar')
+      end
+
+      test("query string sent includes 'me'") do
+        query_string.split('&').include?('me')
+      end
+
+    end
+
+    tests(":query => {:foo => 'bar', :me => 'too'}") do
+
+      response = connection.request(:method => :get, :path => '/query', :query => {:foo => 'bar', :me => 'too'})
+      query_string = response.body[7..-1] # query string sent
+
+      test("query string sent includes 'foo=bar'") do
+        query_string.split('&').include?('foo=bar')
+      end
+
+      test("query string sent includes 'me=too'") do
+        query_string.split('&').include?('me=too')
+      end
+
+    end
+
+  end
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/basic.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/basic.ru
new file mode 100644
index 0000000..504e1cd
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/basic.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/content-length/:value') do |value|
+    headers("Custom" => "Foo: bar")
+    'x' * value.to_i
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/proxy.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/proxy.ru
new file mode 100644
index 0000000..b329ddc
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/proxy.ru
@@ -0,0 +1,14 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/bar') do
+    headers(
+      "Sent-Request-Uri" => request.env['REQUEST_URI'].to_s,
+      "Sent-Host" => request.env['HTTP_HOST'].to_s,
+      "Sent-Proxy-Connection" => request.env['HTTP_PROXY_CONNECTION'].to_s
+    )
+    'proxied content'
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/query_string.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/query_string.ru
new file mode 100644
index 0000000..394063e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/query_string.ru
@@ -0,0 +1,9 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/query') do
+    "query: " << request.query_string
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/request_methods.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/request_methods.ru
new file mode 100644
index 0000000..de552c8
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/request_methods.ru
@@ -0,0 +1,17 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get '/' do
+    'GET'
+  end
+  
+  post '/' do
+    'POST'
+  end
+  
+  delete '/' do
+    'DELETE'
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/response_header.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/response_header.ru
new file mode 100644
index 0000000..7ec75ab
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/response_header.ru
@@ -0,0 +1,14 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/foo') do
+    headers(
+      "MixedCase-Header" => 'MixedCase',
+      "UPPERCASE-HEADER" => 'UPPERCASE',
+      "lowercase-header" => 'lowercase'
+    )
+    'primary content'
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/thread_safety.ru b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/thread_safety.ru
new file mode 100644
index 0000000..8765cac
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/rackups/thread_safety.ru
@@ -0,0 +1,10 @@
+require 'sinatra'
+
+class App < Sinatra::Base
+  get('/id/:id/wait/:wait') do |id, wait|
+    sleep(wait.to_i)
+    id.to_s
+  end
+end
+
+run App
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/request_method_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/request_method_tests.rb
new file mode 100644
index 0000000..6600cd6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/request_method_tests.rb
@@ -0,0 +1,33 @@
+Shindo.tests('Excon request methods') do
+
+  with_rackup('request_methods.ru') do
+
+    tests 'one-offs' do
+      
+      tests('Excon.get').returns('GET') do
+        Excon.get('http://127.0.0.1:9292').body
+      end
+      
+      tests('Excon.post').returns('POST') do
+        Excon.post('http://127.0.0.1:9292').body
+      end
+      
+    end
+    
+    tests 'with a connection object' do
+      
+      connection = Excon.new('http://127.0.0.1:9292')
+      
+      tests('connection.get').returns('GET') do
+        connection.get.body
+      end
+      
+      tests('connection.post').returns('POST') do
+        connection.post.body
+      end
+      
+    end
+
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/stub_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/stub_tests.rb
new file mode 100644
index 0000000..d846bec
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/stub_tests.rb
@@ -0,0 +1,105 @@
+Shindo.tests('Excon stubs') do
+  Excon.mock = true
+
+  tests("missing stub").raises(Excon::Errors::StubNotFound) do
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+  end
+
+  tests("stub({})").raises(ArgumentError) do
+    Excon.stub({})
+  end
+
+  tests("stub({}, {}) {}").raises(ArgumentError) do
+    Excon.stub({}, {}) {}
+  end
+
+  tests("stub({:method => :get}, {:body => 'body', :status => 200})") do
+
+    Excon.stub({:method => :get}, {:body => 'body', :status => 200})
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+
+    tests('response.body').returns('body') do
+      response.body
+    end
+
+    tests('response.headers').returns({}) do
+      response.headers
+    end
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    tests('request body with block given').returns('body') do
+      body = ''
+      connection.request(:method => :get, :path => '/content-length/100') do |chunk, remaining_bytes, total_bytes|
+        body << chunk
+      end
+      body
+    end
+
+    Excon.stubs.pop
+
+  end
+
+  tests("stub({:body => 'body', :method => :get}) {|params| {:body => params[:body], :headers => params[:headers], :status => 200}}") do
+
+    Excon.stub({:body => 'body', :method => :get}) {|params| {:body => params[:body], :headers => params[:headers], :status => 200}}
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:body => 'body', :method => :get, :path => '/content-length/100')
+
+    tests('response.body').returns('body') do
+      response.body
+    end
+
+    tests('response.headers').returns({'Host' => '127.0.0.1:9292'}) do
+      response.headers
+    end
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    tests('request body with block given').returns('body') do
+      body = ''
+      connection.request(:body => 'body', :method => :get, :path => '/content-length/100') do |chunk, remaining_bytes, total_bytes|
+        body << chunk
+      end
+      body
+    end
+
+    Excon.stubs.pop
+
+  end
+
+  tests("mismatched stub").raises(Excon::Errors::StubNotFound) do
+    Excon.stub({:method => :post}, {:body => 'body'})
+    Excon.get('http://127.0.0.1:9292/')
+  end
+
+  tests("stub({}, {:body => 'x' * (Excon::CHUNK_SIZE + 1)})") do
+    connection = Excon.new('http://127.0.0.1:9292')
+    Excon.stub({}, {:body => 'x' * (Excon::CHUNK_SIZE + 1)})
+
+    test("with block") do
+      chunks = []
+      response = connection.request(:method => :get, :path => '/content-length/100') do |chunk, remaining_bytes, total_bytes|
+        chunks << chunk
+      end
+      chunks == ['x' * Excon::CHUNK_SIZE, 'x']
+    end
+  end
+
+  Excon.mock = false
+
+  tests('mock = false') do
+    with_rackup('basic.ru') do
+      basic_tests
+    end
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/test_helper.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/test_helper.rb
new file mode 100644
index 0000000..1529456
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/test_helper.rb
@@ -0,0 +1,64 @@
+require 'rubygems' if RUBY_VERSION < '1.9'
+require 'bundler'
+
+Bundler.require(:default, :development)
+
+def basic_tests
+  tests('GET /content-length/100') do
+
+    connection = Excon.new('http://127.0.0.1:9292')
+    response = connection.request(:method => :get, :path => '/content-length/100')
+
+    tests('response.status').returns(200) do
+      response.status
+    end
+
+    tests("response.headers['Connection']").returns('Keep-Alive') do
+      response.headers['Connection']
+    end
+
+    tests("response.headers['Content-Length']").returns('100') do
+      response.headers['Content-Length']
+    end
+
+    tests("response.headers['Content-Type']").returns('text/html;charset=utf-8') do
+      response.headers['Content-Type']
+    end
+
+    test("Time.parse(response.headers['Date']).is_a?(Time)") do
+      Time.parse(response.headers['Date']).is_a?(Time)
+    end
+
+    test("!!(response.headers['Server'] =~ /^WEBrick/)") do
+      !!(response.headers['Server'] =~ /^WEBrick/)
+    end
+
+    tests("response.headers['Custom']").returns("Foo: bar") do
+      response.headers['Custom']
+    end
+
+    tests("response.body").returns('x' * 100) do
+      response.body
+    end
+
+    tests("block usage").returns(['x' * 100, 0, 100]) do
+      data = []
+      connection.request(:method => :get, :path => '/content-length/100') do |chunk, remaining_length, total_length|
+        data = [chunk, remaining_length, total_length]
+      end
+      data
+    end
+  end
+end
+
+def rackup_path(*parts)
+  File.expand_path(File.join(File.dirname(__FILE__), 'rackups', *parts))
+end
+
+def with_rackup(name)
+  pid, w, r, e = Open4.popen4("rackup #{rackup_path(name)}")
+  until e.gets =~ /HTTPServer#start:/; end
+  yield
+ensure
+  Process.kill(9, pid)
+end
diff --git a/lib/brightbox-cli/vendor/excon-0.6.6/tests/thread_safety_tests.rb b/lib/brightbox-cli/vendor/excon-0.6.6/tests/thread_safety_tests.rb
new file mode 100644
index 0000000..03afb8e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/excon-0.6.6/tests/thread_safety_tests.rb
@@ -0,0 +1,26 @@
+with_rackup('thread_safety.ru') do
+  Shindo.tests('Excon thread safety') do
+    connection = Excon.new('http://127.0.0.1:9292')
+
+    long_thread = Thread.new {
+      response = connection.request(:method => 'GET', :path => '/id/1/wait/2')
+      Thread.current[:success] = response.body == '1'
+    }
+
+    short_thread = Thread.new {
+      response = connection.request(:method => 'GET', :path => '/id/2/wait/1')
+      Thread.current[:success] = response.body == '2'
+    }
+
+    long_thread.join
+    short_thread.join
+
+    test('long_thread') do
+      long_thread[:success]
+    end
+
+    test('short_thread') do
+      short_thread[:success]
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/Gemfile b/lib/brightbox-cli/vendor/formatador-0.2.1/Gemfile
new file mode 100644
index 0000000..c80ee36
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/Gemfile
@@ -0,0 +1,3 @@
+source "http://rubygems.org"
+
+gemspec
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/README.rdoc b/lib/brightbox-cli/vendor/formatador-0.2.1/README.rdoc
new file mode 100644
index 0000000..760e15b
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/README.rdoc
@@ -0,0 +1,64 @@
+= formatador
+
+STDOUT text formatting
+
+== Quick and dirty
+
+You can call class methods to print out single lines like this:
+
+  Formatador.display_line('Hello World')
+
+You use tags, similar to html, to set formatting options:
+
+  Formatador.display_line('[green]Hello World[/]')
+
+  [/] resets everything to normal, colors are supported and [_color_] sets the background color.
+
+== Standard options
+
+* format - and adds color codes if STDOUT.tty? is true
+* display - calls format on the input and prints it
+* display_line - calls display, but adds on a newline (\n)
+* redisplay - Displays text, prepended with \r which will overwrite the last existing line
+
+== Extensions
+
+* display_table: takes an array of hashes. Each hash is a row, with the keys being the headers and values being the data. An optional second argument can specify which headers/columns to include and in what order they should appear.
+* display_compact_table: Same as display_table, execpt that split lines are not drawn by default in the body of the table. If you need a split line, put a :split constant in the body array.
+* redisplay_progressbar: takes the current and total values as its first two arguments and redisplays a progressbar (until current = total and then it display_lines). An optional third argument represents the start time and will add an elapsed time counter.
+
+== Indentation
+
+By initializing a formatador object you can keep track of indentation:
+
+  formatador = Formatador.new
+  formatador.display_line('one level of indentation')
+  formatador.indent {
+    formatador.display_line('two levels of indentation')
+  }
+  formatador.display_line('one level of indentation')
+
+== Copyright
+
+(The MIT License)
+
+Copyright (c) 2009 {geemus (Wesley Beary)}[http://github.com/geemus]
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/Rakefile b/lib/brightbox-cli/vendor/formatador-0.2.1/Rakefile
new file mode 100644
index 0000000..a742dbf
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/Rakefile
@@ -0,0 +1,143 @@
+require 'rubygems'
+require 'rake'
+require 'date'
+
+#############################################################################
+#
+# Helper functions
+#
+#############################################################################
+
+def name
+  @name ||= Dir['*.gemspec'].first.split('.').first
+end
+
+def version
+  line = File.read("lib/#{name}.rb")[/^\s*VERSION\s*=\s*.*/]
+  line.match(/.*VERSION\s*=\s*['"](.*)['"]/)[1]
+end
+
+def date
+  Date.today.to_s
+end
+
+def rubyforge_project
+  name
+end
+
+def gemspec_file
+  "#{name}.gemspec"
+end
+
+def gem_file
+  "#{name}-#{version}.gem"
+end
+
+def replace_header(head, header_name)
+  head.sub!(/(\.#{header_name}\s*= ').*'/) { "#{$1}#{send(header_name)}'"}
+end
+
+#############################################################################
+#
+# Standard tasks
+#
+#############################################################################
+
+require 'shindo/rake'
+Shindo::Rake.new
+
+task :default => :tests
+
+desc "Generate RCov test coverage and open in your browser"
+task :coverage do
+  require 'rcov'
+  sh "rm -fr coverage"
+  sh "rcov test/test_*.rb"
+  sh "open coverage/index.html"
+end
+
+require 'rake/rdoctask'
+Rake::RDocTask.new do |rdoc|
+  rdoc.rdoc_dir = 'rdoc'
+  rdoc.title = "#{name} #{version}"
+  rdoc.rdoc_files.include('README*')
+  rdoc.rdoc_files.include('lib/**/*.rb')
+end
+
+desc "Open an irb session preloaded with this library"
+task :console do
+  sh "irb -rubygems -r ./lib/#{name}.rb"
+end
+
+#############################################################################
+#
+# Custom tasks (add your own tasks here)
+#
+#############################################################################
+
+
+
+#############################################################################
+#
+# Packaging tasks
+#
+#############################################################################
+
+task :release => :build do
+  unless `git branch` =~ /^\* master$/
+    puts "You must be on the master branch to release!"
+    exit!
+  end
+  sh "sudo gem install pkg/#{name}-#{version}.gem"
+  sh "git commit --allow-empty -a -m 'Release #{version}'"
+  sh "git tag v#{version}"
+  sh "git push origin master"
+  sh "git push origin v#{version}"
+  sh "gem push pkg/#{name}-#{version}.gem"
+end
+
+task :build => :gemspec do
+  sh "mkdir -p pkg"
+  sh "gem build #{gemspec_file}"
+  sh "mv #{gem_file} pkg"
+end
+
+task :gemspec => :validate do
+  # read spec file and split out manifest section
+  spec = File.read(gemspec_file)
+  head, manifest, tail = spec.split("  # = MANIFEST =\n")
+
+  # replace name version and date
+  replace_header(head, :name)
+  replace_header(head, :version)
+  replace_header(head, :date)
+  #comment this out if your rubyforge_project has a different name
+  replace_header(head, :rubyforge_project)
+
+  # determine file list from git ls-files
+  files = `git ls-files`.
+    split("\n").
+    sort.
+    reject { |file| file =~ /^\./ }.
+    reject { |file| file =~ /^(rdoc|pkg)/ }.
+    map { |file| "    #{file}" }.
+    join("\n")
+
+  # piece file back together and write
+  manifest = "  s.files = %w[\n#{files}\n  ]\n"
+  spec = [head, manifest, tail].join("  # = MANIFEST =\n")
+  File.open(gemspec_file, 'w') { |io| io.write(spec) }
+  puts "Updated #{gemspec_file}"
+end
+
+task :validate do
+  libfiles = Dir['lib/*'] - ["lib/#{name}.rb", "lib/#{name}"]
+  unless libfiles.empty?
+    puts "Directory `lib` should only contain a `#{name}.rb` file and `#{name}` dir."
+    exit!
+  end
+  unless Dir['VERSION*'].empty?
+    puts "A `VERSION` file at root level violates Gem best practices."
+    exit!
+  end
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/formatador.gemspec b/lib/brightbox-cli/vendor/formatador-0.2.1/formatador.gemspec
new file mode 100644
index 0000000..ce61cf8
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/formatador.gemspec
@@ -0,0 +1,79 @@
+## This is the rakegem gemspec template. Make sure you read and understand
+## all of the comments. Some sections require modification, and others can
+## be deleted if you don't need them. Once you understand the contents of
+## this file, feel free to delete any comments that begin with two hash marks.
+## You can find comprehensive Gem::Specification documentation, at
+## http://docs.rubygems.org/read/chapter/20
+Gem::Specification.new do |s|
+  s.specification_version = 2 if s.respond_to? :specification_version=
+  s.required_rubygems_version = Gem::Requirement.new(">= 0") if s.respond_to? :required_rubygems_version=
+  s.rubygems_version = '1.3.5'
+
+  ## Leave these as is they will be modified for you by the rake gemspec task.
+  ## If your rubyforge_project name is different, then edit it and comment out
+  ## the sub! line in the Rakefile
+  s.name              = 'formatador'
+  s.version           = '0.2.1'
+  s.date              = '2011-09-01'
+  s.rubyforge_project = 'formatador'
+
+  ## Make sure your summary is short. The description may be as long
+  ## as you like.
+  s.summary     = "Ruby STDOUT text formatting"
+  s.description = "STDOUT text formatting"
+
+  ## List the primary authors. If there are a bunch of authors, it's probably
+  ## better to set the email to an email list or something. If you don't have
+  ## a custom homepage, consider using your GitHub URL or the like.
+  s.authors  = ["geemus (Wesley Beary)"]
+  s.email    = 'geemus@gmail.com'
+  s.homepage = 'http://github.com/geemus/NAME'
+
+  ## This gets added to the $LOAD_PATH so that 'lib/NAME.rb' can be required as
+  ## require 'NAME.rb' or'/lib/NAME/file.rb' can be as require 'NAME/file.rb'
+  s.require_paths = %w[lib]
+
+  ## This sections is only necessary if you have C extensions.
+  # s.require_paths << 'ext'
+  # s.extensions = %w[ext/extconf.rb]
+
+  ## If your gem includes any executables, list them here.
+  # s.executables = ["name"]
+  # s.default_executable = 'name'
+
+  ## Specify any RDoc options here. You'll want to add your README and
+  ## LICENSE files to the extra_rdoc_files list.
+  s.rdoc_options = ["--charset=UTF-8"]
+  s.extra_rdoc_files = %w[README.rdoc]
+
+  ## List your runtime dependencies here. Runtime dependencies are those
+  ## that are needed for an end user to actually USE your code.
+  # s.add_dependency('DEPNAME', [">= 1.1.0", "< 2.0.0"])
+
+  ## List your development dependencies here. Development dependencies are
+  ## those that are only needed during development
+  s.add_development_dependency('rake')
+  s.add_development_dependency('shindo')
+
+  ## Leave this section as-is. It will be automatically generated from the
+  ## contents of your Git repository via the gemspec task. DO NOT REMOVE
+  ## THE MANIFEST COMMENTS, they are used as delimiters by the task.
+  # = MANIFEST =
+  s.files = %w[
+    Gemfile
+    README.rdoc
+    Rakefile
+    formatador.gemspec
+    lib/formatador.rb
+    lib/formatador/progressbar.rb
+    lib/formatador/table.rb
+    tests/basic_tests.rb
+    tests/table_tests.rb
+    tests/tests_helper.rb
+  ]
+  # = MANIFEST =
+
+  ## Test files will be grabbed from the file list. Make sure the path glob
+  ## matches what you actually use.
+  s.test_files = s.files.select { |path| path =~ /^[spec|tests]\/.*_[spec|tests]\.rb/ }
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador.rb
new file mode 100644
index 0000000..9368e00
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador.rb
@@ -0,0 +1,130 @@
+require File.join(File.dirname(__FILE__), 'formatador', 'table')
+require File.join(File.dirname(__FILE__), 'formatador', 'progressbar')
+
+class Formatador
+
+  VERSION = '0.2.1'
+
+  STYLES = {
+    :"\/"             => "0",
+    :reset            => "0",
+    :bold             => "1",
+    :underline        => "4",
+    :blink_slow       => "5",
+    :blink_fast       => "6",
+    :negative         => "7", # invert color/color
+    :normal           => "22",
+    :underline_none   => "24",
+    :blink_off        => "25",
+    :positive         => "27", # revert color/color
+    :black            => "30",
+    :red              => "31",
+    :green            => "32",
+    :yellow           => "33",
+    :blue             => "34",
+    :magenta          => "35",
+    :purple           => "35",
+    :cyan             => "36",
+    :white            => "37",
+    :_black_          => "40",
+    :_red_            => "41",
+    :_green_          => "42",
+    :_yellow_         => "43",
+    :_blue_           => "44",
+    :_magenta_        => "45",
+    :_purple_         => "45",
+    :_cyan_           => "46",
+    :_white_          => "47",
+    :light_black      => "90",
+    :light_red        => "91",
+    :light_green      => "92",
+    :light_yellow     => "93",
+    :light_blue       => "94",
+    :light_magenta    => "95",
+    :light_purple     => "95",
+    :light_cyan       => "96",
+    :_light_black_    => "100",
+    :_light_red_      => "101",
+    :_light_green_    => "102",
+    :_light_yellow_   => "103",
+    :_light_blue_     => "104",
+    :_light_magenta_  => "105",
+    :_light_purple_   => "105",
+    :_light_cyan_     => "106",
+  }
+
+  PARSE_REGEX  = /\[(#{ STYLES.keys.join('|') })\]/ix
+  INDENT_REGEX = /\[indent\]/ix
+
+  def initialize
+    @indent = 1
+  end
+
+  def display(string = '')
+    print(parse("[indent]#{string}"))
+    STDOUT.flush
+    nil
+  end
+
+  def display_line(string = '')
+    display(string)
+    new_line
+    nil
+  end
+
+  def display_lines(lines = [])
+    for line in [*lines]
+      display_line(line)
+    end
+    nil
+  end
+
+  def parse(string)
+    if STDOUT.tty?
+      string.gsub(PARSE_REGEX) { "\e[#{STYLES[$1.to_sym]}m" }.gsub(INDENT_REGEX) { indentation }
+    else
+      strip(string)
+    end
+  end
+
+  def indent(&block)
+    @indent += 1
+    yield
+    @indent -= 1
+  end
+
+  def indentation
+    '  ' * @indent
+  end
+
+  def redisplay(string = '', width = 120)
+    print("\r#{' ' * width}\r")
+    display("#{string}")
+    nil
+  end
+
+  def redisplay_line(string = '', width = 120)
+    redisplay(string, width)
+    new_line
+    nil
+  end
+
+  def new_line
+    print("\n")
+    nil
+  end
+
+  def strip(string)
+    string.gsub(PARSE_REGEX, '').gsub(INDENT_REGEX) { indentation }
+  end
+
+  %w{display display_line display_lines display_table display_compact_table indent parse redisplay redisplay_line new_line redisplay_progressbar}.each do |method|
+    eval <<-DEF
+      def self.#{method}(*args, &block)
+        Thread.current[:formatador] ||= new
+        Thread.current[:formatador].#{method}(*args, &block)
+      end
+    DEF
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/progressbar.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/progressbar.rb
new file mode 100644
index 0000000..a0153f6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/progressbar.rb
@@ -0,0 +1,60 @@
+class Formatador
+
+  def redisplay_progressbar(current, total, options = {})
+    options = { :color => 'white', :width => 50, :new_line => true }.merge!(options)
+    data = progressbar(current, total, options)
+    if current < total
+      redisplay(data)
+    else
+      redisplay("#{data}")
+      if options[:new_line]
+        new_line
+      end
+      @progressbar_started_at = nil
+    end
+  end
+
+  private
+
+  def progressbar(current, total, options)
+    color = options[:color]
+    started_at = options[:started_at]
+    width = options[:width]
+
+    output = []
+
+    if options[:label]
+      output << options[:label]
+    end
+
+    # width
+    # we are going to write a string that looks like "   current/total"
+    # It would be nice if it were left padded with spaces in such a way that
+    # it puts the progress bar in a constant place on the page. This witdh
+    # calculation allows for the "current" string to be up to two characters
+    # longer than the "total" string without problems. eg- current =
+    # 9.99, total = 10
+    padding = total.to_s.size * 2 + 3
+
+    output << "[#{color}]%#{padding}s[/]" % "#{current}/#{total}"
+
+    percent = current.to_f / total.to_f
+    percent = 0 if percent < 0
+    percent = 1 if percent > 1
+
+    done = '*' * (percent * width).ceil
+    remaining = ' ' * (width - done.length)
+    output << "[_white_]|[/][#{color}][_#{color}_]#{done}[/]#{remaining}[_white_]|[/]"
+
+    if started_at
+      elapsed = Time.now - started_at
+      minutes = (elapsed / 60).truncate.to_s
+      seconds = (elapsed % 60).truncate.to_s
+      output << "#{minutes}:#{'0' if seconds.size < 2}#{seconds}"
+    end
+
+    output << ''
+    output.join('  ')
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/table.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/table.rb
new file mode 100644
index 0000000..95f757d
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/lib/formatador/table.rb
@@ -0,0 +1,78 @@
+class Formatador
+  def display_table(hashes, keys = nil, &block)
+    new_hashes = hashes.inject([]) do |accum,item|
+      accum << :split unless accum.empty?
+      accum << item
+    end
+    display_compact_table(new_hashes, keys, &block)
+  end
+
+  def display_compact_table(hashes, keys = nil, &block)
+    headers = keys || []
+    widths = {}
+    if hashes.empty? && keys
+      for key in keys
+        widths[key] = key.to_s.length
+      end
+    else
+      for hash in hashes
+        next unless hash.respond_to?(:keys)
+
+        for key in hash.keys
+          unless keys
+            headers << key
+          end
+          widths[key] = [ length(key), widths[key] || 0, hash[key] && length(hash[key]) || 0].max
+        end
+        headers = headers.uniq
+      end
+    end
+
+    if block_given?
+      headers = headers.sort(&block)
+    elsif !keys
+      headers = headers.sort {|x,y| x.to_s <=> y.to_s}
+    end
+
+    split = "+"
+    if headers.empty?
+      split << '--+'
+    else
+      for header in headers
+        widths[header] ||= length(header)
+        split << ('-' * (widths[header] + 2)) << '+'
+      end
+    end
+
+    display_line(split)
+    columns = []
+    for header in headers
+      columns << "[bold]#{header}[/]#{' ' * (widths[header] - header.to_s.length)}"
+    end
+    display_line("| #{columns.join(' | ')} |")
+    display_line(split)
+
+    for hash in hashes
+      if hash.respond_to? :keys
+        columns = []
+        for header in headers
+          datum = hash[header] || ''
+          columns << "#{datum}#{' ' * (widths[header] - length(datum))}"
+        end
+        display_line("| #{columns.join(' | ')} |")
+      else
+        if hash == :split
+          display_line(split)
+        end 
+      end
+      nil
+    end
+    display_line(split)
+  end
+
+  private
+
+  def length(value)
+    value.to_s.gsub(PARSE_REGEX, '').length
+  end
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/tests/basic_tests.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/basic_tests.rb
new file mode 100644
index 0000000..4021093
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/basic_tests.rb
@@ -0,0 +1,28 @@
+Shindo.tests("Formatador") do
+
+  tests("#display_line(Formatador)").returns("    Formatador\n") do
+    capture_stdout do
+      Formatador.display_line('Formatador')
+    end
+  end
+
+output = <<-OUTPUT
+    one
+    two
+OUTPUT
+
+  tests("#display_lines(['one', 'two']").returns(output) do
+    capture_stdout do
+      Formatador.display_lines(['one', 'two'])
+    end
+  end
+
+  tests("#indent { display_line('Formatador') }").returns("      Formatador\n") do
+    capture_stdout do
+      Formatador.indent do
+        Formatador.display_line('Formatador')
+      end
+    end
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/tests/table_tests.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/table_tests.rb
new file mode 100644
index 0000000..f6ffd17
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/table_tests.rb
@@ -0,0 +1,46 @@
+Shindo.tests("Formatador") do
+
+output = <<-OUTPUT
+    +---+
+    | \e[1ma\e[0m |
+    +---+
+    | 1 |
+    +---+
+    | 2 |
+    +---+
+OUTPUT
+
+  tests("#display_table([{:a => 1}, {:a => 2}])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([{:a => 1}, {:a => 2}])
+    end
+  end
+
+output = <<-OUTPUT
+    +--------+
+    | \e[1mheader\e[0m |
+    +--------+
+    +--------+
+OUTPUT
+
+  tests("#display_table([], [:header])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([], [:header])
+    end
+  end
+
+output = <<-OUTPUT
+    +--------+
+    | \e[1mheader\e[0m |
+    +--------+
+    |        |
+    +--------+
+OUTPUT
+
+  tests("#display_table([{:a => 1}], [:header])").returns(output) do
+    capture_stdout do
+      Formatador.display_table([{:a => 1}], [:header])
+    end
+  end
+
+end
diff --git a/lib/brightbox-cli/vendor/formatador-0.2.1/tests/tests_helper.rb b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/tests_helper.rb
new file mode 100644
index 0000000..5c0d6fc
--- /dev/null
+++ b/lib/brightbox-cli/vendor/formatador-0.2.1/tests/tests_helper.rb
@@ -0,0 +1,14 @@
+$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
+$LOAD_PATH.unshift(File.dirname(__FILE__))
+require 'formatador'
+require 'rubygems'
+require 'shindo'
+
+def capture_stdout
+  old_stdout = $stdout
+  new_stdout = StringIO.new
+  $stdout = new_stdout
+  yield
+  $stdout = old_stdout
+  new_stdout.string
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/.gemspec b/lib/brightbox-cli/vendor/hirb-0.3.5/.gemspec
new file mode 100644
index 0000000..3490062
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/.gemspec
@@ -0,0 +1,22 @@
+# -*- encoding: utf-8 -*-
+require 'rubygems' unless Object.const_defined?(:Gem)
+require File.dirname(__FILE__) + "/lib/hirb/version"
+ 
+Gem::Specification.new do |s|
+  s.name        = "hirb"
+  s.version     = Hirb::VERSION
+  s.authors     = ["Gabriel Horner"]
+  s.email       = "gabriel.horner@gmail.com"
+  s.homepage    = "http://tagaholic.me/hirb/"
+  s.summary     = "A mini view framework for console/irb that's easy to use, even while under its influence."
+  s.description = "Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output. Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer two dimensional menus."
+  s.required_rubygems_version = ">= 1.3.5"
+  s.rubyforge_project = 'tagaholic'
+  s.add_development_dependency 'bacon', '>= 1.1.0'
+  s.add_development_dependency 'mocha'
+  s.add_development_dependency 'mocha-on-bacon'
+  s.add_development_dependency 'bacon-bits'
+  s.files = Dir.glob(%w[{lib,test}/**/*.rb bin/* [A-Z]*.{txt,rdoc} ext/**/*.{rb,c} **/deps.rip]) + %w{Rakefile .gemspec}
+  s.extra_rdoc_files = ["README.rdoc", "LICENSE.txt"]
+  s.license = 'MIT'
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/CHANGELOG.rdoc b/lib/brightbox-cli/vendor/hirb-0.3.5/CHANGELOG.rdoc
new file mode 100644
index 0000000..7a65e28
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/CHANGELOG.rdoc
@@ -0,0 +1,112 @@
+== 0.3.5
+* Add ripl support
+* Fix Formatter#determine_output_class for IO and Hash
+* Remove :output_method option for Hirb.enable
+* Allow rubygems 1.3.5
+
+== 0.3.4
+* Added auto format of array-like objects i.e. ActiveRecord::Relation and Set.
+* Fixed bug when Hirb::Console#table is used without Hirb enabled.
+* Fixed bug when hirb is running within cron and uses tput.
+
+== 0.3.3
+* Added ignore_errors option to ignore view errors and continue with original view.
+* Added support for array menu items.
+* Added support to ObjectTable for objects with an undefined :send method.
+
+== 0.3.2
+* Added irb autocompletions for bond.
+* Fixed tests for ruby 1.9.
+* Changed tests to use bacon.
+* Removed jeweler in Rakefile and pointless $LOAD_PATH manipulation.
+
+== 0.3.1
+* Bug fix on DynamicView.class_to_method to allow overrides of default views.
+* Modified mongo_mapper view to have _id first.
+
+== 0.3.0
+* Added dynamic views.
+* Added default table views for the following database classes/modules:
+  CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+  DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+  Mongoid::Document, Ripple::Document and Sequel::Model.
+* Added Hirb.add_view and Hirb.add_dynamic_view for easier view manipulation.
+* Added :multi_line_nodes option for Tree.
+* Fixed :change_fields option bug in Table.
+* Fixed no headers and nil fields bug in Table.
+* Removed deprecations in Hirb.config_file + View.enable.
+* Removed Views classes and View.format_class.
+* Removed :return_rows option for Table.
+
+== 0.2.10
+* Added multiple options to Menu, most importantly :two_d and :action.
+* Improved table resizing algorithm.
+* Added merging of configs for multiple Hirb.enable calls.
+* Added :max_fields, :hide_empty, :delete_callbacks, :resize, :header_filter
+  and :return_rows options to Table.
+* Added escaping for \t and \r in Table.
+* Renamed Table's :no_newlines option to :escape_special_chars.
+* Removed Table's :field_lengths option.
+* Removed Menu's :validate_one option.
+* Bug fix for table header of a basic array.
+* Deprecating Hirb.config_file + View.enable in next release.
+
+== 0.2.9
+* Added newline filtering and :no_newlines option for table helper.
+* Added default filters for hashes that have hash values.
+* Bug fix for deprecated to_a call.
+
+== 0.2.8
+* Added callbacks to Hirb::Helpers::Table.
+* Added :change_fields option to Hirb::Helpers::Table.
+* Added terminal size detection for jruby.
+* Bug fix for paging long outputs.
+* Bug fix to make unexpected hirb rendering errors more clear.
+
+== 0.2.7
+* 2 ruby 1.9 bug fixes.
+* Bug fix in :fields of Hirb::Helpers::ObjectTable.
+* Made :class option in Hirb::Formatter friendlier to external apps.
+
+== 0.2.6
+* Added :description option and added proc ability to :children_method option for helpers.
+* Bug fix for no ENV['HOME'] on Windows.
+* Bug fix on unaliasing output_method.
+* Bug fix on multiple renders of vertical table.
+
+== 0.2.5
+* Added ability to use Hirb.enable with non-irb ruby shells.
+* Helper configs now recursively merge when inheriting from others via :ancestor option.
+
+== 0.2.4
+* Bug fix on UTF-8 support.
+
+== 0.2.3
+* Added UTF-8 support for Ruby 1.8.x
+* Added :all_fields option to Table helper.
+
+== 0.2.2
+* Added a friendlier default (a vertical table) to incorrectly configured tables.
+* Added vertical table helper thanks to chrononaut.
+* Added detection of :select option from ActiveRecord queries in ActiveRecordTable helper.
+* Added handling anything that responds to :to_a in AutoTable helper.
+
+== 0.2.1
+* Fixed typo in Hirb::Console.view
+
+== 0.2.0
+* Major refactoring with bug fixes and better tests.
+* Improved table algorithm to ensure that tables don't wrap.
+* Added a pager which detects if output should be paged, Hirb::Pager.
+* Added a selection menu, Hirb::Menu
+* Following API changes: Hirb::Helpers::Table.max_width removed and config files don't use
+  the :view key anymore.
+== 0.1.2
+* Added tree views.
+* Added output_method option to Hirb::View.render_output.
+
+== 0.1.1
+* Fixed bug when rendering table with many fields.
+
+== 0.1.0
+* Initial release
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/LICENSE.txt b/lib/brightbox-cli/vendor/hirb-0.3.5/LICENSE.txt
new file mode 100644
index 0000000..5b44505
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/LICENSE.txt
@@ -0,0 +1,22 @@
+The MIT LICENSE
+
+Copyright (c) 2010 Gabriel Horner
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/README.rdoc b/lib/brightbox-cli/vendor/hirb-0.3.5/README.rdoc
new file mode 100644
index 0000000..1e86139
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/README.rdoc
@@ -0,0 +1,182 @@
+To read a linked version of this README, {click here}[http://tagaholic.me/hirb/doc/].
+
+== Description
+
+Hirb provides a mini view framework for console applications and uses it to improve irb's default inspect output.
+Given an object or array of objects, hirb renders a view based on the object's class and/or ancestry. Hirb offers reusable
+views in the form of helper classes. The two main helpers, Hirb::Helpers::Table and Hirb::Helpers::Tree, provide several options
+for generating ascii tables and trees. Using Hirb::Helpers::AutoTable, hirb has useful default views for at least ten popular database gems
+i.e. Rails' ActiveRecord::Base. Other than views, hirb offers a smart pager and a console menu. The smart pager
+only pages when the output exceeds the current screen size. The menu is used in conjunction with tables to offer
+{two dimensional menus}[http://tagaholic.me/2010/02/16/two-dimensional-console-menus-with-hirb.html].
+
+== Install
+
+Install the gem with:
+
+    sudo gem install hirb
+
+== View Tutorials
+
+* To create and configure views, see Hirb::View or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/View.html].
+* To create dynamic views, see Hirb::DynamicView or {here if on the web}[http://tagaholic.me/hirb/doc/classes/Hirb/DynamicView.html].
+
+== Printing Ascii Tables
+
+To print ascii tables from an array of arrays, hashes or any objects:
+
+  puts Hirb::Helpers::AutoTable.render(ARRAY_OF_OBJECTS)
+
+Hirb will intelligently pick up on field names from an array of hashes and create properly-aligned
+fields from an array of arrays. See
+{here}[http://tagaholic.me/2009/10/15/boson-and-hirb-interactions.html#hirbs_handy_tables] for examples.
+
+== Rails Example
+
+Let's load and enable the view framework:
+  $ script/console
+  Loading local environment (Rails 2.3.5)
+  >> require 'hirb'
+  => true
+  >> Hirb.enable
+  => nil
+
+The default configuration provides table views for ActiveRecord::Base descendants.
+If a class isn't configured, Hirb reverts to irb's default echo mode.
+  >> Hirb::Formatter.dynamic_config['ActiveRecord::Base']
+  => {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+
+  # Tag is a model class and descendant of ActiveRecord::Base
+  >> Tag.last
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | id  | created_at              | description | name          | namespace | predicate | value |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml | gem       | tags      | yaml  |
+  +-----+-------------------------+-------------+---------------+-----------+-----------+-------+
+  1 row in set
+
+  >> Hirb::Formatter.dynamic_config['String']
+  => nil
+  >> 'plain ol irb'
+  => 'plain ol irb'
+  >> Hirb::Formatter.dynamic_config['Symbol']
+  => nil
+  >> :blah
+  => :blah
+
+From above you can see there are no views configured for a String or a Symbol so Hirb defaults to
+irb's echo mode. On the other hand, Tag has a view thanks to being a descendant of ActiveRecord::Base
+and there being an :ancestor option.
+
+Having seen hirb display views based on an output object's class, let's see it handle an array of objects:
+
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | id  | created_at              | description | name              | namespace | predicate | value    |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  | 907 | 2009-03-06 21:10:41 UTC |             | gem:tags=yaml     | gem       | tags      | yaml     |
+  | 906 | 2009-03-06 08:47:04 UTC |             | gem:tags=nomonkey | gem       | tags      | nomonkey |
+  | 905 | 2009-03-04 00:30:10 UTC |             | article:tags=ruby | article   | tags      | ruby     |
+  +-----+-------------------------+-------------+-------------------+-----------+-----------+----------+
+  3 rows in set
+
+At any time you can disable Hirb if you really like irb's lovely echo mode:
+  >> Hirb.disable
+  => nil
+  >> Tag.all :limit=>3, :order=>"id DESC"
+  => [#<Tag id: 907, name: "gem:tags=yaml", description: nil, created_at: "2009-03-06 21:10:41",
+  namespace: "gem", predicate: "tags", value: "yaml">, #<Tag id: 906, name: "gem:tags=nomonkey",
+  description: nil, created_at: "2009-03-06 08:47:04", namespace: "gem", predicate: "tags", value:
+  "nomonkey">, #<Tag id: 905, name: "article:tags=ruby", description: nil, created_at: "2009-03-04
+  00:30:10", namespace: "article", predicate: "tags", value: "ruby">]
+
+== Views: Anytime, Anywhere
+While preconfigured tables are great for database records, sometimes you just want to create
+tables/views for any output object:
+  
+  #These examples don't need to have Hirb::View enabled.
+  >> Hirb.disable
+  => nil
+
+  # Imports table() and view()
+  >> extend Hirb::Console
+  => main
+
+  # Create a table of Dates comparing them with different formats.
+  >> table [Date.today, Date.today.next_month], :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+  +------------+--------+-----------+-------+--------------------------+
+  | to_s       | ld     | ajd       | amjd  | asctime                  |
+  +------------+--------+-----------+-------+--------------------------+
+  | 2009-03-11 | 155742 | 4909803/2 | 54901 | Wed Mar 11 00:00:00 2009 |
+  | 2009-04-11 | 155773 | 4909865/2 | 54932 | Sat Apr 11 00:00:00 2009 |
+  +------------+--------+-----------+-------+--------------------------+
+  2 rows in set
+
+  # Same table as the previous method. However view() will be able to call any helper.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+If these console methods weren't convenient enough, try:
+
+  # Imports view() to all objects.
+  >> require 'hirb/import_object'
+  =>true
+  # Yields same table as above examples.
+  >> [Date.today, Date.today.next_month].view :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+Although views by default are printed to STDOUT, they can be easily modified to write anywhere:
+  # Setup views to write to file 'console.log'.
+  >> Hirb::View.render_method = lambda {|output| File.open("console.log", 'w') {|f| f.write(output) } }
+
+  # Writes to file with same table output as above example.
+  >> view [Date.today, Date.today.next_month], :class=>:object_table,
+    :fields=>[:to_s, :ld, :ajd, :amjd, :asctime]
+
+  # Doesn't write to file because Symbol doesn't have a view and thus defaults to irb's echo mode.
+  >> :blah
+  =>:blah
+
+  # Go back to printing Hirb views to STDOUT.
+  >> Hirb::View.reset_render_method
+
+== Pager
+
+Hirb has both pager and formatter functionality enabled by default.
+If you want to turn off the functionality of either you can pass that in at startup:
+
+  Hirb.enable :pager=>false
+  Hirb.enable :formatter=>false
+
+or toggle their state at runtime:
+
+  Hirb::View.toggle_pager
+  Hirb::View.toggle_formatter
+
+== Sharing Helpers and Views
+If you have tested helpers you'd like to share, fork Hirb and put them under lib/hirb/helpers. To share
+views for certain classes, put them under lib/hirb/views. Please submit views for gems that have a nontrivial
+number of users.
+
+== Limitations
+If using Wirble, you should call Hirb after it since they both override irb's default output.
+
+== Motivation
+Table code from http://gist.github.com/72234 and {my console app's needs}[http://github.com/cldwalker/tag-tree].
+
+== Credits
+* Chrononaut for vertical table helper.
+* crafterm, spastorino, xaviershay, bogdan and joshua for patches.
+
+== Bugs/Issues
+Please report them {on github}[http://github.com/cldwalker/hirb/issues].
+
+== Links
+* http://tagaholic.me/2009/03/13/hirb-irb-on-the-good-stuff.html
+* http://tagaholic.me/2009/03/18/ruby-class-trees-rails-plugin-trees-with-hirb.html
+* http://tagaholic.me/2009/06/19/page-irb-output-and-improve-ri-with-hirb.html
+
+== Todo
+* Consider generating views based on methods an object responds to.
+* Provide helper methods to all views.
+* Consider adding a template helper.
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/Rakefile b/lib/brightbox-cli/vendor/hirb-0.3.5/Rakefile
new file mode 100644
index 0000000..a88c05a
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/Rakefile
@@ -0,0 +1,35 @@
+require 'rake'
+require 'fileutils'
+
+def gemspec
+  @gemspec ||= eval(File.read('.gemspec'), binding, '.gemspec')
+end
+
+desc "Build the gem"
+task :gem=>:gemspec do
+  sh "gem build .gemspec"
+  FileUtils.mkdir_p 'pkg'
+  FileUtils.mv "#{gemspec.name}-#{gemspec.version}.gem", 'pkg'
+end
+
+desc "Install the gem locally"
+task :install => :gem do
+  sh %{gem install pkg/#{gemspec.name}-#{gemspec.version}}
+end
+
+desc "Generate the gemspec"
+task :generate do
+  puts gemspec.to_ruby
+end
+
+desc "Validate the gemspec"
+task :gemspec do
+  gemspec.validate
+end
+
+desc 'Run tests'
+task :test do |t|
+  sh 'bacon -q -Ilib -I. test/*_test.rb'
+end
+
+task :default => :test
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
new file mode 100644
index 0000000..ca9a642
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/bond/completions/hirb.rb
@@ -0,0 +1,15 @@
+complete(:methods=>%w{Hirb::View.enable Hirb.enable}) {
+  %w{config_file output_method output width height formatter pager pager_command}
+}
+complete(:methods=>%w{Hirb::Helpers::Table.render table}) {
+  %w{fields headers max_fields max_width resize number change_fields}+
+  %w{filters header_filter filter_any filter_classes vertical all_fields}+
+  %w{description escape_special_chars table_class hide_empty}
+}
+complete(:method=>"Hirb::Helpers::Tree.render") {
+  %w{type validate indent limit description multi_line_nodes value_method children_method}
+}
+complete(:methods=>%w{Hirb::Menu.render menu}) {
+  %w{helper_class prompt ask directions readline two_d default_field action multi_action} +
+    %w{action_object command reopen}
+}
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb.rb
new file mode 100644
index 0000000..e3f77ab
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb.rb
@@ -0,0 +1,81 @@
+# Needed by Hirb::String to handle multibyte characters
+$KCODE = 'u' if RUBY_VERSION < '1.9'
+
+require 'hirb/util'
+require 'hirb/string'
+require 'hirb/formatter' # must come before helpers/auto_table
+require 'hirb/dynamic_view'
+require 'hirb/helpers'
+require 'hirb/views'
+require 'hirb/view'
+require 'hirb/console'
+require 'hirb/pager'
+require 'hirb/menu'
+require 'hirb/version'
+
+# Most of Hirb's functionality is in Hirb::View.
+# For a tutorial  on configuring and creating views see Hirb::View. For a tutorial on dynamic views see Hirb::DynamicView.
+#
+# == Config Files
+# Hirb can have multiple config files defined by config_files(). These config files
+# have the following top level keys:
+# [*:output*] This hash is used by the formatter object. See Hirb::Formatter.config for its format.
+# [*:width*]  Width of the terminal/console. Defaults to Hirb::View::DEFAULT_WIDTH or possibly autodetected when Hirb is enabled.
+# [*:height*]  Height of the terminal/console. Defaults to Hirb::View::DEFAULT_HEIGHT or possibly autodetected when Hirb is enabled.
+# [*:formatter*] Boolean which determines if the formatter is enabled. Defaults to true.
+# [*:pager*] Boolean which determines if the pager is enabled. Defaults to true.
+# [*:pager_command*] Command to be used for paging. Command can have options after it i.e. 'less -r'.
+#                    Defaults to common pagers i.e. less and more if detected.
+# [*:ignore_errors*] Boolean which ignores internal view errors and continues with original view
+#                    (i.e. #inspect for irb). Defaults to false.
+module Hirb
+  class <<self
+    attr_accessor :config_files, :config
+
+    # Enables view functionality. See Hirb::View.enable for details.
+    def enable(options={}, &block)
+      View.enable(options, &block)
+    end
+
+    # Disables view functionality. See Hirb::View.disable for details.
+    def disable
+      View.disable
+    end
+
+    # Adds views. See Hirb::View.add for details.
+    def add_view(view, options, &block)
+      View.add(view, options, &block)
+    end
+
+    # Adds views. See Hirb::DynamicView.add for details.
+    def add_dynamic_view(view, options, &block)
+      DynamicView.add(view, options, &block)
+    end
+
+    # Array of config files which are merged sequentially to produce config.
+    # Defaults to config/hirb.yml and ~/.hirb_yml
+    def config_files
+      @config_files ||= default_config_files
+    end
+
+    #:stopdoc:
+    def default_config_files
+      [File.join(Util.find_home, ".hirb.yml")] +
+        (File.exists?('config/hirb.yml') ? ['config/hirb.yml'] : [])
+    end
+
+    def read_config_file(file=config_file)
+      File.exists?(file) ? YAML::load_file(file) : {}
+    end
+
+    def config(reload=false)
+      if (@config.nil? || reload)
+        @config = config_files.inject({}) {|acc,e|
+          Util.recursive_hash_merge(acc,read_config_file(e))
+        }
+      end
+      @config
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/console.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/console.rb
new file mode 100644
index 0000000..fefb134
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/console.rb
@@ -0,0 +1,43 @@
+module Hirb
+  # This module is meant to be extended to provide methods for use in a console/irb shell.
+  # For example:
+  #    >> extend Hirb::Console
+  #    >> view 'some string', :class=>Some::String::Formatter
+  #    >> table [[:row1], [:row2]]
+  module Console
+    class<<self
+      # A console version of render_output() which takes its same options but allows for shorthand. All options are passed to
+      # the helper except for the formatter options. Formatter options are :class, :method and :output_method.
+      # Examples:
+      #   render_output output, :class=>:tree :type=>:directory
+      #   # is the same as:
+      #   render_output output, :class=>:tree, :options=> {:type=>:directory}
+      #
+      def render_output(output, options={})
+        View.load_config unless View.config_loaded?
+        View.render_output(output, options.merge(:console=>true))
+      end
+
+      # Takes same arguments and options as render_output() but returns formatted output instead of rendering it.
+      def format_output(output, options={}, &block)
+        View.load_config unless View.config_loaded?
+        View.formatter.format_output(output, options.merge(:console=>true), &block)
+      end
+    end
+
+    # Renders a table for the given object. Takes same options as Hirb::Helpers::Table.render.
+    def table(output, options={})
+      Console.render_output(output, options.merge(:class=>"Hirb::Helpers::AutoTable"))
+    end
+
+    # Renders any specified view for the given object. Takes same options as Hirb::View.render_output.
+    def view(output, options={})
+      Console.render_output(output, options)
+    end
+
+    # Renders a menu given an array using Hirb::Menu.render.
+    def menu(output, options={}, &block)
+      Console.format_output(output, options.merge(:class=>"Hirb::Menu"), &block)
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
new file mode 100644
index 0000000..31929f6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/dynamic_view.rb
@@ -0,0 +1,113 @@
+module Hirb
+  # This module extends a Helper with the ability to have dynamic views for configured output classes.
+  # After a Helper has extended this module, it can use it within a render() by calling
+  # dynamic_options() to get dynamically generated options for the object it's rendering. See Hirb::Helpers::AutoTable as an example.
+  #
+  # == Dynamic Views
+  # Whereas normal views are generated from helpers with static helper options, dynamic views are generated from helpers and
+  # dynamically generated helper options. Let's look at an example for Rails' ActiveRecord classes:
+  #
+  #   Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj|
+  #    {:fields=>obj.class.column_names} }
+  #
+  # From this dynamic view definition, _any_ ActiveRecord model class will render a table with the correct fields, since the fields
+  # are extracted from the output object's class at runtime. Note that dynamic view definitions should return a hash of helper options.
+  #
+  # To define multiple dynamic views, create a Views module where each method ending in '\_view' maps to a class/module:
+  #
+  #   module Hirb::Views::ORM
+  #     def data_mapper__resource_view(obj)
+  #       {:fields=>obj.class.properties.map {|e| e.name }}
+  #     end
+  #
+  #     def sequel__model_view(obj)
+  #       {:fields=>obj.class.columns}
+  #     end
+  #   end
+  #
+  #   Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+  #
+  # In this example, 'data_mapper__resource_view' maps to DataMapper::Resource and 'sequel__model_view' maps to Sequel::Model.
+  # Note that when mapping method names to class names, '__' maps to '::' and '_' signals the next letter to be capitalized.
+  module DynamicView
+    # Add dynamic views to output class(es) for a given helper. If defining one view, the first argument is the output class
+    # and a block defines the dynamic view. If defining multiple views, the first argument should be a Views::* module where
+    # each method in the module ending in _view defines a view for an output class. To map output classes to method names in
+    # a Views module, translate'::' to '__' and a capital letter translates to a '_' and a lowercase letter.
+    # ==== Options:
+    # [*:helper*] Required option. Helper class that view(s) use to format. Hirb::Helpers::AutoTable is the only valid
+    #             helper among default helpers. Can be given in aliased form i.e. :auto_table -> Hirb::Helpers::AutoTable.
+    #
+    # Examples:
+    #    Hirb.add_dynamic_view Hirb::Views::ORM, :helper=>:auto_table
+    #    Hirb.add_dynamic_view("ActiveRecord::Base", :helper=>:auto_table) {|obj| {:fields=>obj.class.column_names} }
+    def self.add(view, options, &block)
+      raise ArgumentError, ":helper option is required" unless options[:helper]
+      helper = Helpers.helper_class options[:helper]
+      unless helper.is_a?(Module) && class << helper; self.ancestors; end.include?(self)
+        raise ArgumentError, ":helper option must be a helper that has extended DynamicView"
+      end
+      mod = block ? generate_single_view_module(view, &block) : view
+      raise ArgumentError, "'#{mod}' must be a module" unless mod.is_a?(Module)
+      helper.add_module mod
+    end
+
+    def self.generate_single_view_module(output_mod, &block) #:nodoc:
+      meth = class_to_method output_mod.to_s
+      view_mod = meth.capitalize
+      Views::Single.send(:remove_const, view_mod) if Views::Single.const_defined?(view_mod)
+      mod = Views::Single.const_set(view_mod, Module.new)
+      mod.send(:define_method, meth, block)
+      mod
+    end
+
+    def self.class_to_method(mod) #:nodoc:
+      mod.gsub(/(?!^)([A-Z])/) {|e| '_'+e }.gsub('::_', '__').downcase + '_view'
+    end
+
+    # Returns a hash of options based on dynamic views defined for the object's ancestry. If no config is found returns nil.
+    def dynamic_options(obj)
+      view_methods.each do |meth|
+        if obj.class.ancestors.map {|e| e.to_s }.include?(method_to_class(meth))
+          begin
+            return send(meth, obj)
+          rescue
+            raise "View failed to generate for '#{method_to_class(meth)}' "+
+              "while in '#{meth}' with error:\n#{$!.message}"
+          end
+        end
+      end
+      nil
+    end
+
+    #:stopdoc:
+    def add_module(mod)
+      new_methods = mod.instance_methods.select {|e| e.to_s =~ /_view$/ }.map {|e| e.to_s}
+      return if new_methods.empty?
+      extend mod
+      view_methods.replace(view_methods + new_methods).uniq!
+      update_config(new_methods)
+    end
+
+    def update_config(meths)
+      output_config = meths.inject({}) {|t,e|
+        t[method_to_class(e)] = {:class=>self, :ancestor=>true}; t
+      }
+      Formatter.dynamic_config.merge! output_config
+    end
+
+    def method_to_class(meth)
+      view_method_classes[meth] ||= Util.camelize meth.sub(/_view$/, '').gsub('__', '/')
+    end
+
+    def view_method_classes
+      @view_method_classes ||= {}
+    end
+    #:startdoc:
+
+    # Stores view methods that a Helper has been given via DynamicView.add
+    def view_methods
+      @view_methods ||= []
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/formatter.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/formatter.rb
new file mode 100644
index 0000000..df1269a
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/formatter.rb
@@ -0,0 +1,119 @@
+module Hirb
+  # A Formatter object formats an output object (using Formatter.format_output) into a string based on the views defined
+  # for its class and/or ancestry.
+  class Formatter
+    TO_A_EXCEPTIONS = ['Hash', 'IO']
+
+    class<<self
+      # This config is used by Formatter.format_output to lazily load dynamic views defined with Hirb::DynamicView.
+      # This hash has the same format as Formatter.config.
+      attr_accessor :dynamic_config
+    end
+    self.dynamic_config = {}
+
+    def initialize(additional_config={}) #:nodoc:
+      @klass_config = {}
+      @config = additional_config || {}
+    end
+
+    # A hash of Ruby class strings mapped to view hashes. A view hash must have at least a :method, :output_method
+    # or :class option for a view to be applied to an output. A view hash has the following keys:
+    # [*:method*] Specifies a global (Kernel) method to do the formatting.
+    # [*:class*] Specifies a class to do the formatting, using its render() class method. If a symbol it's converted to a corresponding
+    #            Hirb::Helpers::* class if it exists.
+    # [*:output_method*] Specifies a method or proc to call on output before passing it to a helper. If the output is an array, it's applied
+    #                    to every element in the array.
+    # [*:options*] Options to pass the helper method or class.
+    # [*:ancestor*] Boolean which when true causes subclasses of the output class to inherit its config. This doesn't effect the current
+    #               output class. Defaults to false. This is used by ActiveRecord classes.
+    # 
+    #   Examples:
+    #     {'WWW::Delicious::Element'=>{:class=>'Hirb::Helpers::ObjectTable', :ancestor=>true, :options=>{:max_width=>180}}}
+    #     {'Date'=>{:class=>:auto_table, :ancestor=>true}}
+    #     {'Hash'=>{:method=>:puts}}
+    def config
+      @config
+    end
+
+    # Adds the view for the given class and view hash config. See Formatter.config for valid keys for view hash.
+    def add_view(klass, view_config)
+      @klass_config.delete(klass)
+      @config[klass.to_s] = view_config
+      true
+    end
+
+    # This method looks for an output object's view in Formatter.config and then Formatter.dynamic_config.
+    # If a view is found, a stringified view is returned based on the object. If no view is found, nil is returned. The options this
+    # class takes are a view hash as described in Formatter.config. These options will be merged with any existing helper
+    # config hash an output class has in Formatter.config. Any block given is passed along to a helper class.
+    def format_output(output, options={}, &block)
+      output_class = determine_output_class(output)
+      options = parse_console_options(options) if options.delete(:console)
+      options = Util.recursive_hash_merge(klass_config(output_class), options)
+      _format_output(output, options, &block)
+    end
+
+    #:stopdoc:
+    def _format_output(output, options, &block)
+      output = options[:output_method] ? (output.is_a?(Array) ?
+        output.map {|e| call_output_method(options[:output_method], e) } :
+        call_output_method(options[:output_method], output) ) : output
+      args = [output]
+      args << options[:options] if options[:options] && !options[:options].empty?
+      if options[:method]
+        send(options[:method],*args)
+      elsif options[:class] && (helper_class = Helpers.helper_class(options[:class]))
+        helper_class.render(*args, &block)
+      elsif options[:output_method]
+        output
+      end
+    end
+
+    def parse_console_options(options) #:nodoc:
+      real_options = [:method, :class, :output_method].inject({}) do |h, e|
+        h[e] = options.delete(e) if options[e]; h
+      end
+      real_options.merge! :options=>options
+    end
+
+    def determine_output_class(output)
+      output.respond_to?(:to_a) && !TO_A_EXCEPTIONS.include?(output.class.to_s) ?
+        Array(output)[0].class : output.class
+    end
+
+    def call_output_method(output_method, output)
+      output_method.is_a?(Proc) ? output_method.call(output) : output.send(output_method)
+    end
+
+    # Internal view options built from user-defined ones. Options are built by recursively merging options from oldest
+    # ancestors to the most recent ones.
+    def klass_config(output_class)
+      @klass_config[output_class] ||= build_klass_config(output_class)
+    end
+
+    def build_klass_config(output_class)
+      output_ancestors = output_class.ancestors.map {|e| e.to_s}.reverse
+      output_ancestors.pop
+      hash = output_ancestors.inject({}) {|h, klass|
+        add_klass_config_if_true(h, klass) {|c,klass| c[klass] && c[klass][:ancestor] }
+      }
+      add_klass_config_if_true(hash, output_class.to_s) {|c,klass| c[klass] }
+    end
+
+    def add_klass_config_if_true(hash, klass)
+      if yield(@config, klass)
+        Util.recursive_hash_merge hash, @config[klass]
+      elsif yield(self.class.dynamic_config, klass)
+        @config[klass] = self.class.dynamic_config[klass].dup # copy to local
+        Util.recursive_hash_merge hash, self.class.dynamic_config[klass]
+      else
+        hash
+      end
+    end
+
+    def reset_klass_config
+      @klass_config = {}
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers.rb
new file mode 100644
index 0000000..4c8bbd6
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers.rb
@@ -0,0 +1,17 @@
+module Hirb
+  module Helpers #:nodoc:
+    @helper_classes ||= {}
+    def self.helper_class(klass)
+      @helper_classes[klass.to_s] ||= begin
+        if (helper_class = constants.find {|e| e.to_s == Util.camelize(klass.to_s)})
+          klass = "Hirb::Helpers::#{helper_class}"
+        end
+        Util.any_const_get(klass)
+      end
+    end
+  end
+end
+
+%w{table object_table auto_table tree parent_child_tree vertical_table}.each do |e|
+  require "hirb/helpers/#{e}"
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
new file mode 100644
index 0000000..ed31357
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/auto_table.rb
@@ -0,0 +1,24 @@
+# This helper wraps around the other table helpers i.e. Hirb::Helpers::Table while
+# providing default helper options via Hirb::DynamicView. Using these default options, this
+# helper supports views for the following modules/classes:
+# ActiveRecord::Base, CouchFoo::Base, CouchPotato::Persistence, CouchRest::ExtendedDocument,
+# DBI::Row, DataMapper::Resource, Friendly::Document, MongoMapper::Document, MongoMapper::EmbeddedDocument,
+# Mongoid::Document, Ripple::Document, Sequel::Model.
+class Hirb::Helpers::AutoTable < Hirb::Helpers::Table
+  extend Hirb::DynamicView
+
+  # Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:table_class] Explicit table class to use for rendering. Defaults to
+  #                Hirb::Helpers::ObjectTable if output is not an Array or Hash. Otherwise
+  #                defaults to Hirb::Helpers::Table.
+  def self.render(output, options={})
+    output = Array(output)
+    (defaults = dynamic_options(output[0])) && (options = defaults.merge(options))
+    klass = options.delete(:table_class) || (
+      !(output[0].is_a?(Hash) || output[0].is_a?(Array)) ?
+      Hirb::Helpers::ObjectTable : Hirb::Helpers::Table)
+    klass.render(output, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
new file mode 100644
index 0000000..6227dac
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/object_table.rb
@@ -0,0 +1,14 @@
+class Hirb::Helpers::ObjectTable < Hirb::Helpers::Table
+  # Rows are any ruby objects. Takes same options as Hirb::Helpers::Table.render except as noted below.
+  #
+  # ==== Options:
+  # [:fields] Methods of the object to represent as columns. Defaults to [:to_s].
+  def self.render(rows, options ={})
+    options[:fields] ||= [:to_s]
+    options[:headers] ||= {:to_s=>'value'} if options[:fields] == [:to_s]
+    item_hashes = options[:fields].empty? ? [] : Array(rows).inject([]) {|t,item|
+      t << options[:fields].inject({}) {|h,f| h[f] = item.__send__(f); h}
+    }
+    super(item_hashes, options)
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
new file mode 100644
index 0000000..d056057
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/parent_child_tree.rb
@@ -0,0 +1,24 @@
+class Hirb::Helpers::ParentChildTree < Hirb::Helpers::Tree
+  class <<self
+    # Starting with the given node, this builds a tree by recursively calling a children method.
+    # Takes same options as Hirb::Helper::Table.render with some additional ones below.
+    # ==== Options:
+    # [:value_method] Method or proc to call to display as a node's value. If not given, uses :name if node
+    #                 responds to :name or defaults to :object_id.
+    # [:children_method] Method or proc to call to obtain a node's children. Default is :children.
+    def render(root_node, options={})
+      value_method = options[:value_method] || (root_node.respond_to?(:name) ? :name : :object_id)
+      @value_method = value_method.is_a?(Proc) ? value_method : lambda {|n| n.send(value_method) }
+      children_method = options[:children_method] || :children
+      @children_method = children_method.is_a?(Proc) ? children_method : lambda {|n| n.send(children_method)}
+      @nodes = []
+      build_node(root_node, 0)
+      super(@nodes, options)
+    end
+
+    def build_node(node, level) #:nodoc:
+      @nodes << {:value=>@value_method.call(node), :level=>level}
+      @children_method.call(node).each {|e| build_node(e, level + 1)}
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
new file mode 100644
index 0000000..de51309
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table.rb
@@ -0,0 +1,323 @@
+require 'hirb/helpers/table/filters'
+require 'hirb/helpers/table/resizer'
+
+module Hirb
+# Base Table class from which other table classes inherit.
+# By default, a table is constrained to a default width but this can be adjusted
+# via the max_width option or Hirb::View.width.
+# Rows can be an array of arrays or an array of hashes.
+#
+# An array of arrays ie [[1,2], [2,3]], would render:
+#   +---+---+
+#   | 0 | 1 |
+#   +---+---+
+#   | 1 | 2 |
+#   | 2 | 3 |
+#   +---+---+
+#
+# By default, the fields/columns are the numerical indices of the array.
+# 
+# An array of hashes ie [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], would render:
+#   +-----+--------+
+#   | age | weight |
+#   +-----+--------+
+#   | 10  | 100    |
+#   | 80  | 500    |
+#   +-----+--------+
+#
+# By default, the fields/columns are the keys of the first hash.
+#
+# === Custom Callbacks
+# Callback methods can be defined to add your own options that modify rows right before they are rendered.
+# Here's an example that allows for searching with a :query option:
+#   module Query
+#     # Searches fields given a query hash
+#     def query_callback(rows, options)
+#       return rows unless options[:query]
+#       options[:query].map {|field,query|
+#         rows.select {|e| e[field].to_s =~ /#{query}/i }
+#       }.flatten.uniq
+#     end
+#   end
+#   Hirb::Helpers::Table.send :include, Query
+#
+#   >> puts Hirb::Helpers::Table.render [{:name=>'batman'}, {:name=>'robin'}], :query=>{:name=>'rob'}
+#   +-------+
+#   | name  |
+#   +-------+
+#   | robin |
+#   +-------+
+#   1 row in set
+#
+# Callback methods:
+# * must be defined in Helpers::Table and end in '_callback'.
+# * should expect rows and a hash of render options. Rows will be an array of hashes.
+# * are expected to return an array of hashes.
+# * are invoked in alphabetical order.
+# For a thorough example, see {Boson::Pipe}[http://github.com/cldwalker/boson/blob/master/lib/boson/pipe.rb].
+#--
+# derived from http://gist.github.com/72234
+ class Helpers::Table
+  BORDER_LENGTH = 3 # " | " and "-+-" are the borders
+  MIN_FIELD_LENGTH = 3
+  class TooManyFieldsForWidthError < StandardError; end
+
+  class << self
+    
+    # Main method which returns a formatted table.
+    # ==== Options:
+    # [*:fields*] An array which overrides the default fields and can be used to indicate field order.
+    # [*:headers*] A hash of fields and their header names. Fields that aren't specified here default to their name.
+    #              When set to false, headers are hidden. Can also be an array but only for array rows.
+    # [*:max_fields*] A hash of fields and their maximum allowed lengths. Maximum length can also be a percentage of the total width
+    #                 (decimal less than one). When a field exceeds it's maximum then it's
+    #                 truncated and has a ... appended to it. Fields that aren't specified have no maximum.
+    # [*:max_width*] The maximum allowed width of all fields put together including field borders. Only valid when :resize is true.
+    #                Default is Hirb::View.width.
+    # [*:resize*] Resizes table to display all columns in allowed :max_width. Default is true. Setting this false will display the full
+    #             length of each field.
+    # [*:number*] When set to true, numbers rows by adding a :hirb_number column as the first column. Default is false.
+    # [*:change_fields*] A hash to change old field names to new field names. This can also be an array of new names but only for array rows.
+    #                    This is useful when wanting to change auto-generated keys to more user-friendly names i.e. for array rows.
+    # [*:filters*] A hash of fields and their filters, applied to every row in a field. A filter can be a proc, an instance method
+    #              applied to the field value or a Filters method. Also see the filter_classes attribute below.
+    # [*:header_filter*] A filter, like one in :filters, that is applied to all headers after the :headers option.
+    # [*:filter_any*] When set to true, any cell defaults to being filtered by its class in :filter_classes.
+    #                 Default Hirb::Helpers::Table.filter_any().
+    # [*:filter_classes*] Hash which maps classes to filters. Default is Hirb::Helpers::Table.filter_classes().
+    # [*:vertical*] When set to true, renders a vertical table using Hirb::Helpers::VerticalTable. Default is false.
+    # [*:all_fields*] When set to true, renders fields in all rows. Valid only in rows that are hashes. Default is false.
+    # [*:description*] When set to true, renders row count description at bottom. Default is true.
+    # [*:escape_special_chars*] When set to true, escapes special characters \n,\t,\r so they don't disrupt tables. Default is false for
+    #                           vertical tables and true for anything else.
+    # Examples:
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]]
+    #    Hirb::Helpers::Table.render [[1,2], [2,3]], :max_fields=>{0=>10}, :header_filter=>:capitalize
+    #    Hirb::Helpers::Table.render [['a',1], ['b',2]], :change_fields=>%w{letters numbers}, :max_fields=>{'numbers'=>0.4}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}]
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :headers=>{:weight=>"Weight(lbs)"}
+    #    Hirb::Helpers::Table.render [{:age=>10, :weight=>100}, {:age=>80, :weight=>500}], :filters=>{:age=>[:to_f]}
+    def render(rows, options={})
+      options[:vertical] ? Helpers::VerticalTable.render(rows, options) :
+      new(rows, options).render
+    rescue TooManyFieldsForWidthError
+      $stderr.puts "", "** Error: Too many fields for the current width. Configure your width " +
+        "and/or fields to avoid this error. Defaulting to a vertical table. **"
+      Helpers::VerticalTable.render(rows, options)
+    end
+
+    # A hash which maps a cell value's class to a filter. This serves to set a default filter per field if all of its
+    # values are a class in this hash. By default, Array values are comma joined and Hashes are inspected.
+    # See the :filter_any option to apply this filter per value.
+    attr_accessor :filter_classes
+    # Boolean which sets the default for :filter_any option.
+    attr_accessor :filter_any
+    # Holds last table object created
+    attr_accessor :last_table
+  end
+  self.filter_classes = { Array=>:comma_join, Hash=>:inspect }
+
+  #:stopdoc:
+  attr_accessor :width, :max_fields, :field_lengths, :fields
+  def initialize(rows, options={})
+    raise ArgumentError, "Table must be an array of hashes or array of arrays" unless rows.is_a?(Array) &&
+      (rows[0].is_a?(Hash) or rows[0].is_a?(Array) or rows.empty?)
+    @options = {:description=>true, :filters=>{}, :change_fields=>{}, :escape_special_chars=>true,
+      :filter_any=>Helpers::Table.filter_any, :resize=>true}.merge(options)
+    @fields = set_fields(rows)
+    @rows = set_rows(rows)
+    @headers = set_headers
+    if @options[:number]
+      @headers[:hirb_number] = "number"
+      @fields.unshift :hirb_number
+    end
+    Helpers::Table.last_table = self
+  end
+
+  def set_fields(rows)
+    @options[:change_fields] = array_to_indices_hash(@options[:change_fields]) if @options[:change_fields].is_a?(Array)
+    return @options[:fields].dup if @options[:fields]
+
+    fields = if rows[0].is_a?(Hash)
+      keys = @options[:all_fields] ? rows.map {|e| e.keys}.flatten.uniq : rows[0].keys
+      keys.sort {|a,b| a.to_s <=> b.to_s}
+    else
+      rows[0].is_a?(Array) ? (0..rows[0].length - 1).to_a : []
+    end
+
+    @options[:change_fields].each do |oldf, newf|
+      (index = fields.index(oldf)) && fields[index] = newf
+    end
+    fields
+  end
+
+  def set_rows(rows)
+    rows = Array(rows)
+    if rows[0].is_a?(Array)
+      rows = rows.inject([]) {|new_rows, row|
+        new_rows << array_to_indices_hash(row)
+      }
+    end
+    @options[:change_fields].each do |oldf, newf|
+      rows.each {|e| e[newf] = e.delete(oldf) if e.key?(oldf) }
+    end
+    rows = filter_values(rows)
+    rows.each_with_index {|e,i| e[:hirb_number] = (i + 1).to_s} if @options[:number]
+    deleted_callbacks = Array(@options[:delete_callbacks]).map {|e| "#{e}_callback" }
+    (methods.grep(/_callback$/).map {|e| e.to_s} - deleted_callbacks).sort.each do |meth|
+      rows = send(meth, rows, @options.dup)
+    end
+    validate_values(rows)
+    rows
+  end
+
+  def set_headers
+    headers = @fields.inject({}) {|h,e| h[e] = e.to_s; h}
+    if @options.has_key?(:headers)
+      headers = @options[:headers].is_a?(Hash) ? headers.merge(@options[:headers]) :
+        (@options[:headers].is_a?(Array) ? array_to_indices_hash(@options[:headers]) : @options[:headers])
+    end
+    if @options[:header_filter]
+      headers.each {|k,v|
+        headers[k] = call_filter(@options[:header_filter], v)
+      }
+    end
+    headers
+  end
+
+  def render
+    body = []
+    unless @rows.length == 0
+      setup_field_lengths
+      body += render_header
+      body += render_rows
+      body += render_footer
+    end
+    body << render_table_description if @options[:description]
+    body.join("\n")
+  end
+
+  def render_header
+    @headers ? render_table_header : [render_border]
+  end
+
+  def render_footer
+    [render_border]
+  end
+
+  def render_table_header
+    title_row = '| ' + @fields.map {|f|
+      format_cell(@headers[f], @field_lengths[f])
+    }.join(' | ') + ' |'
+    [render_border, title_row, render_border]
+  end
+  
+  def render_border
+    '+-' + @fields.map {|f| '-' * @field_lengths[f] }.join('-+-') + '-+'
+  end
+  
+  def format_cell(value, cell_width)
+    text = String.size(value) > cell_width ?
+      (
+      (cell_width < 5) ? String.slice(value, 0, cell_width) : String.slice(value, 0, cell_width - 3) + '...'
+      ) : value
+    String.ljust(text, cell_width)
+  end
+
+  def render_rows
+    @rows.map do |row|
+      row = '| ' + @fields.map {|f|
+        format_cell(row[f], @field_lengths[f])
+      }.join(' | ') + ' |'
+    end
+  end
+  
+  def render_table_description
+    (@rows.length == 0) ? "0 rows in set" :
+      "#{@rows.length} #{@rows.length == 1 ? 'row' : 'rows'} in set"
+  end
+  
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+    if @options[:resize]
+      raise TooManyFieldsForWidthError if @fields.size > self.actual_width.to_f / MIN_FIELD_LENGTH
+      Resizer.resize!(self)
+    else
+      enforce_field_constraints
+    end
+  end
+
+  def enforce_field_constraints
+    max_fields.each {|k,max| @field_lengths[k] = max if @field_lengths[k].to_i > max }
+  end
+
+  def max_fields
+    @max_fields ||= (@options[:max_fields] ||= {}).each {|k,v|
+      @options[:max_fields][k] = (actual_width * v.to_f.abs).floor if v.to_f.abs < 1
+    }
+  end
+
+  def actual_width
+    @actual_width ||= self.width - (@fields.size * BORDER_LENGTH + 1)
+  end
+
+  def width
+    @width ||= @options[:max_width] || View.width
+  end
+
+  # find max length for each field; start with the headers
+  def default_field_lengths
+    field_lengths = @headers ? @headers.inject({}) {|h,(k,v)| h[k] = String.size(v); h} :
+      @fields.inject({}) {|h,e| h[e] = 1; h }
+    @rows.each do |row|
+      @fields.each do |field|
+        len = String.size(row[field])
+        field_lengths[field] = len if len > field_lengths[field].to_i
+      end
+    end
+    field_lengths
+  end
+
+  def set_filter_defaults(rows)
+    @filter_classes.each do |klass, filter|
+      @fields.each {|field|
+        if rows.all? {|r| r[field].class == klass }
+          @options[:filters][field] ||= filter
+        end
+      }
+    end
+  end
+
+  def filter_values(rows)
+    @filter_classes = Helpers::Table.filter_classes.merge @options[:filter_classes] || {}
+    set_filter_defaults(rows) unless @options[:filter_any]
+    rows.map {|row|
+      @fields.inject({}) {|new_row,f|
+        (filter = @options[:filters][f]) || (@options[:filter_any] && (filter = @filter_classes[row[f].class]))
+        new_row[f] = filter ? call_filter(filter, row[f]) : row[f]
+        new_row
+      }
+    }
+  end
+
+  def call_filter(filter, val)
+    filter.is_a?(Proc) ? filter.call(val) :
+      val.respond_to?(Array(filter)[0]) ? val.send(*filter) : Filters.send(filter, val)
+  end
+
+  def validate_values(rows)
+    rows.each {|row|
+      @fields.each {|f|
+        row[f] = row[f].to_s || ''
+        row[f] = row[f].gsub(/(\t|\r|\n)/) {|e| e.dump.gsub('"','') } if @options[:escape_special_chars]
+      }
+    }
+  end
+  
+  # Converts an array to a hash mapping a numerical index to its array value.
+  def array_to_indices_hash(array)
+    array.inject({}) {|hash,e|  hash[hash.size] = e; hash }
+  end
+  #:startdoc:
+end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
new file mode 100644
index 0000000..46ba518
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/filters.rb
@@ -0,0 +1,10 @@
+class Hirb::Helpers::Table
+  # Contains filter methods used by :filters option. To define a custom filter, simply open this module and create a method
+  # that take one argument, the value you will be filtering.
+  module Filters
+    extend self
+    def comma_join(arr) #:nodoc:
+      arr.join(', ')
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
new file mode 100644
index 0000000..eadbc12
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/table/resizer.rb
@@ -0,0 +1,82 @@
+class Hirb::Helpers::Table
+  # Resizes a table's fields to the table's max width.
+  class Resizer
+    # Modifies field_lengths to fit within width. Also enforces a table's max_fields.
+    def self.resize!(table)
+      obj = new(table)
+      obj.resize
+      obj.field_lengths
+    end
+
+    #:stopdoc:
+    attr_reader :field_lengths
+    def initialize(table)
+      @table, @width, @field_size = table, table.actual_width, table.fields.size
+      @field_lengths = table.field_lengths
+      @original_field_lengths = @field_lengths.dup
+    end
+
+    def resize
+      adjust_long_fields || default_restrict_field_lengths
+      @table.enforce_field_constraints
+      add_extra_width
+    end
+
+    # Simple algorithm which allows smaller fields to be displayed while
+    # restricting longer fields to an average_long_field
+    def adjust_long_fields
+      while (total_length = sum(@field_lengths.values)) > @width
+        average_field = total_length / @field_size.to_f
+        long_lengths = @field_lengths.values.select {|e| e > average_field }
+        return false if long_lengths.empty?
+
+        # adjusts average long field by ratio with @width
+        average_long_field = sum(long_lengths)/long_lengths.size * @width/total_length
+        @field_lengths.each {|f,length|
+          @field_lengths[f] = average_long_field if length > average_long_field
+        }
+      end
+      true
+    end
+
+    # Produces a field_lengths which meets the @width requirement
+    def default_restrict_field_lengths
+      original_total_length = sum @original_field_lengths.values
+      # set fields by their relative weight to original length
+      new_lengths = @original_field_lengths.inject({}) {|t,(k,v)|
+        t[k] = (v / original_total_length.to_f * @width).to_i; t  }
+
+      # set all fields the same if relative doesn't work
+      unless new_lengths.values.all? {|e| e > MIN_FIELD_LENGTH} && (sum(new_lengths.values) <= @width)
+        new_lengths = @field_lengths.inject({}) {|t,(k,v)| t[k] = @width / @field_size; t }
+      end
+      @field_lengths.each {|k,v| @field_lengths[k] = new_lengths[k] }
+    end
+
+    def add_extra_width
+      added_width = 0
+      extra_width = @width - sum(@field_lengths.values)
+      unmaxed_fields = @field_lengths.keys.select {|f| !remaining_width(f).zero? }
+      # order can affect which one gets the remainder so let's keep it consistent
+      unmaxed_fields = unmaxed_fields.sort_by {|e| e.to_s}
+
+      unmaxed_fields.each_with_index do |f, i|
+        extra_per_field = (extra_width - added_width) / (unmaxed_fields.size - i)
+        add_to_field = remaining_width(f) < extra_per_field ? remaining_width(f) : extra_per_field
+        added_width += add_to_field
+        @field_lengths[f] += add_to_field
+      end
+    end
+
+    def remaining_width(field)
+      (@remaining_width ||= {})[field] ||= begin
+        (@table.max_fields[field] || @original_field_lengths[field]) - @field_lengths[field]
+      end
+    end
+
+    def sum(arr)
+      arr.inject {|t,e| t += e }
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
new file mode 100644
index 0000000..2697423
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/tree.rb
@@ -0,0 +1,181 @@
+# Base tree class which given an array of nodes produces different types of trees.
+# The types of trees currently are:
+# * basic:
+#    0
+#      1
+#        2
+#        3
+#      4
+# 
+# * directory:
+#    0
+#    |-- 1
+#    |   |-- 2
+#    |   `-- 3
+#    `-- 4
+# 
+# * number:
+#    1. 0
+#      1. 1
+#        1. 2
+#        2. 3
+#      2. 4 
+# 
+# Tree nodes can be given as an array of arrays or an array of hashes.
+# To render the above basic tree with an array of hashes:
+#   Hirb::Helpers::Tree.render([{:value=>0, :level=>0}, {:value=>1, :level=>1}, {:value=>2, :level=>2}, 
+#     {:value=>3, :level=>2}, {:value=>4, :level=>1}])
+# Note from the hash keys that :level refers to the depth of the tree while :value refers to the text displayed
+# for a node.
+#
+# To render the above basic tree with an array of arrays:
+#   Hirb::Helpers::Tree.render([[0,0], [1,1], [2,2], [2,3], [1,4]])
+# Note that the each array pair consists of the level and the value for the node.
+class Hirb::Helpers::Tree
+  class ParentlessNodeError < StandardError; end
+
+  class <<self
+    # Main method which renders a tree.
+    # ==== Options:
+    # [:type] Type of tree. Either :basic, :directory or :number. Default is :basic.
+    # [:validate] Boolean to validate tree. Checks to see if all nodes have parents. Raises ParentlessNodeError if
+    #             an invalid node is found. Default is false.
+    # [:indent] Number of spaces to indent between levels for basic + number trees. Default is 4.
+    # [:limit] Limits the level or depth of a tree that is displayed. Root node is level 0.
+    # [:description] Displays brief description about tree ie how many nodes it has.
+    # [:multi_line_nodes] Handles multi-lined nodes by indenting their newlines. Default is false.
+    #  Examples:
+    #     Hirb::Helpers::Tree.render([[0, 'root'], [1, 'child']], :type=>:directory)
+    def render(nodes, options={})
+      new(nodes, options).render
+    end
+  end
+
+  # :stopdoc:
+  attr_accessor :nodes
+  
+  def initialize(input_nodes, options={})
+    @options = options
+    @type = options[:type] || :basic
+    if input_nodes[0].is_a?(Array)
+      @nodes = input_nodes.map {|e| Node.new(:level=>e[0], :value=>e[1]) }
+    else
+      @nodes = input_nodes.map {|e| Node.new(e)}
+    end
+    @nodes.each_with_index {|e,i| e.merge!(:tree=>self, :index=>i)}
+    @nodes.each {|e| e[:value] = e[:value].to_s }
+    validate_nodes if options[:validate]
+    self
+  end
+
+  def render
+    body = render_tree
+    body += render_description if @options[:description]
+    body
+  end
+  
+  def render_description
+    "\n\n#{@nodes.length} #{@nodes.length == 1 ? 'node' : 'nodes'} in tree"
+  end
+
+  def render_tree
+    @indent = ' ' * (@options[:indent] || 4 )
+    @nodes = @nodes.select {|e| e[:level] <= @options[:limit] } if @options[:limit]
+    case @type.to_s
+    when 'directory' then render_directory
+    when 'number'    then render_number
+    else render_basic
+    end
+  end
+
+  def render_nodes
+    value_indent = @options[:multi_line_nodes] ? @indent : nil
+    @nodes.map {|e| yield(e) + e.value(value_indent) }.join("\n")
+  end
+
+  def render_directory
+    mark_last_nodes_per_level
+    render_nodes {|e|
+      value = ''
+      unless e.root?
+        value << e.render_parent_characters
+        value << (e[:last_node] ? "`-- " : "|-- ")
+      end
+      value
+    }
+  end
+  
+  def render_number
+    counter = {}
+    @nodes.each {|e|
+      parent_level_key = "#{(e.parent ||{})[:index]}.#{e[:level]}"
+      counter[parent_level_key] ||= 0
+      counter[parent_level_key] += 1
+      e[:pre_value] = "#{counter[parent_level_key]}. "
+    }
+    render_nodes {|e| @indent * e[:level] + e[:pre_value] }
+  end
+
+  def render_basic
+    render_nodes {|e| @indent * e[:level] }
+  end
+
+  def validate_nodes
+    @nodes.each do |e|
+      raise ParentlessNodeError if (e[:level] > e.previous[:level]) && (e[:level] - e.previous[:level]) > 1
+    end
+  end
+  
+  # walks tree accumulating last nodes per unique parent+level
+  def mark_last_nodes_per_level
+    @nodes.each {|e| e.delete(:last_node)}
+    last_node_hash = @nodes.inject({}) {|h,e|
+      h["#{(e.parent ||{})[:index]}.#{e[:level]}"] = e; h
+    }
+    last_node_hash.values.uniq.each {|e| e[:last_node] = true}
+  end
+  #:startdoc:
+  class Node < ::Hash #:nodoc:
+    class MissingLevelError < StandardError; end
+    class MissingValueError < StandardError; end
+    
+    def initialize(hash)
+      super
+      raise MissingLevelError unless hash.has_key?(:level)
+      raise MissingValueError unless hash.has_key?(:value)
+      replace(hash)
+    end
+
+    def value(indent=nil)
+      indent ? self[:value].gsub("\n", "\n#{indent * self[:level]}") : self[:value]
+    end
+
+    def parent
+      self[:tree].nodes.slice(0 .. self[:index]).reverse.detect {|e| e[:level] < self[:level]}
+    end
+
+    def next
+      self[:tree].nodes[self[:index] + 1]
+    end
+
+    def previous
+      self[:tree].nodes[self[:index] - 1]
+    end
+
+    def root?; self[:level] == 0; end
+
+    # refers to characters which connect parent nodes 
+    def render_parent_characters
+      parent_chars = []
+      get_parents_character(parent_chars)
+      parent_chars.reverse.map {|level| level + ' ' * 3 }.join('')
+    end
+
+    def get_parents_character(parent_chars)
+      if self.parent
+        parent_chars << (self.parent[:last_node] ? ' ' : '|') unless self.parent.root?
+        self.parent.get_parents_character(parent_chars)
+      end
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
new file mode 100644
index 0000000..1f18f3e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/helpers/vertical_table.rb
@@ -0,0 +1,37 @@
+class Hirb::Helpers::VerticalTable < Hirb::Helpers::Table
+
+  # Renders a vertical table using the same options as Hirb::Helpers::Table.render except for the ones below
+  # and :max_fields, :vertical and :max_width which aren't used.
+  # ==== Options:
+  # [:hide_empty] Boolean which hides empty values (nil or '') from being displayed. Default is false.
+  def self.render(rows, options={})
+    new(rows, {:escape_special_chars=>false, :resize=>false}.merge(options)).render
+  end
+
+  #:stopdoc:
+  def setup_field_lengths
+    @field_lengths = default_field_lengths
+  end
+
+  def render_header; []; end
+  def render_footer; []; end
+
+  def render_rows
+    i = 0
+    longest_header = Hirb::String.size @headers.values.sort_by {|e| Hirb::String.size(e) }.last
+    stars = "*" * [(longest_header + (longest_header / 2)), 3].max
+    @rows.map do |row|
+      row = "#{stars} #{i+1}. row #{stars}\n" +
+      @fields.map {|f|
+        if !@options[:hide_empty] || (@options[:hide_empty] && !row[f].empty?)
+          "#{Hirb::String.rjust(@headers[f], longest_header)}: #{row[f]}"
+        else
+          nil
+        end
+      }.compact.join("\n")
+      i+= 1
+      row
+    end
+  end
+  #:startdoc:
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/import_object.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/import_object.rb
new file mode 100644
index 0000000..8bd0f1f
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/import_object.rb
@@ -0,0 +1,10 @@
+module Hirb
+  module ObjectMethods
+    # Takes same options as Hirb::View.render_output.
+    def view(*args)
+      Hirb::Console.render_output(*(args.unshift(self)))
+    end
+  end
+end
+
+Object.send :include, Hirb::ObjectMethods
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/menu.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/menu.rb
new file mode 100644
index 0000000..ffafd14
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/menu.rb
@@ -0,0 +1,221 @@
+module Hirb
+  # This class provides a menu using Hirb's table helpers by default to display choices.
+  # Menu choices (syntax at Hirb::Util.choose_from_array) refer to rows. However, when in
+  # two_d mode, choices refer to specific cells by appending a ':field' to a choice.
+  # A field name can be an abbreviated. Menus can also have an action mode, which turns the
+  # menu prompt into a commandline that executes the choices as arguments and uses methods as
+  # actions/commands.
+  class Menu
+    class Error < StandardError; end
+
+    # Detects valid choices and optional field/column
+    CHOSEN_REGEXP = /^(\d([^:]+)?)(?::)?(\S+)?/
+    CHOSEN_ARG = '%s'
+    DIRECTIONS = "Specify individual choices (4,7), range of choices (1-3) or all choices (*)."
+
+
+    # This method will return an array unless it's exited by simply pressing return, which returns nil.
+    # If given a block, the block will yield if and with any menu items are chosen.
+    # All options except for the ones below are passed to render the menu.
+    #
+    # ==== Options:
+    # [*:helper_class*]  Helper class to render menu. Helper class is expected to implement numbering given a :number option.
+    #                    To use a very basic menu, set this to false. Defaults to Hirb::Helpers::AutoTable.
+    # [*:prompt*]  String for menu prompt. Defaults to "Choose: ".
+    # [*:ask*] Always ask for input, even if there is only one choice. Default is true.
+    # [*:directions*] Display directions before prompt. Default is true.
+    # [*:readline*] Use readline to get user input if available. Input strings are added to readline history. Default is false.
+    # [*:two_d*] Turn menu into a 2 dimensional (2D) menu by allowing user to pick values from table cells. Default is false.
+    # [*:default_field*] Default field for a 2D menu. Defaults to first field in a table.
+    # [*:action*] Turn menu into an action menu by letting user pass menu choices as an argument to a method/command.
+    #             A menu choice's place amongst other arguments is preserved. Default is false.
+    # [*:multi_action*] Execute action menu multiple times iterating over the menu choices. Default is false.
+    # [*:action_object*] Object that takes method/command calls. Default is main.
+    # [*:command*] Default method/command to call when no command given.
+    # [*:reopen*] Reopens $stdin with given file or with /dev/tty when set to true. Use when
+    #             $stdin is already reading in piped data.
+    # Examples:
+    #     >> extend Hirb::Console
+    #     => self
+    #     >> menu [1,2,3], :prompt=> "So many choices, so little time: "
+    #     >> menu [{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:a,b], :two_d=>true)
+    def self.render(output, options={}, &block)
+      new(options).render(output, &block)
+    rescue Error=>e
+      $stderr.puts "Error: #{e.message}"
+    end
+
+    #:stopdoc:
+    def initialize(options={})
+      @options = {:helper_class=>Hirb::Helpers::AutoTable, :prompt=>"Choose: ", :ask=>true,
+        :directions=>true}.merge options
+      @options[:reopen] = '/dev/tty' if @options[:reopen] == true
+    end
+
+    def render(output, &block)
+      @output = Array(output)
+      return [] if @output.size.zero?
+      chosen = choose_from_menu
+      block.call(chosen) if block && chosen.size > 0
+      @options[:action] ? execute_action(chosen) : chosen
+    end
+
+    def get_input
+      prompt = pre_prompt + @options[:prompt]
+      prompt = DIRECTIONS+"\n"+prompt if @options[:directions]
+      $stdin.reopen @options[:reopen] if @options[:reopen]
+
+      if @options[:readline] && readline_loads?
+        get_readline_input(prompt)
+      else
+        print prompt
+        $stdin.gets.chomp.strip
+      end
+    end
+
+    def get_readline_input(prompt)
+      input = Readline.readline prompt
+      Readline::HISTORY << input
+      input
+    end
+
+    def pre_prompt
+      prompt = ''
+      prompt << "Default field: #{default_field}\n" if @options[:two_d] && default_field
+      prompt << "Default command: #{@options[:command]}\n" if @options[:action] && @options[:command]
+      prompt
+    end
+
+    def choose_from_menu
+      return unasked_choice if @output.size == 1 && !@options[:ask]
+
+      if (helper_class = Util.any_const_get(@options[:helper_class]))
+        View.render_output(@output, :class=>@options[:helper_class], :options=>@options.merge(:number=>true))
+      else
+        @output.each_with_index {|e,i| puts "#{i+1}: #{e}" }
+      end
+
+      parse_input get_input
+    end
+
+    def unasked_choice
+      return @output unless @options[:action]
+      raise(Error, "Default command and field required for unasked action menu") unless default_field && @options[:command]
+      @new_args = [@options[:command], CHOSEN_ARG]
+      map_tokens([[@output, default_field]])
+    end
+
+    def execute_action(chosen)
+      return nil if chosen.size.zero?
+      if @options[:multi_action]
+        chosen.each {|e| invoke command, add_chosen_to_args(e) }
+      else
+        invoke command, add_chosen_to_args(chosen)
+      end
+    end
+
+    def invoke(cmd, args)
+      action_object.send(cmd, *args)
+    end
+
+    def parse_input(input)
+      if (@options[:two_d] || @options[:action])
+        tokens = input_to_tokens(input)
+        map_tokens(tokens)
+      else
+        Util.choose_from_array(@output, input)
+      end
+    end
+
+    def map_tokens(tokens)
+      if return_cell_values?
+        @output[0].is_a?(Hash) ? tokens.map {|arr,f| arr.map {|e| e[f]} }.flatten :
+          tokens.map {|arr,f|
+            arr.map {|e| e.is_a?(Array) && f.is_a?(Integer) ? e[f] : e.send(f) }
+          }.flatten
+      else
+        tokens.map {|e| e[0] }.flatten
+      end
+    end
+
+    def return_cell_values?
+      @options[:two_d]
+    end
+
+    def input_to_tokens(input)
+      @new_args = []
+      tokens = (@args = split_input_args(input)).map {|word| parse_word(word) }.compact
+      cleanup_new_args
+      tokens
+    end
+
+    def parse_word(word)
+      if word[CHOSEN_REGEXP]
+        @new_args << CHOSEN_ARG
+        field = $3 ? unalias_field($3) : default_field ||
+          raise(Error, "No default field/column found. Fields must be explicitly picked.")
+        [Util.choose_from_array(@output, word), field ]
+      else
+        @new_args << word
+        nil
+      end
+    end
+
+    def cleanup_new_args
+      if @new_args.all? {|e| e == CHOSEN_ARG }
+        @new_args = [CHOSEN_ARG]
+      else
+        i = @new_args.index(CHOSEN_ARG) || raise(Error, "No rows chosen")
+        @new_args.delete(CHOSEN_ARG)
+        @new_args.insert(i, CHOSEN_ARG)
+      end
+    end
+
+    def add_chosen_to_args(items)
+      args = @new_args.dup
+      args[args.index(CHOSEN_ARG)] = items
+      args
+    end
+
+    def command
+      @command ||= begin
+        cmd = (@new_args == [CHOSEN_ARG]) ? nil : @new_args.shift
+        cmd ||= @options[:command] || raise(Error, "No command given for action menu")
+      end
+    end
+
+    def action_object
+      @options[:action_object] || eval("self", TOPLEVEL_BINDING)
+    end
+
+    def split_input_args(input)
+      input.split(/\s+/)
+    end
+
+    def default_field
+      @default_field ||= @options[:default_field] || fields[0]
+    end
+
+    # Has to be called after displaying menu
+    def fields
+      @fields ||= @options[:fields] || (@options[:ask] && table_helper_class? && Helpers::Table.last_table ?
+        Helpers::Table.last_table.fields[1..-1] : [])
+    end
+
+    def table_helper_class?
+      @options[:helper_class].is_a?(Class) && @options[:helper_class] < Helpers::Table
+    end
+
+    def unalias_field(field)
+      fields.sort_by {|e| e.to_s }.find {|e| e.to_s[/^#{field}/] } || raise(Error, "Invalid field '#{field}'")
+    end
+
+    def readline_loads?
+      require 'readline'
+      true
+    rescue LoadError
+      false
+    end
+    #:startdoc:
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/pager.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/pager.rb
new file mode 100644
index 0000000..8ff1250
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/pager.rb
@@ -0,0 +1,95 @@
+module Hirb
+  # This class provides class methods for paging and an object which can conditionally page given a terminal size that is exceeded.
+  class Pager
+    class<<self
+      # Pages using a configured or detected shell command.
+      def command_pager(output, options={})
+        basic_pager(output) if valid_pager_command?(options[:pager_command])
+      end
+
+      def pager_command(*commands) #:nodoc:
+        @pager_command = (!@pager_command.nil? && commands.empty?) ? @pager_command : 
+          begin
+            commands = [ENV['PAGER'], 'less', 'more', 'pager'] if commands.empty?
+            commands.compact.uniq.find {|e| Util.command_exists?(e[/\w+/]) }
+          end
+      end
+
+      # Pages with a ruby-only pager which either pages or quits.
+      def default_pager(output, options={})
+        pager = new(options[:width], options[:height])
+        while pager.activated_by?(output, options[:inspect])
+          puts pager.slice!(output, options[:inspect])
+          return unless continue_paging?
+        end
+        puts output
+        puts "=== Pager finished. ==="
+      end
+
+      #:stopdoc:
+      def valid_pager_command?(cmd)
+        cmd ? pager_command(cmd) : pager_command
+      end
+
+      private
+      def basic_pager(output)
+        pager = IO.popen(pager_command, "w")
+        begin
+          save_stdout = STDOUT.clone
+          STDOUT.reopen(pager)
+          STDOUT.puts output
+        rescue Errno::EPIPE
+        ensure
+         STDOUT.reopen(save_stdout)
+         save_stdout.close
+         pager.close
+        end
+      end
+
+      def continue_paging?
+        puts "=== Press enter/return to continue or q to quit: ==="
+        !$stdin.gets.chomp[/q/i]
+      end
+      #:startdoc:
+    end
+
+    attr_reader :width, :height
+
+    def initialize(width, height, options={})
+      resize(width, height)
+      @pager_command = options[:pager_command] if options[:pager_command]
+    end
+
+    # Pages given string using configured pager.
+    def page(string, inspect_mode)
+      if self.class.valid_pager_command?(@pager_command)
+        self.class.command_pager(string, :pager_command=>@pager_command)
+      else
+        self.class.default_pager(string, :width=>@width, :height=>@height, :inspect=>inspect_mode)
+      end
+    end
+
+    def slice!(output, inspect_mode=false) #:nodoc:
+      effective_height = @height - 2 # takes into account pager prompt
+      if inspect_mode
+        sliced_output = String.slice(output, 0, @width * effective_height)
+        output.replace String.slice(output, @width * effective_height, String.size(output))
+        sliced_output
+      else
+        # could use output.scan(/[^\n]*\n?/) instead of split
+        sliced_output = output.split("\n").slice(0, effective_height).join("\n")
+        output.replace output.split("\n").slice(effective_height..-1).join("\n")
+        sliced_output
+      end
+    end
+
+    # Determines if string should be paged based on configured width and height.
+    def activated_by?(string_to_page, inspect_mode=false)
+      inspect_mode ? (String.size(string_to_page) > @height * @width) : (string_to_page.count("\n") > @height)
+    end
+
+    def resize(width, height) #:nodoc:
+      @width, @height = View.determine_terminal_size(width, height)
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/string.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/string.rb
new file mode 100644
index 0000000..0d96585
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/string.rb
@@ -0,0 +1,44 @@
+module Hirb
+  # Provides string helpers to deal with UTF-8 and ruby 1.8.x
+  module String
+    extend self
+    # :stopdoc:
+    if RUBY_VERSION < '1.9'
+      def size(string)
+        string.scan(/./).length
+      end
+
+      def ljust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? string + " " * leftover : string
+      end
+
+      def rjust(string, desired_length)
+        leftover = desired_length - size(string)
+        leftover > 0 ? " " * leftover + string : string
+      end
+
+      def slice(string, start, finish)
+        string.scan(/./).slice(start, finish).join('')
+      end
+    else
+      def size(string)
+        string.length
+      end
+
+      def ljust(string, desired_length)
+        string.ljust(desired_length)
+      end
+
+      def rjust(string, desired_length)
+        string.rjust(desired_length)
+      end
+
+      def slice(*args)
+        string = args.shift
+        string.slice(*args)
+      end
+    end
+    #:startdoc:
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/util.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/util.rb
new file mode 100644
index 0000000..2db4b65
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/util.rb
@@ -0,0 +1,96 @@
+module Hirb
+  # Group of handy utility functions used throughout Hirb.
+  module Util
+    extend self
+    # Returns a constant like Module#const_get no matter what namespace it's nested in.
+    # Returns nil if the constant is not found.
+    def any_const_get(name)
+      return name if name.is_a?(Module)
+      begin
+        klass = Object
+        name.split('::').each {|e|
+          klass = klass.const_get(e)
+        }
+        klass
+      rescue
+         nil
+      end
+    end
+
+    # Recursively merge hash1 with hash2.
+    def recursive_hash_merge(hash1, hash2)
+      hash1.merge(hash2) {|k,o,n| (o.is_a?(Hash)) ? recursive_hash_merge(o,n) : n}
+    end
+
+    # From Rails ActiveSupport, converting undescored lowercase to camel uppercase.
+    def camelize(string)
+      string.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
+    end
+
+    # Used by Hirb::Menu to select items from an array. Array counting starts at 1. Ranges of numbers are specified with a '-' or '..'.
+    # Multiple ranges can be comma delimited. Anything that isn't a valid number is ignored. All elements can be returned with a '*'.
+    # Examples:
+    #    1-3,5-6 -> [1,2,3,5,6]
+    #    *   -> all elements in array
+    #    ''  -> [] 
+    def choose_from_array(array, input, options={})
+      options = {:splitter=>","}.merge(options)
+      return array if input.strip == '*'
+      result = []
+      input.split(options[:splitter]).each do |e|
+        if e =~ /-|\.\./
+          min,max = e.split(/-|\.\./)
+          slice_min = min.to_i - 1
+          result.push(*array.slice(slice_min, max.to_i - min.to_i + 1))
+        elsif e =~ /\s*(\d+)\s*/
+          index = $1.to_i - 1
+          next if index < 0
+          result.push(array[index]) if array[index]
+        end
+      end
+      result
+    end
+
+    # Determines if a shell command exists by searching for it in ENV['PATH'].
+    def command_exists?(command)
+      ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
+    end
+
+    # Returns [width, height] of terminal when detected, nil if not detected.
+    # Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
+    def detect_terminal_size
+      if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
+        [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
+      elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
+        [`tput cols`.to_i, `tput lines`.to_i]
+      elsif STDIN.tty? && command_exists?('stty')
+        `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
+      else
+        nil
+      end
+    rescue
+      nil
+    end
+
+    # Captures STDOUT of anything run in its block and returns it as string.
+    def capture_stdout(&block)
+      original_stdout = $stdout
+      $stdout = fake = StringIO.new
+      begin
+        yield
+      ensure
+        $stdout = original_stdout
+      end
+      fake.string
+    end
+
+    # From Rubygems, determine a user's home.
+    def find_home
+      ['HOME', 'USERPROFILE'].each {|e| return ENV[e] if ENV[e] }
+      return "#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}" if ENV['HOMEDRIVE'] && ENV['HOMEPATH']
+      File.expand_path("~")
+    rescue
+      File::ALT_SEPARATOR ? "C:/" : "/"
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/version.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/version.rb
new file mode 100644
index 0000000..58002c4
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/version.rb
@@ -0,0 +1,3 @@
+module Hirb
+  VERSION = '0.3.5'
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/view.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/view.rb
new file mode 100644
index 0000000..70a4563
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/view.rb
@@ -0,0 +1,270 @@
+module Hirb
+  # This class is responsible for managing all view-related functionality.
+  #
+  # == Create a View
+  # Let's create a simple view for Hash objects:
+  #   $ irb -rubygems
+  #   >> require 'hirb'
+  #   =>true
+  #   >> Hirb.enable
+  #   =>nil
+  #   >> require 'yaml'
+  #   =>true
+  #
+  #   # A view method is the smallest view
+  #   >> def yaml(output); output.to_yaml; end
+  #   => nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :method=>:yaml
+  #   => true
+  #
+  #   # Hashes now appear as yaml
+  #   >> {:a=>1, :b=>{:c=>3}}
+  #   ---
+  #   :a : 1
+  #   :b : 
+  #     :c : 3
+  #   => true
+  #
+  # Another way of creating a view is a Helper class:
+  #
+  #   # Create yaml view class
+  #   >> class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   =>nil
+  #   # Add the view
+  #   >> Hirb.add_view Hash, :class=>Hirb::Helpers::Yaml
+  #   =>true
+  #
+  #   # Hashes appear as yaml like above ...
+  #
+  # == Configure a View
+  # To configure the above Helper class as a view, either pass Hirb.enable a hash:
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable :output=>{"Hash"=>{:class=>"Hirb::Helpers::Yaml"}}
+  #
+  # Or create a config file at config/hirb.yml or ~/.hirb.yml:
+  #   # The config file for the yaml example would look like:
+  #   # ---
+  #   # :output :
+  #   #   Hash :
+  #   #    :class : Hirb::Helpers::Yaml
+  #
+  #   # In .irbrc
+  #   require 'hirb'
+  #   # View class needs to come before enable()
+  #   class Hirb::Helpers::Yaml; def self.render(output, options={}); output.to_yaml; end ;end
+  #   Hirb.enable
+  #
+  # For more about configuring Hirb, see the Config Files section in Hirb.
+  module View
+    DEFAULT_WIDTH = 120
+    DEFAULT_HEIGHT = 40
+    class<<self
+      attr_accessor :render_method
+      attr_reader :config
+
+      # This activates view functionality i.e. the formatter, pager and size detection. If irb exists, it overrides irb's output
+      # method with Hirb::View.view_output. When called multiple times, new configs are merged into the existing config.
+      # If using Wirble, you should call this after it. The view configuration can be specified in a hash via a config file,
+      # or as options to this method. In addition to the config keys mentioned in Hirb, options also take the following keys:
+      # ==== Options:
+      # * config_file: Name of config file(s) that are merged into existing config
+      # Examples:
+      #   Hirb.enable
+      #   Hirb.enable :formatter=>false
+      def enable(options={}, &block)
+        Array(options.delete(:config_file)).each {|e|
+          @new_config_file = true
+          Hirb.config_files << e
+        }
+        enable_output_method unless @output_method
+        merge_or_load_config options
+        resize(config[:width], config[:height])
+        @enabled = true
+      end
+
+      # Indicates if Hirb::View is enabled.
+      def enabled?
+        @enabled || false
+      end
+
+      # Disable's Hirb's output and revert's irb's output method if irb exists.
+      def disable
+        @enabled = false
+        disable_output_method if @output_method
+        false
+      end
+
+      # Toggles pager on or off. The pager only works while Hirb::View is enabled.
+      def toggle_pager
+        config[:pager] = !config[:pager]
+      end
+
+      # Toggles formatter on or off.
+      def toggle_formatter
+        config[:formatter] = !config[:formatter]
+      end
+
+      # Resizes the console width and height for use with the table and pager i.e. after having resized the console window. *nix users
+      # should only have to call this method. Non-*nix users should call this method with explicit width and height. If you don't know
+      # your width and height, in irb play with "a"* width to find width and puts "a\n" * height to find height.
+      def resize(width=nil, height=nil)
+        config[:width], config[:height] = determine_terminal_size(width, height)
+        pager.resize(config[:width], config[:height])
+      end
+      
+      # This is the main method of this class. When view is enabled, this method searches for a formatter it can use for the output and if
+      # successful renders it using render_method(). The options this method takes are helper config hashes as described in 
+      # Hirb::Formatter.format_output(). Returns true if successful and false if no formatting is done or if not enabled.
+      def view_output(output, options={})
+        enabled? && config[:formatter] && render_output(output, options)
+      rescue Exception=>e
+        if config[:ignore_errors]
+          $stderr.puts "Hirb Error: #{e.message}"
+          false
+        else
+          index = (obj = e.backtrace.find {|f| f =~ /^\(eval\)/}) ? e.backtrace.index(obj) : e.backtrace.length
+          $stderr.puts "Hirb Error: #{e.message}", e.backtrace.slice(0,index).map {|e| "    " + e }
+          true
+        end
+      end
+
+      # Captures STDOUT and renders it using render_method(). The main use case is to conditionally page captured stdout.
+      def capture_and_render(&block)
+        render_method.call Util.capture_stdout(&block)
+      end
+
+      # A lambda or proc which handles the final formatted object.
+      # Although this pages/puts the object by default, it could be set to do other things
+      # i.e. write the formatted object to a file.
+      def render_method
+        @render_method ||= default_render_method
+      end
+
+      # Resets render_method back to its default.
+      def reset_render_method
+        @render_method = default_render_method
+      end
+      
+      # Current console width
+      def width
+        config && config[:width] ? config[:width] : DEFAULT_WIDTH
+      end
+
+      # Current console height
+      def height
+        config && config[:height] ? config[:height] : DEFAULT_HEIGHT
+      end
+
+      # Current formatter config, storing a hash of all static views
+      def formatter_config
+        formatter.config
+      end
+
+      # Adds a view when View is enabled. See Formatter.add_view for more details.
+      def add(klass, view_config)
+        if enabled?
+          formatter.add_view(klass, view_config)
+        else
+          puts "View must be enabled to add a view"
+        end
+      end
+
+      #:stopdoc:
+      def enable_output_method
+        if defined? Ripl
+          @output_method = true
+          require 'ripl/hirb'
+        elsif defined? IRB
+          @output_method = true
+          ::IRB::Irb.class_eval do
+            alias_method :non_hirb_view_output, :output_value
+            def output_value #:nodoc:
+              Hirb::View.view_or_page_output(@context.last_value) || non_hirb_view_output
+            end
+          end
+        end
+      end
+
+      def disable_output_method
+        if defined?(IRB) && !defined? Ripl
+          ::IRB::Irb.send :alias_method, :output_value, :non_hirb_view_output
+        end
+        @output_method = nil
+      end
+
+      def view_or_page_output(str)
+        view_output(str) || page_output(str.inspect, true)
+      end
+
+      def render_output(output, options={})
+        if (formatted_output = formatter.format_output(output, options))
+          render_method.call(formatted_output)
+          true
+        else
+          false
+        end
+      end
+
+      def determine_terminal_size(width, height)
+        detected  = (width.nil? || height.nil?) ? Util.detect_terminal_size || [] : []
+        [width || detected[0] || DEFAULT_WIDTH , height || detected[1] || DEFAULT_HEIGHT]
+      end
+
+      def page_output(output, inspect_mode=false)
+        if enabled? && config[:pager] && pager.activated_by?(output, inspect_mode)
+          pager.page(output, inspect_mode)
+          true
+        else
+          false
+        end
+      end
+
+      def pager
+        @pager ||= Pager.new(config[:width], config[:height], :pager_command=>config[:pager_command])
+      end
+
+      def pager=(value); @pager = value; end
+
+      def formatter(reload=false)
+        @formatter = reload || @formatter.nil? ? Formatter.new(config[:output]) : @formatter
+      end
+
+      def formatter=(value); @formatter = value; end
+
+      def merge_or_load_config(additional_config={})
+        if @config && (@new_config_file || !additional_config.empty?)
+          Hirb.config = nil
+          load_config Util.recursive_hash_merge(@config, additional_config)
+          @new_config_file = false
+        elsif !@enabled
+          load_config(additional_config)
+        end
+      end
+
+      def load_config(additional_config={})
+        @config = Util.recursive_hash_merge default_config, additional_config
+        formatter(true)
+        true
+      end
+
+      def config_loaded?; !!@config; end
+
+      def config
+        @config
+      end
+      
+      def default_render_method
+        lambda {|output| page_output(output) || puts(output) }
+      end
+
+      def default_config
+        Util.recursive_hash_merge({:pager=>true, :formatter=>true}, Hirb.config || {})
+      end
+      #:startdoc:
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views.rb
new file mode 100644
index 0000000..330a802
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views.rb
@@ -0,0 +1,8 @@
+module Hirb
+  # Namespace for Helpers defining multiple views in a module i.e. via DynamicView.
+  module Views
+    module Single #:nodoc:
+    end
+  end
+end
+%w{rails orm mongo_db couch_db misc_db}.each {|e| require "hirb/views/#{e}" }
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
new file mode 100644
index 0000000..ad4ef11
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/couch_db.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::CouchDb #:nodoc:
+  def default_couch(obj)
+    {:fields=>([:_id] + obj.class.properties.map {|e| e.name }) }
+  end
+
+  alias_method :couch_rest__extended_document_view, :default_couch
+  alias_method :couch_foo__base_view, :default_couch
+  alias_method :couch_potato__persistence_view, :default_couch
+end
+
+Hirb::DynamicView.add Hirb::Views::CouchDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
new file mode 100644
index 0000000..48f8d1b
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/misc_db.rb
@@ -0,0 +1,15 @@
+module Hirb::Views::MiscDb #:nodoc:
+  def friendly__document_view(obj)
+    {:fields=>obj.class.attributes.keys - [:id]}
+  end
+
+  def ripple__document_view(obj)
+    {:fields=>obj.class.properties.keys}
+  end
+
+  def d_b_i__row_view(obj)
+    {:fields=>obj.column_names, :table_class=>Hirb::Helpers::Table}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::MiscDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
new file mode 100644
index 0000000..a79d35b
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/mongo_db.rb
@@ -0,0 +1,14 @@
+module Hirb::Views::MongoDb #:nodoc:
+  def mongoid__document_view(obj)
+    {:fields=>['_id'] + obj.class.fields.keys}
+  end
+
+  def mongo_mapper__document_view(obj)
+    fields = obj.class.column_names
+    fields.delete('_id') && fields.unshift('_id')
+    {:fields=>fields}
+  end
+  alias_method :mongo_mapper__embedded_document_view, :mongo_mapper__document_view
+end
+
+Hirb::DynamicView.add Hirb::Views::MongoDb, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/orm.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
new file mode 100644
index 0000000..ded4b9b
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/orm.rb
@@ -0,0 +1,11 @@
+module Hirb::Views::ORM #:nodoc:
+  def data_mapper__resource_view(obj)
+    {:fields=>obj.class.properties.map {|e| e.name }}
+  end
+
+  def sequel__model_view(obj)
+    {:fields=>obj.class.columns}
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::ORM, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/rails.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
new file mode 100644
index 0000000..03105ff
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/hirb/views/rails.rb
@@ -0,0 +1,19 @@
+module Hirb::Views::Rails #:nodoc:
+  def active_record__base_view(obj)
+    {:fields=>get_active_record_fields(obj)}
+  end
+
+  def get_active_record_fields(obj)
+    fields = obj.class.column_names.map {|e| e.to_sym }
+    # if query used select
+    if obj.attributes.keys.sort != obj.class.column_names.sort
+      selected_columns = obj.attributes.keys
+      sorted_columns = obj.class.column_names.dup.delete_if {|e| !selected_columns.include?(e) }
+      sorted_columns += (selected_columns - sorted_columns)
+      fields = sorted_columns.map {|e| e.to_sym}
+    end
+    fields
+  end
+end
+
+Hirb::DynamicView.add Hirb::Views::Rails, :helper=>:auto_table
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/lib/ripl/hirb.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/ripl/hirb.rb
new file mode 100644
index 0000000..c56a45d
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/lib/ripl/hirb.rb
@@ -0,0 +1,14 @@
+module Ripl::Hirb
+  def before_loop
+    super
+    require 'hirb'
+    Hirb.enable(Ripl.config[:hirb] || {}) unless Hirb::View.enabled?
+  end
+
+  def format_result(result)
+    return super if !Hirb::View.enabled?
+    Hirb::View.view_or_page_output(result) || super
+  end
+end
+
+Ripl::Shell.send :include, Ripl::Hirb
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/auto_table_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/auto_table_test.rb
new file mode 100644
index 0000000..8e90d9a
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/auto_table_test.rb
@@ -0,0 +1,30 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "auto table" do
+  it "converts nonarrays to arrays and renders" do
+    require 'set'
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    +-------+
+    3 rows in set
+    TABLE
+    Helpers::AutoTable.render(::Set.new([1,2,3])).should == expected_table
+  end
+
+  it "renders hash" do
+    expected_table = <<-TABLE.unindent
+    +---+-------+
+    | 0 | 1     |
+    +---+-------+
+    | a | 12345 |
+    +---+-------+
+    1 row in set
+    TABLE
+    Helpers::AutoTable.render({:a=>12345}).should == expected_table
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/console_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/console_test.rb
new file mode 100644
index 0000000..b34a0ef
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/console_test.rb
@@ -0,0 +1,27 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Console" do
+  it "#table is called without Hirb enabled" do
+    extend Hirb::Console
+    reset_config
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 5     |
+    | 3     |
+    +-------+
+    2 rows in set
+    TABLE
+    capture_stdout {
+      table([5,3], :fields=>[:to_s])
+    }.should == expected_table +"\n"
+  end
+
+  it ".render_output sets config if it wasn't before" do
+    reset_config
+    View.expects(:render_output)
+    Console.render_output('blah')
+    View.config.is_a?(Hash).should == true
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/deps.rip b/lib/brightbox-cli/vendor/hirb-0.3.5/test/deps.rip
new file mode 100644
index 0000000..89eacd3
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/deps.rip
@@ -0,0 +1,4 @@
+bacon >=1.1.0
+mocha >=0
+mocha-on-bacon >=0
+bacon-bits >=0
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/dynamic_view_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/dynamic_view_test.rb
new file mode 100644
index 0000000..2523684
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/dynamic_view_test.rb
@@ -0,0 +1,94 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "DynamicView" do
+  def output_expects(output, expects)
+    Helpers::ObjectTable.expects(:render).with(output, expects)
+    Helpers::AutoTable.render(output)
+  end
+
+  describe "add" do
+    before_all { View.load_config }
+
+    it "raises error if no :helper option" do
+      lambda { Hirb.add_dynamic_view 'Blah', {} }.should.raise(ArgumentError).
+        message.should =~ /:helper.*required/
+    end
+
+    it "raises error if :helper option not a dynamic_view module" do
+      lambda { Hirb.add_dynamic_view('Blah', :helper=>:table) {|obj| } }.
+        should.raise(ArgumentError).message.should =~ /:helper.*must/
+    end
+
+    it "raises error if views module not a module" do
+      lambda { Hirb.add_dynamic_view 'Blah', :helper=>:auto_table }.should.raise(ArgumentError).
+        message.should =~ /must be a module/
+    end
+
+    it "adds a view with block" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "when adding views with a block, second view for same class overrides first one" do
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>obj.class::DAYNAMES}
+      end
+      Hirb.add_dynamic_view('Date', :helper=>:auto_table) do |obj|
+        {:fields=>[:blah]}
+      end
+      output_expects [Date.new], :fields=>[:blah]
+    end
+  end
+
+  it "class_to_method and method_to_class convert to each other" do
+    ["DBI::Row", "Hirb::View"].each do |e|
+      Helpers::AutoTable.method_to_class(DynamicView.class_to_method(e).downcase).should == e
+    end
+  end
+
+  it "class_to_method converts correctly" do
+    DynamicView.class_to_method("DBI::Row").should == 'd_b_i__row_view'
+  end
+
+  describe "dynamic_view" do
+    def define_view(mod_name= :Blah, &block)
+      mod = Views.const_set(mod_name, Module.new)
+      mod_block = block_given? ? block : lambda {|obj| {:fields=>obj.class::DAYNAMES}}
+      mod.send(:define_method, :date_view, mod_block)
+      Hirb.add_dynamic_view mod, :helper=>:auto_table
+    end
+
+    before_all { View.load_config }
+    before { Formatter.dynamic_config = {} }
+    after { Views.send(:remove_const, :Blah) }
+
+    it "sets a view's options" do
+      define_view
+      output_expects [Date.new], :fields=>Date::DAYNAMES
+    end
+
+    it "does override existing formatter dynamic_config" do
+      Formatter.dynamic_config["Date"] = {:class=>Helpers::Table}
+      define_view
+      Formatter.dynamic_config["Date"].should == {:class=>Hirb::Helpers::AutoTable, :ancestor=>true}
+    end
+
+    it "raises a readable error when error occurs in a view" do
+      define_view {|obj| raise 'blah' }
+      lambda { Helpers::AutoTable.render([Date.new]) }.should.raise(RuntimeError).
+        message.should =~ /'Date'.*date_view.*\nblah/
+    end
+
+    it "another view can reuse an old view's options" do
+      define_view
+      define_view(:Blah2) do |obj|
+        {:fields=>obj.class::DAYNAMES + ['blah']}
+      end
+      output_expects [Date.new], :fields=>(Date::DAYNAMES + ['blah'])
+    end
+    after_all { reset_config }
+  end
+  after_all { Formatter.dynamic_config = {} }
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/formatter_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/formatter_test.rb
new file mode 100644
index 0000000..883f65e
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/formatter_test.rb
@@ -0,0 +1,176 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Formatter" do
+  def set_formatter(hash={})
+    @formatter = Formatter.new(hash)
+  end
+
+  describe "klass_config" do
+    it "recursively merges ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2], :options=>{:fields=>[:to_s]}},
+        "Object"=>{:method=>:object_output, :ancestor=>true, :options=>{:vertical=>true}},
+        "Kernel"=>{:method=>:default_output}
+      expected_result = {:method=>:object_output, :args=>[1, 2], :ancestor=>true, :options=>{:fields=>[:to_s], :vertical=>true}}
+      @formatter.klass_config(::String).should == expected_result
+    end
+
+    it "doesn't merge ancestor options" do
+      @formatter = set_formatter "String"=>{:args=>[1,2]}, "Object"=>{:method=>:object_output},
+       "Kernel"=>{:method=>:default_output}
+      @formatter.klass_config(::String).should == {:args=>[1, 2]}
+    end
+
+    it "returns hash when nothing found" do
+      set_formatter.klass_config(::String).should == {}
+    end
+
+    describe "with dynamic_config" do
+      def set_formatter(hash={})
+        @formatter = Formatter.new(hash)
+      end
+      after { Formatter.dynamic_config = {}}
+
+      it "merges ancestor options and sets local config" do
+        Formatter.dynamic_config = {"Object"=>{:method=>:blah}, "Kernel"=>{:args=>[1,2], :ancestor=>true}}
+        set_formatter.klass_config(::String).should == {:args=>[1,2], :ancestor=>true}
+        @formatter.config['Kernel'].should == {:args=>[1,2], :ancestor=>true}
+      end
+
+      it "uses local config over dynamic_config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter "String"=>{:args=>[1,2]}
+        @formatter.klass_config(::String).should == {:args=>[1,2]}
+      end
+
+      it "uses dynamic_config and sets local config" do
+        Formatter.dynamic_config = {"String"=>{:method=>:blah}}
+        set_formatter.klass_config(::String).should == {:method=>:blah}
+        @formatter.config['String'].should == {:method=>:blah}
+      end
+    end
+  end
+
+  describe "formatter methods:" do
+    before_all { eval "module ::Dooda; end" }
+
+    it "#add_view sets formatter config" do
+      @formatter = set_formatter
+      @formatter.add_view ::Dooda, :class=>"DoodaView"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView"}
+    end
+
+    it "#add_view overwrites existing formatter config" do
+      @formatter = set_formatter "Dooda"=>{:class=>"DoodaView"}
+      @formatter.add_view ::Dooda, :class=>"DoodaView2"
+      @formatter.klass_config(::Dooda).should == {:class=>"DoodaView2"}
+    end
+
+    it "#parse_console_options passes all options except for formatter options into :options" do
+      @formatter = set_formatter
+      options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :blah=>'blah'}
+      expected_options = {:class=>'blah', :method=>'blah', :output_method=>'blah', :options=>{:blah=>'blah'}}
+      @formatter.parse_console_options(options).should == expected_options
+    end
+
+    it "#determine_output_class has exceptions for to_a" do
+      @formatter.determine_output_class(STDOUT).should == IO
+      @formatter.determine_output_class({:a=>1}).should == Hash
+    end
+  end
+
+  describe "format_output" do
+    def view_output(*args, &block); View.view_output(*args, &block); end
+    def render_method(*args); View.render_method(*args); end
+
+    def enable_with_output(value)
+      Hirb.enable :output=>value
+    end
+
+    before_all {
+      eval %[module ::Commify
+        def self.render(strings)
+          strings = Array(strings)
+          strings.map {|e| e.split('').join(',')}.join("\n")
+        end
+      end]
+      reset_config
+    }
+    before { View.formatter = nil; reset_config }
+    after { Hirb.disable }
+    
+    it "formats with method option" do
+      eval "module ::Kernel; def commify(string); string.split('').join(','); end; end"
+      enable_with_output "String"=>{:method=>:commify}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude')
+    end
+    
+    it "formats with class option as symbol" do
+      enable_with_output "String"=>{:class=>:auto_table}
+      Helpers::AutoTable.expects(:render)
+      view_output('dude')
+    end
+
+    it "formats arrays" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output(['dude'])
+    end
+
+    it "formats array-like objects" do
+      enable_with_output "String"=>{:class=>"Commify"}
+      render_method.expects(:call).with('d,u,d,e')
+      require 'set'
+      view_output Set.new(['dude'])
+    end
+
+    it "formats with options option" do
+      eval "module ::Blahify; def self.render(*args); end; end"
+      enable_with_output "String"=>{:class=>"Blahify", :options=>{:fields=>%w{a b}}}
+      Blahify.expects(:render).with('dude', :fields=>%w{a b})
+      view_output('dude')
+    end
+    
+    it "doesn't format and returns false when no format method found" do
+      Hirb.enable
+      render_method.expects(:call).never
+      view_output(Date.today).should == false
+    end
+    
+    it "formats with output_method option as method" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats with output_method option as proc" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>lambda {|e| e.chop}}
+      render_method.expects(:call).with('d,u,d')
+      view_output('dude')
+    end
+
+    it "formats output array with output_method option" do
+      enable_with_output 'String'=>{:class=>"Commify", :output_method=>:chop}
+      render_method.expects(:call).with("d,u,d\nm,a")
+      view_output(['dude', 'man'])
+    end
+
+    it "formats with explicit class option" do
+      enable_with_output 'String'=>{:class=>"Blahify"}
+      render_method.expects(:call).with('d,u,d,e')
+      view_output('dude', :class=>"Commify")
+    end
+    
+    it "formats with explicit options option merges with existing options" do
+      enable_with_output "String"=>{:class=>"Commify", :options=>{:fields=>%w{f1 f2}}}
+      Commify.expects(:render).with('dude', :max_width=>10, :fields=>%w{f1 f2})
+      view_output('dude', :options=>{:max_width=>10})
+    end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/hirb_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/hirb_test.rb
new file mode 100644
index 0000000..58edc95
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/hirb_test.rb
@@ -0,0 +1,39 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Hirb" do
+  before_all { Hirb.config_files = nil }
+  before { Hirb.config = nil }
+
+  it "config converts yaml when config file exists" do
+    yaml_data = {:blah=>'blah'}
+    File.stubs('exists?').returns(true)
+    Hirb.config_files = ['ok']
+    YAML::expects(:load_file).returns(yaml_data)
+    Hirb.config.should == yaml_data
+  end
+  
+  it "config defaults to hash when no config file" do
+    File.stubs('exists?').returns(false)
+    Hirb.config.should == {}
+  end
+  
+  it "config reloads if given explicit reload" do
+    Hirb.config
+    Hirb.expects(:read_config_file).returns({})
+    Hirb.config(true)
+  end
+
+  it "config reads multiple config files and merges them" do
+    Hirb.config_files = %w{one two}
+    Hirb.expects(:read_config_file).times(2).returns({:output=>{"String"=>:auto_table}}, {:output=>{"Array"=>:auto_table}})
+    Hirb.config.should == {:output=>{"Array"=>:auto_table, "String"=>:auto_table}}
+    Hirb.config_files = nil
+  end
+
+  it "config_file sets correctly when no ENV['HOME']" do
+    Hirb.config_files = nil
+    home = ENV.delete('HOME')
+    Hirb.config_files[0].class.should == String
+    ENV["HOME"] = home
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/import_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/import_test.rb
new file mode 100644
index 0000000..0a75368
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/import_test.rb
@@ -0,0 +1,9 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "import" do
+  it "require import_object extends Object" do
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == false
+    require 'hirb/import_object'
+    Object.ancestors.map {|e| e.to_s}.include?("Hirb::ObjectMethods").should == true
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/menu_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/menu_test.rb
new file mode 100644
index 0000000..d8f57db
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/menu_test.rb
@@ -0,0 +1,239 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Menu" do
+  before_all { View.instance_variable_set("@config", :width=>Hirb::View::DEFAULT_WIDTH) }
+
+  def menu(*args, &block)
+    # testing via menu's main use case (through console) instead of Menu.render
+    @console ||= Object.new.extend(Hirb::Console)
+    @console.menu(*args, &block)
+  end
+
+  def basic_menu(*args, &block)
+    menu_input('1')
+    capture_stdout { menu(*args, &block).should == [1] }
+  end
+
+  def menu_input(input='')
+    $stdin.expects(:gets).returns(input)
+  end
+
+  describe "menu" do
+    it "by default renders table menu" do
+      expected_menu = <<-MENU.unindent
+      +--------+-------+
+      | number | value |
+      +--------+-------+
+      | 1      | 1     |
+      | 2      | 2     |
+      | 3      | 3     |
+      +--------+-------+
+      3 rows in set
+      MENU
+      basic_menu([1,2,3]).include?(expected_menu).should == true
+    end
+
+    it "with block renders" do
+      menu_input "1,2"
+      expected_result = [1,2]
+      capture_stdout { 
+        menu([1,2,3]) {|e| e.should == expected_result }.should == expected_result
+      }
+    end
+
+    it "with block and no chosen doesn't call block" do
+      menu_input ""
+      block = lambda {|e| @called = true }
+      capture_stdout {
+        menu([1,2,3], &block).should == []
+      }
+      assert !@called
+    end
+
+    it "with valid helper_class option renders" do
+      Helpers::Table.expects(:render)
+      basic_menu [1,2,3], :helper_class=>"Hirb::Helpers::Table"
+    end
+
+    it "with invalid helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>"SomeHelper").include?(expected_menu).should == true
+    end
+
+    it "with false helper_class option renders default menu" do
+      expected_menu = <<-MENU.unindent
+      1: 1
+      2: 2
+      3: 3
+      MENU
+      basic_menu([1,2,3], :helper_class=>false).include?(expected_menu).should == true
+    end
+
+    it "prints prompt option" do
+      prompt = "Input or else ..."
+      basic_menu([1,2,3], :prompt=>prompt).include?(prompt).should == true
+    end
+
+    it "converts non-array inputs to array" do
+      Helpers::AutoTable.expects(:render).with([1], anything)
+      basic_menu 1
+    end
+
+    it "with false ask option returns one choice without asking" do
+      $stdin.expects(:gets).never
+      menu([1], :ask=>false).should == [1]
+    end
+
+    it "with no items to choose from always return without asking" do
+      $stdin.expects(:gets).never
+      menu([], :ask=>false).should == []
+      menu([], :ask=>true).should == []
+    end
+
+    it "with directions option turns off directions" do
+      menu_input('blah')
+      capture_stdout { menu([1], :directions=>false) }.should.not =~ /range.*all/
+    end
+
+    it "with true reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/tty')
+      basic_menu [1], :reopen=>true
+    end
+
+    it "with string reopen option reopens" do
+      $stdin.expects(:reopen).with('/dev/blah')
+      basic_menu [1], :reopen=>'/dev/blah'
+    end
+  end
+
+  def two_d_menu(options={})
+    if options[:invokes] || options[:invoke]
+      cmd = options[:command] || 'p'
+      (options[:invokes] || [options[:invoke]]).each {|e|
+        Menu.any_instance.expects(:invoke).with(cmd, e)
+      }
+    end
+
+    capture_stdout {
+      return menu(options[:output] || [{:a=>1, :bro=>2}, {:a=>3, :bro=>4}],
+       {:two_d=>true}.merge(options))
+    }
+  end
+
+  describe "2d menu" do
+    it "with default field from last_table renders" do
+      menu_input "1"
+      two_d_menu.should == [1]
+    end
+
+    it "with default field from fields option renders" do
+      menu_input "1"
+      two_d_menu(:fields=>[:bro, :a]).should == [2]
+    end
+
+    it "with default field option renders" do
+      menu_input "1"
+      two_d_menu(:default_field=>:bro).should == [2]
+    end
+
+    it "with non-table helper class renders" do
+      menu_input "1"
+      two_d_menu(:helper_class=>false, :fields=>[:a,:bro]).should == [1]
+    end
+
+    it "with no default field prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:fields=>[]) }.should =~ /No default.*found/
+    end
+
+    it "with invalid field prints error" do
+      menu_input "1:z"
+      capture_stderr { two_d_menu }.should =~ /Invalid.*'z'/
+    end
+
+    it "with choice from abbreviated field" do
+      menu_input "2:b"
+      two_d_menu.should == [4]
+    end
+
+    it "with choices from multiple fields renders" do
+      menu_input "1 2:bro"
+      two_d_menu.should == [1,4]
+    end
+  end
+
+  describe "action menu" do
+    it "invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :invoke=>[[1,4]])
+    end
+
+    it "with 1d invokes" do
+      menu_input "p 1"
+      two_d_menu(:action=>true, :two_d=>nil, :invoke=>[[{:a=>1, :bro=>2}]])
+    end
+
+    it "with non-choice arguments invokes" do
+      menu_input "p arg1 1"
+      two_d_menu :action=>true, :invoke=>['arg1', [1]]
+    end
+
+    it "with multiple choice arguments flattens them into arg" do
+      menu_input "p arg1 1 2:bro arg2"
+      two_d_menu :action=>true, :invoke=>['arg1', [1,4], 'arg2']
+    end
+
+    it "with nothing chosen prints error" do
+      menu_input "cmd"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No rows chosen/
+    end
+
+    it "with no command given prints error" do
+      menu_input "1"
+      capture_stderr { two_d_menu(:action=>true) }.should =~ /No command given/
+    end
+
+    it "with array menu items" do
+      menu_input "p 1"
+      two_d_menu :action=>true, :output=>[['some', 'choice'], ['and', 'another']],
+        :invokes=>[[['some']]]
+    end
+
+    it "with multi_action option invokes" do
+      menu_input "p 1 2:bro"
+      two_d_menu(:action=>true, :multi_action=>true, :invokes=>[[1], [4]])
+    end
+
+    it "with command option invokes" do
+      menu_input "1"
+      two_d_menu(:action=>true, :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with command option and empty input doesn't invoke action and exists silently" do
+      Menu.any_instance.expects(:invoke).never
+      menu_input ""
+      two_d_menu(:action=>true, :command=>'p').should == nil
+    end
+
+    it "with action_object option invokes" do
+      obj = mock(:blah=>true)
+      menu_input "blah 1"
+      two_d_menu(:action=>true, :action_object=>obj)
+    end
+
+    it "with ask false and defaults invokes" do
+      two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :default_field=>:a,
+        :command=>'p', :invoke=>[[1]])
+    end
+
+    it "with ask false and no defaults prints error" do
+      capture_stderr {
+        two_d_menu(:output=>[{:a=>1, :bro=>2}], :action=>true, :ask=>false, :command=>'p')
+      }.should =~ /Default.*required/
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/object_table_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/object_table_test.rb
new file mode 100644
index 0000000..c0ef8f2
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/object_table_test.rb
@@ -0,0 +1,79 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "object table" do
+  def table(*args)
+    Helpers::ObjectTable.render(*args)
+  end
+
+  before_all {
+    @pets = [stub(:name=>'rufus', :age=>7, :to_s=>'rufus'), stub(:name=>'alf', :age=>101, :to_s=>'alf')]
+  }
+  it "renders" do
+    expected_table = <<-TABLE.unindent
+    +-------+-----+
+    | name  | age |
+    +-------+-----+
+    | rufus | 7   |
+    | alf   | 101 |
+    +-------+-----+
+    2 rows in set
+    TABLE
+    table(@pets, :fields=>[:name, :age]).should == expected_table
+  end
+  
+  it "with no options defaults to to_s field" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | rufus |
+    | alf   |
+    +-------+
+    2 rows in set
+    TABLE
+    table(@pets).should == expected_table
+  end
+
+  it "renders simple arrays" do
+    expected_table = <<-TABLE.unindent
+    +-------+
+    | value |
+    +-------+
+    | 1     |
+    | 2     |
+    | 3     |
+    | 4     |
+    +-------+
+    4 rows in set
+    TABLE
+    table([1,2,3,4]).should == expected_table
+  end
+
+  it "renders simple arrays with custom header" do
+    expected_table = <<-TABLE.unindent
+    +-----+
+    | num |
+    +-----+
+    | 1   |
+    | 2   |
+    | 3   |
+    | 4   |
+    +-----+
+    4 rows in set
+    TABLE
+    table([1,2,3,4], :headers=>{:to_s=>'num'}).should == expected_table
+  end
+
+  it "with empty fields" do
+    expected_table = <<-TABLE.unindent
+    0 rows in set
+    TABLE
+    table(@pets, :fields => []).should == expected_table
+  end
+
+  it "doesn't raise error for objects that don't have :send defined" do
+    object = Object.new
+    class<<object; self; end.send :undef_method, :send
+    should.not.raise(NoMethodError) { table([object], :fields=>[:to_s]) }
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/pager_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/pager_test.rb
new file mode 100644
index 0000000..4878e12
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/pager_test.rb
@@ -0,0 +1,162 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Pager" do
+  def pager; View.pager; end
+
+  def create_pageable_string(inspect_mode=false, size={})
+    size = {:width=>pager.width, :height=>pager.height}.merge(size)
+    seed = inspect_mode ? "a" : "a\n"
+    if inspect_mode
+      seed * (size[:width] * size[:height] + 1)
+    else
+      seed * (size[:height] + 1)
+    end
+  end
+
+  it "command_pager sets pager_command when command exists" do
+    Util.expects(:command_exists?).returns(true)
+    Pager.expects(:basic_pager)
+    Pager.command_pager 'blah', :pager_command=>'less'
+  end
+
+  it "command_pager doesn't set pager_command when command doesn't exist" do
+    Util.expects(:command_exists?).returns(false)
+    Pager.expects(:basic_pager).never
+    Pager.command_pager 'blah', :pager_command=>'moreless'
+  end
+
+  describe "default_pager" do
+    before_all { reset_config; Hirb.enable :pager=>true }
+    before { View.pager = nil; Pager.stubs(:pager_command).returns(nil) }
+
+    it "pages once in normal mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string, false) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in normal mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a\n", false) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+
+    it "pages once in inspect mode" do
+      $stdin.expects(:gets).returns("\n")
+      output = capture_stdout { pager.page(create_pageable_string(true), true) }
+      output.include?('quit').should == true
+      output.include?('finished').should == true
+    end
+
+    it "doesn't page in inspect mode" do
+      $stdin.expects(:gets).never
+      output = capture_stdout { pager.page("a", true) }
+      output.include?("a\n=== Pager finished. ===\n").should == true
+    end
+    after_all { Hirb.disable }
+  end
+
+  describe "pager" do
+    before_all { reset_config; Hirb.enable }
+    before { View.pager = nil; View.formatter = nil }
+
+    def irb_eval(string)
+      context_stub = stub(:last_value=>string)
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    # this mode is called within @irb.output_value
+    describe "in inspect_mode" do
+      it "activates when output is wide enough" do
+        output = create_pageable_string(true)
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "doesn't activate when output isn't wide enough" do
+        pager.expects(:page).never
+        View.expects(:render_output).returns(false)
+        irb_eval("a")
+      end
+
+      it "activates with an explicit width" do
+        View.config[:width] = 10
+        output = create_pageable_string true, :width=>10
+        pager.expects(:page).with(output.inspect, true)
+        View.expects(:render_output).returns(false)
+        irb_eval output
+      end
+
+      it "activates default_pager when pager command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string(true)
+        Pager.expects(:default_pager).with(output.inspect, anything)
+        View.expects(:render_output).returns(false)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    # this mode is called within View.render_output
+    describe "in normal mode" do
+      it "activates when output is long enough" do
+        output = create_pageable_string
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "doesn't activate when output isn't long enough" do
+        output = "a\n"
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).never
+        capture_stdout { irb_eval(output) }
+      end
+
+      it "activates with an explicit height" do
+        View.config[:height] = 100
+        output = create_pageable_string false, :height=>100
+        View.formatter.expects(:format_output).returns(output)
+        pager.expects(:page).with(output, false)
+        irb_eval(output)
+      end
+
+      it "activates default_pager when pager_command is invalid" do
+        Pager.expects(:pager_command).returns(nil)
+        output = create_pageable_string
+        Pager.expects(:default_pager).with(output, anything)
+        View.formatter.expects(:format_output).returns(output)
+        capture_stdout { irb_eval output }
+      end
+    end
+
+    it "activates pager_command with valid pager_command option" do
+      View.config[:pager_command] = "less"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "activates pager_command with pager_command option that has command options" do
+      View.config[:pager_command] = "less -r"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).with('less').returns(true)
+      Pager.expects(:command_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+
+    it "doesn't activate pager_command with invalid pager_command option" do
+      View.config[:pager_command] = "moreless"
+      View.expects(:render_output).returns(false)
+      Util.expects(:command_exists?).returns(false)
+      Pager.expects(:default_pager)
+      irb_eval create_pageable_string(true)
+      View.config[:pager_command] = nil
+    end
+  end
+  after_all { Hirb.disable }
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/resizer_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/resizer_test.rb
new file mode 100644
index 0000000..55160a7
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/resizer_test.rb
@@ -0,0 +1,62 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Resizer" do
+  def table(options)
+    @table = Helpers::Table.new [options[:field_lengths].keys.inject({}) {|t,e| t[e] = '1'; t}]
+    @table.field_lengths = options[:field_lengths]
+    @table.width = options[:width]
+    @table.max_fields = options[:max_fields] if options[:max_fields]
+    @width, @field_lengths = @table.width, @table.field_lengths
+    @table
+  end
+
+  it "resize ensures columns total doesn't exceed max width" do
+    table :field_lengths=>{:f1=>135, :f2=>45, :f3=>4, :f4=>55}, :width=>195
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+  end
+
+  it "resize sets columns by relative lengths" do
+    table :field_lengths=>{:a=>30, :b=>30, :c=>40}, :width=>60
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.uniq.size.should.not == 1
+  end
+
+  it "resize sets all columns roughly equal when adusting long fields don't work" do
+    table :field_lengths=>{:field1=>10, :field2=>15, :field3=>100}, :width=>20
+    Helpers::Table::Resizer.resize!(@table)
+    @field_lengths.values.inject {|a,e| a+=e}.should <= @width
+    @field_lengths.values.each {|e| e.should <= 4 }
+  end
+
+  describe "add_extra_width and max_fields" do
+    def table_and_resize(options={})
+      defaults = {:field_lengths=>{:f1=>135, :f2=>30, :f3=>4, :f4=>100}, :width=>195, :max_fields=>{:f1=>80, :f4=>30} }
+      @table = table defaults.merge(options)
+      # repeated from table since instance variables aren't copied b/n contexts
+      @width, @field_lengths = @table.width, @table.field_lengths
+      Helpers::Table::Resizer.resize! @table
+    end
+
+    it "doesn't add to already maxed out field" do
+      table_and_resize
+      @field_lengths[:f3].should == 4
+    end
+
+    it "restricted before adding width" do
+      table_and_resize
+      @field_lengths[:f4].should <= 30
+    end
+
+    it "adds to restricted field" do
+      table_and_resize
+      @field_lengths[:f1].should <= 80
+    end
+
+    it "adds to unrestricted field" do
+      table_and_resize :field_lengths=>{:f1=>135, :f2=>70, :f3=>4, :f4=>100}
+      @field_lengths[:f2].should == 70
+    end
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/table_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/table_test.rb
new file mode 100644
index 0000000..1247a42
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/table_test.rb
@@ -0,0 +1,550 @@
+# encoding: UTF-8
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Table" do
+  def table(*args)
+    Helpers::Table.render(*args)
+  end
+  before_all { reset_config }
+  
+  describe "basic table" do
+    it "renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}]).should == expected_table
+    end
+    
+    it "with no headers renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 | 2 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>2}], :headers=>false).should == expected_table
+    end
+
+    it "with no headers and nil fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 1 |   |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=>1, :b=>nil}], :headers=>false).should == expected_table
+    end
+
+    it "with string keys renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}]).should == expected_table
+    end
+
+    it "with array only rows renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]]).should == expected_table
+    end
+
+    it "with too many fields defaults to vertical table" do
+      rows = [Array.new(25, "A"* 10)]
+      Helpers::VerticalTable.expects(:render).with(rows, anything)
+      capture_stderr { table(rows)}.should =~ /Error/
+    end
+
+    it "with no rows renders" do
+      table([]).should == "0 rows in set"
+    end
+
+    it "with invalid rows raises an argumenterror" do
+      lambda { table(:a=>1) }.should.raise(ArgumentError).message.should =~ /Table must/
+    end
+
+    it "renders utf8" do
+      expected_table = <<-TABLE.unindent
+      +--------------------+
+      | name               |
+      +--------------------+
+      |             |
+      |        |
+      | Tata l'asticote    |
+      | toto ltoile PAOLI |
+      +--------------------+
+      4 rows in set
+      TABLE
+      table([{:name=>""}, {:name=>""}, {:name=>"Tata l'asticote"}, {:name=>"toto ltoile PAOLI"}]).should == expected_table
+    end
+
+    it "stringifies newlines and tabs and renders" do
+      expected_table = <<-TABLE.unindent
+      +-----+---+
+      | a   | b |
+      +-----+---+
+      | 1#{'\n'} | 2 |
+      | 3#{'\t'} | 4 |
+      +-----+---+
+      2 rows in set
+      TABLE
+      value = [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+      table(value).should == expected_table
+      value.should == [{'a'=>"1\n", 'b'=>2}, {'a'=>"3\t", 'b'=>4}]
+    end
+
+    it "with a field of only array values renders values comma joined" do
+      expected_table = <<-TABLE.unindent
+      +----+------+
+      | a  | b    |
+      +----+------+
+      | 1  | 1, 2 |
+      | ok | 3, 4 |
+      +----+------+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>[1,2]}, {:a=>'ok', :b=>[3,4]}]).should == expected_table
+    end
+
+    it "with filter class default doesn't override explicit filters" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | a    | 1     |
+      +------+-------+
+      1 row in set
+      TABLE
+      table([{:name=>'a', :value=>{:b=>1}}], :filters=>{:value=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with" do
+    it "fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | a |
+      +---+---+
+      | 2 | 1 |
+      | 4 | 3 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :a]).should == expected_table
+    end
+    
+    it "fields option and array only rows" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 2 |
+      +---+---+
+      | 1 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([[1,2,3]], :fields=>[0,2]).should == expected_table
+    end
+
+    it "fields and number options copies fields option and does not modify it" do
+      options = {:fields=>[:f1], :number=>true}
+      table([{:f1=>1, :f2=>2}], options)
+      options[:fields].should == [:f1]
+    end
+  
+    it "invalid fields option renders empty columns" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | b | c |
+      +---+---+
+      | 2 |   |
+      | 4 |   |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :fields=>[:b, :c]).should == expected_table
+    end
+  
+    it "invalid field in max_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10,:c=>10}).should == expected_table
+    end
+  
+    it "max_fields option with fields less than 3 characters renders" do
+      expected_table = <<-TABLE.unindent
+      +----+---+
+      | a  | b |
+      +----+---+
+      | AA | 2 |
+      +----+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>2}, :resize=>false).should == expected_table
+    end
+  
+    it "max_fields option without resize renders" do
+      expected_table = <<-TABLE.unindent
+      +------------+---+
+      | a          | b |
+      +------------+---+
+      | AAAAAAA... | 2 |
+      +------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>10}, :resize=>false).should == expected_table
+    end
+
+    it "max_fields option with percentage renders" do
+      expected_table = <<-TABLE.unindent
+      +------------------+---+
+      | a                | b |
+      +------------------+---+
+      | AAAAAAAAAAAAA... | 2 |
+      +------------------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2}], :max_fields=>{:a=>'0.15'}).should == expected_table
+    end
+  
+    it "max_width option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :max_width=>30).should == expected_table
+    end
+
+    it "resize option false renders full table" do
+      expected_table = <<-TABLE.unindent
+      +----------------------------------------------------+---+------------+
+      | a                                                  | b | c          |
+      +----------------------------------------------------+---+------------+
+      | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | 2 | CCCCCCCCCC |
+      +----------------------------------------------------+---+------------+
+      1 row in set
+      TABLE
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}], :resize=>false).should == expected_table
+    end
+    
+    it "global width renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+------------+
+      | a         | b | c          |
+      +-----------+---+------------+
+      | AAAAAA... | 2 | CCCCCCCCCC |
+      +-----------+---+------------+
+      1 row in set
+      TABLE
+      View.load_config
+      View.resize(30)
+      table([{:a=> "A" * 50, :b=>2, :c=>"C"*10}]).should == expected_table
+      reset_config
+    end
+
+    it "headers option and headers longer than fields renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---------+---------+
+      | a | field B | field C |
+      +---+---------+---------+
+      | A | 2       | C       |
+      +---+---------+---------+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2, :c=>"C"}], :headers=>{:b=>"field B", :c=>"field C"}).should == expected_table
+    end
+  
+    it "headers option and headers shortened by max_fields renders" do
+      expected_table = <<-TABLE.unindent
+      +-------+---+
+      | fi... | b |
+      +-------+---+
+      | A     | 2 |
+      +-------+---+
+      1 row in set
+      TABLE
+      table([{:a=> "A", :b=>2}], :headers=>{:a=>"field A"}, :max_fields=>{:a=>5}, :resize=>false).should == expected_table
+    end
+    
+    it "headers option as an array renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 1 | 2 |
+      | 3 | 4 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([[1,2], [3,4]], :headers=>['A', 'B']).should == expected_table
+    end
+
+    it "header_filter option renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | A | B |
+      +---+---+
+      | 2 | 3 |
+      +---+---+
+      1 row in set
+      TABLE
+      table([{:a=> 2, :b=>3}], :header_filter=>:capitalize).should == expected_table
+    end
+
+    it "filters option renders" do
+      expected_table = <<-TABLE.unindent
+      +-----------+---+
+      | 0         | 1 |
+      +-----------+---+
+      | s,o,m,e   | 2 |
+      | t,h,i,n,g | 1 |
+      +-----------+---+
+      2 rows in set
+      TABLE
+      table([['some', {:num=>2}], ['thing', {:num=>1}]], :filters=>{0=>lambda {|e| e.split("").join(",")},
+        1=>[:[], :num]}).should == expected_table
+    end
+
+    it "filters option calls Filters method and renders" do
+      module ::Hirb::Helpers::Table::Filters
+        def semicolon_join(arr); arr.join('; '); end
+      end
+
+      expected_table = <<-TABLE.unindent
+      +------+------------------------------+
+      | 0    | 1                            |
+      +------+------------------------------+
+      | some | unsightly; unreadable; array |
+      +------+------------------------------+
+      1 row in set
+      TABLE
+      table([[['some'], %w{unsightly unreadable array}]], :filters=>{1=>:semicolon_join}).should == expected_table
+    end
+
+    it "number option renders" do
+      expected_table = <<-TABLE.unindent
+      +--------+---+---+
+      | number | 0 | 1 |
+      +--------+---+---+
+      | 1      | a | b |
+      | 2      | c | d |
+      +--------+---+---+
+      2 rows in set
+      TABLE
+      table([['a','b'], ['c', 'd']], :number=>true).should == expected_table
+    end
+
+    it "description option false renders" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | 0 | 1 |
+      +---+---+
+      | a | b |
+      | c | d |
+      +---+---+
+      TABLE
+      table([['a','b'], ['c', 'd']], :description=>false).should == expected_table
+    end
+
+    it "vertical option renders vertical table" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table with newlines" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      and one
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>"4\nand one"}], :vertical=>true).should == expected_table
+    end
+
+    it "vertical option renders vertical table successively" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      a: 1
+      b: 2
+      *** 2. row ***
+      a: 3
+      b: 4
+      2 rows in set
+      TABLE
+      options = {:vertical=>true}
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+      table([{:a=>1, :b=>2}, {:a=>3, :b=>4}], options).should == expected_table
+    end
+
+    it "hide_empty and vertical options renders" do
+      expected_table = <<-TABLE.unindent
+      *** 1. row ***
+      b: 2
+      *** 2. row ***
+      a: 3
+      2 rows in set
+      TABLE
+      table([{:a=>'', :b=>2}, {:a=>3, :b=>nil}], :hide_empty=>true, :vertical=>true).should == expected_table
+    end
+
+    it "all_fields option renders all fields" do
+      expected_table = <<-TABLE.unindent
+      +---+---+---+
+      | a | b | c |
+      +---+---+---+
+      | 1 | 2 |   |
+      | 3 |   | 4 |
+      +---+---+---+
+      2 rows in set
+      TABLE
+      table([{:a=>1, :b=>2}, {:a=>3, :c=>4}], :all_fields=>true).should == expected_table
+    end
+
+    it "change_fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>{0=>'name', 1=>'value'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value']).should == expected_table
+    end
+
+    it "change_fields and fields option renders" do
+      expected_table = <<-TABLE.unindent
+      +------+
+      | name |
+      +------+
+      | 1    |
+      | 2    |
+      +------+
+      2 rows in set
+      TABLE
+      table([[1,2],[2,3]], :change_fields=>['name', 'value'], :fields=>['name']).should == expected_table
+    end
+
+    it "invalid fields in change_fields options are ignored" do
+      expected_table = <<-TABLE.unindent
+      +------+-------+
+      | name | value |
+      +------+-------+
+      | 1    | 2     |
+      | 2    | 3     |
+      +------+-------+
+      2 rows in set
+      TABLE
+      table([{:a=>1,:b=>2}, {:a=>2,:b=>3}], :change_fields=>{:a=>'name', :b=>'value', :c=>'time'}).should == expected_table
+      table([[1,2],[2,3]], :change_fields=>['name', 'value','time']).should == expected_table
+    end
+
+    it "filter_any option filters any value" do
+      expected_table = <<-TABLE.unindent
+      +---------+
+      | a       |
+      +---------+
+      | {:b=>1} |
+      | 2       |
+      +---------+
+      2 rows in set
+      TABLE
+      table([{:a=>{:b=>1}}, {:a=>2}], :filter_any=>true).should == expected_table
+    end
+
+    it "filter_classes option overrides class-wide filter_classes" do
+      expected_table = <<-TABLE.unindent
+      +---+
+      | a |
+      +---+
+      | 1 |
+      +---+
+      1 row in set
+      TABLE
+      table([{:a=>{:b=>1}}], :filter_classes=>{Hash=>:size}).should == expected_table
+    end
+  end
+
+  describe "table with callbacks" do
+    before_all {
+      Helpers::Table.send(:define_method, :and_one_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] += opt[:add] } }
+        obj
+      end
+    }
+    it "detects and runs them" do
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1).should == expected_table
+    end
+
+    it "doesn't run callbacks in delete_callbacks option" do
+      Helpers::Table.send(:define_method, :and_two_callback) do |obj, opt|
+        obj.each {|row| row.each {|k,v| row[k] = row[k] * 2 } }
+        obj
+      end
+
+      expected_table = <<-TABLE.unindent
+      +---+---+
+      | a | b |
+      +---+---+
+      | 2 | 3 |
+      | 4 | 5 |
+      +---+---+
+      2 rows in set
+      TABLE
+      table([{'a'=>1, 'b'=>2}, {'a'=>3, 'b'=>4}], :add=>1, :delete_callbacks=>[:and_two]).should == expected_table
+
+      Helpers::Table.send(:remove_method, :and_two_callback)
+    end
+    after_all { Helpers::Table.send(:remove_method, :and_one_callback) }
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/test_helper.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/test_helper.rb
new file mode 100644
index 0000000..4706d0a
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/test_helper.rb
@@ -0,0 +1,61 @@
+require 'bacon'
+require 'bacon/bits'
+require 'mocha'
+require 'mocha-on-bacon'
+require 'hirb'
+include Hirb
+
+module TestHelpers
+  # set these to avoid invoking stty multiple times which doubles test suite running time
+  ENV["LINES"] = ENV["COLUMNS"] = "20"
+  def reset_terminal_size
+    ENV["LINES"] = ENV["COLUMNS"] = "20"
+  end
+
+  def capture_stdout(&block)
+    original_stdout = $stdout
+    $stdout = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stdout = original_stdout
+    end
+    fake.string
+  end
+
+  def capture_stderr(&block)
+    original_stderr = $stderr
+    $stderr = fake = StringIO.new
+    begin
+      yield
+    ensure
+      $stderr = original_stderr
+    end
+    fake.string
+  end
+
+  def reset_config
+    View.instance_eval "@config = nil"
+  end
+end
+
+class Bacon::Context
+  include TestHelpers
+end
+
+class String
+  def unindent(num=nil)
+    regex = num ? /^\s{#{num}}/ : /^\s*/
+    gsub(regex, '').chomp
+  end
+end
+
+# mocks IRB for View + Pager
+module ::IRB
+  class Irb
+    def initialize(context)
+      @context = context
+    end
+    def output_value; end
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/tree_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/tree_test.rb
new file mode 100644
index 0000000..cd046ef
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/tree_test.rb
@@ -0,0 +1,184 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Tree helpers:" do
+  def tree(*args)
+    Helpers::Tree.render(*args)
+  end
+  
+  describe "basic tree" do
+    it "with hash nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([{:level=>0, :value=>'0.0'}, {:level=>1, :value=>'1.1'}, {:level=>2, :value=>'2.2'},{:level=>2, :value=>'3.2'},
+         {:level=>1, :value=>'4.1'}]).should == expected_tree
+    end
+  
+    it "with array nodes renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]]).should == expected_tree
+    end
+    
+    it "with non-string values renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      TREE
+      tree([[0,0.0],[1,1.1],[2,2.2],[2,3.2],[1,4.1]]).should == expected_tree
+    end
+
+    it "with indent option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+        1.1
+          2.2
+          3.2
+        4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :indent=>2).should == expected_tree
+    end
+
+    it "with limit option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+          4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :limit=>1).should == expected_tree
+    end
+
+    it "with description option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      0.0
+          1.1
+              2.2
+              3.2
+          4.1
+      
+      5 nodes in tree
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :description=>true).should == expected_tree
+    end
+
+    it "with type directory renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      tree([[0, "0.0"], [1, "1.1"], [2, "2.2"], [2, "3.2"], [1, "4.1"]], :type=>:directory).should == expected_tree
+    end
+
+    it "with type directory and multiple children per level renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |   |-- 2.2
+      |   |   `-- 3.3
+      |   `-- 4.2
+      |       `-- 5.3
+      `-- 6.1
+      TREE
+      tree([[0,'0.0'], [1,'1.1'], [2,'2.2'],[3,'3.3'],[2,'4.2'],[3,'5.3'],[1,'6.1']], :type=>:directory).should == expected_tree
+    end
+
+    it "with type number renders" do
+      expected_tree = <<-TREE.unindent(6)
+      1. 0
+          1. 1
+              1. 2
+              2. 3
+          2. 4
+      TREE
+      tree([[0,'0'],[1,'1'],[2,'2'],[2,'3'],[1,'4']], :type=>:number).should == expected_tree
+    end
+
+    it "with multi-line nodes option renders" do
+      expected_tree = <<-TREE.unindent(6)
+      parent
+          +-------+
+          | value |
+          +-------+
+          | 1     |
+          | 2     |
+          | 3     |
+          +-------+
+              indented
+              stuff
+      TREE
+      node1 = "+-------+\n| value |\n+-------+\n| 1     |\n| 2     |\n| 3     |\n+-------+"
+      tree([ [0, 'parent'],[1, node1],[2, "indented\nstuff"]], :multi_line_nodes=>true).should == expected_tree
+    end
+  end
+
+  def mock_node(value, value_method)
+    children = []
+    value,children = *value if value.is_a?(Array)
+    mock(value_method=>value, :children=>children.map {|e| mock_node(e, value_method)})
+  end
+
+  describe "parent_child_tree" do
+    it "with name value renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :name)
+      Helpers::ParentChildTree.render(root, :type=>:directory).should == expected_tree
+    end
+    
+    it "with value_method option renders" do
+      expected_tree = <<-TREE.unindent
+      0.0
+      |-- 1.1
+      |-- 2.1
+      |   `-- 3.2
+      `-- 4.1
+      TREE
+      root = mock_node(['0.0', ['1.1', ['2.1', ['3.2']], '4.1']], :blah)
+      Helpers::ParentChildTree.render(root, :type=>:directory, :value_method=>:blah).should == expected_tree
+    end
+
+    it "with children_method proc option renders" do
+      expected_tree = <<-TREE.unindent
+      1
+      |-- 2
+      |-- 3
+      |-- 4
+      `-- 5
+      TREE
+      Helpers::ParentChildTree.render(1, :type=>:directory,
+        :children_method=>lambda {|e| e == 1 ? (2..5).to_a : []}, :value_method=>:to_s).should == expected_tree
+    end
+  end
+
+  it "tree with parentless nodes renders ParentlessNodeError" do
+    lambda { tree([[0, "0.0"], [2, '1.2']], :validate=>true) }.should.raise(Helpers::Tree::ParentlessNodeError)
+  end
+  
+  it "tree with hash nodes missing level raises MissingLevelError" do
+    lambda { tree([{:value=>'ok'}]) }.should.raise(Helpers::Tree::Node::MissingLevelError)
+  end
+
+  it "tree with hash nodes missing level raises MissingValueError" do
+    lambda { tree([{:level=>0}]) }.should.raise(Helpers::Tree::Node::MissingValueError)
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/util_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/util_test.rb
new file mode 100644
index 0000000..faadd5d
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/util_test.rb
@@ -0,0 +1,59 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "Util" do
+  it "camelize converts underscore lowercase to camelcase" do
+    Util.camelize('hirb/util').should == "Hirb::Util"
+    Util.camelize('hirb_hash').should == "HirbHash"
+  end
+
+  it "any_const_get returns nested class" do
+    Util.any_const_get("YAML::BaseNode").should == ::YAML::BaseNode
+  end
+
+  it "any_const_get returns nil for invalid class" do
+    Util.any_const_get("Basdfr").should == nil
+  end
+
+  it "any_const_get returns class when given class" do
+    Util.any_const_get(String).should == String
+  end
+
+  it "recursive_hash_merge merges" do
+    expected_hash = {:output=>{:fields=>["f1", "f2"], :method=>"blah"}, :key1=>"hash1", :key2=>"hash2"}
+    Util.recursive_hash_merge({:output=>{:fields=>%w{f1 f2}}, :key1=>'hash1'},
+      {:output=>{:method=>'blah'}, :key2=>'hash2'}).should == expected_hash
+  end
+
+  it "choose_from_array specifies range with -" do
+    Util.choose_from_array([1,2,3,4], '1-2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array specifies range with .." do
+    Util.choose_from_array([1,2,3,4], '1 .. 2,4').should == [1,2,4]
+  end
+
+  it "choose_from_array chooses all with *" do
+    Util.choose_from_array([1,2,3,4], '*').should == [1,2,3,4]
+  end
+
+  it "choose_from_array ignores non-numerical input" do
+    Util.choose_from_array([1,2,3,4], 'a,2').should == [2]
+  end
+
+  it "choose_from_array ignores 0" do
+    Util.choose_from_array([1,2,3,4], '0,2').should == [2]
+  end
+
+  it "choose_from_array returns empty when empty input" do
+    Util.choose_from_array([1,2,3,4], "\n").should == []
+  end
+
+  it "choose_from_array returns empty with an invalid range" do
+    Util.choose_from_array([1,2,3,4], "5").should == []
+  end
+
+  it "capture_stdout" do
+    string = "sweetness man"
+    Util.capture_stdout { puts string }.should == string + "\n"
+  end
+end
\ No newline at end of file
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/view_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/view_test.rb
new file mode 100644
index 0000000..4d611a0
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/view_test.rb
@@ -0,0 +1,165 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "View" do
+  def formatter_config
+    View.formatter.config
+  end
+  
+  it "page_output pages when view is enabled" do
+    Hirb.enable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page)
+    View.page_output('blah').should == true
+    Hirb.disable
+  end
+
+  it "page_output doesn't page when view is disabled" do
+    Hirb.enable
+    Hirb.disable
+    View.pager.stubs(:activated_by?).returns(true)
+    View.pager.expects(:page).never
+    View.page_output('blah').should == false
+  end
+
+  it "view_output catches unexpected errors and prints them" do
+    reset_config
+    Hirb.enable
+    View.expects(:render_output).raises('blah')
+    capture_stderr { View.view_output([1,2,3]) }.should =~ /Hirb Error: blah/
+    Hirb.disable
+  end
+
+  describe "enable" do
+    before { reset_config }
+    after { Hirb.disable }
+    it "redefines irb output_value" do
+      View.expects(:render_output).once
+      Hirb.enable
+      context_stub = stub(:last_value=>'')
+      ::IRB::Irb.new(context_stub).output_value
+    end
+
+    it "is enabled?" do
+      Hirb.enable
+      View.enabled?.should == true
+    end
+
+    def output_class_config(klass)
+      { :output=>{klass=>{:class=>:auto_table}} }
+    end
+
+    it "sets formatter config" do
+      class_hash = {"Something::Base"=>{:class=>"BlahBlah"}}
+      Hirb.enable :output=>class_hash
+      View.formatter_config['Something::Base'].should == class_hash['Something::Base']
+    end
+
+    it "when called multiple times merges configs" do
+      Hirb.config = nil
+      # default config + config_file
+      Hirb.expects(:read_config_file).returns(output_class_config('Regexp'))
+      Hirb.enable output_class_config('String')
+
+      # add config file and explicit config
+      [{:config_file=>'ok'}, output_class_config('Struct')].each do |config|
+        Hirb.expects(:read_config_file).times(2).returns(
+          output_class_config('ActiveRecord::Base'), output_class_config('Array'))
+        Hirb.enable config
+      end
+
+      Hirb.config_files.include?('ok').should == true
+      output_keys = %w{ActiveRecord::Base Array Regexp String Struct}
+      View.config[:output].keys.sort.should == output_keys
+    end
+
+    it "when called multiple times without config doesn't affect config" do
+      Hirb.enable
+      old_config = View.config
+      Hirb.expects(:read_config_file).never
+      View.expects(:load_config).never
+      Hirb.enable
+      View.config.should == old_config
+    end
+
+    it "works without irb" do
+      Object.stubs(:const_defined?).with(:IRB).returns(false)
+      Hirb.enable
+      formatter_config.size.should.be > 0
+    end
+
+    it "with config_file option adds to config_file" do
+      Hirb.enable :config_file=> 'test_file'
+      Hirb.config_files.include?('test_file').should == true
+    end
+
+    it "with ignore_errors enable option" do
+      Hirb.enable :ignore_errors => true
+      View.stubs(:render_output).raises(Exception, "Ex mesg")
+      capture_stderr { View.view_output("").should == false }.should =~ /Error: Ex mesg/
+    end
+  end
+
+  describe "resize" do
+    def pager; View.pager; end
+    before { View.pager = nil; reset_config; Hirb.enable }
+    after { Hirb.disable}
+    it "changes width and height with stty" do
+      Util.expects(:command_exists?).with('stty').returns(true)
+      ENV['COLUMNS'] = ENV['LINES'] = nil # bypasses env usage
+      View.resize
+      pager.width.should.not == 10
+      pager.height.should.not == 10
+      reset_terminal_size
+    end
+
+    it "changes width and height with ENV" do
+      ENV['COLUMNS'] = ENV['LINES'] = '10' # simulates resizing
+      View.resize
+      pager.width.should == 10
+      pager.height.should == 10
+    end
+
+    it "with no environment or stty still has valid width and height" do
+      View.config[:width] = View.config[:height] = nil
+      Util.expects(:command_exists?).with('stty').returns(false)
+      ENV['COLUMNS'] = ENV['LINES'] = nil
+      View.resize
+      pager.width.is_a?(Integer).should == true
+      pager.height.is_a?(Integer).should == true
+      reset_terminal_size
+    end
+  end
+
+  it "disable points output_value back to original output_value" do
+    View.expects(:render_output).never
+    Hirb.enable
+    Hirb.disable
+    context_stub = stub(:last_value=>'')
+    ::IRB::Irb.new(context_stub).output_value
+  end
+
+  it "disable works without irb defined" do
+    Object.stubs(:const_defined?).with(:IRB).returns(false)
+    Hirb.enable
+    Hirb.disable
+    View.enabled?.should == false
+  end
+
+  it "capture_and_render" do
+    string = 'no waaaay'
+    View.render_method.expects(:call).with(string)
+    View.capture_and_render { print string }
+  end
+  
+  it "state is toggled by toggle_pager" do
+    previous_state = View.config[:pager]
+    View.toggle_pager
+    View.config[:pager].should == !previous_state
+  end
+  
+  it "state is toggled by toggle_formatter" do
+    previous_state = View.config[:formatter]
+    View.toggle_formatter
+    View.config[:formatter].should == !previous_state
+  end
+end
diff --git a/lib/brightbox-cli/vendor/hirb-0.3.5/test/views_test.rb b/lib/brightbox-cli/vendor/hirb-0.3.5/test/views_test.rb
new file mode 100644
index 0000000..1aeb641
--- /dev/null
+++ b/lib/brightbox-cli/vendor/hirb-0.3.5/test/views_test.rb
@@ -0,0 +1,13 @@
+require File.join(File.dirname(__FILE__), 'test_helper')
+
+describe "activerecord table" do
+  it "with no select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{"name"=>'rufus', 'age'=>7}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:age, :name]}
+  end
+
+  it "with select gets default options" do
+    pet = stub(:name=>'rufus', :age=>7, :attributes=>{'name'=>'rufus'}, :class=>stub(:column_names=>%w{age name}))
+    Helpers::AutoTable.active_record__base_view(pet).should == {:fields=>[:name]}
+  end
+end
\ No newline at end of file
